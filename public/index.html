<!-- public/index.html -->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Real-Time Collaborative Drawing</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        #toolbar {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        #colorPicker,
        #brushSize {
            margin-right: 10px;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #resetButton {
            padding: 5px 10px;
            border: none;
            background-color: #dc3545;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }

        #resetButton:hover {
            background-color: #c82333;
        }
    </style>
</head>

<body>
    <div id="toolbar">
        <input type="color" id="colorPicker" value="#000000" />
        <input type="range" id="brushSize" min="1" max="50" value="5" />
        <button id="resetButton">Reset Canvas</button> <!-- Added Reset Button -->
    </div>
    <canvas id="canvas"></canvas>

    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');

        let drawing = false;
        let current = {
            color: colorPicker.value,
            size: brushSize.value
        };

        // Resize canvas to full window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

        // Mouse events
        canvas.addEventListener('mousedown', onMouseDown, false);
        canvas.addEventListener('mouseup', onMouseUp, false);
        canvas.addEventListener('mouseout', onMouseUp, false);
        canvas.addEventListener('mousemove', throttle(onMouseMove, 10), false);

        // Touch events for mobile
        canvas.addEventListener('touchstart', onTouchStart, false);
        canvas.addEventListener('touchend', onMouseUp, false);
        canvas.addEventListener('touchcancel', onMouseUp, false);
        canvas.addEventListener('touchmove', throttle(onTouchMove, 10), false);

        // Update current color and size
        colorPicker.addEventListener('change', (e) => {
            current.color = e.target.value;
        });

        brushSize.addEventListener('change', (e) => {
            current.size = e.target.value;
        });

        // Drawing functions
        function drawLine(x0, y0, x1, y1, color, size, emit) {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            ctx.stroke();
            ctx.closePath();

            if (!emit) return;

            const w = canvas.width;
            const h = canvas.height;

            socket.emit('drawing', {
                x0: x0 / w,
                y0: y0 / h,
                x1: x1 / w,
                y1: y1 / h,
                color: color,
                size: size
            });
        }

        // Handle incoming drawing data
        socket.on('drawing', (data) => {
            const w = canvas.width;
            const h = canvas.height;
            drawLine(data.x0 * w, data.y0 * h, data.x1 * w, data.y1 * h, data.color, data.size);
        });

        // Mouse event handlers
        function onMouseDown(e) {
            drawing = true;
            current.x = e.clientX;
            current.y = e.clientY;
        }

        function onMouseUp(e) {
            if (!drawing) return;
            drawing = false;
            drawLine(current.x, current.y, e.clientX, e.clientY, current.color, current.size, true);
        }

        function onMouseMove(e) {
            if (!drawing) return;
            drawLine(current.x, current.y, e.clientX, e.clientY, current.color, current.size, true);
            current.x = e.clientX;
            current.y = e.clientY;
        }

        // Touch event handlers
        function onTouchStart(e) {
            if (e.touches.length !== 1) return;
            const touch = e.touches[0];
            drawing = true;
            current.x = touch.clientX;
            current.y = touch.clientY;
        }

        function onTouchMove(e) {
            if (!drawing) return;
            if (e.touches.length !== 1) return;
            const touch = e.touches[0];
            drawLine(current.x, current.y, touch.clientX, touch.clientY, current.color, current.size, true);
            current.x = touch.clientX;
            current.y = touch.clientY;
            e.preventDefault();
        }

        // Throttle function to limit the rate of function calls
        function throttle(callback, delay) {
            let previousCall = new Date().getTime();
            return function () {
                const time = new Date().getTime();

                if ((time - previousCall) >= delay) {
                    previousCall = time;
                    callback.apply(null, arguments);
                }
            };
        }
        const resetButton = document.getElementById('resetButton');

        resetButton.addEventListener('click', () => {
            clearCanvas(); 
            socket.emit('clearCanvas'); 
        });
        socket.on('clearCanvas', () => {
            clearCanvas();
        });
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>

</html>