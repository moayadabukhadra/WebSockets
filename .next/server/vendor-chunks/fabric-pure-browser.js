/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fabric-pure-browser";
exports.ids = ["vendor-chunks/fabric-pure-browser"];
exports.modules = {

/***/ "(ssr)/./node_modules/fabric-pure-browser/dist/fabric.js":
/*!*********************************************************!*\
  !*** ./node_modules/fabric-pure-browser/dist/fabric.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* build: `node build.js modules=ALL exclude=gestures,accessors,erasing requirejs minifier=uglifyjs` */ /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */ var fabric = fabric || {\n    version: \"5.1.0\"\n};\nif (true) {\n    exports.fabric = fabric;\n} else {}\n/* _AMD_END_ */ if (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {} else {\n    // assume we're running under node.js when document/window are not present\n    var jsdom = __webpack_require__(/*! jsdom */ \"(ssr)/./node_modules/jsdom/lib/api.js\");\n    var virtualWindow = new jsdom.JSDOM(decodeURIComponent(\"%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E\"), {\n        features: {\n            FetchExternalResources: [\n                \"img\"\n            ]\n        },\n        resources: \"usable\"\n    }).window;\n    fabric.document = virtualWindow.document;\n    fabric.jsdomImplForWrapper = (__webpack_require__(/*! jsdom/lib/jsdom/living/generated/utils */ \"(ssr)/./node_modules/jsdom/lib/jsdom/living/generated/utils.js\").implForWrapper);\n    fabric.nodeCanvas = (__webpack_require__(/*! jsdom/lib/jsdom/utils */ \"(ssr)/./node_modules/jsdom/lib/jsdom/utils.js\").Canvas);\n    fabric.window = virtualWindow;\n    DOMParser = fabric.window.DOMParser;\n}\n/**\n * True when in environment that supports touch events\n * @type boolean\n */ fabric.isTouchSupported = \"ontouchstart\" in fabric.window || \"ontouchstart\" in fabric.document || fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0;\n/**\n * True when in environment that's probably Node.js\n * @type boolean\n */ fabric.isLikelyNode = typeof Buffer !== \"undefined\" && \"undefined\" === \"undefined\";\n/* _FROM_SVG_START_ */ /**\n * Attributes parsed from all SVG elements\n * @type array\n */ fabric.SHARED_ATTRIBUTES = [\n    \"display\",\n    \"transform\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"opacity\",\n    \"stroke\",\n    \"stroke-dasharray\",\n    \"stroke-linecap\",\n    \"stroke-dashoffset\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke-width\",\n    \"id\",\n    \"paint-order\",\n    \"vector-effect\",\n    \"instantiated_by_use\",\n    \"clip-path\"\n];\n/* _FROM_SVG_END_ */ /**\n * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.\n */ fabric.DPI = 96;\nfabric.reNum = \"(?:[-+]?(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)\";\nfabric.commaWsp = \"(?:\\\\s+,?\\\\s*|,\\\\s*)\";\nfabric.rePathCommand = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:[eE][-+]?\\d+)?)/ig;\nfabric.reNonWord = /[ \\n\\.,;!\\?\\-]/;\nfabric.fontPaths = {};\nfabric.iMatrix = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n];\nfabric.svgNS = \"http://www.w3.org/2000/svg\";\n/**\n * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.perfLimitSizeTotal = 2097152;\n/**\n * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.maxCacheSideLimit = 4096;\n/**\n * Lowest pixel limit for cache canvases, set at 256PX\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.minCacheSideLimit = 256;\n/**\n * Cache Object for widths of chars in text rendering.\n */ fabric.charWidthsCache = {};\n/**\n * if webgl is enabled and available, textureSize will determine the size\n * of the canvas backend\n * @since 2.0.0\n * @type Number\n * @default\n */ fabric.textureSize = 2048;\n/**\n * When 'true', style information is not retained when copy/pasting text, making\n * pasted text use destination style.\n * Defaults to 'false'.\n * @type Boolean\n * @default\n */ fabric.disableStyleCopyPaste = false;\n/**\n * Enable webgl for filtering picture is available\n * A filtering backend will be initialized, this will both take memory and\n * time since a default 2048x2048 canvas will be created for the gl context\n * @since 2.0.0\n * @type Boolean\n * @default\n */ fabric.enableGLFiltering = true;\n/**\n * Device Pixel Ratio\n * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html\n */ fabric.devicePixelRatio = fabric.window.devicePixelRatio || fabric.window.webkitDevicePixelRatio || fabric.window.mozDevicePixelRatio || 1;\n/**\n * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,\n * which is unitless and not rendered equally across browsers.\n *\n * Values that work quite well (as of October 2017) are:\n * - Chrome: 1.5\n * - Edge: 1.75\n * - Firefox: 0.9\n * - Safari: 0.95\n *\n * @since 2.0.0\n * @type Number\n * @default 1\n */ fabric.browserShadowBlurConstant = 1;\n/**\n * This object contains the result of arc to bezier conversion for faster retrieving if the same arc needs to be converted again.\n * It was an internal variable, is accessible since version 2.3.4\n */ fabric.arcToSegmentsCache = {};\n/**\n * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.\n * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing\n * you do not get any speed benefit and you get a big object in memory.\n * The object was a private variable before, while now is appended to the lib so that you have access to it and you\n * can eventually clear it.\n * It was an internal variable, is accessible since version 2.3.4\n */ fabric.boundsOfCurveCache = {};\n/**\n * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better\n * @default true\n */ fabric.cachesBoundsOfCurve = true;\n/**\n * Skip performance testing of setupGLContext and force the use of putImageData that seems to be the one that works best on\n * Chrome + old hardware. if your users are experiencing empty images after filtering you may try to force this to true\n * this has to be set before instantiating the filtering backend ( before filtering the first image )\n * @type Boolean\n * @default false\n */ fabric.forceGLPutImageData = false;\nfabric.initFilterBackend = function() {\n    if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {\n        console.log(\"max texture size: \" + fabric.maxTextureSize);\n        return new fabric.WebglFilterBackend({\n            tileSize: fabric.textureSize\n        });\n    } else if (fabric.Canvas2dFilterBackend) {\n        return new fabric.Canvas2dFilterBackend();\n    }\n};\nif (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {}\n(function() {\n    /**\n   * @private\n   * @param {String} eventName\n   * @param {Function} handler\n   */ function _removeEventListener(eventName, handler) {\n        if (!this.__eventListeners[eventName]) {\n            return;\n        }\n        var eventListener = this.__eventListeners[eventName];\n        if (handler) {\n            eventListener[eventListener.indexOf(handler)] = false;\n        } else {\n            fabric.util.array.fill(eventListener, false);\n        }\n    }\n    /**\n   * Observes specified event\n   * @memberOf fabric.Observable\n   * @alias on\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\n   * @return {Self} thisArg\n   * @chainable\n   */ function on(eventName, handler) {\n        if (!this.__eventListeners) {\n            this.__eventListeners = {};\n        }\n        // one object with key/value pairs was passed\n        if (arguments.length === 1) {\n            for(var prop in eventName){\n                this.on(prop, eventName[prop]);\n            }\n        } else {\n            if (!this.__eventListeners[eventName]) {\n                this.__eventListeners[eventName] = [];\n            }\n            this.__eventListeners[eventName].push(handler);\n        }\n        return this;\n    }\n    function _once(eventName, handler) {\n        var _handler = (function() {\n            handler.apply(this, arguments);\n            this.off(eventName, _handler);\n        }).bind(this);\n        this.on(eventName, _handler);\n    }\n    function once(eventName, handler) {\n        // one object with key/value pairs was passed\n        if (arguments.length === 1) {\n            for(var prop in eventName){\n                _once.call(this, prop, eventName[prop]);\n            }\n        } else {\n            _once.call(this, eventName, handler);\n        }\n        return this;\n    }\n    /**\n   * Stops event observing for a particular event handler. Calling this method\n   * without arguments removes all handlers for all events\n   * @memberOf fabric.Observable\n   * @alias off\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function to be deleted from EventListeners\n   * @return {Self} thisArg\n   * @chainable\n   */ function off(eventName, handler) {\n        if (!this.__eventListeners) {\n            return this;\n        }\n        // remove all key/value pairs (event name -> event handler)\n        if (arguments.length === 0) {\n            for(eventName in this.__eventListeners){\n                _removeEventListener.call(this, eventName);\n            }\n        } else if (arguments.length === 1 && typeof arguments[0] === \"object\") {\n            for(var prop in eventName){\n                _removeEventListener.call(this, prop, eventName[prop]);\n            }\n        } else {\n            _removeEventListener.call(this, eventName, handler);\n        }\n        return this;\n    }\n    /**\n   * Fires event with an optional options object\n   * @memberOf fabric.Observable\n   * @param {String} eventName Event name to fire\n   * @param {Object} [options] Options object\n   * @return {Self} thisArg\n   * @chainable\n   */ function fire(eventName, options) {\n        if (!this.__eventListeners) {\n            return this;\n        }\n        var listenersForEvent = this.__eventListeners[eventName];\n        if (!listenersForEvent) {\n            return this;\n        }\n        for(var i = 0, len = listenersForEvent.length; i < len; i++){\n            listenersForEvent[i] && listenersForEvent[i].call(this, options || {});\n        }\n        this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {\n            return value !== false;\n        });\n        return this;\n    }\n    /**\n   * @namespace fabric.Observable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}\n   * @see {@link http://fabricjs.com/events|Events demo}\n   */ fabric.Observable = {\n        fire: fire,\n        on: on,\n        once: once,\n        off: off\n    };\n})();\n/**\n * @namespace fabric.Collection\n */ fabric.Collection = {\n    _objects: [],\n    /**\n   * Adds objects to collection, Canvas or Group, then renders canvas\n   * (if `renderOnAddRemove` is not `false`).\n   * in case of Group no changes to bounding box are made.\n   * Objects should be instances of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the add method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */ add: function() {\n        this._objects.push.apply(this._objects, arguments);\n        if (this._onObjectAdded) {\n            for(var i = 0, length = arguments.length; i < length; i++){\n                this._onObjectAdded(arguments[i]);\n            }\n        }\n        this.renderOnAddRemove && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * An object should be an instance of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the insertAt method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {Object} object Object to insert\n   * @param {Number} index Index to insert object at\n   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs\n   * @return {Self} thisArg\n   * @chainable\n   */ insertAt: function(object, index, nonSplicing) {\n        var objects = this._objects;\n        if (nonSplicing) {\n            objects[index] = object;\n        } else {\n            objects.splice(index, 0, object);\n        }\n        this._onObjectAdded && this._onObjectAdded(object);\n        this.renderOnAddRemove && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */ remove: function() {\n        var objects = this._objects, index, somethingRemoved = false;\n        for(var i = 0, length = arguments.length; i < length; i++){\n            index = objects.indexOf(arguments[i]);\n            // only call onObjectRemoved if an object was actually removed\n            if (index !== -1) {\n                somethingRemoved = true;\n                objects.splice(index, 1);\n                this._onObjectRemoved && this._onObjectRemoved(arguments[i]);\n            }\n        }\n        this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Executes given function for each object in this group\n   * @param {Function} callback\n   *                   Callback invoked with current object as first argument,\n   *                   index - as second and an array of all objects - as third.\n   *                   Callback is invoked in a context of Global Object (e.g. `window`)\n   *                   when no `context` argument is given\n   *\n   * @param {Object} context Context (aka thisObject)\n   * @return {Self} thisArg\n   * @chainable\n   */ forEachObject: function(callback, context) {\n        var objects = this.getObjects();\n        for(var i = 0, len = objects.length; i < len; i++){\n            callback.call(context, objects[i], i, objects);\n        }\n        return this;\n    },\n    /**\n   * Returns an array of children objects of this instance\n   * Type parameter introduced in 1.3.10\n   * since 2.3.5 this method return always a COPY of the array;\n   * @param {String} [type] When specified, only objects of this type are returned\n   * @return {Array}\n   */ getObjects: function(type) {\n        if (typeof type === \"undefined\") {\n            return this._objects.concat();\n        }\n        return this._objects.filter(function(o) {\n            return o.type === type;\n        });\n    },\n    /**\n   * Returns object at specified index\n   * @param {Number} index\n   * @return {Self} thisArg\n   */ item: function(index) {\n        return this._objects[index];\n    },\n    /**\n   * Returns true if collection contains no objects\n   * @return {Boolean} true if collection is empty\n   */ isEmpty: function() {\n        return this._objects.length === 0;\n    },\n    /**\n   * Returns a size of a collection (i.e: length of an array containing its objects)\n   * @return {Number} Collection size\n   */ size: function() {\n        return this._objects.length;\n    },\n    /**\n   * Returns true if collection contains an object\n   * @param {Object} object Object to check against\n   * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`\n   * @return {Boolean} `true` if collection contains an object\n   */ contains: function(object, deep) {\n        if (this._objects.indexOf(object) > -1) {\n            return true;\n        } else if (deep) {\n            return this._objects.some(function(obj) {\n                return typeof obj.contains === \"function\" && obj.contains(object, true);\n            });\n        }\n        return false;\n    },\n    /**\n   * Returns number representation of a collection complexity\n   * @return {Number} complexity\n   */ complexity: function() {\n        return this._objects.reduce(function(memo, current) {\n            memo += current.complexity ? current.complexity() : 0;\n            return memo;\n        }, 0);\n    }\n};\n/**\n * @namespace fabric.CommonMethods\n */ fabric.CommonMethods = {\n    /**\n   * Sets object's properties from options\n   * @param {Object} [options] Options object\n   */ _setOptions: function(options) {\n        for(var prop in options){\n            this.set(prop, options[prop]);\n        }\n    },\n    /**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Gradient to\n   */ _initGradient: function(filler, property) {\n        if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {\n            this.set(property, new fabric.Gradient(filler));\n        }\n    },\n    /**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Pattern to\n   * @param {Function} [callback] callback to invoke after pattern load\n   */ _initPattern: function(filler, property, callback) {\n        if (filler && filler.source && !(filler instanceof fabric.Pattern)) {\n            this.set(property, new fabric.Pattern(filler, callback));\n        } else {\n            callback && callback();\n        }\n    },\n    /**\n   * @private\n   */ _setObject: function(obj) {\n        for(var prop in obj){\n            this._set(prop, obj[prop]);\n        }\n    },\n    /**\n   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n   * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ set: function(key, value) {\n        if (typeof key === \"object\") {\n            this._setObject(key);\n        } else {\n            this._set(key, value);\n        }\n        return this;\n    },\n    _set: function(key, value) {\n        this[key] = value;\n    },\n    /**\n   * Toggles specified property from `true` to `false` or from `false` to `true`\n   * @param {String} property Property to toggle\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ toggle: function(property) {\n        var value = this.get(property);\n        if (typeof value === \"boolean\") {\n            this.set(property, !value);\n        }\n        return this;\n    },\n    /**\n   * Basic getter\n   * @param {String} property Property name\n   * @return {*} value of a property\n   */ get: function(property) {\n        return this[property];\n    }\n};\n(function(global) {\n    var sqrt = Math.sqrt, atan2 = Math.atan2, pow = Math.pow, PiBy180 = Math.PI / 180, PiBy2 = Math.PI / 2;\n    /**\n   * @namespace fabric.util\n   */ fabric.util = {\n        /**\n     * Calculate the cos of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */ cos: function(angle) {\n            if (angle === 0) {\n                return 1;\n            }\n            if (angle < 0) {\n                // cos(a) = cos(-a)\n                angle = -angle;\n            }\n            var angleSlice = angle / PiBy2;\n            switch(angleSlice){\n                case 1:\n                case 3:\n                    return 0;\n                case 2:\n                    return -1;\n            }\n            return Math.cos(angle);\n        },\n        /**\n     * Calculate the sin of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */ sin: function(angle) {\n            if (angle === 0) {\n                return 0;\n            }\n            var angleSlice = angle / PiBy2, sign = 1;\n            if (angle < 0) {\n                // sin(-a) = -sin(a)\n                sign = -1;\n            }\n            switch(angleSlice){\n                case 1:\n                    return sign;\n                case 2:\n                    return 0;\n                case 3:\n                    return -sign;\n            }\n            return Math.sin(angle);\n        },\n        /**\n     * Removes value from an array.\n     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} array\n     * @param {*} value\n     * @return {Array} original array\n     */ removeFromArray: function(array, value) {\n            var idx = array.indexOf(value);\n            if (idx !== -1) {\n                array.splice(idx, 1);\n            }\n            return array;\n        },\n        /**\n     * Returns random number between 2 specified ones.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} min lower limit\n     * @param {Number} max upper limit\n     * @return {Number} random value (between min and max)\n     */ getRandomInt: function(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        },\n        /**\n     * Transforms degrees to radians.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} degrees value in degrees\n     * @return {Number} value in radians\n     */ degreesToRadians: function(degrees) {\n            return degrees * PiBy180;\n        },\n        /**\n     * Transforms radians to degrees.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} radians value in radians\n     * @return {Number} value in degrees\n     */ radiansToDegrees: function(radians) {\n            return radians / PiBy180;\n        },\n        /**\n     * Rotates `point` around `origin` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {fabric.Point} point The point to rotate\n     * @param {fabric.Point} origin The origin of the rotation\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {fabric.Point} The new rotated point\n     */ rotatePoint: function(point, origin, radians) {\n            var newPoint = new fabric.Point(point.x - origin.x, point.y - origin.y), v = fabric.util.rotateVector(newPoint, radians);\n            return new fabric.Point(v.x, v.y).addEquals(origin);\n        },\n        /**\n     * Rotates `vector` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} vector The vector to rotate (x and y)\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {Object} The new rotated point\n     */ rotateVector: function(vector, radians) {\n            var sin = fabric.util.sin(radians), cos = fabric.util.cos(radians), rx = vector.x * cos - vector.y * sin, ry = vector.x * sin + vector.y * cos;\n            return {\n                x: rx,\n                y: ry\n            };\n        },\n        /**\n     * Creates a vetor from points represented as a point\n     * @static\n     * @memberOf fabric.util\n     *\n     * @typedef {Object} Point\n     * @property {number} x\n     * @property {number} y\n     *\n     * @param {Point} from\n     * @param {Point} to\n     * @returns {Point} vector\n     */ createVector: function(from, to) {\n            return new fabric.Point(to.x - from.x, to.y - from.y);\n        },\n        /**\n     * Calculates angle between 2 vectors using dot product\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} a\n     * @param {Point} b\n     * @returns the angle in radian between the vectors\n     */ calcAngleBetweenVectors: function(a, b) {\n            return Math.acos((a.x * b.x + a.y * b.y) / (Math.hypot(a.x, a.y) * Math.hypot(b.x, b.y)));\n        },\n        /**\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} v\n     * @returns {Point} vector representing the unit vector of pointing to the direction of `v`\n     */ getHatVector: function(v) {\n            return new fabric.Point(v.x, v.y).multiply(1 / Math.hypot(v.x, v.y));\n        },\n        /**\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} A\n     * @param {Point} B\n     * @param {Point} C\n     * @returns {{ vector: Point, angle: number }} vector representing the bisector of A and A's angle\n     */ getBisector: function(A, B, C) {\n            var AB = fabric.util.createVector(A, B), AC = fabric.util.createVector(A, C);\n            var alpha = fabric.util.calcAngleBetweenVectors(AB, AC);\n            //  check if alpha is relative to AB->BC\n            var ro = fabric.util.calcAngleBetweenVectors(fabric.util.rotateVector(AB, alpha), AC);\n            var phi = alpha * (ro === 0 ? 1 : -1) / 2;\n            return {\n                vector: fabric.util.getHatVector(fabric.util.rotateVector(AB, phi)),\n                angle: alpha\n            };\n        },\n        /**\n     * Project stroke width on points returning 2 projections for each point as follows:\n     * - `miter`: 2 points corresponding to the outer boundary and the inner boundary of stroke.\n     * - `bevel`: 2 points corresponding to the bevel boundaries, tangent to the bisector.\n     * - `round`: same as `bevel`\n     * Used to calculate object's bounding box\n     * @static\n     * @memberOf fabric.util\n     * @param {Point[]} points\n     * @param {Object} options\n     * @param {number} options.strokeWidth\n     * @param {'miter'|'bevel'|'round'} options.strokeLineJoin\n     * @param {number} options.strokeMiterLimit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n     * @param {boolean} options.strokeUniform\n     * @param {number} options.scaleX\n     * @param {number} options.scaleY\n     * @param {boolean} [openPath] whether the shape is open or not, affects the calculations of the first and last points\n     * @returns {fabric.Point[]} array of size 2n/4n of all suspected points\n     */ projectStrokeOnPoints: function(points, options, openPath) {\n            var coords = [], s = options.strokeWidth / 2, strokeUniformScalar = options.strokeUniform ? new fabric.Point(1 / options.scaleX, 1 / options.scaleY) : new fabric.Point(1, 1), getStrokeHatVector = function(v) {\n                var scalar = s / Math.hypot(v.x, v.y);\n                return new fabric.Point(v.x * scalar * strokeUniformScalar.x, v.y * scalar * strokeUniformScalar.y);\n            };\n            if (points.length <= 1) {\n                return coords;\n            }\n            points.forEach(function(p, index) {\n                var A = new fabric.Point(p.x, p.y), B, C;\n                if (index === 0) {\n                    C = points[index + 1];\n                    B = openPath ? getStrokeHatVector(fabric.util.createVector(C, A)).addEquals(A) : points[points.length - 1];\n                } else if (index === points.length - 1) {\n                    B = points[index - 1];\n                    C = openPath ? getStrokeHatVector(fabric.util.createVector(B, A)).addEquals(A) : points[0];\n                } else {\n                    B = points[index - 1];\n                    C = points[index + 1];\n                }\n                var bisector = fabric.util.getBisector(A, B, C), bisectorVector = bisector.vector, alpha = bisector.angle, scalar, miterVector;\n                if (options.strokeLineJoin === \"miter\") {\n                    scalar = -s / Math.sin(alpha / 2);\n                    miterVector = new fabric.Point(bisectorVector.x * scalar * strokeUniformScalar.x, bisectorVector.y * scalar * strokeUniformScalar.y);\n                    if (Math.hypot(miterVector.x, miterVector.y) / s <= options.strokeMiterLimit) {\n                        coords.push(A.add(miterVector));\n                        coords.push(A.subtract(miterVector));\n                        return;\n                    }\n                }\n                scalar = -s * Math.SQRT2;\n                miterVector = new fabric.Point(bisectorVector.x * scalar * strokeUniformScalar.x, bisectorVector.y * scalar * strokeUniformScalar.y);\n                coords.push(A.add(miterVector));\n                coords.push(A.subtract(miterVector));\n            });\n            return coords;\n        },\n        /**\n     * Apply transform t to point p\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Point} p The point to transform\n     * @param  {Array} t The transform\n     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied\n     * @return {fabric.Point} The transformed point\n     */ transformPoint: function(p, t, ignoreOffset) {\n            if (ignoreOffset) {\n                return new fabric.Point(t[0] * p.x + t[2] * p.y, t[1] * p.x + t[3] * p.y);\n            }\n            return new fabric.Point(t[0] * p.x + t[2] * p.y + t[4], t[1] * p.x + t[3] * p.y + t[5]);\n        },\n        /**\n     * Returns coordinates of points's bounding rectangle (left, top, width, height)\n     * @param {Array} points 4 points array\n     * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix\n     * @return {Object} Object with left, top, width, height properties\n     */ makeBoundingBoxFromPoints: function(points, transform) {\n            if (transform) {\n                for(var i = 0; i < points.length; i++){\n                    points[i] = fabric.util.transformPoint(points[i], transform);\n                }\n            }\n            var xPoints = [\n                points[0].x,\n                points[1].x,\n                points[2].x,\n                points[3].x\n            ], minX = fabric.util.array.min(xPoints), maxX = fabric.util.array.max(xPoints), width = maxX - minX, yPoints = [\n                points[0].y,\n                points[1].y,\n                points[2].y,\n                points[3].y\n            ], minY = fabric.util.array.min(yPoints), maxY = fabric.util.array.max(yPoints), height = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: width,\n                height: height\n            };\n        },\n        /**\n     * Invert transformation t\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} t The transform\n     * @return {Array} The inverted transform\n     */ invertTransform: function(t) {\n            var a = 1 / (t[0] * t[3] - t[1] * t[2]), r = [\n                a * t[3],\n                -a * t[1],\n                -a * t[2],\n                a * t[0]\n            ], o = fabric.util.transformPoint({\n                x: t[4],\n                y: t[5]\n            }, r, true);\n            r[4] = -o.x;\n            r[5] = -o.y;\n            return r;\n        },\n        /**\n     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number|String} number number to operate on\n     * @param {Number} fractionDigits number of fraction digits to \"leave\"\n     * @return {Number}\n     */ toFixed: function(number, fractionDigits) {\n            return parseFloat(Number(number).toFixed(fractionDigits));\n        },\n        /**\n     * Converts from attribute value to pixel value if applicable.\n     * Returns converted pixels or original value not converted.\n     * @param {Number|String} value number to operate on\n     * @param {Number} fontSize\n     * @return {Number|String}\n     */ parseUnit: function(value, fontSize) {\n            var unit = /\\D{0,2}$/.exec(value), number = parseFloat(value);\n            if (!fontSize) {\n                fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\n            }\n            switch(unit[0]){\n                case \"mm\":\n                    return number * fabric.DPI / 25.4;\n                case \"cm\":\n                    return number * fabric.DPI / 2.54;\n                case \"in\":\n                    return number * fabric.DPI;\n                case \"pt\":\n                    return number * fabric.DPI / 72; // or * 4 / 3\n                case \"pc\":\n                    return number * fabric.DPI / 72 * 12; // or * 16\n                case \"em\":\n                    return number * fontSize;\n                default:\n                    return number;\n            }\n        },\n        /**\n     * Function which always returns `false`.\n     * @static\n     * @memberOf fabric.util\n     * @return {Boolean}\n     */ falseFunction: function() {\n            return false;\n        },\n        /**\n     * Returns klass \"Class\" object of given namespace\n     * @memberOf fabric.util\n     * @param {String} type Type of object (eg. 'circle')\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @return {Object} klass \"Class\"\n     */ getKlass: function(type, namespace) {\n            // capitalize first letter only\n            type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));\n            return fabric.util.resolveNamespace(namespace)[type];\n        },\n        /**\n     * Returns array of attributes for given svg that fabric parses\n     * @memberOf fabric.util\n     * @param {String} type Type of svg element (eg. 'circle')\n     * @return {Array} string names of supported attributes\n     */ getSvgAttributes: function(type) {\n            var attributes = [\n                \"instantiated_by_use\",\n                \"style\",\n                \"id\",\n                \"class\"\n            ];\n            switch(type){\n                case \"linearGradient\":\n                    attributes = attributes.concat([\n                        \"x1\",\n                        \"y1\",\n                        \"x2\",\n                        \"y2\",\n                        \"gradientUnits\",\n                        \"gradientTransform\"\n                    ]);\n                    break;\n                case \"radialGradient\":\n                    attributes = attributes.concat([\n                        \"gradientUnits\",\n                        \"gradientTransform\",\n                        \"cx\",\n                        \"cy\",\n                        \"r\",\n                        \"fx\",\n                        \"fy\",\n                        \"fr\"\n                    ]);\n                    break;\n                case \"stop\":\n                    attributes = attributes.concat([\n                        \"offset\",\n                        \"stop-color\",\n                        \"stop-opacity\"\n                    ]);\n                    break;\n            }\n            return attributes;\n        },\n        /**\n     * Returns object of given namespace\n     * @memberOf fabric.util\n     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'\n     * @return {Object} Object for given namespace (default fabric)\n     */ resolveNamespace: function(namespace) {\n            if (!namespace) {\n                return fabric;\n            }\n            var parts = namespace.split(\".\"), len = parts.length, i, obj = global || fabric.window;\n            for(i = 0; i < len; ++i){\n                obj = obj[parts[i]];\n            }\n            return obj;\n        },\n        /**\n     * Loads image element from given url and passes it to a callback\n     * @memberOf fabric.util\n     * @param {String} url URL representing an image\n     * @param {Function} callback Callback; invoked with loaded image\n     * @param {*} [context] Context to invoke callback in\n     * @param {Object} [crossOrigin] crossOrigin value to set image element to\n     */ loadImage: function(url, callback, context, crossOrigin) {\n            if (!url) {\n                callback && callback.call(context, url);\n                return;\n            }\n            var img = fabric.util.createImage();\n            /** @ignore */ var onLoadCallback = function() {\n                callback && callback.call(context, img, false);\n                img = img.onload = img.onerror = null;\n            };\n            img.onload = onLoadCallback;\n            /** @ignore */ img.onerror = function() {\n                fabric.log(\"Error loading \" + img.src);\n                callback && callback.call(context, null, true);\n                img = img.onload = img.onerror = null;\n            };\n            // data-urls appear to be buggy with crossOrigin\n            // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767\n            // see https://code.google.com/p/chromium/issues/detail?id=315152\n            //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069\n            // crossOrigin null is the same as not set.\n            if (url.indexOf(\"data\") !== 0 && crossOrigin !== undefined && crossOrigin !== null) {\n                img.crossOrigin = crossOrigin;\n            }\n            // IE10 / IE11-Fix: SVG contents from data: URI\n            // will only be available if the IMG is present\n            // in the DOM (and visible)\n            if (url.substring(0, 14) === \"data:image/svg\") {\n                img.onload = null;\n                fabric.util.loadImageInDom(img, onLoadCallback);\n            }\n            img.src = url;\n        },\n        /**\n     * Attaches SVG image with data: URL to the dom\n     * @memberOf fabric.util\n     * @param {Object} img Image object with data:image/svg src\n     * @param {Function} callback Callback; invoked with loaded image\n     * @return {Object} DOM element (div containing the SVG image)\n     */ loadImageInDom: function(img, onLoadCallback) {\n            var div = fabric.document.createElement(\"div\");\n            div.style.width = div.style.height = \"1px\";\n            div.style.left = div.style.top = \"-100%\";\n            div.style.position = \"absolute\";\n            div.appendChild(img);\n            fabric.document.querySelector(\"body\").appendChild(div);\n            /**\n       * Wrap in function to:\n       *   1. Call existing callback\n       *   2. Cleanup DOM\n       */ img.onload = function() {\n                onLoadCallback();\n                div.parentNode.removeChild(div);\n                div = null;\n            };\n        },\n        /**\n     * Creates corresponding fabric instances from their object representations\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} objects Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @param {Function} reviver Method for further parsing of object elements,\n     * called after each fabric object created.\n     */ enlivenObjects: function(objects, callback, namespace, reviver) {\n            objects = objects || [];\n            var enlivenedObjects = [], numLoadedObjects = 0, numTotalObjects = objects.length;\n            function onLoaded() {\n                if (++numLoadedObjects === numTotalObjects) {\n                    callback && callback(enlivenedObjects.filter(function(obj) {\n                        // filter out undefined objects (objects that gave error)\n                        return obj;\n                    }));\n                }\n            }\n            if (!numTotalObjects) {\n                callback && callback(enlivenedObjects);\n                return;\n            }\n            objects.forEach(function(o, index) {\n                // if sparse array\n                if (!o || !o.type) {\n                    onLoaded();\n                    return;\n                }\n                var klass = fabric.util.getKlass(o.type, namespace);\n                klass.fromObject(o, function(obj, error) {\n                    error || (enlivenedObjects[index] = obj);\n                    reviver && reviver(o, obj, error);\n                    onLoaded();\n                });\n            });\n        },\n        /**\n     * Creates corresponding fabric instances residing in an object, e.g. `clipPath`\n     * @see {@link fabric.Object.ENLIVEN_PROPS}\n     * @param {Object} object\n     * @param {Object} [context] assign enlived props to this object (pass null to skip this)\n     * @param {(objects:fabric.Object[]) => void} callback\n     */ enlivenObjectEnlivables: function(object, context, callback) {\n            var enlivenProps = fabric.Object.ENLIVEN_PROPS.filter(function(key) {\n                return !!object[key];\n            });\n            fabric.util.enlivenObjects(enlivenProps.map(function(key) {\n                return object[key];\n            }), function(enlivedProps) {\n                var objects = {};\n                enlivenProps.forEach(function(key, index) {\n                    objects[key] = enlivedProps[index];\n                    context && (context[key] = enlivedProps[index]);\n                });\n                callback && callback(objects);\n            });\n        },\n        /**\n     * Create and wait for loading of patterns\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} patterns Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * called after each fabric object created.\n     */ enlivenPatterns: function(patterns, callback) {\n            patterns = patterns || [];\n            function onLoaded() {\n                if (++numLoadedPatterns === numPatterns) {\n                    callback && callback(enlivenedPatterns);\n                }\n            }\n            var enlivenedPatterns = [], numLoadedPatterns = 0, numPatterns = patterns.length;\n            if (!numPatterns) {\n                callback && callback(enlivenedPatterns);\n                return;\n            }\n            patterns.forEach(function(p, index) {\n                if (p && p.source) {\n                    new fabric.Pattern(p, function(pattern) {\n                        enlivenedPatterns[index] = pattern;\n                        onLoaded();\n                    });\n                } else {\n                    enlivenedPatterns[index] = p;\n                    onLoaded();\n                }\n            });\n        },\n        /**\n     * Groups SVG elements (usually those retrieved from SVG document)\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} elements SVG elements to group\n     * @param {Object} [options] Options object\n     * @param {String} path Value to set sourcePath to\n     * @return {fabric.Object|fabric.Group}\n     */ groupSVGElements: function(elements, options, path) {\n            var object;\n            if (elements && elements.length === 1) {\n                return elements[0];\n            }\n            if (options) {\n                if (options.width && options.height) {\n                    options.centerPoint = {\n                        x: options.width / 2,\n                        y: options.height / 2\n                    };\n                } else {\n                    delete options.width;\n                    delete options.height;\n                }\n            }\n            object = new fabric.Group(elements, options);\n            if (typeof path !== \"undefined\") {\n                object.sourcePath = path;\n            }\n            return object;\n        },\n        /**\n     * Populates an object with properties of another object\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} source Source object\n     * @param {Object} destination Destination object\n     * @return {Array} properties Properties names to include\n     */ populateWithProperties: function(source, destination, properties) {\n            if (properties && Object.prototype.toString.call(properties) === \"[object Array]\") {\n                for(var i = 0, len = properties.length; i < len; i++){\n                    if (properties[i] in source) {\n                        destination[properties[i]] = source[properties[i]];\n                    }\n                }\n            }\n        },\n        /**\n     * Creates canvas element\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */ createCanvasElement: function() {\n            return fabric.document.createElement(\"canvas\");\n        },\n        /**\n     * Creates a canvas element that is a copy of another and is also painted\n     * @param {CanvasElement} canvas to copy size and content of\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */ copyCanvasElement: function(canvas) {\n            var newCanvas = fabric.util.createCanvasElement();\n            newCanvas.width = canvas.width;\n            newCanvas.height = canvas.height;\n            newCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n            return newCanvas;\n        },\n        /**\n     * since 2.6.0 moved from canvas instance to utility.\n     * @param {CanvasElement} canvasEl to copy size and content of\n     * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too\n     * @param {Number} quality <= 1 and > 0\n     * @static\n     * @memberOf fabric.util\n     * @return {String} data url\n     */ toDataURL: function(canvasEl, format, quality) {\n            return canvasEl.toDataURL(\"image/\" + format, quality);\n        },\n        /**\n     * Creates image element (works on client and node)\n     * @static\n     * @memberOf fabric.util\n     * @return {HTMLImageElement} HTML image element\n     */ createImage: function() {\n            return fabric.document.createElement(\"img\");\n        },\n        /**\n     * Multiply matrix A by matrix B to nest transformations\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a First transformMatrix\n     * @param  {Array} b Second transformMatrix\n     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices\n     * @return {Array} The product of the two transform matrices\n     */ multiplyTransformMatrices: function(a, b, is2x2) {\n            // Matrix multiply a * b\n            return [\n                a[0] * b[0] + a[2] * b[1],\n                a[1] * b[0] + a[3] * b[1],\n                a[0] * b[2] + a[2] * b[3],\n                a[1] * b[2] + a[3] * b[3],\n                is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],\n                is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]\n            ];\n        },\n        /**\n     * Decomposes standard 2x3 matrix into transform components\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a transformMatrix\n     * @return {Object} Components of transform\n     */ qrDecompose: function(a) {\n            var angle = atan2(a[1], a[0]), denom = pow(a[0], 2) + pow(a[1], 2), scaleX = sqrt(denom), scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX, skewX = atan2(a[0] * a[2] + a[1] * a[3], denom);\n            return {\n                angle: angle / PiBy180,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                skewX: skewX / PiBy180,\n                skewY: 0,\n                translateX: a[4],\n                translateY: a[5]\n            };\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle] angle in degrees\n     * @return {Number[]} transform matrix\n     */ calcRotateMatrix: function(options) {\n            if (!options.angle) {\n                return fabric.iMatrix.concat();\n            }\n            var theta = fabric.util.degreesToRadians(options.angle), cos = fabric.util.cos(theta), sin = fabric.util.sin(theta);\n            return [\n                cos,\n                sin,\n                -sin,\n                cos,\n                0,\n                0\n            ];\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet.\n     * is called DimensionsTransformMatrix because those properties are the one that influence\n     * the size of the resulting box of the object.\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewY]\n     * @return {Number[]} transform matrix\n     */ calcDimensionsMatrix: function(options) {\n            var scaleX = typeof options.scaleX === \"undefined\" ? 1 : options.scaleX, scaleY = typeof options.scaleY === \"undefined\" ? 1 : options.scaleY, scaleMatrix = [\n                options.flipX ? -scaleX : scaleX,\n                0,\n                0,\n                options.flipY ? -scaleY : scaleY,\n                0,\n                0\n            ], multiply = fabric.util.multiplyTransformMatrices, degreesToRadians = fabric.util.degreesToRadians;\n            if (options.skewX) {\n                scaleMatrix = multiply(scaleMatrix, [\n                    1,\n                    0,\n                    Math.tan(degreesToRadians(options.skewX)),\n                    1\n                ], true);\n            }\n            if (options.skewY) {\n                scaleMatrix = multiply(scaleMatrix, [\n                    1,\n                    Math.tan(degreesToRadians(options.skewY)),\n                    0,\n                    1\n                ], true);\n            }\n            return scaleMatrix;\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle]\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.translateX]\n     * @param  {Number} [options.translateY]\n     * @return {Number[]} transform matrix\n     */ composeMatrix: function(options) {\n            var matrix = [\n                1,\n                0,\n                0,\n                1,\n                options.translateX || 0,\n                options.translateY || 0\n            ], multiply = fabric.util.multiplyTransformMatrices;\n            if (options.angle) {\n                matrix = multiply(matrix, fabric.util.calcRotateMatrix(options));\n            }\n            if (options.scaleX !== 1 || options.scaleY !== 1 || options.skewX || options.skewY || options.flipX || options.flipY) {\n                matrix = multiply(matrix, fabric.util.calcDimensionsMatrix(options));\n            }\n            return matrix;\n        },\n        /**\n     * reset an object transform state to neutral. Top and left are not accounted for\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to transform\n     */ resetObjectTransform: function(target) {\n            target.scaleX = 1;\n            target.scaleY = 1;\n            target.skewX = 0;\n            target.skewY = 0;\n            target.flipX = false;\n            target.flipY = false;\n            target.rotate(0);\n        },\n        /**\n     * Extract Object transform values\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to read from\n     * @return {Object} Components of transform\n     */ saveObjectTransform: function(target) {\n            return {\n                scaleX: target.scaleX,\n                scaleY: target.scaleY,\n                skewX: target.skewX,\n                skewY: target.skewY,\n                angle: target.angle,\n                left: target.left,\n                flipX: target.flipX,\n                flipY: target.flipY,\n                top: target.top\n            };\n        },\n        /**\n     * Returns true if context has transparent pixel\n     * at specified location (taking tolerance into account)\n     * @param {CanvasRenderingContext2D} ctx context\n     * @param {Number} x x coordinate\n     * @param {Number} y y coordinate\n     * @param {Number} tolerance Tolerance\n     */ isTransparent: function(ctx, x, y, tolerance) {\n            // If tolerance is > 0 adjust start coords to take into account.\n            // If moves off Canvas fix to 0\n            if (tolerance > 0) {\n                if (x > tolerance) {\n                    x -= tolerance;\n                } else {\n                    x = 0;\n                }\n                if (y > tolerance) {\n                    y -= tolerance;\n                } else {\n                    y = 0;\n                }\n            }\n            var _isTransparent = true, i, temp, imageData = ctx.getImageData(x, y, tolerance * 2 || 1, tolerance * 2 || 1), l = imageData.data.length;\n            // Split image data - for tolerance > 1, pixelDataSize = 4;\n            for(i = 3; i < l; i += 4){\n                temp = imageData.data[i];\n                _isTransparent = temp <= 0;\n                if (_isTransparent === false) {\n                    break; // Stop if colour found\n                }\n            }\n            imageData = null;\n            return _isTransparent;\n        },\n        /**\n     * Parse preserveAspectRatio attribute from element\n     * @param {string} attribute to be parsed\n     * @return {Object} an object containing align and meetOrSlice attribute\n     */ parsePreserveAspectRatioAttribute: function(attribute) {\n            var meetOrSlice = \"meet\", alignX = \"Mid\", alignY = \"Mid\", aspectRatioAttrs = attribute.split(\" \"), align;\n            if (aspectRatioAttrs && aspectRatioAttrs.length) {\n                meetOrSlice = aspectRatioAttrs.pop();\n                if (meetOrSlice !== \"meet\" && meetOrSlice !== \"slice\") {\n                    align = meetOrSlice;\n                    meetOrSlice = \"meet\";\n                } else if (aspectRatioAttrs.length) {\n                    align = aspectRatioAttrs.pop();\n                }\n            }\n            //divide align in alignX and alignY\n            alignX = align !== \"none\" ? align.slice(1, 4) : \"none\";\n            alignY = align !== \"none\" ? align.slice(5, 8) : \"none\";\n            return {\n                meetOrSlice: meetOrSlice,\n                alignX: alignX,\n                alignY: alignY\n            };\n        },\n        /**\n     * Clear char widths cache for the given font family or all the cache if no\n     * fontFamily is specified.\n     * Use it if you know you are loading fonts in a lazy way and you are not waiting\n     * for custom fonts to load properly when adding text objects to the canvas.\n     * If a text object is added when its own font is not loaded yet, you will get wrong\n     * measurement and so wrong bounding boxes.\n     * After the font cache is cleared, either change the textObject text content or call\n     * initDimensions() to trigger a recalculation\n     * @memberOf fabric.util\n     * @param {String} [fontFamily] font family to clear\n     */ clearFabricFontCache: function(fontFamily) {\n            fontFamily = (fontFamily || \"\").toLowerCase();\n            if (!fontFamily) {\n                fabric.charWidthsCache = {};\n            } else if (fabric.charWidthsCache[fontFamily]) {\n                delete fabric.charWidthsCache[fontFamily];\n            }\n        },\n        /**\n     * Given current aspect ratio, determines the max width and height that can\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Number} ar aspect ratio\n     * @param {Number} maximumArea Maximum area you want to achieve\n     * @return {Object.x} Limited dimensions by X\n     * @return {Object.y} Limited dimensions by Y\n     */ limitDimsByArea: function(ar, maximumArea) {\n            var roughWidth = Math.sqrt(maximumArea * ar), perfLimitSizeY = Math.floor(maximumArea / roughWidth);\n            return {\n                x: Math.floor(roughWidth),\n                y: perfLimitSizeY\n            };\n        },\n        capValue: function(min, value, max) {\n            return Math.max(min, Math.min(value, max));\n        },\n        /**\n     * Finds the scale for the object source to fit inside the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to fit into destination\n     */ findScaleToFit: function(source, destination) {\n            return Math.min(destination.width / source.width, destination.height / source.height);\n        },\n        /**\n     * Finds the scale for the object source to cover entirely the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to cover destination\n     */ findScaleToCover: function(source, destination) {\n            return Math.max(destination.width / source.width, destination.height / source.height);\n        },\n        /**\n     * given an array of 6 number returns something like `\"matrix(...numbers)\"`\n     * @memberOf fabric.util\n     * @param {Array} transform an array with 6 numbers\n     * @return {String} transform matrix for svg\n     * @return {Object.y} Limited dimensions by Y\n     */ matrixToSVG: function(transform) {\n            return \"matrix(\" + transform.map(function(value) {\n                return fabric.util.toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);\n            }).join(\" \") + \")\";\n        },\n        /**\n     * given an object and a transform, apply the inverse transform to the object,\n     * this is equivalent to remove from that object that transformation, so that\n     * added in a space with the removed transform, the object will be the same as before.\n     * Removing from an object a transform that scale by 2 is like scaling it by 1/2.\n     * Removing from an object a transfrom that rotate by 30deg is like rotating by 30deg\n     * in the opposite direction.\n     * This util is used to add objects inside transformed groups or nested groups.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ removeTransformFromObject: function(object, transform) {\n            var inverted = fabric.util.invertTransform(transform), finalTransform = fabric.util.multiplyTransformMatrices(inverted, object.calcOwnMatrix());\n            fabric.util.applyTransformToObject(object, finalTransform);\n        },\n        /**\n     * given an object and a transform, apply the transform to the object.\n     * this is equivalent to change the space where the object is drawn.\n     * Adding to an object a transform that scale by 2 is like scaling it by 2.\n     * This is used when removing an object from an active selection for example.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ addTransformToObject: function(object, transform) {\n            fabric.util.applyTransformToObject(object, fabric.util.multiplyTransformMatrices(transform, object.calcOwnMatrix()));\n        },\n        /**\n     * discard an object transform state and apply the one from the matrix.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ applyTransformToObject: function(object, transform) {\n            var options = fabric.util.qrDecompose(transform), center = new fabric.Point(options.translateX, options.translateY);\n            object.flipX = false;\n            object.flipY = false;\n            object.set(\"scaleX\", options.scaleX);\n            object.set(\"scaleY\", options.scaleY);\n            object.skewX = options.skewX;\n            object.skewY = options.skewY;\n            object.angle = options.angle;\n            object.setPositionByOrigin(center, \"center\", \"center\");\n        },\n        /**\n     * given a width and height, return the size of the bounding box\n     * that can contains the box with width/height with applied transform\n     * described in options.\n     * Use to calculate the boxes around objects for controls.\n     * @memberOf fabric.util\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Object} options\n     * @param {Number} options.scaleX\n     * @param {Number} options.scaleY\n     * @param {Number} options.skewX\n     * @param {Number} options.skewY\n     * @return {Object.x} width of containing\n     * @return {Object.y} height of containing\n     */ sizeAfterTransform: function(width, height, options) {\n            var dimX = width / 2, dimY = height / 2, points = [\n                {\n                    x: -dimX,\n                    y: -dimY\n                },\n                {\n                    x: dimX,\n                    y: -dimY\n                },\n                {\n                    x: -dimX,\n                    y: dimY\n                },\n                {\n                    x: dimX,\n                    y: dimY\n                }\n            ], transformMatrix = fabric.util.calcDimensionsMatrix(options), bbox = fabric.util.makeBoundingBoxFromPoints(points, transformMatrix);\n            return {\n                x: bbox.width,\n                y: bbox.height\n            };\n        },\n        /**\n     * Merges 2 clip paths into one visually equal clip path\n     *\n     * **IMPORTANT**:\\\n     * Does **NOT** clone the arguments, clone them proir if necessary.\n     *\n     * Creates a wrapper (group) that contains one clip path and is clipped by the other so content is kept where both overlap.\n     * Use this method if both the clip paths may have nested clip paths of their own, so assigning one to the other's clip path property is not possible.\n     *\n     * In order to handle the `inverted` property we follow logic described in the following cases:\\\n     * **(1)** both clip paths are inverted - the clip paths pass the inverted prop to the wrapper and loose it themselves.\\\n     * **(2)** one is inverted and the other isn't - the wrapper shouldn't become inverted and the inverted clip path must clip the non inverted one to produce an identical visual effect.\\\n     * **(3)** both clip paths are not inverted - wrapper and clip paths remain unchanged.\n     *\n     * @memberOf fabric.util\n     * @param {fabric.Object} c1\n     * @param {fabric.Object} c2\n     * @returns {fabric.Object} merged clip path\n     */ mergeClipPaths: function(c1, c2) {\n            var a = c1, b = c2;\n            if (a.inverted && !b.inverted) {\n                //  case (2)\n                a = c2;\n                b = c1;\n            }\n            //  `b` becomes `a`'s clip path so we transform `b` to `a` coordinate plane\n            fabric.util.applyTransformToObject(b, fabric.util.multiplyTransformMatrices(fabric.util.invertTransform(a.calcTransformMatrix()), b.calcTransformMatrix()));\n            //  assign the `inverted` prop to the wrapping group\n            var inverted = a.inverted && b.inverted;\n            if (inverted) {\n                //  case (1)\n                a.inverted = b.inverted = false;\n            }\n            return new fabric.Group([\n                a\n            ], {\n                clipPath: b,\n                inverted: inverted\n            });\n        }\n    };\n})( true ? exports : 0);\n(function() {\n    var _join = Array.prototype.join, commandLengths = {\n        m: 2,\n        l: 2,\n        h: 1,\n        v: 1,\n        c: 6,\n        s: 4,\n        q: 4,\n        t: 2,\n        a: 7\n    }, repeatedCommands = {\n        m: \"l\",\n        M: \"L\"\n    };\n    function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {\n        var costh2 = fabric.util.cos(th2), sinth2 = fabric.util.sin(th2), costh3 = fabric.util.cos(th3), sinth3 = fabric.util.sin(th3), toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1, toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1, cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2), cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2), cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3), cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);\n        return [\n            \"C\",\n            cp1X,\n            cp1Y,\n            cp2X,\n            cp2Y,\n            toX,\n            toY\n        ];\n    }\n    /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp\n   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here\n   * http://mozilla.org/MPL/2.0/\n   */ function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {\n        var PI = Math.PI, th = rotateX * PI / 180, sinTh = fabric.util.sin(th), cosTh = fabric.util.cos(th), fromX = 0, fromY = 0;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5, py = -cosTh * toY * 0.5 + sinTh * toX * 0.5, rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px, pl = rx2 * ry2 - rx2 * py2 - ry2 * px2, root = 0;\n        if (pl < 0) {\n            var s = Math.sqrt(1 - pl / (rx2 * ry2));\n            rx *= s;\n            ry *= s;\n        } else {\n            root = (large === sweep ? -1.0 : 1.0) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));\n        }\n        var cx = root * rx * py / ry, cy = -root * ry * px / rx, cx1 = cosTh * cx - sinTh * cy + toX * 0.5, cy1 = sinTh * cx + cosTh * cy + toY * 0.5, mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry), dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);\n        if (sweep === 0 && dtheta > 0) {\n            dtheta -= 2 * PI;\n        } else if (sweep === 1 && dtheta < 0) {\n            dtheta += 2 * PI;\n        }\n        // Convert into cubic bezier segments <= 90deg\n        var segments = Math.ceil(Math.abs(dtheta / PI * 2)), result = [], mDelta = dtheta / segments, mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2), th3 = mTheta + mDelta;\n        for(var i = 0; i < segments; i++){\n            result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);\n            fromX = result[i][5];\n            fromY = result[i][6];\n            mTheta = th3;\n            th3 += mDelta;\n        }\n        return result;\n    }\n    /*\n   * Private\n   */ function calcVectorAngle(ux, uy, vx, vy) {\n        var ta = Math.atan2(uy, ux), tb = Math.atan2(vy, vx);\n        if (tb >= ta) {\n            return tb - ta;\n        } else {\n            return 2 * Math.PI - (ta - tb);\n        }\n    }\n    /**\n   * Calculate bounding box of a beziercurve\n   * @param {Number} x0 starting point\n   * @param {Number} y0\n   * @param {Number} x1 first control point\n   * @param {Number} y1\n   * @param {Number} x2 secondo control point\n   * @param {Number} y2\n   * @param {Number} x3 end of bezier\n   * @param {Number} y3\n   */ // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.\n    // TODO: can we normalize this with the starting points set at 0 and then translated the bbox?\n    function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var argsString;\n        if (fabric.cachesBoundsOfCurve) {\n            argsString = _join.call(arguments);\n            if (fabric.boundsOfCurveCache[argsString]) {\n                return fabric.boundsOfCurveCache[argsString];\n            }\n        }\n        var sqrt = Math.sqrt, min = Math.min, max = Math.max, abs = Math.abs, tvalues = [], bounds = [\n            [],\n            []\n        ], a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n        for(var i = 0; i < 2; ++i){\n            if (i > 0) {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            if (b2ac < 0) {\n                continue;\n            }\n            sqrtb2ac = sqrt(b2ac);\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n        var x, y, j = tvalues.length, jlen = j, mt;\n        while(j--){\n            t = tvalues[j];\n            mt = 1 - t;\n            x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n            bounds[0][j] = x;\n            y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n            bounds[1][j] = y;\n        }\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        var result = [\n            {\n                x: min.apply(null, bounds[0]),\n                y: min.apply(null, bounds[1])\n            },\n            {\n                x: max.apply(null, bounds[0]),\n                y: max.apply(null, bounds[1])\n            }\n        ];\n        if (fabric.cachesBoundsOfCurve) {\n            fabric.boundsOfCurveCache[argsString] = result;\n        }\n        return result;\n    }\n    /**\n   * Converts arc to a bunch of bezier curves\n   * @param {Number} fx starting point x\n   * @param {Number} fy starting point y\n   * @param {Array} coords Arc command\n   */ function fromArcToBeziers(fx, fy, coords) {\n        var rx = coords[1], ry = coords[2], rot = coords[3], large = coords[4], sweep = coords[5], tx = coords[6], ty = coords[7], segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);\n        for(var i = 0, len = segsNorm.length; i < len; i++){\n            segsNorm[i][1] += fx;\n            segsNorm[i][2] += fy;\n            segsNorm[i][3] += fx;\n            segsNorm[i][4] += fy;\n            segsNorm[i][5] += fx;\n            segsNorm[i][6] += fy;\n        }\n        return segsNorm;\n    }\n    ;\n    /**\n   * This function take a parsed SVG path and make it simpler for fabricJS logic.\n   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )\n   * S converted in C, T converted in Q, A converted in C.\n   * @param {Array} path the array of commands of a parsed svg path for fabric.Path\n   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path\n   */ function makePathSimpler(path) {\n        // x and y represent the last point of the path. the previous command point.\n        // we add them to each relative command to make it an absolute comment.\n        // we also swap the v V h H with L, because are easier to transform.\n        var x = 0, y = 0, len = path.length, // x1 and y1 represent the last point of the subpath. the subpath is started with\n        // m or M command. When a z or Z command is drawn, x and y need to be resetted to\n        // the last x1 and y1.\n        x1 = 0, y1 = 0, current, i, converted, // previous will host the letter of the previous command, to handle S and T.\n        // controlX and controlY will host the previous reflected control point\n        destinationPath = [], previous, controlX, controlY;\n        for(i = 0; i < len; ++i){\n            converted = false;\n            current = path[i].slice(0);\n            switch(current[0]){\n                case \"l\":\n                    current[0] = \"L\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"L\":\n                    x = current[1];\n                    y = current[2];\n                    break;\n                case \"h\":\n                    current[1] += x;\n                // falls through\n                case \"H\":\n                    current[0] = \"L\";\n                    current[2] = y;\n                    x = current[1];\n                    break;\n                case \"v\":\n                    current[1] += y;\n                // falls through\n                case \"V\":\n                    current[0] = \"L\";\n                    y = current[1];\n                    current[1] = x;\n                    current[2] = y;\n                    break;\n                case \"m\":\n                    current[0] = \"M\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"M\":\n                    x = current[1];\n                    y = current[2];\n                    x1 = current[1];\n                    y1 = current[2];\n                    break;\n                case \"c\":\n                    current[0] = \"C\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                    current[5] += x;\n                    current[6] += y;\n                // falls through\n                case \"C\":\n                    controlX = current[3];\n                    controlY = current[4];\n                    x = current[5];\n                    y = current[6];\n                    break;\n                case \"s\":\n                    current[0] = \"S\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                // falls through\n                case \"S\":\n                    // would be sScC but since we are swapping sSc for C, we check just that.\n                    if (previous === \"C\") {\n                        // calculate reflection of previous control points\n                        controlX = 2 * x - controlX;\n                        controlY = 2 * y - controlY;\n                    } else {\n                        // If there is no previous command or if the previous command was not a C, c, S, or s,\n                        // the control point is coincident with the current point\n                        controlX = x;\n                        controlY = y;\n                    }\n                    x = current[3];\n                    y = current[4];\n                    current[0] = \"C\";\n                    current[5] = current[3];\n                    current[6] = current[4];\n                    current[3] = current[1];\n                    current[4] = current[2];\n                    current[1] = controlX;\n                    current[2] = controlY;\n                    // current[3] and current[4] are NOW the second control point.\n                    // we keep it for the next reflection.\n                    controlX = current[3];\n                    controlY = current[4];\n                    break;\n                case \"q\":\n                    current[0] = \"Q\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                // falls through\n                case \"Q\":\n                    controlX = current[1];\n                    controlY = current[2];\n                    x = current[3];\n                    y = current[4];\n                    break;\n                case \"t\":\n                    current[0] = \"T\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"T\":\n                    if (previous === \"Q\") {\n                        // calculate reflection of previous control point\n                        controlX = 2 * x - controlX;\n                        controlY = 2 * y - controlY;\n                    } else {\n                        // If there is no previous command or if the previous command was not a Q, q, T or t,\n                        // assume the control point is coincident with the current point\n                        controlX = x;\n                        controlY = y;\n                    }\n                    current[0] = \"Q\";\n                    x = current[1];\n                    y = current[2];\n                    current[1] = controlX;\n                    current[2] = controlY;\n                    current[3] = x;\n                    current[4] = y;\n                    break;\n                case \"a\":\n                    current[0] = \"A\";\n                    current[6] += x;\n                    current[7] += y;\n                // falls through\n                case \"A\":\n                    converted = true;\n                    destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));\n                    x = current[6];\n                    y = current[7];\n                    break;\n                case \"z\":\n                case \"Z\":\n                    x = x1;\n                    y = y1;\n                    break;\n                default:\n            }\n            if (!converted) {\n                destinationPath.push(current);\n            }\n            previous = current[0];\n        }\n        return destinationPath;\n    }\n    ;\n    /**\n   * Calc length from point x1,y1 to x2,y2\n   * @param {Number} x1 starting point x\n   * @param {Number} y1 starting point y\n   * @param {Number} x2 starting point x\n   * @param {Number} y2 starting point y\n   * @return {Number} length of segment\n   */ function calcLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    // functions for the Cubic beizer\n    // taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350\n    function CB1(t) {\n        return t * t * t;\n    }\n    function CB2(t) {\n        return 3 * t * t * (1 - t);\n    }\n    function CB3(t) {\n        return 3 * t * (1 - t) * (1 - t);\n    }\n    function CB4(t) {\n        return (1 - t) * (1 - t) * (1 - t);\n    }\n    function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        return function(pct) {\n            var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);\n            return {\n                x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,\n                y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4\n            };\n        };\n    }\n    function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        return function(pct) {\n            var invT = 1 - pct, tangentX = 3 * invT * invT * (p2x - p1x) + 6 * invT * pct * (p3x - p2x) + 3 * pct * pct * (p4x - p3x), tangentY = 3 * invT * invT * (p2y - p1y) + 6 * invT * pct * (p3y - p2y) + 3 * pct * pct * (p4y - p3y);\n            return Math.atan2(tangentY, tangentX);\n        };\n    }\n    function QB1(t) {\n        return t * t;\n    }\n    function QB2(t) {\n        return 2 * t * (1 - t);\n    }\n    function QB3(t) {\n        return (1 - t) * (1 - t);\n    }\n    function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return function(pct) {\n            var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);\n            return {\n                x: p3x * c1 + p2x * c2 + p1x * c3,\n                y: p3y * c1 + p2y * c2 + p1y * c3\n            };\n        };\n    }\n    function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return function(pct) {\n            var invT = 1 - pct, tangentX = 2 * invT * (p2x - p1x) + 2 * pct * (p3x - p2x), tangentY = 2 * invT * (p2y - p1y) + 2 * pct * (p3y - p2y);\n            return Math.atan2(tangentY, tangentX);\n        };\n    }\n    // this will run over a path segment ( a cubic or quadratic segment) and approximate it\n    // with 100 segemnts. This will good enough to calculate the length of the curve\n    function pathIterator(iterator, x1, y1) {\n        var tempP = {\n            x: x1,\n            y: y1\n        }, p, tmpLen = 0, perc;\n        for(perc = 1; perc <= 100; perc += 1){\n            p = iterator(perc / 100);\n            tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);\n            tempP = p;\n        }\n        return tmpLen;\n    }\n    /**\n   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1\n   * that correspond to that pixels run over the path.\n   * The percentage will be then used to find the correct point on the canvas for the path.\n   * @param {Array} segInfo fabricJS collection of information on a parsed path\n   * @param {Number} distance from starting point, in pixels.\n   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;\n   */ function findPercentageForDistance(segInfo, distance) {\n        var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = {\n            x: segInfo.x,\n            y: segInfo.y\n        }, p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;\n        // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100\n        // the path\n        while(tmpLen < distance && nextStep > 0.0001){\n            p = iterator(perc);\n            lastPerc = perc;\n            nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);\n            // compare tmpLen each cycle with distance, decide next perc to test.\n            if (nextLen + tmpLen > distance) {\n                // we discard this step and we make smaller steps.\n                perc -= nextStep;\n                nextStep /= 2;\n            } else {\n                tempP = p;\n                perc += nextStep;\n                tmpLen += nextLen;\n            }\n        }\n        p.angle = angleFinder(lastPerc);\n        return p;\n    }\n    /**\n   * Run over a parsed and simplifed path and extrac some informations.\n   * informations are length of each command and starting point\n   * @param {Array} path fabricJS parsed path commands\n   * @return {Array} path commands informations\n   */ function getPathSegmentsInfo(path) {\n        var totalLength = 0, len = path.length, current, //x2 and y2 are the coords of segment start\n        //x1 and y1 are the coords of the current point\n        x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;\n        for(var i = 0; i < len; i++){\n            current = path[i];\n            tempInfo = {\n                x: x1,\n                y: y1,\n                command: current[0]\n            };\n            switch(current[0]){\n                case \"M\":\n                    tempInfo.length = 0;\n                    x2 = x1 = current[1];\n                    y2 = y1 = current[2];\n                    break;\n                case \"L\":\n                    tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);\n                    x1 = current[1];\n                    y1 = current[2];\n                    break;\n                case \"C\":\n                    iterator = getPointOnCubicBezierIterator(x1, y1, current[1], current[2], current[3], current[4], current[5], current[6]);\n                    angleFinder = getTangentCubicIterator(x1, y1, current[1], current[2], current[3], current[4], current[5], current[6]);\n                    tempInfo.iterator = iterator;\n                    tempInfo.angleFinder = angleFinder;\n                    tempInfo.length = pathIterator(iterator, x1, y1);\n                    x1 = current[5];\n                    y1 = current[6];\n                    break;\n                case \"Q\":\n                    iterator = getPointOnQuadraticBezierIterator(x1, y1, current[1], current[2], current[3], current[4]);\n                    angleFinder = getTangentQuadraticIterator(x1, y1, current[1], current[2], current[3], current[4]);\n                    tempInfo.iterator = iterator;\n                    tempInfo.angleFinder = angleFinder;\n                    tempInfo.length = pathIterator(iterator, x1, y1);\n                    x1 = current[3];\n                    y1 = current[4];\n                    break;\n                case \"Z\":\n                case \"z\":\n                    // we add those in order to ease calculations later\n                    tempInfo.destX = x2;\n                    tempInfo.destY = y2;\n                    tempInfo.length = calcLineLength(x1, y1, x2, y2);\n                    x1 = x2;\n                    y1 = y2;\n                    break;\n            }\n            totalLength += tempInfo.length;\n            info.push(tempInfo);\n        }\n        info.push({\n            length: totalLength,\n            x: x1,\n            y: y1\n        });\n        return info;\n    }\n    function getPointOnPath(path, distance, infos) {\n        if (!infos) {\n            infos = getPathSegmentsInfo(path);\n        }\n        var i = 0;\n        while(distance - infos[i].length > 0 && i < infos.length - 2){\n            distance -= infos[i].length;\n            i++;\n        }\n        // var distance = infos[infos.length - 1] * perc;\n        var segInfo = infos[i], segPercent = distance / segInfo.length, command = segInfo.command, segment = path[i], info;\n        switch(command){\n            case \"M\":\n                return {\n                    x: segInfo.x,\n                    y: segInfo.y,\n                    angle: 0\n                };\n            case \"Z\":\n            case \"z\":\n                info = new fabric.Point(segInfo.x, segInfo.y).lerp(new fabric.Point(segInfo.destX, segInfo.destY), segPercent);\n                info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);\n                return info;\n            case \"L\":\n                info = new fabric.Point(segInfo.x, segInfo.y).lerp(new fabric.Point(segment[1], segment[2]), segPercent);\n                info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);\n                return info;\n            case \"C\":\n                return findPercentageForDistance(segInfo, distance);\n            case \"Q\":\n                return findPercentageForDistance(segInfo, distance);\n        }\n    }\n    /**\n   *\n   * @param {string} pathString\n   * @return {(string|number)[][]} An array of SVG path commands\n   * @example <caption>Usage</caption>\n   * parsePath('M 3 4 Q 3 5 2 1 4 0 Q 9 12 2 1 4 0') === [\n   *   ['M', 3, 4],\n   *   ['Q', 3, 5, 2, 1, 4, 0],\n   *   ['Q', 9, 12, 2, 1, 4, 0],\n   * ];\n   *\n   */ function parsePath(pathString) {\n        var result = [], coords = [], currentPath, parsed, re = fabric.rePathCommand, rNumber = \"[-+]?(?:\\\\d*\\\\.\\\\d+|\\\\d+\\\\.?)(?:[eE][-+]?\\\\d+)?\\\\s*\", rNumberCommaWsp = \"(\" + rNumber + \")\" + fabric.commaWsp, rFlagCommaWsp = \"([01])\" + fabric.commaWsp + \"?\", rArcSeq = rNumberCommaWsp + \"?\" + rNumberCommaWsp + \"?\" + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp + rNumberCommaWsp + \"?(\" + rNumber + \")\", regArcArgumentSequence = new RegExp(rArcSeq, \"g\"), match, coordsStr, // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)\n        path;\n        if (!pathString || !pathString.match) {\n            return result;\n        }\n        path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);\n        for(var i = 0, coordsParsed, len = path.length; i < len; i++){\n            currentPath = path[i];\n            coordsStr = currentPath.slice(1).trim();\n            coords.length = 0;\n            var command = currentPath.charAt(0);\n            coordsParsed = [\n                command\n            ];\n            if (command.toLowerCase() === \"a\") {\n                // arcs have special flags that apparently don't require spaces so handle special\n                for(var args; args = regArcArgumentSequence.exec(coordsStr);){\n                    for(var j = 1; j < args.length; j++){\n                        coords.push(args[j]);\n                    }\n                }\n            } else {\n                while(match = re.exec(coordsStr)){\n                    coords.push(match[0]);\n                }\n            }\n            for(var j = 0, jlen = coords.length; j < jlen; j++){\n                parsed = parseFloat(coords[j]);\n                if (!isNaN(parsed)) {\n                    coordsParsed.push(parsed);\n                }\n            }\n            var commandLength = commandLengths[command.toLowerCase()], repeatedCommand = repeatedCommands[command] || command;\n            if (coordsParsed.length - 1 > commandLength) {\n                for(var k = 1, klen = coordsParsed.length; k < klen; k += commandLength){\n                    result.push([\n                        command\n                    ].concat(coordsParsed.slice(k, k + commandLength)));\n                    command = repeatedCommand;\n                }\n            } else {\n                result.push(coordsParsed);\n            }\n        }\n        return result;\n    }\n    ;\n    /**\n   *\n   * Converts points to a smooth SVG path\n   * @param {{ x: number,y: number }[]} points Array of points\n   * @param {number} [correction] Apply a correction to the path (usually we use `width / 1000`). If value is undefined 0 is used as the correction value.\n   * @return {(string|number)[][]} An array of SVG path commands\n   */ function getSmoothPathFromPoints(points, correction) {\n        var path = [], i, p1 = new fabric.Point(points[0].x, points[0].y), p2 = new fabric.Point(points[1].x, points[1].y), len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;\n        correction = correction || 0;\n        if (manyPoints) {\n            multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;\n            multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;\n        }\n        path.push([\n            \"M\",\n            p1.x - multSignX * correction,\n            p1.y - multSignY * correction\n        ]);\n        for(i = 1; i < len; i++){\n            if (!p1.eq(p2)) {\n                var midPoint = p1.midPointFrom(p2);\n                // p1 is our bezier control point\n                // midpoint is our endpoint\n                // start point is p(i-1) value.\n                path.push([\n                    \"Q\",\n                    p1.x,\n                    p1.y,\n                    midPoint.x,\n                    midPoint.y\n                ]);\n            }\n            p1 = points[i];\n            if (i + 1 < points.length) {\n                p2 = points[i + 1];\n            }\n        }\n        if (manyPoints) {\n            multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;\n            multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;\n        }\n        path.push([\n            \"L\",\n            p1.x + multSignX * correction,\n            p1.y + multSignY * correction\n        ]);\n        return path;\n    }\n    /**\n   * Transform a path by transforming each segment.\n   * it has to be a simplified path or it won't work.\n   * WARNING: this depends from pathOffset for correct operation\n   * @param {Array} path fabricJS parsed and simplified path commands\n   * @param {Array} transform matrix that represent the transformation\n   * @param {Object} [pathOffset] the fabric.Path pathOffset\n   * @param {Number} pathOffset.x\n   * @param {Number} pathOffset.y\n   * @returns {Array} the transformed path\n   */ function transformPath(path, transform, pathOffset) {\n        if (pathOffset) {\n            transform = fabric.util.multiplyTransformMatrices(transform, [\n                1,\n                0,\n                0,\n                1,\n                -pathOffset.x,\n                -pathOffset.y\n            ]);\n        }\n        return path.map(function(pathSegment) {\n            var newSegment = pathSegment.slice(0), point = {};\n            for(var i = 1; i < pathSegment.length - 1; i += 2){\n                point.x = pathSegment[i];\n                point.y = pathSegment[i + 1];\n                point = fabric.util.transformPoint(point, transform);\n                newSegment[i] = point.x;\n                newSegment[i + 1] = point.y;\n            }\n            return newSegment;\n        });\n    }\n    /**\n   * Join path commands to go back to svg format\n   * @param {Array} pathData fabricJS parsed path commands\n   * @return {String} joined path 'M 0 0 L 20 30'\n   */ fabric.util.joinPath = function(pathData) {\n        return pathData.map(function(segment) {\n            return segment.join(\" \");\n        }).join(\" \");\n    };\n    fabric.util.parsePath = parsePath;\n    fabric.util.makePathSimpler = makePathSimpler;\n    fabric.util.getSmoothPathFromPoints = getSmoothPathFromPoints;\n    fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;\n    fabric.util.getBoundsOfCurve = getBoundsOfCurve;\n    fabric.util.getPointOnPath = getPointOnPath;\n    fabric.util.transformPath = transformPath;\n})();\n(function() {\n    var slice = Array.prototype.slice;\n    /**\n   * Invokes method on all items in a given array\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} method Name of a method to invoke\n   * @return {Array}\n   */ function invoke(array, method) {\n        var args = slice.call(arguments, 2), result = [];\n        for(var i = 0, len = array.length; i < len; i++){\n            result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);\n        }\n        return result;\n    }\n    /**\n   * Finds maximum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */ function max(array, byProperty) {\n        return find(array, byProperty, function(value1, value2) {\n            return value1 >= value2;\n        });\n    }\n    /**\n   * Finds minimum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */ function min(array, byProperty) {\n        return find(array, byProperty, function(value1, value2) {\n            return value1 < value2;\n        });\n    }\n    /**\n   * @private\n   */ function fill(array, value) {\n        var k = array.length;\n        while(k--){\n            array[k] = value;\n        }\n        return array;\n    }\n    /**\n   * @private\n   */ function find(array, byProperty, condition) {\n        if (!array || array.length === 0) {\n            return;\n        }\n        var i = array.length - 1, result = byProperty ? array[i][byProperty] : array[i];\n        if (byProperty) {\n            while(i--){\n                if (condition(array[i][byProperty], result)) {\n                    result = array[i][byProperty];\n                }\n            }\n        } else {\n            while(i--){\n                if (condition(array[i], result)) {\n                    result = array[i];\n                }\n            }\n        }\n        return result;\n    }\n    /**\n   * @namespace fabric.util.array\n   */ fabric.util.array = {\n        fill: fill,\n        invoke: invoke,\n        min: min,\n        max: max\n    };\n})();\n(function() {\n    /**\n   * Copies all enumerable properties of one js object to another\n   * this does not and cannot compete with generic utils.\n   * Does not clone or extend fabric.Object subclasses.\n   * This is mostly for internal use and has extra handling for fabricJS objects\n   * it skips the canvas and group properties in deep cloning.\n   * @memberOf fabric.util.object\n   * @param {Object} destination Where to copy to\n   * @param {Object} source Where to copy from\n   * @param {Boolean} [deep] Whether to extend nested objects\n   * @return {Object}\n   */ function extend(destination, source, deep) {\n        // JScript DontEnum bug is not taken care of\n        // the deep clone is for internal use, is not meant to avoid\n        // javascript traps or cloning html element or self referenced objects.\n        if (deep) {\n            if (!fabric.isLikelyNode && source instanceof Element) {\n                // avoid cloning deep images, canvases,\n                destination = source;\n            } else if (source instanceof Array) {\n                destination = [];\n                for(var i = 0, len = source.length; i < len; i++){\n                    destination[i] = extend({}, source[i], deep);\n                }\n            } else if (source && typeof source === \"object\") {\n                for(var property in source){\n                    if (property === \"canvas\" || property === \"group\") {\n                        // we do not want to clone this props at all.\n                        // we want to keep the keys in the copy\n                        destination[property] = null;\n                    } else if (source.hasOwnProperty(property)) {\n                        destination[property] = extend({}, source[property], deep);\n                    }\n                }\n            } else {\n                // this sounds odd for an extend but is ok for recursive use\n                destination = source;\n            }\n        } else {\n            for(var property in source){\n                destination[property] = source[property];\n            }\n        }\n        return destination;\n    }\n    /**\n   * Creates an empty object and copies all enumerable properties of another object to it\n   * This method is mostly for internal use, and not intended for duplicating shapes in canvas. \n   * @memberOf fabric.util.object\n   * @param {Object} object Object to clone\n   * @param {Boolean} [deep] Whether to clone nested objects\n   * @return {Object}\n   */ //TODO: this function return an empty object if you try to clone null\n    function clone(object, deep) {\n        return extend({}, object, deep);\n    }\n    /** @namespace fabric.util.object */ fabric.util.object = {\n        extend: extend,\n        clone: clone\n    };\n    fabric.util.object.extend(fabric.util, fabric.Observable);\n})();\n(function() {\n    /**\n   * Camelizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to camelize\n   * @return {String} Camelized version of a string\n   */ function camelize(string) {\n        return string.replace(/-+(.)?/g, function(match, character) {\n            return character ? character.toUpperCase() : \"\";\n        });\n    }\n    /**\n   * Capitalizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to capitalize\n   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized\n   * and other letters stay untouched, if false first letter is capitalized\n   * and other letters are converted to lowercase.\n   * @return {String} Capitalized version of a string\n   */ function capitalize(string, firstLetterOnly) {\n        return string.charAt(0).toUpperCase() + (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());\n    }\n    /**\n   * Escapes XML in a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to escape\n   * @return {String} Escaped version of a string\n   */ function escapeXml(string) {\n        return string.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n    /**\n   * Divide a string in the user perceived single units\n   * @memberOf fabric.util.string\n   * @param {String} textstring String to escape\n   * @return {Array} array containing the graphemes\n   */ function graphemeSplit(textstring) {\n        var i = 0, chr, graphemes = [];\n        for(i = 0, chr; i < textstring.length; i++){\n            if ((chr = getWholeChar(textstring, i)) === false) {\n                continue;\n            }\n            graphemes.push(chr);\n        }\n        return graphemes;\n    }\n    // taken from mdn in the charAt doc page.\n    function getWholeChar(str, i) {\n        var code = str.charCodeAt(i);\n        if (isNaN(code)) {\n            return \"\"; // Position not found\n        }\n        if (code < 0xD800 || code > 0xDFFF) {\n            return str.charAt(i);\n        }\n        // High surrogate (could change last hex to 0xDB7F to treat high private\n        // surrogates as single characters)\n        if (0xD800 <= code && code <= 0xDBFF) {\n            if (str.length <= i + 1) {\n                throw \"High surrogate without following low surrogate\";\n            }\n            var next = str.charCodeAt(i + 1);\n            if (0xDC00 > next || next > 0xDFFF) {\n                throw \"High surrogate without following low surrogate\";\n            }\n            return str.charAt(i) + str.charAt(i + 1);\n        }\n        // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n        if (i === 0) {\n            throw \"Low surrogate without preceding high surrogate\";\n        }\n        var prev = str.charCodeAt(i - 1);\n        // (could change last hex to 0xDB7F to treat high private\n        // surrogates as single characters)\n        if (0xD800 > prev || prev > 0xDBFF) {\n            throw \"Low surrogate without preceding high surrogate\";\n        }\n        // We can pass over low surrogates now as the second component\n        // in a pair which we have already processed\n        return false;\n    }\n    /**\n   * String utilities\n   * @namespace fabric.util.string\n   */ fabric.util.string = {\n        camelize: camelize,\n        capitalize: capitalize,\n        escapeXml: escapeXml,\n        graphemeSplit: graphemeSplit\n    };\n})();\n(function() {\n    var slice = Array.prototype.slice, emptyFunction = function() {}, IS_DONTENUM_BUGGY = function() {\n        for(var p in {\n            toString: 1\n        }){\n            if (p === \"toString\") {\n                return false;\n            }\n        }\n        return true;\n    }(), /** @ignore */ addMethods = function(klass, source, parent) {\n        for(var property in source){\n            if (property in klass.prototype && typeof klass.prototype[property] === \"function\" && (source[property] + \"\").indexOf(\"callSuper\") > -1) {\n                klass.prototype[property] = function(property) {\n                    return function() {\n                        var superclass = this.constructor.superclass;\n                        this.constructor.superclass = parent;\n                        var returnValue = source[property].apply(this, arguments);\n                        this.constructor.superclass = superclass;\n                        if (property !== \"initialize\") {\n                            return returnValue;\n                        }\n                    };\n                }(property);\n            } else {\n                klass.prototype[property] = source[property];\n            }\n            if (IS_DONTENUM_BUGGY) {\n                if (source.toString !== Object.prototype.toString) {\n                    klass.prototype.toString = source.toString;\n                }\n                if (source.valueOf !== Object.prototype.valueOf) {\n                    klass.prototype.valueOf = source.valueOf;\n                }\n            }\n        }\n    };\n    function Subclass() {}\n    function callSuper(methodName) {\n        var parentMethod = null, _this = this;\n        // climb prototype chain to find method not equal to callee's method\n        while(_this.constructor.superclass){\n            var superClassMethod = _this.constructor.superclass.prototype[methodName];\n            if (_this[methodName] !== superClassMethod) {\n                parentMethod = superClassMethod;\n                break;\n            }\n            // eslint-disable-next-line\n            _this = _this.constructor.superclass.prototype;\n        }\n        if (!parentMethod) {\n            return console.log(\"tried to callSuper \" + methodName + \", method not found in prototype chain\", this);\n        }\n        return arguments.length > 1 ? parentMethod.apply(this, slice.call(arguments, 1)) : parentMethod.call(this);\n    }\n    /**\n   * Helper for creation of \"classes\".\n   * @memberOf fabric.util\n   * @param {Function} [parent] optional \"Class\" to inherit from\n   * @param {Object} [properties] Properties shared by all instances of this class\n   *                  (be careful modifying objects defined here as this would affect all instances)\n   */ function createClass() {\n        var parent = null, properties = slice.call(arguments, 0);\n        if (typeof properties[0] === \"function\") {\n            parent = properties.shift();\n        }\n        function klass() {\n            this.initialize.apply(this, arguments);\n        }\n        klass.superclass = parent;\n        klass.subclasses = [];\n        if (parent) {\n            Subclass.prototype = parent.prototype;\n            klass.prototype = new Subclass();\n            parent.subclasses.push(klass);\n        }\n        for(var i = 0, length = properties.length; i < length; i++){\n            addMethods(klass, properties[i], parent);\n        }\n        if (!klass.prototype.initialize) {\n            klass.prototype.initialize = emptyFunction;\n        }\n        klass.prototype.constructor = klass;\n        klass.prototype.callSuper = callSuper;\n        return klass;\n    }\n    fabric.util.createClass = createClass;\n})();\n(function() {\n    // since ie11 can use addEventListener but they do not support options, i need to check\n    var couldUseAttachEvent = !!fabric.document.createElement(\"div\").attachEvent, touchEvents = [\n        \"touchstart\",\n        \"touchmove\",\n        \"touchend\"\n    ];\n    /**\n   * Adds an event listener to an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */ fabric.util.addListener = function(element, eventName, handler, options) {\n        element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);\n    };\n    /**\n   * Removes an event listener from an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */ fabric.util.removeListener = function(element, eventName, handler, options) {\n        element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);\n    };\n    function getTouchInfo(event) {\n        var touchProp = event.changedTouches;\n        if (touchProp && touchProp[0]) {\n            return touchProp[0];\n        }\n        return event;\n    }\n    fabric.util.getPointer = function(event) {\n        var element = event.target, scroll = fabric.util.getScrollLeftTop(element), _evt = getTouchInfo(event);\n        return {\n            x: _evt.clientX + scroll.left,\n            y: _evt.clientY + scroll.top\n        };\n    };\n    fabric.util.isTouchEvent = function(event) {\n        return touchEvents.indexOf(event.type) > -1 || event.pointerType === \"touch\";\n    };\n})();\n(function() {\n    /**\n   * Cross-browser wrapper for setting element's style\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   * @return {HTMLElement} Element that was passed as a first argument\n   */ function setStyle(element, styles) {\n        var elementStyle = element.style;\n        if (!elementStyle) {\n            return element;\n        }\n        if (typeof styles === \"string\") {\n            element.style.cssText += \";\" + styles;\n            return styles.indexOf(\"opacity\") > -1 ? setOpacity(element, styles.match(/opacity:\\s*(\\d?\\.?\\d*)/)[1]) : element;\n        }\n        for(var property in styles){\n            if (property === \"opacity\") {\n                setOpacity(element, styles[property]);\n            } else {\n                var normalizedProperty = property === \"float\" || property === \"cssFloat\" ? typeof elementStyle.styleFloat === \"undefined\" ? \"cssFloat\" : \"styleFloat\" : property;\n                elementStyle[normalizedProperty] = styles[property];\n            }\n        }\n        return element;\n    }\n    var parseEl = fabric.document.createElement(\"div\"), supportsOpacity = typeof parseEl.style.opacity === \"string\", supportsFilters = typeof parseEl.style.filter === \"string\", reOpacity = /alpha\\s*\\(\\s*opacity\\s*=\\s*([^\\)]+)\\)/, /** @ignore */ setOpacity = function(element) {\n        return element;\n    };\n    if (supportsOpacity) {\n        /** @ignore */ setOpacity = function(element, value) {\n            element.style.opacity = value;\n            return element;\n        };\n    } else if (supportsFilters) {\n        /** @ignore */ setOpacity = function(element, value) {\n            var es = element.style;\n            if (element.currentStyle && !element.currentStyle.hasLayout) {\n                es.zoom = 1;\n            }\n            if (reOpacity.test(es.filter)) {\n                value = value >= 0.9999 ? \"\" : \"alpha(opacity=\" + value * 100 + \")\";\n                es.filter = es.filter.replace(reOpacity, value);\n            } else {\n                es.filter += \" alpha(opacity=\" + value * 100 + \")\";\n            }\n            return element;\n        };\n    }\n    fabric.util.setStyle = setStyle;\n})();\n(function() {\n    var _slice = Array.prototype.slice;\n    /**\n   * Takes id and returns an element with that id (if one exists in a document)\n   * @memberOf fabric.util\n   * @param {String|HTMLElement} id\n   * @return {HTMLElement|null}\n   */ function getById(id) {\n        return typeof id === \"string\" ? fabric.document.getElementById(id) : id;\n    }\n    var sliceCanConvertNodelists, /**\n       * Converts an array-like object (e.g. arguments or NodeList) to an array\n       * @memberOf fabric.util\n       * @param {Object} arrayLike\n       * @return {Array}\n       */ toArray = function(arrayLike) {\n        return _slice.call(arrayLike, 0);\n    };\n    try {\n        sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;\n    } catch (err) {}\n    if (!sliceCanConvertNodelists) {\n        toArray = function(arrayLike) {\n            var arr = new Array(arrayLike.length), i = arrayLike.length;\n            while(i--){\n                arr[i] = arrayLike[i];\n            }\n            return arr;\n        };\n    }\n    /**\n   * Creates specified element with specified attributes\n   * @memberOf fabric.util\n   * @param {String} tagName Type of an element to create\n   * @param {Object} [attributes] Attributes to set on an element\n   * @return {HTMLElement} Newly created element\n   */ function makeElement(tagName, attributes) {\n        var el = fabric.document.createElement(tagName);\n        for(var prop in attributes){\n            if (prop === \"class\") {\n                el.className = attributes[prop];\n            } else if (prop === \"for\") {\n                el.htmlFor = attributes[prop];\n            } else {\n                el.setAttribute(prop, attributes[prop]);\n            }\n        }\n        return el;\n    }\n    /**\n   * Adds class to an element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to add class to\n   * @param {String} className Class to add to an element\n   */ function addClass(element, className) {\n        if (element && (\" \" + element.className + \" \").indexOf(\" \" + className + \" \") === -1) {\n            element.className += (element.className ? \" \" : \"\") + className;\n        }\n    }\n    /**\n   * Wraps element with another element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to wrap\n   * @param {HTMLElement|String} wrapper Element to wrap with\n   * @param {Object} [attributes] Attributes to set on a wrapper\n   * @return {HTMLElement} wrapper\n   */ function wrapElement(element, wrapper, attributes) {\n        if (typeof wrapper === \"string\") {\n            wrapper = makeElement(wrapper, attributes);\n        }\n        if (element.parentNode) {\n            element.parentNode.replaceChild(wrapper, element);\n        }\n        wrapper.appendChild(element);\n        return wrapper;\n    }\n    /**\n   * Returns element scroll offsets\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to operate on\n   * @return {Object} Object with left/top values\n   */ function getScrollLeftTop(element) {\n        var left = 0, top = 0, docElement = fabric.document.documentElement, body = fabric.document.body || {\n            scrollLeft: 0,\n            scrollTop: 0\n        };\n        // While loop checks (and then sets element to) .parentNode OR .host\n        //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,\n        //  but the .parentNode of a root ShadowDOM node will always be null, instead\n        //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938\n        while(element && (element.parentNode || element.host)){\n            // Set element to element parent, or 'host' in case of ShadowDOM\n            element = element.parentNode || element.host;\n            if (element === fabric.document) {\n                left = body.scrollLeft || docElement.scrollLeft || 0;\n                top = body.scrollTop || docElement.scrollTop || 0;\n            } else {\n                left += element.scrollLeft || 0;\n                top += element.scrollTop || 0;\n            }\n            if (element.nodeType === 1 && element.style.position === \"fixed\") {\n                break;\n            }\n        }\n        return {\n            left: left,\n            top: top\n        };\n    }\n    /**\n   * Returns offset for a given element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get offset for\n   * @return {Object} Object with \"left\" and \"top\" properties\n   */ function getElementOffset(element) {\n        var docElem, doc = element && element.ownerDocument, box = {\n            left: 0,\n            top: 0\n        }, offset = {\n            left: 0,\n            top: 0\n        }, scrollLeftTop, offsetAttributes = {\n            borderLeftWidth: \"left\",\n            borderTopWidth: \"top\",\n            paddingLeft: \"left\",\n            paddingTop: \"top\"\n        };\n        if (!doc) {\n            return offset;\n        }\n        for(var attr in offsetAttributes){\n            offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;\n        }\n        docElem = doc.documentElement;\n        if (typeof element.getBoundingClientRect !== \"undefined\") {\n            box = element.getBoundingClientRect();\n        }\n        scrollLeftTop = getScrollLeftTop(element);\n        return {\n            left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,\n            top: box.top + scrollLeftTop.top - (docElem.clientTop || 0) + offset.top\n        };\n    }\n    /**\n   * Returns style attribute value of a given element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get style attribute for\n   * @param {String} attr Style attribute to get for element\n   * @return {String} Style attribute value of the given element.\n   */ var getElementStyle;\n    if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {\n        getElementStyle = function(element, attr) {\n            var style = fabric.document.defaultView.getComputedStyle(element, null);\n            return style ? style[attr] : undefined;\n        };\n    } else {\n        getElementStyle = function(element, attr) {\n            var value = element.style[attr];\n            if (!value && element.currentStyle) {\n                value = element.currentStyle[attr];\n            }\n            return value;\n        };\n    }\n    (function() {\n        var style = fabric.document.documentElement.style, selectProp = \"userSelect\" in style ? \"userSelect\" : \"MozUserSelect\" in style ? \"MozUserSelect\" : \"WebkitUserSelect\" in style ? \"WebkitUserSelect\" : \"KhtmlUserSelect\" in style ? \"KhtmlUserSelect\" : \"\";\n        /**\n     * Makes element unselectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make unselectable\n     * @return {HTMLElement} Element that was passed in\n     */ function makeElementUnselectable(element) {\n            if (typeof element.onselectstart !== \"undefined\") {\n                element.onselectstart = fabric.util.falseFunction;\n            }\n            if (selectProp) {\n                element.style[selectProp] = \"none\";\n            } else if (typeof element.unselectable === \"string\") {\n                element.unselectable = \"on\";\n            }\n            return element;\n        }\n        /**\n     * Makes element selectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make selectable\n     * @return {HTMLElement} Element that was passed in\n     */ function makeElementSelectable(element) {\n            if (typeof element.onselectstart !== \"undefined\") {\n                element.onselectstart = null;\n            }\n            if (selectProp) {\n                element.style[selectProp] = \"\";\n            } else if (typeof element.unselectable === \"string\") {\n                element.unselectable = \"\";\n            }\n            return element;\n        }\n        fabric.util.makeElementUnselectable = makeElementUnselectable;\n        fabric.util.makeElementSelectable = makeElementSelectable;\n    })();\n    function getNodeCanvas(element) {\n        var impl = fabric.jsdomImplForWrapper(element);\n        return impl._canvas || impl._image;\n    }\n    ;\n    function cleanUpJsdomNode(element) {\n        if (!fabric.isLikelyNode) {\n            return;\n        }\n        var impl = fabric.jsdomImplForWrapper(element);\n        if (impl) {\n            impl._image = null;\n            impl._canvas = null;\n            // unsure if necessary\n            impl._currentSrc = null;\n            impl._attributes = null;\n            impl._classList = null;\n        }\n    }\n    function setImageSmoothing(ctx, value) {\n        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;\n        ctx.imageSmoothingEnabled = value;\n    }\n    /**\n   * setImageSmoothing sets the context imageSmoothingEnabled property.\n   * Used by canvas and by ImageObject.\n   * @memberOf fabric.util\n   * @since 4.0.0\n   * @param {HTMLRenderingContext2D} ctx to set on\n   * @param {Boolean} value true or false\n   */ fabric.util.setImageSmoothing = setImageSmoothing;\n    fabric.util.getById = getById;\n    fabric.util.toArray = toArray;\n    fabric.util.addClass = addClass;\n    fabric.util.makeElement = makeElement;\n    fabric.util.wrapElement = wrapElement;\n    fabric.util.getScrollLeftTop = getScrollLeftTop;\n    fabric.util.getElementOffset = getElementOffset;\n    fabric.util.getNodeCanvas = getNodeCanvas;\n    fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;\n})();\n(function() {\n    function addParamToUrl(url, param) {\n        return url + (/\\?/.test(url) ? \"&\" : \"?\") + param;\n    }\n    function emptyFn() {}\n    /**\n   * Cross-browser abstraction for sending XMLHttpRequest\n   * @memberOf fabric.util\n   * @param {String} url URL to send XMLHttpRequest to\n   * @param {Object} [options] Options object\n   * @param {String} [options.method=\"GET\"]\n   * @param {String} [options.parameters] parameters to append to url in GET or in body\n   * @param {String} [options.body] body to send with POST or PUT request\n   * @param {Function} options.onComplete Callback to invoke when request is completed\n   * @return {XMLHttpRequest} request\n   */ function request(url, options) {\n        options || (options = {});\n        var method = options.method ? options.method.toUpperCase() : \"GET\", onComplete = options.onComplete || function() {}, xhr = new fabric.window.XMLHttpRequest(), body = options.body || options.parameters;\n        /** @ignore */ xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4) {\n                onComplete(xhr);\n                xhr.onreadystatechange = emptyFn;\n            }\n        };\n        if (method === \"GET\") {\n            body = null;\n            if (typeof options.parameters === \"string\") {\n                url = addParamToUrl(url, options.parameters);\n            }\n        }\n        xhr.open(method, url, true);\n        if (method === \"POST\" || method === \"PUT\") {\n            xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        }\n        xhr.send(body);\n        return xhr;\n    }\n    fabric.util.request = request;\n})();\n/**\n * Wrapper around `console.log` (when available)\n * @param {*} [values] Values to log\n */ fabric.log = console.log;\n/**\n * Wrapper around `console.warn` (when available)\n * @param {*} [values] Values to log as a warning\n */ fabric.warn = console.warn;\n(function() {\n    var extend = fabric.util.object.extend, clone = fabric.util.object.clone;\n    /**\n   * @typedef {Object} AnimationOptions\n   * Animation of a value or list of values.\n   * When using lists, think of something like this:\n   * fabric.util.animate({\n   *   startValue: [1, 2, 3],\n   *   endValue: [2, 4, 6],\n   *   onChange: function([a, b, c]) {\n   *     canvas.zoomToPoint({x: b, y: c}, a)\n   *     canvas.renderAll()\n   *   }\n   * });\n   * @example\n   * @property {Function} [onChange] Callback; invoked on every value change\n   * @property {Function} [onComplete] Callback; invoked when value change is completed\n   * @example\n   * // Note: startValue, endValue, and byValue must match the type\n   * var animationOptions = { startValue: 0, endValue: 1, byValue: 0.25 }\n   * var animationOptions = { startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] }\n   * @property {number | number[]} [startValue=0] Starting value\n   * @property {number | number[]} [endValue=100] Ending value\n   * @property {number | number[]} [byValue=100] Value to modify the property by\n   * @property {Function} [easing] Easing function\n   * @property {Number} [duration=500] Duration of change (in ms)\n   * @property {Function} [abort] Additional function with logic. If returns true, animation aborts.\n   *\n   * @typedef {() => void} CancelFunction\n   *\n   * @typedef {Object} AnimationCurrentState\n   * @property {number | number[]} currentValue value in range [`startValue`, `endValue`]\n   * @property {number} completionRate value in range [0, 1]\n   * @property {number} durationRate value in range [0, 1]\n   *\n   * @typedef {(AnimationOptions & AnimationCurrentState & { cancel: CancelFunction }} AnimationContext\n   */ /**\n   * Array holding all running animations\n   * @memberof fabric\n   * @type {AnimationContext[]}\n   */ var RUNNING_ANIMATIONS = [];\n    fabric.util.object.extend(RUNNING_ANIMATIONS, {\n        /**\n     * cancel all running animations at the next requestAnimFrame\n     * @returns {AnimationContext[]}\n     */ cancelAll: function() {\n            var animations = this.splice(0);\n            animations.forEach(function(animation) {\n                animation.cancel();\n            });\n            return animations;\n        },\n        /**\n     * cancel all running animations attached to canvas at the next requestAnimFrame\n     * @param {fabric.Canvas} canvas\n     * @returns {AnimationContext[]}\n     */ cancelByCanvas: function(canvas) {\n            if (!canvas) {\n                return [];\n            }\n            var cancelled = this.filter(function(animation) {\n                return typeof animation.target === \"object\" && animation.target.canvas === canvas;\n            });\n            cancelled.forEach(function(animation) {\n                animation.cancel();\n            });\n            return cancelled;\n        },\n        /**\n     * cancel all running animations for target at the next requestAnimFrame\n     * @param {*} target\n     * @returns {AnimationContext[]}\n     */ cancelByTarget: function(target) {\n            var cancelled = this.findAnimationsByTarget(target);\n            cancelled.forEach(function(animation) {\n                animation.cancel();\n            });\n            return cancelled;\n        },\n        /**\n     *\n     * @param {CancelFunction} cancelFunc the function returned by animate\n     * @returns {number}\n     */ findAnimationIndex: function(cancelFunc) {\n            return this.indexOf(this.findAnimation(cancelFunc));\n        },\n        /**\n     *\n     * @param {CancelFunction} cancelFunc the function returned by animate\n     * @returns {AnimationContext | undefined} animation's options object\n     */ findAnimation: function(cancelFunc) {\n            return this.find(function(animation) {\n                return animation.cancel === cancelFunc;\n            });\n        },\n        /**\n     *\n     * @param {*} target the object that is assigned to the target property of the animation context\n     * @returns {AnimationContext[]} array of animation options object associated with target\n     */ findAnimationsByTarget: function(target) {\n            if (!target) {\n                return [];\n            }\n            return this.filter(function(animation) {\n                return animation.target === target;\n            });\n        }\n    });\n    function noop() {\n        return false;\n    }\n    function defaultEasing(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    /**\n   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {AnimationOptions} [options] Animation options\n   * @example\n   * // Note: startValue, endValue, and byValue must match the type\n   * fabric.util.animate({ startValue: 0, endValue: 1, byValue: 0.25 })\n   * fabric.util.animate({ startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] })\n   * @returns {CancelFunction} cancel function\n   */ function animate(options) {\n        options || (options = {});\n        var cancel = false, context, removeFromRegistry = function() {\n            var index = fabric.runningAnimations.indexOf(context);\n            return index > -1 && fabric.runningAnimations.splice(index, 1)[0];\n        };\n        context = extend(clone(options), {\n            cancel: function() {\n                cancel = true;\n                return removeFromRegistry();\n            },\n            currentValue: \"startValue\" in options ? options.startValue : 0,\n            completionRate: 0,\n            durationRate: 0\n        });\n        fabric.runningAnimations.push(context);\n        requestAnimFrame(function(timestamp) {\n            var start = timestamp || +new Date(), duration = options.duration || 500, finish = start + duration, time, onChange = options.onChange || noop, abort = options.abort || noop, onComplete = options.onComplete || noop, easing = options.easing || defaultEasing, isMany = \"startValue\" in options ? options.startValue.length > 0 : false, startValue = \"startValue\" in options ? options.startValue : 0, endValue = \"endValue\" in options ? options.endValue : 100, byValue = options.byValue || (isMany ? startValue.map(function(value, i) {\n                return endValue[i] - startValue[i];\n            }) : endValue - startValue);\n            options.onStart && options.onStart();\n            (function tick(ticktime) {\n                time = ticktime || +new Date();\n                var currentTime = time > finish ? duration : time - start, timePerc = currentTime / duration, current = isMany ? startValue.map(function(_value, i) {\n                    return easing(currentTime, startValue[i], byValue[i], duration);\n                }) : easing(currentTime, startValue, byValue, duration), valuePerc = isMany ? Math.abs((current[0] - startValue[0]) / byValue[0]) : Math.abs((current - startValue) / byValue);\n                //  update context\n                context.currentValue = isMany ? current.slice() : current;\n                context.completionRate = valuePerc;\n                context.durationRate = timePerc;\n                if (cancel) {\n                    return;\n                }\n                if (abort(current, valuePerc, timePerc)) {\n                    removeFromRegistry();\n                    return;\n                }\n                if (time > finish) {\n                    //  update context\n                    context.currentValue = isMany ? endValue.slice() : endValue;\n                    context.completionRate = 1;\n                    context.durationRate = 1;\n                    //  execute callbacks\n                    onChange(isMany ? endValue.slice() : endValue, 1, 1);\n                    onComplete(endValue, 1, 1);\n                    removeFromRegistry();\n                    return;\n                } else {\n                    onChange(current, valuePerc, timePerc);\n                    requestAnimFrame(tick);\n                }\n            })(start);\n        });\n        return context.cancel;\n    }\n    var _requestAnimFrame = fabric.window.requestAnimationFrame || fabric.window.webkitRequestAnimationFrame || fabric.window.mozRequestAnimationFrame || fabric.window.oRequestAnimationFrame || fabric.window.msRequestAnimationFrame || function(callback) {\n        return fabric.window.setTimeout(callback, 1000 / 60);\n    };\n    var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;\n    /**\n   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method\n   * @memberOf fabric.util\n   * @param {Function} callback Callback to invoke\n   * @param {DOMElement} element optional Element to associate with animation\n   */ function requestAnimFrame() {\n        return _requestAnimFrame.apply(fabric.window, arguments);\n    }\n    function cancelAnimFrame() {\n        return _cancelAnimFrame.apply(fabric.window, arguments);\n    }\n    fabric.util.animate = animate;\n    fabric.util.requestAnimFrame = requestAnimFrame;\n    fabric.util.cancelAnimFrame = cancelAnimFrame;\n    fabric.runningAnimations = RUNNING_ANIMATIONS;\n})();\n(function() {\n    // Calculate an in-between color. Returns a \"rgba()\" string.\n    // Credit: Edwin Martin <edwin@bitstorm.org>\n    //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js\n    function calculateColor(begin, end, pos) {\n        var color = \"rgba(\" + parseInt(begin[0] + pos * (end[0] - begin[0]), 10) + \",\" + parseInt(begin[1] + pos * (end[1] - begin[1]), 10) + \",\" + parseInt(begin[2] + pos * (end[2] - begin[2]), 10);\n        color += \",\" + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);\n        color += \")\";\n        return color;\n    }\n    /**\n   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {String} fromColor The starting color in hex or rgb(a) format.\n   * @param {String} toColor The starting color in hex or rgb(a) format.\n   * @param {Number} [duration] Duration of change (in ms).\n   * @param {Object} [options] Animation options\n   * @param {Function} [options.onChange] Callback; invoked on every value change\n   * @param {Function} [options.onComplete] Callback; invoked when value change is completed\n   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.\n   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.\n   * @returns {Function} abort function\n   */ function animateColor(fromColor, toColor, duration, options) {\n        var startColor = new fabric.Color(fromColor).getSource(), endColor = new fabric.Color(toColor).getSource(), originalOnComplete = options.onComplete, originalOnChange = options.onChange;\n        options = options || {};\n        return fabric.util.animate(fabric.util.object.extend(options, {\n            duration: duration || 500,\n            startValue: startColor,\n            endValue: endColor,\n            byValue: endColor,\n            easing: function(currentTime, startValue, byValue, duration) {\n                var posValue = options.colorEasing ? options.colorEasing(currentTime, duration) : 1 - Math.cos(currentTime / duration * (Math.PI / 2));\n                return calculateColor(startValue, byValue, posValue);\n            },\n            // has to take in account for color restoring;\n            onComplete: function(current, valuePerc, timePerc) {\n                if (originalOnComplete) {\n                    return originalOnComplete(calculateColor(endColor, endColor, 0), valuePerc, timePerc);\n                }\n            },\n            onChange: function(current, valuePerc, timePerc) {\n                if (originalOnChange) {\n                    if (Array.isArray(current)) {\n                        return originalOnChange(calculateColor(current, current, 0), valuePerc, timePerc);\n                    }\n                    originalOnChange(current, valuePerc, timePerc);\n                }\n            }\n        }));\n    }\n    fabric.util.animateColor = animateColor;\n})();\n(function() {\n    function normalize(a, c, p, s) {\n        if (a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        } else {\n            //handle the 0/0 case:\n            if (c === 0 && a === 0) {\n                s = p / (2 * Math.PI) * Math.asin(1);\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(c / a);\n            }\n        }\n        return {\n            a: a,\n            c: c,\n            p: p,\n            s: s\n        };\n    }\n    function elastic(opts, t, d) {\n        return opts.a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p);\n    }\n    /**\n   * Cubic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutCubic(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t + 1) + b;\n    }\n    /**\n   * Cubic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutCubic(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t + 2) + b;\n    }\n    /**\n   * Quartic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInQuart(t, b, c, d) {\n        return c * (t /= d) * t * t * t + b;\n    }\n    /**\n   * Quartic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutQuart(t, b, c, d) {\n        return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n    }\n    /**\n   * Quartic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutQuart(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t * t + b;\n        }\n        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n    }\n    /**\n   * Quintic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInQuint(t, b, c, d) {\n        return c * (t /= d) * t * t * t * t + b;\n    }\n    /**\n   * Quintic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutQuint(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n    }\n    /**\n   * Quintic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutQuint(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n    }\n    /**\n   * Sinusoidal easing in\n   * @memberOf fabric.util.ease\n   */ function easeInSine(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    /**\n   * Sinusoidal easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutSine(t, b, c, d) {\n        return c * Math.sin(t / d * (Math.PI / 2)) + b;\n    }\n    /**\n   * Sinusoidal easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutSine(t, b, c, d) {\n        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n    }\n    /**\n   * Exponential easing in\n   * @memberOf fabric.util.ease\n   */ function easeInExpo(t, b, c, d) {\n        return t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n    }\n    /**\n   * Exponential easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutExpo(t, b, c, d) {\n        return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n    }\n    /**\n   * Exponential easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutExpo(t, b, c, d) {\n        if (t === 0) {\n            return b;\n        }\n        if (t === d) {\n            return b + c;\n        }\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n        }\n        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n    }\n    /**\n   * Circular easing in\n   * @memberOf fabric.util.ease\n   */ function easeInCirc(t, b, c, d) {\n        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n    }\n    /**\n   * Circular easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutCirc(t, b, c, d) {\n        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n    }\n    /**\n   * Circular easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutCirc(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n        }\n        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n    }\n    /**\n   * Elastic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d;\n        if (t === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var opts = normalize(a, c, p, s);\n        return -elastic(opts, t, d) + b;\n    }\n    /**\n   * Elastic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d;\n        if (t === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var opts = normalize(a, c, p, s);\n        return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) + opts.c + b;\n    }\n    /**\n   * Elastic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d / 2;\n        if (t === 2) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * (0.3 * 1.5);\n        }\n        var opts = normalize(a, c, p, s);\n        if (t < 1) {\n            return -0.5 * elastic(opts, t, d) + b;\n        }\n        return opts.a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) * 0.5 + opts.c + b;\n    }\n    /**\n   * Backwards easing in\n   * @memberOf fabric.util.ease\n   */ function easeInBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * (t /= d) * t * ((s + 1) * t - s) + b;\n    }\n    /**\n   * Backwards easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n    }\n    /**\n   * Backwards easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n        }\n        return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n    }\n    /**\n   * Bouncing easing in\n   * @memberOf fabric.util.ease\n   */ function easeInBounce(t, b, c, d) {\n        return c - easeOutBounce(d - t, 0, c, d) + b;\n    }\n    /**\n   * Bouncing easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutBounce(t, b, c, d) {\n        if ((t /= d) < 1 / 2.75) {\n            return c * (7.5625 * t * t) + b;\n        } else if (t < 2 / 2.75) {\n            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;\n        } else if (t < 2.5 / 2.75) {\n            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;\n        } else {\n            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;\n        }\n    }\n    /**\n   * Bouncing easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutBounce(t, b, c, d) {\n        if (t < d / 2) {\n            return easeInBounce(t * 2, 0, c, d) * 0.5 + b;\n        }\n        return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\n    }\n    /**\n   * Easing functions\n   * See <a href=\"http://gizma.com/easing/\">Easing Equations by Robert Penner</a>\n   * @namespace fabric.util.ease\n   */ fabric.util.ease = {\n        /**\n     * Quadratic easing in\n     * @memberOf fabric.util.ease\n     */ easeInQuad: function(t, b, c, d) {\n            return c * (t /= d) * t + b;\n        },\n        /**\n     * Quadratic easing out\n     * @memberOf fabric.util.ease\n     */ easeOutQuad: function(t, b, c, d) {\n            return -c * (t /= d) * (t - 2) + b;\n        },\n        /**\n     * Quadratic easing in and out\n     * @memberOf fabric.util.ease\n     */ easeInOutQuad: function(t, b, c, d) {\n            t /= d / 2;\n            if (t < 1) {\n                return c / 2 * t * t + b;\n            }\n            return -c / 2 * (--t * (t - 2) - 1) + b;\n        },\n        /**\n     * Cubic easing in\n     * @memberOf fabric.util.ease\n     */ easeInCubic: function(t, b, c, d) {\n            return c * (t /= d) * t * t + b;\n        },\n        easeOutCubic: easeOutCubic,\n        easeInOutCubic: easeInOutCubic,\n        easeInQuart: easeInQuart,\n        easeOutQuart: easeOutQuart,\n        easeInOutQuart: easeInOutQuart,\n        easeInQuint: easeInQuint,\n        easeOutQuint: easeOutQuint,\n        easeInOutQuint: easeInOutQuint,\n        easeInSine: easeInSine,\n        easeOutSine: easeOutSine,\n        easeInOutSine: easeInOutSine,\n        easeInExpo: easeInExpo,\n        easeOutExpo: easeOutExpo,\n        easeInOutExpo: easeInOutExpo,\n        easeInCirc: easeInCirc,\n        easeOutCirc: easeOutCirc,\n        easeInOutCirc: easeInOutCirc,\n        easeInElastic: easeInElastic,\n        easeOutElastic: easeOutElastic,\n        easeInOutElastic: easeInOutElastic,\n        easeInBack: easeInBack,\n        easeOutBack: easeOutBack,\n        easeInOutBack: easeInOutBack,\n        easeInBounce: easeInBounce,\n        easeOutBounce: easeOutBounce,\n        easeInOutBounce: easeInOutBounce\n    };\n})();\n(function(global) {\n    \"use strict\";\n    /**\n   * @name fabric\n   * @namespace\n   */ var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed, parseUnit = fabric.util.parseUnit, multiplyTransformMatrices = fabric.util.multiplyTransformMatrices, svgValidTagNames = [\n        \"path\",\n        \"circle\",\n        \"polygon\",\n        \"polyline\",\n        \"ellipse\",\n        \"rect\",\n        \"line\",\n        \"image\",\n        \"text\"\n    ], svgViewBoxElements = [\n        \"symbol\",\n        \"image\",\n        \"marker\",\n        \"pattern\",\n        \"view\",\n        \"svg\"\n    ], svgInvalidAncestors = [\n        \"pattern\",\n        \"defs\",\n        \"symbol\",\n        \"metadata\",\n        \"clipPath\",\n        \"mask\",\n        \"desc\"\n    ], svgValidParents = [\n        \"symbol\",\n        \"g\",\n        \"a\",\n        \"svg\",\n        \"clipPath\",\n        \"defs\"\n    ], attributesMap = {\n        cx: \"left\",\n        x: \"left\",\n        r: \"radius\",\n        cy: \"top\",\n        y: \"top\",\n        display: \"visible\",\n        visibility: \"visible\",\n        transform: \"transformMatrix\",\n        \"fill-opacity\": \"fillOpacity\",\n        \"fill-rule\": \"fillRule\",\n        \"font-family\": \"fontFamily\",\n        \"font-size\": \"fontSize\",\n        \"font-style\": \"fontStyle\",\n        \"font-weight\": \"fontWeight\",\n        \"letter-spacing\": \"charSpacing\",\n        \"paint-order\": \"paintFirst\",\n        \"stroke-dasharray\": \"strokeDashArray\",\n        \"stroke-dashoffset\": \"strokeDashOffset\",\n        \"stroke-linecap\": \"strokeLineCap\",\n        \"stroke-linejoin\": \"strokeLineJoin\",\n        \"stroke-miterlimit\": \"strokeMiterLimit\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        \"stroke-width\": \"strokeWidth\",\n        \"text-decoration\": \"textDecoration\",\n        \"text-anchor\": \"textAnchor\",\n        opacity: \"opacity\",\n        \"clip-path\": \"clipPath\",\n        \"clip-rule\": \"clipRule\",\n        \"vector-effect\": \"strokeUniform\",\n        \"image-rendering\": \"imageSmoothing\"\n    }, colorAttributes = {\n        stroke: \"strokeOpacity\",\n        fill: \"fillOpacity\"\n    }, fSize = \"font-size\", cPath = \"clip-path\";\n    fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);\n    fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);\n    fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);\n    fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);\n    fabric.cssRules = {};\n    fabric.gradientDefs = {};\n    fabric.clipPaths = {};\n    function normalizeAttr(attr) {\n        // transform attribute names\n        if (attr in attributesMap) {\n            return attributesMap[attr];\n        }\n        return attr;\n    }\n    function normalizeValue(attr, value, parentAttributes, fontSize) {\n        var isArray = Object.prototype.toString.call(value) === \"[object Array]\", parsed;\n        if ((attr === \"fill\" || attr === \"stroke\") && value === \"none\") {\n            value = \"\";\n        } else if (attr === \"strokeUniform\") {\n            return value === \"non-scaling-stroke\";\n        } else if (attr === \"strokeDashArray\") {\n            if (value === \"none\") {\n                value = null;\n            } else {\n                value = value.replace(/,/g, \" \").split(/\\s+/).map(parseFloat);\n            }\n        } else if (attr === \"transformMatrix\") {\n            if (parentAttributes && parentAttributes.transformMatrix) {\n                value = multiplyTransformMatrices(parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));\n            } else {\n                value = fabric.parseTransformAttribute(value);\n            }\n        } else if (attr === \"visible\") {\n            value = value !== \"none\" && value !== \"hidden\";\n            // display=none on parent element always takes precedence over child element\n            if (parentAttributes && parentAttributes.visible === false) {\n                value = false;\n            }\n        } else if (attr === \"opacity\") {\n            value = parseFloat(value);\n            if (parentAttributes && typeof parentAttributes.opacity !== \"undefined\") {\n                value *= parentAttributes.opacity;\n            }\n        } else if (attr === \"textAnchor\" /* text-anchor */ ) {\n            value = value === \"start\" ? \"left\" : value === \"end\" ? \"right\" : \"center\";\n        } else if (attr === \"charSpacing\") {\n            // parseUnit returns px and we convert it to em\n            parsed = parseUnit(value, fontSize) / fontSize * 1000;\n        } else if (attr === \"paintFirst\") {\n            var fillIndex = value.indexOf(\"fill\");\n            var strokeIndex = value.indexOf(\"stroke\");\n            var value = \"fill\";\n            if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {\n                value = \"stroke\";\n            } else if (fillIndex === -1 && strokeIndex > -1) {\n                value = \"stroke\";\n            }\n        } else if (attr === \"href\" || attr === \"xlink:href\" || attr === \"font\") {\n            return value;\n        } else if (attr === \"imageSmoothing\") {\n            return value === \"optimizeQuality\";\n        } else {\n            parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);\n        }\n        return !isArray && isNaN(parsed) ? value : parsed;\n    }\n    /**\n    * @private\n    */ function getSvgRegex(arr) {\n        return new RegExp(\"^(\" + arr.join(\"|\") + \")\\\\b\", \"i\");\n    }\n    /**\n   * @private\n   * @param {Object} attributes Array of attributes to parse\n   */ function _setStrokeFillOpacity(attributes) {\n        for(var attr in colorAttributes){\n            if (typeof attributes[colorAttributes[attr]] === \"undefined\" || attributes[attr] === \"\") {\n                continue;\n            }\n            if (typeof attributes[attr] === \"undefined\") {\n                if (!fabric.Object.prototype[attr]) {\n                    continue;\n                }\n                attributes[attr] = fabric.Object.prototype[attr];\n            }\n            if (attributes[attr].indexOf(\"url(\") === 0) {\n                continue;\n            }\n            var color = new fabric.Color(attributes[attr]);\n            attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();\n        }\n        return attributes;\n    }\n    /**\n   * @private\n   */ function _getMultipleNodes(doc, nodeNames) {\n        var nodeName, nodeArray = [], nodeList, i, len;\n        for(i = 0, len = nodeNames.length; i < len; i++){\n            nodeName = nodeNames[i];\n            nodeList = doc.getElementsByTagName(nodeName);\n            nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));\n        }\n        return nodeArray;\n    }\n    /**\n   * Parses \"transform\" attribute, returning an array of values\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {String} attributeValue String containing attribute value\n   * @return {Array} Array of 6 elements representing transformation matrix\n   */ fabric.parseTransformAttribute = function() {\n        function rotateMatrix(matrix, args) {\n            var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]), x = 0, y = 0;\n            if (args.length === 3) {\n                x = args[1];\n                y = args[2];\n            }\n            matrix[0] = cos;\n            matrix[1] = sin;\n            matrix[2] = -sin;\n            matrix[3] = cos;\n            matrix[4] = x - (cos * x - sin * y);\n            matrix[5] = y - (sin * x + cos * y);\n        }\n        function scaleMatrix(matrix, args) {\n            var multiplierX = args[0], multiplierY = args.length === 2 ? args[1] : args[0];\n            matrix[0] = multiplierX;\n            matrix[3] = multiplierY;\n        }\n        function skewMatrix(matrix, args, pos) {\n            matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));\n        }\n        function translateMatrix(matrix, args) {\n            matrix[4] = args[0];\n            if (args.length === 2) {\n                matrix[5] = args[1];\n            }\n        }\n        // identity matrix\n        var iMatrix = fabric.iMatrix, // == begin transform regexp\n        number = fabric.reNum, commaWsp = fabric.commaWsp, skewX = \"(?:(skewX)\\\\s*\\\\(\\\\s*(\" + number + \")\\\\s*\\\\))\", skewY = \"(?:(skewY)\\\\s*\\\\(\\\\s*(\" + number + \")\\\\s*\\\\))\", rotate = \"(?:(rotate)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", scale = \"(?:(scale)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", translate = \"(?:(translate)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", matrix = \"(?:(matrix)\\\\s*\\\\(\\\\s*\" + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + \"\\\\s*\\\\))\", transform = \"(?:\" + matrix + \"|\" + translate + \"|\" + scale + \"|\" + rotate + \"|\" + skewX + \"|\" + skewY + \")\", transforms = \"(?:\" + transform + \"(?:\" + commaWsp + \"*\" + transform + \")*\" + \")\", transformList = \"^\\\\s*(?:\" + transforms + \"?)\\\\s*$\", // http://www.w3.org/TR/SVG/coords.html#TransformAttribute\n        reTransformList = new RegExp(transformList), // == end transform regexp\n        reTransform = new RegExp(transform, \"g\");\n        return function(attributeValue) {\n            // start with identity matrix\n            var matrix = iMatrix.concat(), matrices = [];\n            // return if no argument was given or\n            // an argument does not match transform attribute regexp\n            if (!attributeValue || attributeValue && !reTransformList.test(attributeValue)) {\n                return matrix;\n            }\n            attributeValue.replace(reTransform, function(match) {\n                var m = new RegExp(transform).exec(match).filter(function(match) {\n                    // match !== '' && match != null\n                    return !!match;\n                }), operation = m[1], args = m.slice(2).map(parseFloat);\n                switch(operation){\n                    case \"translate\":\n                        translateMatrix(matrix, args);\n                        break;\n                    case \"rotate\":\n                        args[0] = fabric.util.degreesToRadians(args[0]);\n                        rotateMatrix(matrix, args);\n                        break;\n                    case \"scale\":\n                        scaleMatrix(matrix, args);\n                        break;\n                    case \"skewX\":\n                        skewMatrix(matrix, args, 2);\n                        break;\n                    case \"skewY\":\n                        skewMatrix(matrix, args, 1);\n                        break;\n                    case \"matrix\":\n                        matrix = args;\n                        break;\n                }\n                // snapshot current matrix into matrices array\n                matrices.push(matrix.concat());\n                // reset\n                matrix = iMatrix.concat();\n            });\n            var combinedMatrix = matrices[0];\n            while(matrices.length > 1){\n                matrices.shift();\n                combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);\n            }\n            return combinedMatrix;\n        };\n    }();\n    /**\n   * @private\n   */ function parseStyleString(style, oStyle) {\n        var attr, value;\n        style.replace(/;\\s*$/, \"\").split(\";\").forEach(function(chunk) {\n            var pair = chunk.split(\":\");\n            attr = pair[0].trim().toLowerCase();\n            value = pair[1].trim();\n            oStyle[attr] = value;\n        });\n    }\n    /**\n   * @private\n   */ function parseStyleObject(style, oStyle) {\n        var attr, value;\n        for(var prop in style){\n            if (typeof style[prop] === \"undefined\") {\n                continue;\n            }\n            attr = prop.toLowerCase();\n            value = style[prop];\n            oStyle[attr] = value;\n        }\n    }\n    /**\n   * @private\n   */ function getGlobalStylesForElement(element, svgUid) {\n        var styles = {};\n        for(var rule in fabric.cssRules[svgUid]){\n            if (elementMatchesRule(element, rule.split(\" \"))) {\n                for(var property in fabric.cssRules[svgUid][rule]){\n                    styles[property] = fabric.cssRules[svgUid][rule][property];\n                }\n            }\n        }\n        return styles;\n    }\n    /**\n   * @private\n   */ function elementMatchesRule(element, selectors) {\n        var firstMatching, parentMatching = true;\n        //start from rightmost selector.\n        firstMatching = selectorMatches(element, selectors.pop());\n        if (firstMatching && selectors.length) {\n            parentMatching = doesSomeParentMatch(element, selectors);\n        }\n        return firstMatching && parentMatching && selectors.length === 0;\n    }\n    function doesSomeParentMatch(element, selectors) {\n        var selector, parentMatching = true;\n        while(element.parentNode && element.parentNode.nodeType === 1 && selectors.length){\n            if (parentMatching) {\n                selector = selectors.pop();\n            }\n            element = element.parentNode;\n            parentMatching = selectorMatches(element, selector);\n        }\n        return selectors.length === 0;\n    }\n    /**\n   * @private\n   */ function selectorMatches(element, selector) {\n        var nodeName = element.nodeName, classNames = element.getAttribute(\"class\"), id = element.getAttribute(\"id\"), matcher, i;\n        // i check if a selector matches slicing away part from it.\n        // if i get empty string i should match\n        matcher = new RegExp(\"^\" + nodeName, \"i\");\n        selector = selector.replace(matcher, \"\");\n        if (id && selector.length) {\n            matcher = new RegExp(\"#\" + id + \"(?![a-zA-Z\\\\-]+)\", \"i\");\n            selector = selector.replace(matcher, \"\");\n        }\n        if (classNames && selector.length) {\n            classNames = classNames.split(\" \");\n            for(i = classNames.length; i--;){\n                matcher = new RegExp(\"\\\\.\" + classNames[i] + \"(?![a-zA-Z\\\\-]+)\", \"i\");\n                selector = selector.replace(matcher, \"\");\n            }\n        }\n        return selector.length === 0;\n    }\n    /**\n   * @private\n   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM\n   */ function elementById(doc, id) {\n        var el;\n        doc.getElementById && (el = doc.getElementById(id));\n        if (el) {\n            return el;\n        }\n        var node, i, len, nodelist = doc.getElementsByTagName(\"*\");\n        for(i = 0, len = nodelist.length; i < len; i++){\n            node = nodelist[i];\n            if (id === node.getAttribute(\"id\")) {\n                return node;\n            }\n        }\n    }\n    /**\n   * @private\n   */ function parseUseDirectives(doc) {\n        var nodelist = _getMultipleNodes(doc, [\n            \"use\",\n            \"svg:use\"\n        ]), i = 0;\n        while(nodelist.length && i < nodelist.length){\n            var el = nodelist[i], xlinkAttribute = el.getAttribute(\"xlink:href\") || el.getAttribute(\"href\");\n            if (xlinkAttribute === null) {\n                return;\n            }\n            var xlink = xlinkAttribute.substr(1), x = el.getAttribute(\"x\") || 0, y = el.getAttribute(\"y\") || 0, el2 = elementById(doc, xlink).cloneNode(true), currentTrans = (el2.getAttribute(\"transform\") || \"\") + \" translate(\" + x + \", \" + y + \")\", parentNode, oldLength = nodelist.length, attr, j, attrs, len, namespace = fabric.svgNS;\n            applyViewboxTransform(el2);\n            if (/^svg$/i.test(el2.nodeName)) {\n                var el3 = el2.ownerDocument.createElementNS(namespace, \"g\");\n                for(j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++){\n                    attr = attrs.item(j);\n                    el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);\n                }\n                // el2.firstChild != null\n                while(el2.firstChild){\n                    el3.appendChild(el2.firstChild);\n                }\n                el2 = el3;\n            }\n            for(j = 0, attrs = el.attributes, len = attrs.length; j < len; j++){\n                attr = attrs.item(j);\n                if (attr.nodeName === \"x\" || attr.nodeName === \"y\" || attr.nodeName === \"xlink:href\" || attr.nodeName === \"href\") {\n                    continue;\n                }\n                if (attr.nodeName === \"transform\") {\n                    currentTrans = attr.nodeValue + \" \" + currentTrans;\n                } else {\n                    el2.setAttribute(attr.nodeName, attr.nodeValue);\n                }\n            }\n            el2.setAttribute(\"transform\", currentTrans);\n            el2.setAttribute(\"instantiated_by_use\", \"1\");\n            el2.removeAttribute(\"id\");\n            parentNode = el.parentNode;\n            parentNode.replaceChild(el2, el);\n            // some browsers do not shorten nodelist after replaceChild (IE8)\n            if (nodelist.length === oldLength) {\n                i++;\n            }\n        }\n    }\n    // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute\n    // matches, e.g.: +14.56e-12, etc.\n    var reViewBoxAttrValue = new RegExp(\"^\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*\" + \"$\");\n    /**\n   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements\n   */ function applyViewboxTransform(element) {\n        if (!fabric.svgViewBoxElementsRegEx.test(element.nodeName)) {\n            return {};\n        }\n        var viewBoxAttr = element.getAttribute(\"viewBox\"), scaleX = 1, scaleY = 1, minX = 0, minY = 0, viewBoxWidth, viewBoxHeight, matrix, el, widthAttr = element.getAttribute(\"width\"), heightAttr = element.getAttribute(\"height\"), x = element.getAttribute(\"x\") || 0, y = element.getAttribute(\"y\") || 0, preserveAspectRatio = element.getAttribute(\"preserveAspectRatio\") || \"\", missingViewBox = !viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue)), missingDimAttr = !widthAttr || !heightAttr || widthAttr === \"100%\" || heightAttr === \"100%\", toBeParsed = missingViewBox && missingDimAttr, parsedDim = {}, translateMatrix = \"\", widthDiff = 0, heightDiff = 0;\n        parsedDim.width = 0;\n        parsedDim.height = 0;\n        parsedDim.toBeParsed = toBeParsed;\n        if (missingViewBox) {\n            if ((x || y) && element.parentNode && element.parentNode.nodeName !== \"#document\") {\n                translateMatrix = \" translate(\" + parseUnit(x) + \" \" + parseUnit(y) + \") \";\n                matrix = (element.getAttribute(\"transform\") || \"\") + translateMatrix;\n                element.setAttribute(\"transform\", matrix);\n                element.removeAttribute(\"x\");\n                element.removeAttribute(\"y\");\n            }\n        }\n        if (toBeParsed) {\n            return parsedDim;\n        }\n        if (missingViewBox) {\n            parsedDim.width = parseUnit(widthAttr);\n            parsedDim.height = parseUnit(heightAttr);\n            // set a transform for elements that have x y and are inner(only) SVGs\n            return parsedDim;\n        }\n        minX = -parseFloat(viewBoxAttr[1]);\n        minY = -parseFloat(viewBoxAttr[2]);\n        viewBoxWidth = parseFloat(viewBoxAttr[3]);\n        viewBoxHeight = parseFloat(viewBoxAttr[4]);\n        parsedDim.minX = minX;\n        parsedDim.minY = minY;\n        parsedDim.viewBoxWidth = viewBoxWidth;\n        parsedDim.viewBoxHeight = viewBoxHeight;\n        if (!missingDimAttr) {\n            parsedDim.width = parseUnit(widthAttr);\n            parsedDim.height = parseUnit(heightAttr);\n            scaleX = parsedDim.width / viewBoxWidth;\n            scaleY = parsedDim.height / viewBoxHeight;\n        } else {\n            parsedDim.width = viewBoxWidth;\n            parsedDim.height = viewBoxHeight;\n        }\n        // default is to preserve aspect ratio\n        preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);\n        if (preserveAspectRatio.alignX !== \"none\") {\n            //translate all container for the effect of Mid, Min, Max\n            if (preserveAspectRatio.meetOrSlice === \"meet\") {\n                scaleY = scaleX = scaleX > scaleY ? scaleY : scaleX;\n            // calculate additional translation to move the viewbox\n            }\n            if (preserveAspectRatio.meetOrSlice === \"slice\") {\n                scaleY = scaleX = scaleX > scaleY ? scaleX : scaleY;\n            // calculate additional translation to move the viewbox\n            }\n            widthDiff = parsedDim.width - viewBoxWidth * scaleX;\n            heightDiff = parsedDim.height - viewBoxHeight * scaleX;\n            if (preserveAspectRatio.alignX === \"Mid\") {\n                widthDiff /= 2;\n            }\n            if (preserveAspectRatio.alignY === \"Mid\") {\n                heightDiff /= 2;\n            }\n            if (preserveAspectRatio.alignX === \"Min\") {\n                widthDiff = 0;\n            }\n            if (preserveAspectRatio.alignY === \"Min\") {\n                heightDiff = 0;\n            }\n        }\n        if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {\n            return parsedDim;\n        }\n        if ((x || y) && element.parentNode.nodeName !== \"#document\") {\n            translateMatrix = \" translate(\" + parseUnit(x) + \" \" + parseUnit(y) + \") \";\n        }\n        matrix = translateMatrix + \" matrix(\" + scaleX + \" 0\" + \" 0 \" + scaleY + \" \" + (minX * scaleX + widthDiff) + \" \" + (minY * scaleY + heightDiff) + \") \";\n        // seems unused.\n        // parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);\n        if (element.nodeName === \"svg\") {\n            el = element.ownerDocument.createElementNS(fabric.svgNS, \"g\");\n            // element.firstChild != null\n            while(element.firstChild){\n                el.appendChild(element.firstChild);\n            }\n            element.appendChild(el);\n        } else {\n            el = element;\n            el.removeAttribute(\"x\");\n            el.removeAttribute(\"y\");\n            matrix = el.getAttribute(\"transform\") + matrix;\n        }\n        el.setAttribute(\"transform\", matrix);\n        return parsedDim;\n    }\n    function hasAncestorWithNodeName(element, nodeName) {\n        while(element && (element = element.parentNode)){\n            if (element.nodeName && nodeName.test(element.nodeName.replace(\"svg:\", \"\")) && !element.getAttribute(\"instantiated_by_use\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {SVGDocument} doc SVG document to parse\n   * @param {Function} callback Callback to call when parsing is finished;\n   * It's being passed an array of elements (parsed from a document).\n   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n   * @param {Object} [parsingOptions] options for parsing document\n   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings\n   */ fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {\n        if (!doc) {\n            return;\n        }\n        parseUseDirectives(doc);\n        var svgUid = fabric.Object.__uid++, i, len, options = applyViewboxTransform(doc), descendants = fabric.util.toArray(doc.getElementsByTagName(\"*\"));\n        options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;\n        options.svgUid = svgUid;\n        if (descendants.length === 0 && fabric.isLikelyNode) {\n            // we're likely in node, where \"o3-xml\" library fails to gEBTN(\"*\")\n            // https://github.com/ajaxorg/node-o3-xml/issues/21\n            descendants = doc.selectNodes('//*[name(.)!=\"svg\"]');\n            var arr = [];\n            for(i = 0, len = descendants.length; i < len; i++){\n                arr[i] = descendants[i];\n            }\n            descendants = arr;\n        }\n        var elements = descendants.filter(function(el) {\n            applyViewboxTransform(el);\n            return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace(\"svg:\", \"\")) && !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement\n        });\n        if (!elements || elements && !elements.length) {\n            callback && callback([], {});\n            return;\n        }\n        var clipPaths = {};\n        descendants.filter(function(el) {\n            return el.nodeName.replace(\"svg:\", \"\") === \"clipPath\";\n        }).forEach(function(el) {\n            var id = el.getAttribute(\"id\");\n            clipPaths[id] = fabric.util.toArray(el.getElementsByTagName(\"*\")).filter(function(el) {\n                return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace(\"svg:\", \"\"));\n            });\n        });\n        fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);\n        fabric.cssRules[svgUid] = fabric.getCSSRules(doc);\n        fabric.clipPaths[svgUid] = clipPaths;\n        // Precedence of rules:   style > class > attribute\n        fabric.parseElements(elements, function(instances, elements) {\n            if (callback) {\n                callback(instances, options, elements, descendants);\n                delete fabric.gradientDefs[svgUid];\n                delete fabric.cssRules[svgUid];\n                delete fabric.clipPaths[svgUid];\n            }\n        }, clone(options), reviver, parsingOptions);\n    };\n    function recursivelyParseGradientsXlink(doc, gradient) {\n        var gradientsAttrs = [\n            \"gradientTransform\",\n            \"x1\",\n            \"x2\",\n            \"y1\",\n            \"y2\",\n            \"gradientUnits\",\n            \"cx\",\n            \"cy\",\n            \"r\",\n            \"fx\",\n            \"fy\"\n        ], xlinkAttr = \"xlink:href\", xLink = gradient.getAttribute(xlinkAttr).substr(1), referencedGradient = elementById(doc, xLink);\n        if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {\n            recursivelyParseGradientsXlink(doc, referencedGradient);\n        }\n        gradientsAttrs.forEach(function(attr) {\n            if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {\n                gradient.setAttribute(attr, referencedGradient.getAttribute(attr));\n            }\n        });\n        if (!gradient.children.length) {\n            var referenceClone = referencedGradient.cloneNode(true);\n            while(referenceClone.firstChild){\n                gradient.appendChild(referenceClone.firstChild);\n            }\n        }\n        gradient.removeAttribute(xlinkAttr);\n    }\n    var reFontDeclaration = new RegExp(\"(normal|italic)?\\\\s*(normal|small-caps)?\\\\s*\" + \"(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\s*(\" + fabric.reNum + \"(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\/(normal|\" + fabric.reNum + \"))?\\\\s+(.*)\");\n    extend(fabric, {\n        /**\n     * Parses a short font declaration, building adding its properties to a style object\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {String} value font declaration\n     * @param {Object} oStyle definition\n     */ parseFontDeclaration: function(value, oStyle) {\n            var match = value.match(reFontDeclaration);\n            if (!match) {\n                return;\n            }\n            var fontStyle = match[1], // font variant is not used\n            // fontVariant = match[2],\n            fontWeight = match[3], fontSize = match[4], lineHeight = match[5], fontFamily = match[6];\n            if (fontStyle) {\n                oStyle.fontStyle = fontStyle;\n            }\n            if (fontWeight) {\n                oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);\n            }\n            if (fontSize) {\n                oStyle.fontSize = parseUnit(fontSize);\n            }\n            if (fontFamily) {\n                oStyle.fontFamily = fontFamily;\n            }\n            if (lineHeight) {\n                oStyle.lineHeight = lineHeight === \"normal\" ? 1 : lineHeight;\n            }\n        },\n        /**\n     * Parses an SVG document, returning all of the gradient declarations found in it\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element\n     */ getGradientDefs: function(doc) {\n            var tagArray = [\n                \"linearGradient\",\n                \"radialGradient\",\n                \"svg:linearGradient\",\n                \"svg:radialGradient\"\n            ], elList = _getMultipleNodes(doc, tagArray), el, j = 0, gradientDefs = {};\n            j = elList.length;\n            while(j--){\n                el = elList[j];\n                if (el.getAttribute(\"xlink:href\")) {\n                    recursivelyParseGradientsXlink(doc, el);\n                }\n                gradientDefs[el.getAttribute(\"id\")] = el;\n            }\n            return gradientDefs;\n        },\n        /**\n     * Returns an object of attributes' name/value, given element and an array of attribute names;\n     * Parses parent \"g\" nodes recursively upwards.\n     * @static\n     * @memberOf fabric\n     * @param {DOMElement} element Element to parse\n     * @param {Array} attributes Array of attributes to parse\n     * @return {Object} object containing parsed attributes' names/values\n     */ parseAttributes: function(element, attributes, svgUid) {\n            if (!element) {\n                return;\n            }\n            var value, parentAttributes = {}, fontSize, parentFontSize;\n            if (typeof svgUid === \"undefined\") {\n                svgUid = element.getAttribute(\"svgUid\");\n            }\n            // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards\n            if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {\n                parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);\n            }\n            var ownAttributes = attributes.reduce(function(memo, attr) {\n                value = element.getAttribute(attr);\n                if (value) {\n                    memo[attr] = value;\n                }\n                return memo;\n            }, {});\n            // add values parsed from style, which take precedence over attributes\n            // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)\n            var cssAttrs = extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element));\n            ownAttributes = extend(ownAttributes, cssAttrs);\n            if (cssAttrs[cPath]) {\n                element.setAttribute(cPath, cssAttrs[cPath]);\n            }\n            fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;\n            if (ownAttributes[fSize]) {\n                // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.\n                ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);\n            }\n            var normalizedAttr, normalizedValue, normalizedStyle = {};\n            for(var attr in ownAttributes){\n                normalizedAttr = normalizeAttr(attr);\n                normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);\n                normalizedStyle[normalizedAttr] = normalizedValue;\n            }\n            if (normalizedStyle && normalizedStyle.font) {\n                fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);\n            }\n            var mergedAttrs = extend(parentAttributes, normalizedStyle);\n            return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);\n        },\n        /**\n     * Transforms an array of svg elements to corresponding fabric.* instances\n     * @static\n     * @memberOf fabric\n     * @param {Array} elements Array of elements to parse\n     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)\n     * @param {Object} [options] Options object\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     */ parseElements: function(elements, callback, options, reviver, parsingOptions) {\n            new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();\n        },\n        /**\n     * Parses \"style\" attribute, retuning an object with values\n     * @static\n     * @memberOf fabric\n     * @param {SVGElement} element Element to parse\n     * @return {Object} Objects with values parsed from style attribute of an element\n     */ parseStyleAttribute: function(element) {\n            var oStyle = {}, style = element.getAttribute(\"style\");\n            if (!style) {\n                return oStyle;\n            }\n            if (typeof style === \"string\") {\n                parseStyleString(style, oStyle);\n            } else {\n                parseStyleObject(style, oStyle);\n            }\n            return oStyle;\n        },\n        /**\n     * Parses \"points\" attribute, returning an array of values\n     * @static\n     * @memberOf fabric\n     * @param {String} points points attribute string\n     * @return {Array} array of points\n     */ parsePointsAttribute: function(points) {\n            // points attribute is required and must not be empty\n            if (!points) {\n                return null;\n            }\n            // replace commas with whitespace and remove bookending whitespace\n            points = points.replace(/,/g, \" \").trim();\n            points = points.split(/\\s+/);\n            var parsedPoints = [], i, len;\n            for(i = 0, len = points.length; i < len; i += 2){\n                parsedPoints.push({\n                    x: parseFloat(points[i]),\n                    y: parseFloat(points[i + 1])\n                });\n            }\n            // odd number of points is an error\n            // if (parsedPoints.length % 2 !== 0) {\n            //   return null;\n            // }\n            return parsedPoints;\n        },\n        /**\n     * Returns CSS rules for a given SVG document\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} CSS rules of this document\n     */ getCSSRules: function(doc) {\n            var styles = doc.getElementsByTagName(\"style\"), i, len, allRules = {}, rules;\n            // very crude parsing of style contents\n            for(i = 0, len = styles.length; i < len; i++){\n                var styleContents = styles[i].textContent;\n                // remove comments\n                styleContents = styleContents.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n                if (styleContents.trim() === \"\") {\n                    continue;\n                }\n                // recovers all the rule in this form `body { style code... }`\n                // rules = styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);\n                rules = styleContents.split(\"}\");\n                // remove empty rules.\n                rules = rules.filter(function(rule) {\n                    return rule.trim();\n                });\n                // at this point we have hopefully an array of rules `body { style code... `\n                // eslint-disable-next-line no-loop-func\n                rules.forEach(function(rule) {\n                    var match = rule.split(\"{\"), ruleObj = {}, declaration = match[1].trim(), propertyValuePairs = declaration.split(\";\").filter(function(pair) {\n                        return pair.trim();\n                    });\n                    for(i = 0, len = propertyValuePairs.length; i < len; i++){\n                        var pair = propertyValuePairs[i].split(\":\"), property = pair[0].trim(), value = pair[1].trim();\n                        ruleObj[property] = value;\n                    }\n                    rule = match[0].trim();\n                    rule.split(\",\").forEach(function(_rule) {\n                        _rule = _rule.replace(/^svg/i, \"\").trim();\n                        if (_rule === \"\") {\n                            return;\n                        }\n                        if (allRules[_rule]) {\n                            fabric.util.object.extend(allRules[_rule], ruleObj);\n                        } else {\n                            allRules[_rule] = fabric.util.object.clone(ruleObj);\n                        }\n                    });\n                });\n            }\n            return allRules;\n        },\n        /**\n     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.\n     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)\n     * @memberOf fabric\n     * @param {String} url\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */ loadSVGFromURL: function(url, callback, reviver, options) {\n            url = url.replace(/^\\n\\s*/, \"\").trim();\n            new fabric.util.request(url, {\n                method: \"get\",\n                onComplete: onComplete\n            });\n            function onComplete(r) {\n                var xml = r.responseXML;\n                if (!xml || !xml.documentElement) {\n                    callback && callback(null);\n                    return false;\n                }\n                fabric.parseSVGDocument(xml.documentElement, function(results, _options, elements, allElements) {\n                    callback && callback(results, _options, elements, allElements);\n                }, reviver, options);\n            }\n        },\n        /**\n     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects\n     * @memberOf fabric\n     * @param {String} string\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */ loadSVGFromString: function(string, callback, reviver, options) {\n            var parser = new fabric.window.DOMParser(), doc = parser.parseFromString(string.trim(), \"text/xml\");\n            fabric.parseSVGDocument(doc.documentElement, function(results, _options, elements, allElements) {\n                callback(results, _options, elements, allElements);\n            }, reviver, options);\n        }\n    });\n})( true ? exports : 0);\nfabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {\n    this.elements = elements;\n    this.callback = callback;\n    this.options = options;\n    this.reviver = reviver;\n    this.svgUid = options && options.svgUid || 0;\n    this.parsingOptions = parsingOptions;\n    this.regexUrl = /^url\\(['\"]?#([^'\"]+)['\"]?\\)/g;\n    this.doc = doc;\n};\n(function(proto) {\n    proto.parse = function() {\n        this.instances = new Array(this.elements.length);\n        this.numElements = this.elements.length;\n        this.createObjects();\n    };\n    proto.createObjects = function() {\n        var _this = this;\n        this.elements.forEach(function(element, i) {\n            element.setAttribute(\"svgUid\", _this.svgUid);\n            _this.createObject(element, i);\n        });\n    };\n    proto.findTag = function(el) {\n        return fabric[fabric.util.string.capitalize(el.tagName.replace(\"svg:\", \"\"))];\n    };\n    proto.createObject = function(el, index) {\n        var klass = this.findTag(el);\n        if (klass && klass.fromElement) {\n            try {\n                klass.fromElement(el, this.createCallback(index, el), this.options);\n            } catch (err) {\n                fabric.log(err);\n            }\n        } else {\n            this.checkIfDone();\n        }\n    };\n    proto.createCallback = function(index, el) {\n        var _this = this;\n        return function(obj) {\n            var _options;\n            _this.resolveGradient(obj, el, \"fill\");\n            _this.resolveGradient(obj, el, \"stroke\");\n            if (obj instanceof fabric.Image && obj._originalElement) {\n                _options = obj.parsePreserveAspectRatioAttribute(el);\n            }\n            obj._removeTransformMatrix(_options);\n            _this.resolveClipPath(obj, el);\n            _this.reviver && _this.reviver(el, obj);\n            _this.instances[index] = obj;\n            _this.checkIfDone();\n        };\n    };\n    proto.extractPropertyDefinition = function(obj, property, storage) {\n        var value = obj[property], regex = this.regexUrl;\n        if (!regex.test(value)) {\n            return;\n        }\n        regex.lastIndex = 0;\n        var id = regex.exec(value)[1];\n        regex.lastIndex = 0;\n        return fabric[storage][this.svgUid][id];\n    };\n    proto.resolveGradient = function(obj, el, property) {\n        var gradientDef = this.extractPropertyDefinition(obj, property, \"gradientDefs\");\n        if (gradientDef) {\n            var opacityAttr = el.getAttribute(property + \"-opacity\");\n            var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);\n            obj.set(property, gradient);\n        }\n    };\n    proto.createClipPathCallback = function(obj, container) {\n        return function(_newObj) {\n            _newObj._removeTransformMatrix();\n            _newObj.fillRule = _newObj.clipRule;\n            container.push(_newObj);\n        };\n    };\n    proto.resolveClipPath = function(obj, usingElement) {\n        var clipPath = this.extractPropertyDefinition(obj, \"clipPath\", \"clipPaths\"), element, klass, objTransformInv, container, gTransform, options;\n        if (clipPath) {\n            container = [];\n            objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());\n            // move the clipPath tag as sibling to the real element that is using it\n            var clipPathTag = clipPath[0].parentNode;\n            var clipPathOwner = usingElement;\n            while(clipPathOwner.parentNode && clipPathOwner.getAttribute(\"clip-path\") !== obj.clipPath){\n                clipPathOwner = clipPathOwner.parentNode;\n            }\n            clipPathOwner.parentNode.appendChild(clipPathTag);\n            for(var i = 0; i < clipPath.length; i++){\n                element = clipPath[i];\n                klass = this.findTag(element);\n                klass.fromElement(element, this.createClipPathCallback(obj, container), this.options);\n            }\n            if (container.length === 1) {\n                clipPath = container[0];\n            } else {\n                clipPath = new fabric.Group(container);\n            }\n            gTransform = fabric.util.multiplyTransformMatrices(objTransformInv, clipPath.calcTransformMatrix());\n            if (clipPath.clipPath) {\n                this.resolveClipPath(clipPath, clipPathOwner);\n            }\n            var options = fabric.util.qrDecompose(gTransform);\n            clipPath.flipX = false;\n            clipPath.flipY = false;\n            clipPath.set(\"scaleX\", options.scaleX);\n            clipPath.set(\"scaleY\", options.scaleY);\n            clipPath.angle = options.angle;\n            clipPath.skewX = options.skewX;\n            clipPath.skewY = 0;\n            clipPath.setPositionByOrigin({\n                x: options.translateX,\n                y: options.translateY\n            }, \"center\", \"center\");\n            obj.clipPath = clipPath;\n        } else {\n            // if clip-path does not resolve to any element, delete the property.\n            delete obj.clipPath;\n        }\n    };\n    proto.checkIfDone = function() {\n        if (--this.numElements === 0) {\n            this.instances = this.instances.filter(function(el) {\n                // eslint-disable-next-line no-eq-null, eqeqeq\n                return el != null;\n            });\n            this.callback(this.instances, this.elements);\n        }\n    };\n})(fabric.ElementsParser.prototype);\n(function(global) {\n    \"use strict\";\n    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */ var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Point) {\n        fabric.warn(\"fabric.Point is already defined\");\n        return;\n    }\n    fabric.Point = Point;\n    /**\n   * Point class\n   * @class fabric.Point\n   * @memberOf fabric\n   * @constructor\n   * @param {Number} x\n   * @param {Number} y\n   * @return {fabric.Point} thisArg\n   */ function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point.prototype = /** @lends fabric.Point.prototype */ {\n        type: \"point\",\n        constructor: Point,\n        /**\n     * Adds another point to this one and returns another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point instance with added values\n     */ add: function(that) {\n            return new Point(this.x + that.x, this.y + that.y);\n        },\n        /**\n     * Adds another point to this one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ addEquals: function(that) {\n            this.x += that.x;\n            this.y += that.y;\n            return this;\n        },\n        /**\n     * Adds value to this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point} new Point with added value\n     */ scalarAdd: function(scalar) {\n            return new Point(this.x + scalar, this.y + scalar);\n        },\n        /**\n     * Adds value to this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ scalarAddEquals: function(scalar) {\n            this.x += scalar;\n            this.y += scalar;\n            return this;\n        },\n        /**\n     * Subtracts another point from this point and returns a new one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point object with subtracted values\n     */ subtract: function(that) {\n            return new Point(this.x - that.x, this.y - that.y);\n        },\n        /**\n     * Subtracts another point from this point\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ subtractEquals: function(that) {\n            this.x -= that.x;\n            this.y -= that.y;\n            return this;\n        },\n        /**\n     * Subtracts value from this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ scalarSubtract: function(scalar) {\n            return new Point(this.x - scalar, this.y - scalar);\n        },\n        /**\n     * Subtracts value from this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ scalarSubtractEquals: function(scalar) {\n            this.x -= scalar;\n            this.y -= scalar;\n            return this;\n        },\n        /**\n     * Multiplies this point by a value and returns a new one\n     * TODO: rename in scalarMultiply in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ multiply: function(scalar) {\n            return new Point(this.x * scalar, this.y * scalar);\n        },\n        /**\n     * Multiplies this point by a value\n     * TODO: rename in scalarMultiplyEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ multiplyEquals: function(scalar) {\n            this.x *= scalar;\n            this.y *= scalar;\n            return this;\n        },\n        /**\n     * Divides this point by a value and returns a new one\n     * TODO: rename in scalarDivide in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ divide: function(scalar) {\n            return new Point(this.x / scalar, this.y / scalar);\n        },\n        /**\n     * Divides this point by a value\n     * TODO: rename in scalarDivideEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ divideEquals: function(scalar) {\n            this.x /= scalar;\n            this.y /= scalar;\n            return this;\n        },\n        /**\n     * Returns true if this point is equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ eq: function(that) {\n            return this.x === that.x && this.y === that.y;\n        },\n        /**\n     * Returns true if this point is less than another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ lt: function(that) {\n            return this.x < that.x && this.y < that.y;\n        },\n        /**\n     * Returns true if this point is less than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ lte: function(that) {\n            return this.x <= that.x && this.y <= that.y;\n        },\n        /**\n\n     * Returns true if this point is greater another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ gt: function(that) {\n            return this.x > that.x && this.y > that.y;\n        },\n        /**\n     * Returns true if this point is greater than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ gte: function(that) {\n            return this.x >= that.x && this.y >= that.y;\n        },\n        /**\n     * Returns new point which is the result of linear interpolation with this one and another one\n     * @param {fabric.Point} that\n     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5\n     * @return {fabric.Point}\n     */ lerp: function(that, t) {\n            if (typeof t === \"undefined\") {\n                t = 0.5;\n            }\n            t = Math.max(Math.min(1, t), 0);\n            return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);\n        },\n        /**\n     * Returns distance from this point and another one\n     * @param {fabric.Point} that\n     * @return {Number}\n     */ distanceFrom: function(that) {\n            var dx = this.x - that.x, dy = this.y - that.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        },\n        /**\n     * Returns the point between this point and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ midPointFrom: function(that) {\n            return this.lerp(that);\n        },\n        /**\n     * Returns a new point which is the min of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ min: function(that) {\n            return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));\n        },\n        /**\n     * Returns a new point which is the max of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ max: function(that) {\n            return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));\n        },\n        /**\n     * Returns string representation of this point\n     * @return {String}\n     */ toString: function() {\n            return this.x + \",\" + this.y;\n        },\n        /**\n     * Sets x/y of this point\n     * @param {Number} x\n     * @param {Number} y\n     * @chainable\n     */ setXY: function(x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        },\n        /**\n     * Sets x of this point\n     * @param {Number} x\n     * @chainable\n     */ setX: function(x) {\n            this.x = x;\n            return this;\n        },\n        /**\n     * Sets y of this point\n     * @param {Number} y\n     * @chainable\n     */ setY: function(y) {\n            this.y = y;\n            return this;\n        },\n        /**\n     * Sets x/y of this point from another point\n     * @param {fabric.Point} that\n     * @chainable\n     */ setFromPoint: function(that) {\n            this.x = that.x;\n            this.y = that.y;\n            return this;\n        },\n        /**\n     * Swaps x/y of this point and another point\n     * @param {fabric.Point} that\n     */ swap: function(that) {\n            var x = this.x, y = this.y;\n            this.x = that.x;\n            this.y = that.y;\n            that.x = x;\n            that.y = y;\n        },\n        /**\n     * return a cloned instance of the point\n     * @return {fabric.Point}\n     */ clone: function() {\n            return new Point(this.x, this.y);\n        }\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */ var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Intersection) {\n        fabric.warn(\"fabric.Intersection is already defined\");\n        return;\n    }\n    /**\n   * Intersection class\n   * @class fabric.Intersection\n   * @memberOf fabric\n   * @constructor\n   */ function Intersection(status) {\n        this.status = status;\n        this.points = [];\n    }\n    fabric.Intersection = Intersection;\n    fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {\n        constructor: Intersection,\n        /**\n     * Appends a point to intersection\n     * @param {fabric.Point} point\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */ appendPoint: function(point) {\n            this.points.push(point);\n            return this;\n        },\n        /**\n     * Appends points to intersection\n     * @param {Array} points\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */ appendPoints: function(points) {\n            this.points = this.points.concat(points);\n            return this;\n        }\n    };\n    /**\n   * Checks if one line intersects another\n   * TODO: rename in intersectSegmentSegment\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {fabric.Point} b1\n   * @param {fabric.Point} b2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectLineLine = function(a1, a2, b1, b2) {\n        var result, uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x), ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x), uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n        if (uB !== 0) {\n            var ua = uaT / uB, ub = ubT / uB;\n            if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n                result = new Intersection(\"Intersection\");\n                result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));\n            } else {\n                result = new Intersection();\n            }\n        } else {\n            if (uaT === 0 || ubT === 0) {\n                result = new Intersection(\"Coincident\");\n            } else {\n                result = new Intersection(\"Parallel\");\n            }\n        }\n        return result;\n    };\n    /**\n   * Checks if line intersects polygon\n   * TODO: rename in intersectSegmentPolygon\n   * fix detection of coincident\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {Array} points\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {\n        var result = new Intersection(), length = points.length, b1, b2, inter, i;\n        for(i = 0; i < length; i++){\n            b1 = points[i];\n            b2 = points[(i + 1) % length];\n            inter = Intersection.intersectLineLine(a1, a2, b1, b2);\n            result.appendPoints(inter.points);\n        }\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n    /**\n   * Checks if polygon intersects another polygon\n   * @static\n   * @param {Array} points1\n   * @param {Array} points2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectPolygonPolygon = function(points1, points2) {\n        var result = new Intersection(), length = points1.length, i;\n        for(i = 0; i < length; i++){\n            var a1 = points1[i], a2 = points1[(i + 1) % length], inter = Intersection.intersectLinePolygon(a1, a2, points2);\n            result.appendPoints(inter.points);\n        }\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n    /**\n   * Checks if polygon intersects rectangle\n   * @static\n   * @param {Array} points\n   * @param {fabric.Point} r1\n   * @param {fabric.Point} r2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectPolygonRectangle = function(points, r1, r2) {\n        var min = r1.min(r2), max = r1.max(r2), topRight = new fabric.Point(max.x, min.y), bottomLeft = new fabric.Point(min.x, max.y), inter1 = Intersection.intersectLinePolygon(min, topRight, points), inter2 = Intersection.intersectLinePolygon(topRight, max, points), inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points), inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points), result = new Intersection();\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Color) {\n        fabric.warn(\"fabric.Color is already defined.\");\n        return;\n    }\n    /**\n   * Color class\n   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;\n   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.\n   *\n   * @class fabric.Color\n   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list\n   * @return {fabric.Color} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}\n   */ function Color(color) {\n        if (!color) {\n            this.setSource([\n                0,\n                0,\n                0,\n                1\n            ]);\n        } else {\n            this._tryParsingColor(color);\n        }\n    }\n    fabric.Color = Color;\n    fabric.Color.prototype = /** @lends fabric.Color.prototype */ {\n        /**\n     * @private\n     * @param {String|Array} color Color value to parse\n     */ _tryParsingColor: function(color) {\n            var source;\n            if (color in Color.colorNameMap) {\n                color = Color.colorNameMap[color];\n            }\n            if (color === \"transparent\") {\n                source = [\n                    255,\n                    255,\n                    255,\n                    0\n                ];\n            }\n            if (!source) {\n                source = Color.sourceFromHex(color);\n            }\n            if (!source) {\n                source = Color.sourceFromRgb(color);\n            }\n            if (!source) {\n                source = Color.sourceFromHsl(color);\n            }\n            if (!source) {\n                //if color is not recognize let's make black as canvas does\n                source = [\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n            }\n            if (source) {\n                this.setSource(source);\n            }\n        },\n        /**\n     * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n     * @private\n     * @param {Number} r Red color value\n     * @param {Number} g Green color value\n     * @param {Number} b Blue color value\n     * @return {Array} Hsl color\n     */ _rgbToHsl: function(r, g, b) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            var h, s, l, max = fabric.util.array.max([\n                r,\n                g,\n                b\n            ]), min = fabric.util.array.min([\n                r,\n                g,\n                b\n            ]);\n            l = (max + min) / 2;\n            if (max === min) {\n                h = s = 0; // achromatic\n            } else {\n                var d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch(max){\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                }\n                h /= 6;\n            }\n            return [\n                Math.round(h * 360),\n                Math.round(s * 100),\n                Math.round(l * 100)\n            ];\n        },\n        /**\n     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @return {Array}\n     */ getSource: function() {\n            return this._source;\n        },\n        /**\n     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @param {Array} source\n     */ setSource: function(source) {\n            this._source = source;\n        },\n        /**\n     * Returns color representation in RGB format\n     * @return {String} ex: rgb(0-255,0-255,0-255)\n     */ toRgb: function() {\n            var source = this.getSource();\n            return \"rgb(\" + source[0] + \",\" + source[1] + \",\" + source[2] + \")\";\n        },\n        /**\n     * Returns color representation in RGBA format\n     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)\n     */ toRgba: function() {\n            var source = this.getSource();\n            return \"rgba(\" + source[0] + \",\" + source[1] + \",\" + source[2] + \",\" + source[3] + \")\";\n        },\n        /**\n     * Returns color representation in HSL format\n     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)\n     */ toHsl: function() {\n            var source = this.getSource(), hsl = this._rgbToHsl(source[0], source[1], source[2]);\n            return \"hsl(\" + hsl[0] + \",\" + hsl[1] + \"%,\" + hsl[2] + \"%)\";\n        },\n        /**\n     * Returns color representation in HSLA format\n     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)\n     */ toHsla: function() {\n            var source = this.getSource(), hsl = this._rgbToHsl(source[0], source[1], source[2]);\n            return \"hsla(\" + hsl[0] + \",\" + hsl[1] + \"%,\" + hsl[2] + \"%,\" + source[3] + \")\";\n        },\n        /**\n     * Returns color representation in HEX format\n     * @return {String} ex: FF5555\n     */ toHex: function() {\n            var source = this.getSource(), r, g, b;\n            r = source[0].toString(16);\n            r = r.length === 1 ? \"0\" + r : r;\n            g = source[1].toString(16);\n            g = g.length === 1 ? \"0\" + g : g;\n            b = source[2].toString(16);\n            b = b.length === 1 ? \"0\" + b : b;\n            return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();\n        },\n        /**\n     * Returns color representation in HEXA format\n     * @return {String} ex: FF5555CC\n     */ toHexa: function() {\n            var source = this.getSource(), a;\n            a = Math.round(source[3] * 255);\n            a = a.toString(16);\n            a = a.length === 1 ? \"0\" + a : a;\n            return this.toHex() + a.toUpperCase();\n        },\n        /**\n     * Gets value of alpha channel for this color\n     * @return {Number} 0-1\n     */ getAlpha: function() {\n            return this.getSource()[3];\n        },\n        /**\n     * Sets value of alpha channel for this color\n     * @param {Number} alpha Alpha value 0-1\n     * @return {fabric.Color} thisArg\n     */ setAlpha: function(alpha) {\n            var source = this.getSource();\n            source[3] = alpha;\n            this.setSource(source);\n            return this;\n        },\n        /**\n     * Transforms color to its grayscale representation\n     * @return {fabric.Color} thisArg\n     */ toGrayscale: function() {\n            var source = this.getSource(), average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10), currentAlpha = source[3];\n            this.setSource([\n                average,\n                average,\n                average,\n                currentAlpha\n            ]);\n            return this;\n        },\n        /**\n     * Transforms color to its black and white representation\n     * @param {Number} threshold\n     * @return {fabric.Color} thisArg\n     */ toBlackWhite: function(threshold) {\n            var source = this.getSource(), average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), currentAlpha = source[3];\n            threshold = threshold || 127;\n            average = Number(average) < Number(threshold) ? 0 : 255;\n            this.setSource([\n                average,\n                average,\n                average,\n                currentAlpha\n            ]);\n            return this;\n        },\n        /**\n     * Overlays color with another color\n     * @param {String|fabric.Color} otherColor\n     * @return {fabric.Color} thisArg\n     */ overlayWith: function(otherColor) {\n            if (!(otherColor instanceof Color)) {\n                otherColor = new Color(otherColor);\n            }\n            var result = [], alpha = this.getAlpha(), otherAlpha = 0.5, source = this.getSource(), otherSource = otherColor.getSource(), i;\n            for(i = 0; i < 3; i++){\n                result.push(Math.round(source[i] * (1 - otherAlpha) + otherSource[i] * otherAlpha));\n            }\n            result[3] = alpha;\n            this.setSource(result);\n            return this;\n        }\n    };\n    /**\n   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ // eslint-disable-next-line max-len\n    fabric.Color.reRGBa = /^rgba?\\(\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*(?:\\s*,\\s*((?:\\d*\\.?\\d+)?)\\s*)?\\)$/i;\n    /**\n   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ fabric.Color.reHSLa = /^hsla?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}\\%)\\s*,\\s*(\\d{1,3}\\%)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/i;\n    /**\n   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;\n    /**\n   * Map of the 148 color names with HEX code\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   * @see: https://www.w3.org/TR/css3-color/#svg-color\n   */ fabric.Color.colorNameMap = {\n        aliceblue: \"#F0F8FF\",\n        antiquewhite: \"#FAEBD7\",\n        aqua: \"#00FFFF\",\n        aquamarine: \"#7FFFD4\",\n        azure: \"#F0FFFF\",\n        beige: \"#F5F5DC\",\n        bisque: \"#FFE4C4\",\n        black: \"#000000\",\n        blanchedalmond: \"#FFEBCD\",\n        blue: \"#0000FF\",\n        blueviolet: \"#8A2BE2\",\n        brown: \"#A52A2A\",\n        burlywood: \"#DEB887\",\n        cadetblue: \"#5F9EA0\",\n        chartreuse: \"#7FFF00\",\n        chocolate: \"#D2691E\",\n        coral: \"#FF7F50\",\n        cornflowerblue: \"#6495ED\",\n        cornsilk: \"#FFF8DC\",\n        crimson: \"#DC143C\",\n        cyan: \"#00FFFF\",\n        darkblue: \"#00008B\",\n        darkcyan: \"#008B8B\",\n        darkgoldenrod: \"#B8860B\",\n        darkgray: \"#A9A9A9\",\n        darkgrey: \"#A9A9A9\",\n        darkgreen: \"#006400\",\n        darkkhaki: \"#BDB76B\",\n        darkmagenta: \"#8B008B\",\n        darkolivegreen: \"#556B2F\",\n        darkorange: \"#FF8C00\",\n        darkorchid: \"#9932CC\",\n        darkred: \"#8B0000\",\n        darksalmon: \"#E9967A\",\n        darkseagreen: \"#8FBC8F\",\n        darkslateblue: \"#483D8B\",\n        darkslategray: \"#2F4F4F\",\n        darkslategrey: \"#2F4F4F\",\n        darkturquoise: \"#00CED1\",\n        darkviolet: \"#9400D3\",\n        deeppink: \"#FF1493\",\n        deepskyblue: \"#00BFFF\",\n        dimgray: \"#696969\",\n        dimgrey: \"#696969\",\n        dodgerblue: \"#1E90FF\",\n        firebrick: \"#B22222\",\n        floralwhite: \"#FFFAF0\",\n        forestgreen: \"#228B22\",\n        fuchsia: \"#FF00FF\",\n        gainsboro: \"#DCDCDC\",\n        ghostwhite: \"#F8F8FF\",\n        gold: \"#FFD700\",\n        goldenrod: \"#DAA520\",\n        gray: \"#808080\",\n        grey: \"#808080\",\n        green: \"#008000\",\n        greenyellow: \"#ADFF2F\",\n        honeydew: \"#F0FFF0\",\n        hotpink: \"#FF69B4\",\n        indianred: \"#CD5C5C\",\n        indigo: \"#4B0082\",\n        ivory: \"#FFFFF0\",\n        khaki: \"#F0E68C\",\n        lavender: \"#E6E6FA\",\n        lavenderblush: \"#FFF0F5\",\n        lawngreen: \"#7CFC00\",\n        lemonchiffon: \"#FFFACD\",\n        lightblue: \"#ADD8E6\",\n        lightcoral: \"#F08080\",\n        lightcyan: \"#E0FFFF\",\n        lightgoldenrodyellow: \"#FAFAD2\",\n        lightgray: \"#D3D3D3\",\n        lightgrey: \"#D3D3D3\",\n        lightgreen: \"#90EE90\",\n        lightpink: \"#FFB6C1\",\n        lightsalmon: \"#FFA07A\",\n        lightseagreen: \"#20B2AA\",\n        lightskyblue: \"#87CEFA\",\n        lightslategray: \"#778899\",\n        lightslategrey: \"#778899\",\n        lightsteelblue: \"#B0C4DE\",\n        lightyellow: \"#FFFFE0\",\n        lime: \"#00FF00\",\n        limegreen: \"#32CD32\",\n        linen: \"#FAF0E6\",\n        magenta: \"#FF00FF\",\n        maroon: \"#800000\",\n        mediumaquamarine: \"#66CDAA\",\n        mediumblue: \"#0000CD\",\n        mediumorchid: \"#BA55D3\",\n        mediumpurple: \"#9370DB\",\n        mediumseagreen: \"#3CB371\",\n        mediumslateblue: \"#7B68EE\",\n        mediumspringgreen: \"#00FA9A\",\n        mediumturquoise: \"#48D1CC\",\n        mediumvioletred: \"#C71585\",\n        midnightblue: \"#191970\",\n        mintcream: \"#F5FFFA\",\n        mistyrose: \"#FFE4E1\",\n        moccasin: \"#FFE4B5\",\n        navajowhite: \"#FFDEAD\",\n        navy: \"#000080\",\n        oldlace: \"#FDF5E6\",\n        olive: \"#808000\",\n        olivedrab: \"#6B8E23\",\n        orange: \"#FFA500\",\n        orangered: \"#FF4500\",\n        orchid: \"#DA70D6\",\n        palegoldenrod: \"#EEE8AA\",\n        palegreen: \"#98FB98\",\n        paleturquoise: \"#AFEEEE\",\n        palevioletred: \"#DB7093\",\n        papayawhip: \"#FFEFD5\",\n        peachpuff: \"#FFDAB9\",\n        peru: \"#CD853F\",\n        pink: \"#FFC0CB\",\n        plum: \"#DDA0DD\",\n        powderblue: \"#B0E0E6\",\n        purple: \"#800080\",\n        rebeccapurple: \"#663399\",\n        red: \"#FF0000\",\n        rosybrown: \"#BC8F8F\",\n        royalblue: \"#4169E1\",\n        saddlebrown: \"#8B4513\",\n        salmon: \"#FA8072\",\n        sandybrown: \"#F4A460\",\n        seagreen: \"#2E8B57\",\n        seashell: \"#FFF5EE\",\n        sienna: \"#A0522D\",\n        silver: \"#C0C0C0\",\n        skyblue: \"#87CEEB\",\n        slateblue: \"#6A5ACD\",\n        slategray: \"#708090\",\n        slategrey: \"#708090\",\n        snow: \"#FFFAFA\",\n        springgreen: \"#00FF7F\",\n        steelblue: \"#4682B4\",\n        tan: \"#D2B48C\",\n        teal: \"#008080\",\n        thistle: \"#D8BFD8\",\n        tomato: \"#FF6347\",\n        turquoise: \"#40E0D0\",\n        violet: \"#EE82EE\",\n        wheat: \"#F5DEB3\",\n        white: \"#FFFFFF\",\n        whitesmoke: \"#F5F5F5\",\n        yellow: \"#FFFF00\",\n        yellowgreen: \"#9ACD32\"\n    };\n    /**\n   * @private\n   * @param {Number} p\n   * @param {Number} q\n   * @param {Number} t\n   * @return {Number}\n   */ function hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    /**\n   * Returns new color object, when given a color in RGB format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)\n   * @return {fabric.Color}\n   */ fabric.Color.fromRgb = function(color) {\n        return Color.fromSource(Color.sourceFromRgb(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)\n   * @return {Array} source\n   */ fabric.Color.sourceFromRgb = function(color) {\n        var match = color.match(Color.reRGBa);\n        if (match) {\n            var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1), g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1), b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);\n            return [\n                parseInt(r, 10),\n                parseInt(g, 10),\n                parseInt(b, 10),\n                match[4] ? parseFloat(match[4]) : 1\n            ];\n        }\n    };\n    /**\n   * Returns new color object, when given a color in RGBA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */ fabric.Color.fromRgba = Color.fromRgb;\n    /**\n   * Returns new color object, when given a color in HSL format\n   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)\n   * @memberOf fabric.Color\n   * @return {fabric.Color}\n   */ fabric.Color.fromHsl = function(color) {\n        return Color.fromSource(Color.sourceFromHsl(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.\n   * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)\n   * @return {Array} source\n   * @see http://http://www.w3.org/TR/css3-color/#hsl-color\n   */ fabric.Color.sourceFromHsl = function(color) {\n        var match = color.match(Color.reHSLa);\n        if (!match) {\n            return;\n        }\n        var h = (parseFloat(match[1]) % 360 + 360) % 360 / 360, s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1), l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1), r, g, b;\n        if (s === 0) {\n            r = g = b = l;\n        } else {\n            var q = l <= 0.5 ? l * (s + 1) : l + s - l * s, p = l * 2 - q;\n            r = hue2rgb(p, q, h + 1 / 3);\n            g = hue2rgb(p, q, h);\n            b = hue2rgb(p, q, h - 1 / 3);\n        }\n        return [\n            Math.round(r * 255),\n            Math.round(g * 255),\n            Math.round(b * 255),\n            match[4] ? parseFloat(match[4]) : 1\n        ];\n    };\n    /**\n   * Returns new color object, when given a color in HSLA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */ fabric.Color.fromHsla = Color.fromHsl;\n    /**\n   * Returns new color object, when given a color in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: FF5555\n   * @return {fabric.Color}\n   */ fabric.Color.fromHex = function(color) {\n        return Color.fromSource(Color.sourceFromHex(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color ex: FF5555 or FF5544CC (RGBa)\n   * @return {Array} source\n   */ fabric.Color.sourceFromHex = function(color) {\n        if (color.match(Color.reHex)) {\n            var value = color.slice(color.indexOf(\"#\") + 1), isShortNotation = value.length === 3 || value.length === 4, isRGBa = value.length === 8 || value.length === 4, r = isShortNotation ? value.charAt(0) + value.charAt(0) : value.substring(0, 2), g = isShortNotation ? value.charAt(1) + value.charAt(1) : value.substring(2, 4), b = isShortNotation ? value.charAt(2) + value.charAt(2) : value.substring(4, 6), a = isRGBa ? isShortNotation ? value.charAt(3) + value.charAt(3) : value.substring(6, 8) : \"FF\";\n            return [\n                parseInt(r, 16),\n                parseInt(g, 16),\n                parseInt(b, 16),\n                parseFloat((parseInt(a, 16) / 255).toFixed(2))\n            ];\n        }\n    };\n    /**\n   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])\n   * @static\n   * @memberOf fabric.Color\n   * @param {Array} source\n   * @return {fabric.Color}\n   */ fabric.Color.fromSource = function(source) {\n        var oColor = new Color();\n        oColor.setSource(source);\n        return oColor;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), scaleMap = [\n        \"e\",\n        \"se\",\n        \"s\",\n        \"sw\",\n        \"w\",\n        \"nw\",\n        \"n\",\n        \"ne\",\n        \"e\"\n    ], skewMap = [\n        \"ns\",\n        \"nesw\",\n        \"ew\",\n        \"nwse\"\n    ], controls = {}, LEFT = \"left\", TOP = \"top\", RIGHT = \"right\", BOTTOM = \"bottom\", CENTER = \"center\", opposite = {\n        top: BOTTOM,\n        bottom: TOP,\n        left: RIGHT,\n        right: LEFT,\n        center: CENTER\n    }, radiansToDegrees = fabric.util.radiansToDegrees, sign = Math.sign || function(x) {\n        return (x > 0) - (x < 0) || +x;\n    };\n    /**\n   * Combine control position and object angle to find the control direction compared\n   * to the object center.\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   * @param {fabric.Control} control the control class\n   * @return {Number} 0 - 7 a quadrant number\n   */ function findCornerQuadrant(fabricObject, control) {\n        var cornerAngle = fabricObject.angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;\n        return Math.round(cornerAngle % 360 / 45);\n    }\n    function fireEvent(eventName, options) {\n        var target = options.transform.target, canvas = target.canvas, canvasOptions = fabric.util.object.clone(options);\n        canvasOptions.target = target;\n        canvas && canvas.fire(\"object:\" + eventName, canvasOptions);\n        target.fire(eventName, options);\n    }\n    /**\n   * Inspect event and fabricObject properties to understand if the scaling action\n   * @param {Event} eventData from the user action\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @return {Boolean} true if scale is proportional\n   */ function scaleIsProportional(eventData, fabricObject) {\n        var canvas = fabricObject.canvas, uniScaleKey = canvas.uniScaleKey, uniformIsToggled = eventData[uniScaleKey];\n        return canvas.uniformScaling && !uniformIsToggled || !canvas.uniformScaling && uniformIsToggled;\n    }\n    /**\n   * Checks if transform is centered\n   * @param {Object} transform transform data\n   * @return {Boolean} true if transform is centered\n   */ function isTransformCentered(transform) {\n        return transform.originX === CENTER && transform.originY === CENTER;\n    }\n    /**\n   * Inspect fabricObject to understand if the current scaling action is allowed\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @param {String} by 'x' or 'y' or ''\n   * @param {Boolean} scaleProportionally true if we are trying to scale proportionally\n   * @return {Boolean} true if scaling is not allowed at current conditions\n   */ function scalingIsForbidden(fabricObject, by, scaleProportionally) {\n        var lockX = fabricObject.lockScalingX, lockY = fabricObject.lockScalingY;\n        if (lockX && lockY) {\n            return true;\n        }\n        if (!by && (lockX || lockY) && scaleProportionally) {\n            return true;\n        }\n        if (lockX && by === \"x\") {\n            return true;\n        }\n        if (lockY && by === \"y\") {\n            return true;\n        }\n        return false;\n    }\n    /**\n   * return the correct cursor style for the scale action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function scaleCursorStyleHandler(eventData, control, fabricObject) {\n        var notAllowed = \"not-allowed\", scaleProportionally = scaleIsProportional(eventData, fabricObject), by = \"\";\n        if (control.x !== 0 && control.y === 0) {\n            by = \"x\";\n        } else if (control.x === 0 && control.y !== 0) {\n            by = \"y\";\n        }\n        if (scalingIsForbidden(fabricObject, by, scaleProportionally)) {\n            return notAllowed;\n        }\n        var n = findCornerQuadrant(fabricObject, control);\n        return scaleMap[n] + \"-resize\";\n    }\n    /**\n   * return the correct cursor style for the skew action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function skewCursorStyleHandler(eventData, control, fabricObject) {\n        var notAllowed = \"not-allowed\";\n        if (control.x !== 0 && fabricObject.lockSkewingY) {\n            return notAllowed;\n        }\n        if (control.y !== 0 && fabricObject.lockSkewingX) {\n            return notAllowed;\n        }\n        var n = findCornerQuadrant(fabricObject, control) % 4;\n        return skewMap[n] + \"-resize\";\n    }\n    /**\n   * Combine skew and scale style handlers to cover fabric standard use case\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function scaleSkewCursorStyleHandler(eventData, control, fabricObject) {\n        if (eventData[fabricObject.canvas.altActionKey]) {\n            return controls.skewCursorStyleHandler(eventData, control, fabricObject);\n        }\n        return controls.scaleCursorStyleHandler(eventData, control, fabricObject);\n    }\n    /**\n   * Inspect event, control and fabricObject to return the correct action name\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} an action name\n   */ function scaleOrSkewActionName(eventData, control, fabricObject) {\n        var isAlternative = eventData[fabricObject.canvas.altActionKey];\n        if (control.x === 0) {\n            // then is scaleY or skewX\n            return isAlternative ? \"skewX\" : \"scaleY\";\n        }\n        if (control.y === 0) {\n            // then is scaleY or skewX\n            return isAlternative ? \"skewY\" : \"scaleX\";\n        }\n    }\n    /**\n   * Find the correct style for the control that is used for rotation.\n   * this function is very simple and it just take care of not-allowed or standard cursor\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function rotationStyleHandler(eventData, control, fabricObject) {\n        if (fabricObject.lockRotation) {\n            return \"not-allowed\";\n        }\n        return control.cursorStyle;\n    }\n    function commonEventInfo(eventData, transform, x, y) {\n        return {\n            e: eventData,\n            transform: transform,\n            pointer: {\n                x: x,\n                y: y\n            }\n        };\n    }\n    /**\n   * Wrap an action handler with saving/restoring object position on the transform.\n   * this is the code that permits to objects to keep their position while transforming.\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */ function wrapWithFixedAnchor(actionHandler) {\n        return function(eventData, transform, x, y) {\n            var target = transform.target, centerPoint = target.getCenterPoint(), constraint = target.translateToOriginPoint(centerPoint, transform.originX, transform.originY), actionPerformed = actionHandler(eventData, transform, x, y);\n            target.setPositionByOrigin(constraint, transform.originX, transform.originY);\n            return actionPerformed;\n        };\n    }\n    /**\n   * Wrap an action handler with firing an event if the action is performed\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */ function wrapWithFireEvent(eventName, actionHandler) {\n        return function(eventData, transform, x, y) {\n            var actionPerformed = actionHandler(eventData, transform, x, y);\n            if (actionPerformed) {\n                fireEvent(eventName, commonEventInfo(eventData, transform, x, y));\n            }\n            return actionPerformed;\n        };\n    }\n    /**\n   * Transforms a point described by x and y in a distance from the top left corner of the object\n   * bounding box.\n   * @param {Object} transform\n   * @param {String} originX\n   * @param {String} originY\n   * @param {number} x\n   * @param {number} y\n   * @return {Fabric.Point} the normalized point\n   */ function getLocalPoint(transform, originX, originY, x, y) {\n        var target = transform.target, control = target.controls[transform.corner], zoom = target.canvas.getZoom(), padding = target.padding / zoom, localPoint = target.toLocalPoint(new fabric.Point(x, y), originX, originY);\n        if (localPoint.x >= padding) {\n            localPoint.x -= padding;\n        }\n        if (localPoint.x <= -padding) {\n            localPoint.x += padding;\n        }\n        if (localPoint.y >= padding) {\n            localPoint.y -= padding;\n        }\n        if (localPoint.y <= padding) {\n            localPoint.y += padding;\n        }\n        localPoint.x -= control.offsetX;\n        localPoint.y -= control.offsetY;\n        return localPoint;\n    }\n    /**\n   * Detect if the fabric object is flipped on one side.\n   * @param {fabric.Object} target\n   * @return {Boolean} true if one flip, but not two.\n   */ function targetHasOneFlip(target) {\n        return target.flipX !== target.flipY;\n    }\n    /**\n   * Utility function to compensate the scale factor when skew is applied on both axes\n   * @private\n   */ function compensateScaleForSkew(target, oppositeSkew, scaleToCompensate, axis, reference) {\n        if (target[oppositeSkew] !== 0) {\n            var newDim = target._getTransformedDimensions()[axis];\n            var newValue = reference / newDim * target[scaleToCompensate];\n            target.set(scaleToCompensate, newValue);\n        }\n    }\n    /**\n   * Action handler for skewing on the X axis\n   * @private\n   */ function skewObjectX(eventData, transform, x, y) {\n        var target = transform.target, // find how big the object would be, if there was no skewX. takes in account scaling\n        dimNoSkew = target._getTransformedDimensions(0, target.skewY), localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), // the mouse is in the center of the object, and we want it to stay there.\n        // so the object will grow twice as much as the mouse.\n        // this makes the skew growth to localPoint * 2 - dimNoSkew.\n        totalSkewSize = Math.abs(localPoint.x * 2) - dimNoSkew.x, currentSkew = target.skewX, newSkew;\n        if (totalSkewSize < 2) {\n            // let's make it easy to go back to position 0.\n            newSkew = 0;\n        } else {\n            newSkew = radiansToDegrees(Math.atan2(totalSkewSize / target.scaleX, dimNoSkew.y / target.scaleY));\n            // now we have to find the sign of the skew.\n            // it mostly depend on the origin of transformation.\n            if (transform.originX === LEFT && transform.originY === BOTTOM) {\n                newSkew = -newSkew;\n            }\n            if (transform.originX === RIGHT && transform.originY === TOP) {\n                newSkew = -newSkew;\n            }\n            if (targetHasOneFlip(target)) {\n                newSkew = -newSkew;\n            }\n        }\n        var hasSkewed = currentSkew !== newSkew;\n        if (hasSkewed) {\n            var dimBeforeSkewing = target._getTransformedDimensions().y;\n            target.set(\"skewX\", newSkew);\n            compensateScaleForSkew(target, \"skewY\", \"scaleY\", \"y\", dimBeforeSkewing);\n        }\n        return hasSkewed;\n    }\n    /**\n   * Action handler for skewing on the Y axis\n   * @private\n   */ function skewObjectY(eventData, transform, x, y) {\n        var target = transform.target, // find how big the object would be, if there was no skewX. takes in account scaling\n        dimNoSkew = target._getTransformedDimensions(target.skewX, 0), localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), // the mouse is in the center of the object, and we want it to stay there.\n        // so the object will grow twice as much as the mouse.\n        // this makes the skew growth to localPoint * 2 - dimNoSkew.\n        totalSkewSize = Math.abs(localPoint.y * 2) - dimNoSkew.y, currentSkew = target.skewY, newSkew;\n        if (totalSkewSize < 2) {\n            // let's make it easy to go back to position 0.\n            newSkew = 0;\n        } else {\n            newSkew = radiansToDegrees(Math.atan2(totalSkewSize / target.scaleY, dimNoSkew.x / target.scaleX));\n            // now we have to find the sign of the skew.\n            // it mostly depend on the origin of transformation.\n            if (transform.originX === LEFT && transform.originY === BOTTOM) {\n                newSkew = -newSkew;\n            }\n            if (transform.originX === RIGHT && transform.originY === TOP) {\n                newSkew = -newSkew;\n            }\n            if (targetHasOneFlip(target)) {\n                newSkew = -newSkew;\n            }\n        }\n        var hasSkewed = currentSkew !== newSkew;\n        if (hasSkewed) {\n            var dimBeforeSkewing = target._getTransformedDimensions().x;\n            target.set(\"skewY\", newSkew);\n            compensateScaleForSkew(target, \"skewX\", \"scaleX\", \"x\", dimBeforeSkewing);\n        }\n        return hasSkewed;\n    }\n    /**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function skewHandlerX(eventData, transform, x, y) {\n        // step1 figure out and change transform origin.\n        // if skewX > 0 and originY bottom we anchor on right\n        // if skewX > 0 and originY top we anchor on left\n        // if skewX < 0 and originY bottom we anchor on left\n        // if skewX < 0 and originY top we anchor on right\n        // if skewX is 0, we look for mouse position to understand where are we going.\n        var target = transform.target, currentSkew = target.skewX, originX, originY = transform.originY;\n        if (target.lockSkewingX) {\n            return false;\n        }\n        if (currentSkew === 0) {\n            var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);\n            if (localPointFromCenter.x > 0) {\n                // we are pulling right, anchor left;\n                originX = LEFT;\n            } else {\n                // we are pulling right, anchor right\n                originX = RIGHT;\n            }\n        } else {\n            if (currentSkew > 0) {\n                originX = originY === TOP ? LEFT : RIGHT;\n            }\n            if (currentSkew < 0) {\n                originX = originY === TOP ? RIGHT : LEFT;\n            }\n            // is the object flipped on one side only? swap the origin.\n            if (targetHasOneFlip(target)) {\n                originX = originX === LEFT ? RIGHT : LEFT;\n            }\n        }\n        // once we have the origin, we find the anchor point\n        transform.originX = originX;\n        var finalHandler = wrapWithFireEvent(\"skewing\", wrapWithFixedAnchor(skewObjectX));\n        return finalHandler(eventData, transform, x, y);\n    }\n    /**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function skewHandlerY(eventData, transform, x, y) {\n        // step1 figure out and change transform origin.\n        // if skewY > 0 and originX left we anchor on top\n        // if skewY > 0 and originX right we anchor on bottom\n        // if skewY < 0 and originX left we anchor on bottom\n        // if skewY < 0 and originX right we anchor on top\n        // if skewY is 0, we look for mouse position to understand where are we going.\n        var target = transform.target, currentSkew = target.skewY, originY, originX = transform.originX;\n        if (target.lockSkewingY) {\n            return false;\n        }\n        if (currentSkew === 0) {\n            var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);\n            if (localPointFromCenter.y > 0) {\n                // we are pulling down, anchor up;\n                originY = TOP;\n            } else {\n                // we are pulling up, anchor down\n                originY = BOTTOM;\n            }\n        } else {\n            if (currentSkew > 0) {\n                originY = originX === LEFT ? TOP : BOTTOM;\n            }\n            if (currentSkew < 0) {\n                originY = originX === LEFT ? BOTTOM : TOP;\n            }\n            // is the object flipped on one side only? swap the origin.\n            if (targetHasOneFlip(target)) {\n                originY = originY === TOP ? BOTTOM : TOP;\n            }\n        }\n        // once we have the origin, we find the anchor point\n        transform.originY = originY;\n        var finalHandler = wrapWithFireEvent(\"skewing\", wrapWithFixedAnchor(skewObjectY));\n        return finalHandler(eventData, transform, x, y);\n    }\n    /**\n   * Action handler for rotation and snapping, without anchor point.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   * @private\n   */ function rotationWithSnapping(eventData, transform, x, y) {\n        var t = transform, target = t.target, pivotPoint = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);\n        if (target.lockRotation) {\n            return false;\n        }\n        var lastAngle = Math.atan2(t.ey - pivotPoint.y, t.ex - pivotPoint.x), curAngle = Math.atan2(y - pivotPoint.y, x - pivotPoint.x), angle = radiansToDegrees(curAngle - lastAngle + t.theta), hasRotated = true;\n        if (target.snapAngle > 0) {\n            var snapAngle = target.snapAngle, snapThreshold = target.snapThreshold || snapAngle, rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle, leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;\n            if (Math.abs(angle - leftAngleLocked) < snapThreshold) {\n                angle = leftAngleLocked;\n            } else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {\n                angle = rightAngleLocked;\n            }\n        }\n        // normalize angle to positive value\n        if (angle < 0) {\n            angle = 360 + angle;\n        }\n        angle %= 360;\n        hasRotated = target.angle !== angle;\n        target.angle = angle;\n        return hasRotated;\n    }\n    /**\n   * Basic scaling logic, reused with different constrain for scaling X,Y, freely or equally.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @param {Object} options additional information for scaling\n   * @param {String} options.by 'x', 'y', 'equally' or '' to indicate type of scaling\n   * @return {Boolean} true if some change happened\n   * @private\n   */ function scaleObject(eventData, transform, x, y, options) {\n        options = options || {};\n        var target = transform.target, lockScalingX = target.lockScalingX, lockScalingY = target.lockScalingY, by = options.by, newPoint, scaleX, scaleY, dim, scaleProportionally = scaleIsProportional(eventData, target), forbidScaling = scalingIsForbidden(target, by, scaleProportionally), signX, signY, gestureScale = transform.gestureScale;\n        if (forbidScaling) {\n            return false;\n        }\n        if (gestureScale) {\n            scaleX = transform.scaleX * gestureScale;\n            scaleY = transform.scaleY * gestureScale;\n        } else {\n            newPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y);\n            // use of sign: We use sign to detect change of direction of an action. sign usually change when\n            // we cross the origin point with the mouse. So a scale flip for example. There is an issue when scaling\n            // by center and scaling using one middle control ( default: mr, mt, ml, mb), the mouse movement can easily\n            // cross many time the origin point and flip the object. so we need a way to filter out the noise.\n            // This ternary here should be ok to filter out X scaling when we want Y only and vice versa.\n            signX = by !== \"y\" ? sign(newPoint.x) : 1;\n            signY = by !== \"x\" ? sign(newPoint.y) : 1;\n            if (!transform.signX) {\n                transform.signX = signX;\n            }\n            if (!transform.signY) {\n                transform.signY = signY;\n            }\n            if (target.lockScalingFlip && (transform.signX !== signX || transform.signY !== signY)) {\n                return false;\n            }\n            dim = target._getTransformedDimensions();\n            // missing detection of flip and logic to switch the origin\n            if (scaleProportionally && !by) {\n                // uniform scaling\n                var distance = Math.abs(newPoint.x) + Math.abs(newPoint.y), original = transform.original, originalDistance = Math.abs(dim.x * original.scaleX / target.scaleX) + Math.abs(dim.y * original.scaleY / target.scaleY), scale = distance / originalDistance;\n                scaleX = original.scaleX * scale;\n                scaleY = original.scaleY * scale;\n            } else {\n                scaleX = Math.abs(newPoint.x * target.scaleX / dim.x);\n                scaleY = Math.abs(newPoint.y * target.scaleY / dim.y);\n            }\n            // if we are scaling by center, we need to double the scale\n            if (isTransformCentered(transform)) {\n                scaleX *= 2;\n                scaleY *= 2;\n            }\n            if (transform.signX !== signX && by !== \"y\") {\n                transform.originX = opposite[transform.originX];\n                scaleX *= -1;\n                transform.signX = signX;\n            }\n            if (transform.signY !== signY && by !== \"x\") {\n                transform.originY = opposite[transform.originY];\n                scaleY *= -1;\n                transform.signY = signY;\n            }\n        }\n        // minScale is taken are in the setter.\n        var oldScaleX = target.scaleX, oldScaleY = target.scaleY;\n        if (!by) {\n            !lockScalingX && target.set(\"scaleX\", scaleX);\n            !lockScalingY && target.set(\"scaleY\", scaleY);\n        } else {\n            // forbidden cases already handled on top here.\n            by === \"x\" && target.set(\"scaleX\", scaleX);\n            by === \"y\" && target.set(\"scaleY\", scaleY);\n        }\n        return oldScaleX !== target.scaleX || oldScaleY !== target.scaleY;\n    }\n    /**\n   * Generic scaling logic, to scale from corners either equally or freely.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectFromCorner(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y);\n    }\n    /**\n   * Scaling logic for the X axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectX(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y, {\n            by: \"x\"\n        });\n    }\n    /**\n   * Scaling logic for the Y axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectY(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y, {\n            by: \"y\"\n        });\n    }\n    /**\n   * Composed action handler to either scale Y or skew X\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scalingYOrSkewingX(eventData, transform, x, y) {\n        // ok some safety needed here.\n        if (eventData[transform.target.canvas.altActionKey]) {\n            return controls.skewHandlerX(eventData, transform, x, y);\n        }\n        return controls.scalingY(eventData, transform, x, y);\n    }\n    /**\n   * Composed action handler to either scale X or skew Y\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scalingXOrSkewingY(eventData, transform, x, y) {\n        // ok some safety needed here.\n        if (eventData[transform.target.canvas.altActionKey]) {\n            return controls.skewHandlerY(eventData, transform, x, y);\n        }\n        return controls.scalingX(eventData, transform, x, y);\n    }\n    /**\n   * Action handler to change textbox width\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function changeWidth(eventData, transform, x, y) {\n        var target = transform.target, localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), strokePadding = target.strokeWidth / (target.strokeUniform ? target.scaleX : 1), multiplier = isTransformCentered(transform) ? 2 : 1, oldWidth = target.width, newWidth = Math.abs(localPoint.x * multiplier / target.scaleX) - strokePadding;\n        target.set(\"width\", Math.max(newWidth, 0));\n        return oldWidth !== newWidth;\n    }\n    /**\n   * Action handler\n   * @private\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if the translation occurred\n   */ function dragHandler(eventData, transform, x, y) {\n        var target = transform.target, newLeft = x - transform.offsetX, newTop = y - transform.offsetY, moveX = !target.get(\"lockMovementX\") && target.left !== newLeft, moveY = !target.get(\"lockMovementY\") && target.top !== newTop;\n        moveX && target.set(\"left\", newLeft);\n        moveY && target.set(\"top\", newTop);\n        if (moveX || moveY) {\n            fireEvent(\"moving\", commonEventInfo(eventData, transform, x, y));\n        }\n        return moveX || moveY;\n    }\n    controls.scaleCursorStyleHandler = scaleCursorStyleHandler;\n    controls.skewCursorStyleHandler = skewCursorStyleHandler;\n    controls.scaleSkewCursorStyleHandler = scaleSkewCursorStyleHandler;\n    controls.rotationWithSnapping = wrapWithFireEvent(\"rotating\", wrapWithFixedAnchor(rotationWithSnapping));\n    controls.scalingEqually = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectFromCorner));\n    controls.scalingX = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectX));\n    controls.scalingY = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectY));\n    controls.scalingYOrSkewingX = scalingYOrSkewingX;\n    controls.scalingXOrSkewingY = scalingXOrSkewingY;\n    controls.changeWidth = wrapWithFireEvent(\"resizing\", wrapWithFixedAnchor(changeWidth));\n    controls.skewHandlerX = skewHandlerX;\n    controls.skewHandlerY = skewHandlerY;\n    controls.dragHandler = dragHandler;\n    controls.scaleOrSkewActionName = scaleOrSkewActionName;\n    controls.rotationStyleHandler = rotationStyleHandler;\n    controls.fireEvent = fireEvent;\n    controls.wrapWithFixedAnchor = wrapWithFixedAnchor;\n    controls.wrapWithFireEvent = wrapWithFireEvent;\n    controls.getLocalPoint = getLocalPoint;\n    fabric.controlsUtils = controls;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), degreesToRadians = fabric.util.degreesToRadians, controls = fabric.controlsUtils;\n    /**\n   * Render a round control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */ function renderCircleControl(ctx, left, top, styleOverride, fabricObject) {\n        styleOverride = styleOverride || {};\n        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== \"undefined\" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? \"stroke\" : \"fill\", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), myLeft = left, myTop = top, size;\n        ctx.save();\n        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;\n        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;\n        // as soon as fabric react v5, remove ie11, use proper ellipse code.\n        if (xSize > ySize) {\n            size = xSize;\n            ctx.scale(1.0, ySize / xSize);\n            myTop = top * xSize / ySize;\n        } else if (ySize > xSize) {\n            size = ySize;\n            ctx.scale(xSize / ySize, 1.0);\n            myLeft = left * ySize / xSize;\n        } else {\n            size = xSize;\n        }\n        // this is still wrong\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.arc(myLeft, myTop, size / 2, 0, 2 * Math.PI, false);\n        ctx[methodName]();\n        if (stroke) {\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n    /**\n   * Render a square control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */ function renderSquareControl(ctx, left, top, styleOverride, fabricObject) {\n        styleOverride = styleOverride || {};\n        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== \"undefined\" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? \"stroke\" : \"fill\", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), xSizeBy2 = xSize / 2, ySizeBy2 = ySize / 2;\n        ctx.save();\n        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;\n        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;\n        // this is still wrong\n        ctx.lineWidth = 1;\n        ctx.translate(left, top);\n        ctx.rotate(degreesToRadians(fabricObject.angle));\n        // this does not work, and fixed with ( && ) does not make sense.\n        // to have real transparent corners we need the controls on upperCanvas\n        // transparentCorners || ctx.clearRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n        ctx[methodName + \"Rect\"](-xSizeBy2, -ySizeBy2, xSize, ySize);\n        if (stroke) {\n            ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n        }\n        ctx.restore();\n    }\n    controls.renderCircleControl = renderCircleControl;\n    controls.renderSquareControl = renderSquareControl;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    function Control(options) {\n        for(var i in options){\n            this[i] = options[i];\n        }\n    }\n    fabric.Control = Control;\n    fabric.Control.prototype = /** @lends fabric.Control.prototype */ {\n        /**\n     * keep track of control visibility.\n     * mainly for backward compatibility.\n     * if you do not want to see a control, you can remove it\n     * from the controlset.\n     * @type {Boolean}\n     * @default true\n     */ visible: true,\n        /**\n     * Name of the action that the control will likely execute.\n     * This is optional. FabricJS uses to identify what the user is doing for some\n     * extra optimizations. If you are writing a custom control and you want to know\n     * somewhere else in the code what is going on, you can use this string here.\n     * you can also provide a custom getActionName if your control run multiple actions\n     * depending on some external state.\n     * default to scale since is the most common, used on 4 corners by default\n     * @type {String}\n     * @default 'scale'\n     */ actionName: \"scale\",\n        /**\n     * Drawing angle of the control.\n     * NOT used for now, but name marked as needed for internal logic\n     * example: to reuse the same drawing function for different rotated controls\n     * @type {Number}\n     * @default 0\n     */ angle: 0,\n        /**\n     * Relative position of the control. X\n     * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ x: 0,\n        /**\n     * Relative position of the control. Y\n     * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ y: 0,\n        /**\n     * Horizontal offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the right, negative to the left.\n     * It used when you want to have position of control that does not scale with\n     * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on\n     * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will\n     * stay 30 pixels no matter how the object is big. Another example is having 2\n     * controls in the corner, that stay in the same position when the object scale.\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ offsetX: 0,\n        /**\n     * Vertical offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the bottom, negative to the top.\n     * @type {Number}\n     * @default 0\n     */ offsetY: 0,\n        /**\n     * Sets the length of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ sizeX: null,\n        /**\n     * Sets the height of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ sizeY: null,\n        /**\n     * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ touchSizeX: null,\n        /**\n     * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ touchSizeY: null,\n        /**\n     * Css cursor style to display when the control is hovered.\n     * if the method `cursorStyleHandler` is provided, this property is ignored.\n     * @type {String}\n     * @default 'crosshair'\n     */ cursorStyle: \"crosshair\",\n        /**\n     * If controls has an offsetY or offsetX, draw a line that connects\n     * the control to the bounding box\n     * @type {Boolean}\n     * @default false\n     */ withConnection: false,\n        /**\n     * The control actionHandler, provide one to handle action ( control being moved )\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ actionHandler: function() {},\n        /**\n     * The control handler for mouse down, provide one to handle mouse down on control\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ mouseDownHandler: function() {},\n        /**\n     * The control mouseUpHandler, provide one to handle an effect on mouse up.\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ mouseUpHandler: function() {},\n        /**\n     * Returns control actionHandler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getActionHandler: function() {\n            return this.actionHandler;\n        },\n        /**\n     * Returns control mouseDown handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getMouseDownHandler: function() {\n            return this.mouseDownHandler;\n        },\n        /**\n     * Returns control mouseUp handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getMouseUpHandler: function() {\n            return this.mouseUpHandler;\n        },\n        /**\n     * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate\n     * function you can pass one in the constructor\n     * the cursorStyle property\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */ cursorStyleHandler: function(eventData, control /* fabricObject */ ) {\n            return control.cursorStyle;\n        },\n        /**\n     * Returns the action name. The basic implementation just return the actionName property.\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */ getActionName: function(eventData, control /* fabricObject */ ) {\n            return control.actionName;\n        },\n        /**\n     * Returns controls visibility\n     * @param {fabric.Object} object on which the control is displayed\n     * @param {String} controlKey key where the control is memorized on the\n     * @return {Boolean}\n     */ getVisibility: function(fabricObject, controlKey) {\n            var objectVisibility = fabricObject._controlsVisibility;\n            if (objectVisibility && typeof objectVisibility[controlKey] !== \"undefined\") {\n                return objectVisibility[controlKey];\n            }\n            return this.visible;\n        },\n        /**\n     * Sets controls visibility\n     * @param {Boolean} visibility for the object\n     * @return {Void}\n     */ setVisibility: function(visibility /* name, fabricObject */ ) {\n            this.visible = visibility;\n        },\n        positionHandler: function(dim, finalMatrix /*, fabricObject, currentControl */ ) {\n            var point = fabric.util.transformPoint({\n                x: this.x * dim.x + this.offsetX,\n                y: this.y * dim.y + this.offsetY\n            }, finalMatrix);\n            return point;\n        },\n        /**\n     * Returns the coords for this control based on object values.\n     * @param {Number} objectAngle angle from the fabric object holding the control\n     * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if\n     *   isTouch is true)\n     * @param {Number} centerX x coordinate where the control center should be\n     * @param {Number} centerY y coordinate where the control center should be\n     * @param {boolean} isTouch true if touch corner, false if normal corner\n     */ calcCornerCoords: function(objectAngle, objectCornerSize, centerX, centerY, isTouch) {\n            var cosHalfOffset, sinHalfOffset, cosHalfOffsetComp, sinHalfOffsetComp, xSize = isTouch ? this.touchSizeX : this.sizeX, ySize = isTouch ? this.touchSizeY : this.sizeY;\n            if (xSize && ySize && xSize !== ySize) {\n                // handle rectangular corners\n                var controlTriangleAngle = Math.atan2(ySize, xSize);\n                var cornerHypotenuse = Math.sqrt(xSize * xSize + ySize * ySize) / 2;\n                var newTheta = controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);\n                var newThetaComp = Math.PI / 2 - controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);\n                cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta);\n                sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta);\n                // use complementary angle for two corners\n                cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newThetaComp);\n                sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newThetaComp);\n            } else {\n                // handle square corners\n                // use default object corner size unless size is defined\n                var cornerSize = xSize && ySize ? xSize : objectCornerSize;\n                /* 0.7071067812 stands for sqrt(2)/2 */ cornerHypotenuse = cornerSize * 0.7071067812;\n                // complementary angles are equal since they're both 45 degrees\n                var newTheta = fabric.util.degreesToRadians(45 - objectAngle);\n                cosHalfOffset = cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newTheta);\n                sinHalfOffset = sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newTheta);\n            }\n            return {\n                tl: {\n                    x: centerX - sinHalfOffsetComp,\n                    y: centerY - cosHalfOffsetComp\n                },\n                tr: {\n                    x: centerX + cosHalfOffset,\n                    y: centerY - sinHalfOffset\n                },\n                bl: {\n                    x: centerX - cosHalfOffset,\n                    y: centerY + sinHalfOffset\n                },\n                br: {\n                    x: centerX + sinHalfOffsetComp,\n                    y: centerY + cosHalfOffsetComp\n                }\n            };\n        },\n        /**\n    * Render function for the control.\n    * When this function runs the context is unscaled. unrotate. Just retina scaled.\n    * all the functions will have to translate to the point left,top before starting Drawing\n    * if they want to draw a control where the position is detected.\n    * left and top are the result of the positionHandler function\n    * @param {RenderingContext2D} ctx the context where the control will be drawn\n    * @param {Number} left position of the canvas where we are about to render the control.\n    * @param {Number} top position of the canvas where we are about to render the control.\n    * @param {Object} styleOverride\n    * @param {fabric.Object} fabricObject the object where the control is about to be rendered\n    */ render: function(ctx, left, top, styleOverride, fabricObject) {\n            styleOverride = styleOverride || {};\n            switch(styleOverride.cornerStyle || fabricObject.cornerStyle){\n                case \"circle\":\n                    fabric.controlsUtils.renderCircleControl.call(this, ctx, left, top, styleOverride, fabricObject);\n                    break;\n                default:\n                    fabric.controlsUtils.renderSquareControl.call(this, ctx, left, top, styleOverride, fabricObject);\n            }\n        }\n    };\n})( true ? exports : 0);\n(function() {\n    /* _FROM_SVG_START_ */ function getColorStop(el, multiplier) {\n        var style = el.getAttribute(\"style\"), offset = el.getAttribute(\"offset\") || 0, color, colorAlpha, opacity, i;\n        // convert percents to absolute values\n        offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);\n        offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;\n        if (style) {\n            var keyValuePairs = style.split(/\\s*;\\s*/);\n            if (keyValuePairs[keyValuePairs.length - 1] === \"\") {\n                keyValuePairs.pop();\n            }\n            for(i = keyValuePairs.length; i--;){\n                var split = keyValuePairs[i].split(/\\s*:\\s*/), key = split[0].trim(), value = split[1].trim();\n                if (key === \"stop-color\") {\n                    color = value;\n                } else if (key === \"stop-opacity\") {\n                    opacity = value;\n                }\n            }\n        }\n        if (!color) {\n            color = el.getAttribute(\"stop-color\") || \"rgb(0,0,0)\";\n        }\n        if (!opacity) {\n            opacity = el.getAttribute(\"stop-opacity\");\n        }\n        color = new fabric.Color(color);\n        colorAlpha = color.getAlpha();\n        opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);\n        opacity *= colorAlpha * multiplier;\n        return {\n            offset: offset,\n            color: color.toRgb(),\n            opacity: opacity\n        };\n    }\n    function getLinearCoords(el) {\n        return {\n            x1: el.getAttribute(\"x1\") || 0,\n            y1: el.getAttribute(\"y1\") || 0,\n            x2: el.getAttribute(\"x2\") || \"100%\",\n            y2: el.getAttribute(\"y2\") || 0\n        };\n    }\n    function getRadialCoords(el) {\n        return {\n            x1: el.getAttribute(\"fx\") || el.getAttribute(\"cx\") || \"50%\",\n            y1: el.getAttribute(\"fy\") || el.getAttribute(\"cy\") || \"50%\",\n            r1: 0,\n            x2: el.getAttribute(\"cx\") || \"50%\",\n            y2: el.getAttribute(\"cy\") || \"50%\",\n            r2: el.getAttribute(\"r\") || \"50%\"\n        };\n    }\n    /* _FROM_SVG_END_ */ var clone = fabric.util.object.clone;\n    /**\n   * Gradient class\n   * @class fabric.Gradient\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}\n   * @see {@link fabric.Gradient#initialize} for constructor definition\n   */ fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {\n        /**\n     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */ offsetX: 0,\n        /**\n     * Vertical offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */ offsetY: 0,\n        /**\n     * A transform matrix to apply to the gradient before painting.\n     * Imported from svg gradients, is not applied with the current transform in the center.\n     * Before this transform is applied, the origin point is at the top left corner of the object\n     * plus the addition of offsetY and offsetX.\n     * @type Number[]\n     * @default null\n     */ gradientTransform: null,\n        /**\n     * coordinates units for coords.\n     * If `pixels`, the number of coords are in the same unit of width / height.\n     * If set as `percentage` the coords are still a number, but 1 means 100% of width\n     * for the X and 100% of the height for the y. It can be bigger than 1 and negative.\n     * allowed values pixels or percentage.\n     * @type String\n     * @default 'pixels'\n     */ gradientUnits: \"pixels\",\n        /**\n     * Gradient type linear or radial\n     * @type String\n     * @default 'pixels'\n     */ type: \"linear\",\n        /**\n     * Constructor\n     * @param {Object} options Options object with type, coords, gradientUnits and colorStops\n     * @param {Object} [options.type] gradient type linear or radial\n     * @param {Object} [options.gradientUnits] gradient units\n     * @param {Object} [options.offsetX] SVG import compatibility\n     * @param {Object} [options.offsetY] SVG import compatibility\n     * @param {Object[]} options.colorStops contains the colorstops.\n     * @param {Object} options.coords contains the coords of the gradient\n     * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle\n     * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle\n     * @return {fabric.Gradient} thisArg\n     */ initialize: function(options) {\n            options || (options = {});\n            options.coords || (options.coords = {});\n            var coords, _this = this;\n            // sets everything, then coords and colorstops get sets again\n            Object.keys(options).forEach(function(option) {\n                _this[option] = options[option];\n            });\n            if (this.id) {\n                this.id += \"_\" + fabric.Object.__uid++;\n            } else {\n                this.id = fabric.Object.__uid++;\n            }\n            coords = {\n                x1: options.coords.x1 || 0,\n                y1: options.coords.y1 || 0,\n                x2: options.coords.x2 || 0,\n                y2: options.coords.y2 || 0\n            };\n            if (this.type === \"radial\") {\n                coords.r1 = options.coords.r1 || 0;\n                coords.r2 = options.coords.r2 || 0;\n            }\n            this.coords = coords;\n            this.colorStops = options.colorStops.slice();\n        },\n        /**\n     * Adds another colorStop\n     * @param {Object} colorStop Object with offset and color\n     * @return {fabric.Gradient} thisArg\n     */ addColorStop: function(colorStops) {\n            for(var position in colorStops){\n                var color = new fabric.Color(colorStops[position]);\n                this.colorStops.push({\n                    offset: parseFloat(position),\n                    color: color.toRgb(),\n                    opacity: color.getAlpha()\n                });\n            }\n            return this;\n        },\n        /**\n     * Returns object representation of a gradient\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object}\n     */ toObject: function(propertiesToInclude) {\n            var object = {\n                type: this.type,\n                coords: this.coords,\n                colorStops: this.colorStops,\n                offsetX: this.offsetX,\n                offsetY: this.offsetY,\n                gradientUnits: this.gradientUnits,\n                gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform\n            };\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            return object;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of an gradient\n     * @param {Object} object Object to create a gradient for\n     * @return {String} SVG representation of an gradient (linear/radial)\n     */ toSVG: function(object, options) {\n            var coords = clone(this.coords, true), i, len, options = options || {}, markup, commonAttributes, colorStops = clone(this.colorStops, true), needsSwap = coords.r1 > coords.r2, transform = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(), offsetX = -this.offsetX, offsetY = -this.offsetY, withViewport = !!options.additionalTransform, gradientUnits = this.gradientUnits === \"pixels\" ? \"userSpaceOnUse\" : \"objectBoundingBox\";\n            // colorStops must be sorted ascending\n            colorStops.sort(function(a, b) {\n                return a.offset - b.offset;\n            });\n            if (gradientUnits === \"objectBoundingBox\") {\n                offsetX /= object.width;\n                offsetY /= object.height;\n            } else {\n                offsetX += object.width / 2;\n                offsetY += object.height / 2;\n            }\n            if (object.type === \"path\" && this.gradientUnits !== \"percentage\") {\n                offsetX -= object.pathOffset.x;\n                offsetY -= object.pathOffset.y;\n            }\n            transform[4] -= offsetX;\n            transform[5] -= offsetY;\n            commonAttributes = 'id=\"SVGID_' + this.id + '\" gradientUnits=\"' + gradientUnits + '\"';\n            commonAttributes += ' gradientTransform=\"' + (withViewport ? options.additionalTransform + \" \" : \"\") + fabric.util.matrixToSVG(transform) + '\" ';\n            if (this.type === \"linear\") {\n                markup = [\n                    \"<linearGradient \",\n                    commonAttributes,\n                    ' x1=\"',\n                    coords.x1,\n                    '\" y1=\"',\n                    coords.y1,\n                    '\" x2=\"',\n                    coords.x2,\n                    '\" y2=\"',\n                    coords.y2,\n                    '\">\\n'\n                ];\n            } else if (this.type === \"radial\") {\n                // svg radial gradient has just 1 radius. the biggest.\n                markup = [\n                    \"<radialGradient \",\n                    commonAttributes,\n                    ' cx=\"',\n                    needsSwap ? coords.x1 : coords.x2,\n                    '\" cy=\"',\n                    needsSwap ? coords.y1 : coords.y2,\n                    '\" r=\"',\n                    needsSwap ? coords.r1 : coords.r2,\n                    '\" fx=\"',\n                    needsSwap ? coords.x2 : coords.x1,\n                    '\" fy=\"',\n                    needsSwap ? coords.y2 : coords.y1,\n                    '\">\\n'\n                ];\n            }\n            if (this.type === \"radial\") {\n                if (needsSwap) {\n                    // svg goes from internal to external radius. if radius are inverted, swap color stops.\n                    colorStops = colorStops.concat();\n                    colorStops.reverse();\n                    for(i = 0, len = colorStops.length; i < len; i++){\n                        colorStops[i].offset = 1 - colorStops[i].offset;\n                    }\n                }\n                var minRadius = Math.min(coords.r1, coords.r2);\n                if (minRadius > 0) {\n                    // i have to shift all colorStops and add new one in 0.\n                    var maxRadius = Math.max(coords.r1, coords.r2), percentageShift = minRadius / maxRadius;\n                    for(i = 0, len = colorStops.length; i < len; i++){\n                        colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);\n                    }\n                }\n            }\n            for(i = 0, len = colorStops.length; i < len; i++){\n                var colorStop = colorStops[i];\n                markup.push(\"<stop \", 'offset=\"', colorStop.offset * 100 + \"%\", '\" style=\"stop-color:', colorStop.color, typeof colorStop.opacity !== \"undefined\" ? \";stop-opacity: \" + colorStop.opacity : \";\", '\"/>\\n');\n            }\n            markup.push(this.type === \"linear\" ? \"</linearGradient>\\n\" : \"</radialGradient>\\n\");\n            return markup.join(\"\");\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns an instance of CanvasGradient\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {CanvasGradient}\n     */ toLive: function(ctx) {\n            var gradient, coords = fabric.util.object.clone(this.coords), i, len;\n            if (!this.type) {\n                return;\n            }\n            if (this.type === \"linear\") {\n                gradient = ctx.createLinearGradient(coords.x1, coords.y1, coords.x2, coords.y2);\n            } else if (this.type === \"radial\") {\n                gradient = ctx.createRadialGradient(coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);\n            }\n            for(i = 0, len = this.colorStops.length; i < len; i++){\n                var color = this.colorStops[i].color, opacity = this.colorStops[i].opacity, offset = this.colorStops[i].offset;\n                if (typeof opacity !== \"undefined\") {\n                    color = new fabric.Color(color).setAlpha(opacity).toRgba();\n                }\n                gradient.addColorStop(offset, color);\n            }\n            return gradient;\n        }\n    });\n    fabric.util.object.extend(fabric.Gradient, {\n        /* _FROM_SVG_START_ */ /**\n     * Returns {@link fabric.Gradient} instance from an SVG element\n     * @static\n     * @memberOf fabric.Gradient\n     * @param {SVGGradientElement} el SVG gradient element\n     * @param {fabric.Object} instance\n     * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.\n     * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients\n     * that uses gradientUnits as 'userSpaceOnUse' and percentages.\n     * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg\n     * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg\n     * @param {Object.number} width width part of the svg tag if viewBox is not specified\n     * @param {Object.number} height height part of the svg tag if viewBox is not specified\n     * @return {fabric.Gradient} Gradient instance\n     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement\n     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement\n     */ fromElement: function(el, instance, opacityAttr, svgOptions) {\n            /**\n       *  @example:\n       *\n       *  <linearGradient id=\"linearGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\"/>\n       *    <stop offset=\"100%\" stop-color=\"black\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <linearGradient id=\"linearGrad2\">\n       *    <stop offset=\"0\" style=\"stop-color:rgb(255,255,255)\"/>\n       *    <stop offset=\"1\" style=\"stop-color:rgb(0,0,0)\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *    <stop offset=\"50%\" stop-color=\"black\" stop-opacity=\"0.5\" />\n       *    <stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *  </radialGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad2\">\n       *    <stop offset=\"0\" stop-color=\"rgb(255,255,255)\" />\n       *    <stop offset=\"0.5\" stop-color=\"rgb(0,0,0)\" />\n       *    <stop offset=\"1\" stop-color=\"rgb(255,255,255)\" />\n       *  </radialGradient>\n       *\n       */ var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);\n            multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;\n            if (isNaN(multiplier)) {\n                multiplier = 1;\n            }\n            var colorStopEls = el.getElementsByTagName(\"stop\"), type, gradientUnits = el.getAttribute(\"gradientUnits\") === \"userSpaceOnUse\" ? \"pixels\" : \"percentage\", gradientTransform = el.getAttribute(\"gradientTransform\") || \"\", colorStops = [], coords, i, offsetX = 0, offsetY = 0, transformMatrix;\n            if (el.nodeName === \"linearGradient\" || el.nodeName === \"LINEARGRADIENT\") {\n                type = \"linear\";\n                coords = getLinearCoords(el);\n            } else {\n                type = \"radial\";\n                coords = getRadialCoords(el);\n            }\n            for(i = colorStopEls.length; i--;){\n                colorStops.push(getColorStop(colorStopEls[i], multiplier));\n            }\n            transformMatrix = fabric.parseTransformAttribute(gradientTransform);\n            __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);\n            if (gradientUnits === \"pixels\") {\n                offsetX = -instance.left;\n                offsetY = -instance.top;\n            }\n            var gradient = new fabric.Gradient({\n                id: el.getAttribute(\"id\"),\n                type: type,\n                coords: coords,\n                colorStops: colorStops,\n                gradientUnits: gradientUnits,\n                gradientTransform: transformMatrix,\n                offsetX: offsetX,\n                offsetY: offsetY\n            });\n            return gradient;\n        }\n    });\n    /**\n   * @private\n   */ function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {\n        var propValue, finalValue;\n        Object.keys(options).forEach(function(prop) {\n            propValue = options[prop];\n            if (propValue === \"Infinity\") {\n                finalValue = 1;\n            } else if (propValue === \"-Infinity\") {\n                finalValue = 0;\n            } else {\n                finalValue = parseFloat(options[prop], 10);\n                if (typeof propValue === \"string\" && /^(\\d+\\.\\d+)%|(\\d+)%$/.test(propValue)) {\n                    finalValue *= 0.01;\n                    if (gradientUnits === \"pixels\") {\n                        // then we need to fix those percentages here in svg parsing\n                        if (prop === \"x1\" || prop === \"x2\" || prop === \"r2\") {\n                            finalValue *= svgOptions.viewBoxWidth || svgOptions.width;\n                        }\n                        if (prop === \"y1\" || prop === \"y2\") {\n                            finalValue *= svgOptions.viewBoxHeight || svgOptions.height;\n                        }\n                    }\n                }\n            }\n            options[prop] = finalValue;\n        });\n    }\n})();\n(function() {\n    \"use strict\";\n    var toFixed = fabric.util.toFixed;\n    /**\n   * Pattern class\n   * @class fabric.Pattern\n   * @see {@link http://fabricjs.com/patterns|Pattern demo}\n   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}\n   * @see {@link fabric.Pattern#initialize} for constructor definition\n   */ fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {\n        /**\n     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\n     * @type String\n     * @default\n     */ repeat: \"repeat\",\n        /**\n     * Pattern horizontal offset from object's left/top corner\n     * @type Number\n     * @default\n     */ offsetX: 0,\n        /**\n     * Pattern vertical offset from object's left/top corner\n     * @type Number\n     * @default\n     */ offsetY: 0,\n        /**\n     * crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @type String\n     * @default\n     */ crossOrigin: \"\",\n        /**\n     * transform matrix to change the pattern, imported from svgs.\n     * @type Array\n     * @default\n     */ patternTransform: null,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @param {Function} [callback] function to invoke after callback init.\n     * @return {fabric.Pattern} thisArg\n     */ initialize: function(options, callback) {\n            options || (options = {});\n            this.id = fabric.Object.__uid++;\n            this.setOptions(options);\n            if (!options.source || options.source && typeof options.source !== \"string\") {\n                callback && callback(this);\n                return;\n            } else {\n                // img src string\n                var _this = this;\n                this.source = fabric.util.createImage();\n                fabric.util.loadImage(options.source, function(img, isError) {\n                    _this.source = img;\n                    callback && callback(_this, isError);\n                }, null, this.crossOrigin);\n            }\n        },\n        /**\n     * Returns object representation of a pattern\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of a pattern instance\n     */ toObject: function(propertiesToInclude) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, source, object;\n            // <img> element\n            if (typeof this.source.src === \"string\") {\n                source = this.source.src;\n            } else if (typeof this.source === \"object\" && this.source.toDataURL) {\n                source = this.source.toDataURL();\n            }\n            object = {\n                type: \"pattern\",\n                source: source,\n                repeat: this.repeat,\n                crossOrigin: this.crossOrigin,\n                offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),\n                offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),\n                patternTransform: this.patternTransform ? this.patternTransform.concat() : null\n            };\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            return object;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a pattern\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a pattern\n     */ toSVG: function(object) {\n            var patternSource = typeof this.source === \"function\" ? this.source() : this.source, patternWidth = patternSource.width / object.width, patternHeight = patternSource.height / object.height, patternOffsetX = this.offsetX / object.width, patternOffsetY = this.offsetY / object.height, patternImgSrc = \"\";\n            if (this.repeat === \"repeat-x\" || this.repeat === \"no-repeat\") {\n                patternHeight = 1;\n                if (patternOffsetY) {\n                    patternHeight += Math.abs(patternOffsetY);\n                }\n            }\n            if (this.repeat === \"repeat-y\" || this.repeat === \"no-repeat\") {\n                patternWidth = 1;\n                if (patternOffsetX) {\n                    patternWidth += Math.abs(patternOffsetX);\n                }\n            }\n            if (patternSource.src) {\n                patternImgSrc = patternSource.src;\n            } else if (patternSource.toDataURL) {\n                patternImgSrc = patternSource.toDataURL();\n            }\n            return '<pattern id=\"SVGID_' + this.id + '\" x=\"' + patternOffsetX + '\" y=\"' + patternOffsetY + '\" width=\"' + patternWidth + '\" height=\"' + patternHeight + '\">\\n' + '<image x=\"0\" y=\"0\"' + ' width=\"' + patternSource.width + '\" height=\"' + patternSource.height + '\" xlink:href=\"' + patternImgSrc + '\"></image>\\n' + \"</pattern>\\n\";\n        },\n        /* _TO_SVG_END_ */ setOptions: function(options) {\n            for(var prop in options){\n                this[prop] = options[prop];\n            }\n        },\n        /**\n     * Returns an instance of CanvasPattern\n     * @param {CanvasRenderingContext2D} ctx Context to create pattern\n     * @return {CanvasPattern}\n     */ toLive: function(ctx) {\n            var source = this.source;\n            // if the image failed to load, return, and allow rest to continue loading\n            if (!source) {\n                return \"\";\n            }\n            // if an image\n            if (typeof source.src !== \"undefined\") {\n                if (!source.complete) {\n                    return \"\";\n                }\n                if (source.naturalWidth === 0 || source.naturalHeight === 0) {\n                    return \"\";\n                }\n            }\n            return ctx.createPattern(source, this.repeat);\n        }\n    });\n})();\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), toFixed = fabric.util.toFixed;\n    if (fabric.Shadow) {\n        fabric.warn(\"fabric.Shadow is already defined.\");\n        return;\n    }\n    /**\n   * Shadow class\n   * @class fabric.Shadow\n   * @see {@link http://fabricjs.com/shadows|Shadow demo}\n   * @see {@link fabric.Shadow#initialize} for constructor definition\n   */ fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {\n        /**\n     * Shadow color\n     * @type String\n     * @default\n     */ color: \"rgb(0,0,0)\",\n        /**\n     * Shadow blur\n     * @type Number\n     */ blur: 0,\n        /**\n     * Shadow horizontal offset\n     * @type Number\n     * @default\n     */ offsetX: 0,\n        /**\n     * Shadow vertical offset\n     * @type Number\n     * @default\n     */ offsetY: 0,\n        /**\n     * Whether the shadow should affect stroke operations\n     * @type Boolean\n     * @default\n     */ affectStroke: false,\n        /**\n     * Indicates whether toObject should include default values\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * When `false`, the shadow will scale with the object.\n     * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.\n     * default to false\n     * @type Boolean\n     * @default\n     */ nonScaling: false,\n        /**\n     * Constructor\n     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. \"rgba(0,0,0,0.2) 2px 2px 10px\")\n     * @return {fabric.Shadow} thisArg\n     */ initialize: function(options) {\n            if (typeof options === \"string\") {\n                options = this._parseShadow(options);\n            }\n            for(var prop in options){\n                this[prop] = options[prop];\n            }\n            this.id = fabric.Object.__uid++;\n        },\n        /**\n     * @private\n     * @param {String} shadow Shadow value to parse\n     * @return {Object} Shadow object with color, offsetX, offsetY and blur\n     */ _parseShadow: function(shadow) {\n            var shadowStr = shadow.trim(), offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [], color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, \"\") || \"rgb(0,0,0)\";\n            return {\n                color: color.trim(),\n                offsetX: parseFloat(offsetsAndBlur[1], 10) || 0,\n                offsetY: parseFloat(offsetsAndBlur[2], 10) || 0,\n                blur: parseFloat(offsetsAndBlur[3], 10) || 0\n            };\n        },\n        /**\n     * Returns a string representation of an instance\n     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow\n     * @return {String} Returns CSS3 text-shadow declaration\n     */ toString: function() {\n            return [\n                this.offsetX,\n                this.offsetY,\n                this.blur,\n                this.color\n            ].join(\"px \");\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a shadow\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a shadow\n     */ toSVG: function(object) {\n            var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, offset = fabric.util.rotateVector({\n                x: this.offsetX,\n                y: this.offsetY\n            }, fabric.util.degreesToRadians(-object.angle)), BLUR_BOX = 20, color = new fabric.Color(this.color);\n            if (object.width && object.height) {\n                //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion\n                // we add some extra space to filter box to contain the blur ( 20 )\n                fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\n                fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\n            }\n            if (object.flipX) {\n                offset.x *= -1;\n            }\n            if (object.flipY) {\n                offset.y *= -1;\n            }\n            return '<filter id=\"SVGID_' + this.id + '\" y=\"-' + fBoxY + '%\" height=\"' + (100 + 2 * fBoxY) + '%\" ' + 'x=\"-' + fBoxX + '%\" width=\"' + (100 + 2 * fBoxX) + '%\" ' + \">\\n\" + '\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"' + toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '\"></feGaussianBlur>\\n' + '\t<feOffset dx=\"' + toFixed(offset.x, NUM_FRACTION_DIGITS) + '\" dy=\"' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '\" result=\"oBlur\" ></feOffset>\\n' + '\t<feFlood flood-color=\"' + color.toRgb() + '\" flood-opacity=\"' + color.getAlpha() + '\"/>\\n' + '\t<feComposite in2=\"oBlur\" operator=\"in\" />\\n' + \"\t<feMerge>\\n\" + \"\t\t<feMergeNode></feMergeNode>\\n\" + '\t\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\\n' + \"\t</feMerge>\\n\" + \"</filter>\\n\";\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns object representation of a shadow\n     * @return {Object} Object representation of a shadow instance\n     */ toObject: function() {\n            if (this.includeDefaultValues) {\n                return {\n                    color: this.color,\n                    blur: this.blur,\n                    offsetX: this.offsetX,\n                    offsetY: this.offsetY,\n                    affectStroke: this.affectStroke,\n                    nonScaling: this.nonScaling\n                };\n            }\n            var obj = {}, proto = fabric.Shadow.prototype;\n            [\n                \"color\",\n                \"blur\",\n                \"offsetX\",\n                \"offsetY\",\n                \"affectStroke\",\n                \"nonScaling\"\n            ].forEach(function(prop) {\n                if (this[prop] !== proto[prop]) {\n                    obj[prop] = this[prop];\n                }\n            }, this);\n            return obj;\n        }\n    });\n    /**\n   * Regex matching shadow offsetX, offsetY and blur (ex: \"2px 2px 10px rgba(0,0,0,0.2)\", \"rgb(0,255,0) 2px 2px\")\n   * @static\n   * @field\n   * @memberOf fabric.Shadow\n   */ // eslint-disable-next-line max-len\n    fabric.Shadow.reOffsetsAndBlur = /(?:\\s|^)(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(\\d+(?:\\.\\d*)?(?:px)?)?(?:\\s?|$)(?:$|\\s)/;\n})( true ? exports : 0);\n(function() {\n    \"use strict\";\n    if (fabric.StaticCanvas) {\n        fabric.warn(\"fabric.StaticCanvas is already defined.\");\n        return;\n    }\n    // aliases for faster resolution\n    var extend = fabric.util.object.extend, getElementOffset = fabric.util.getElementOffset, removeFromArray = fabric.util.removeFromArray, toFixed = fabric.util.toFixed, transformPoint = fabric.util.transformPoint, invertTransform = fabric.util.invertTransform, getNodeCanvas = fabric.util.getNodeCanvas, createCanvasElement = fabric.util.createCanvasElement, CANVAS_INIT_ERROR = new Error(\"Could not initialize `canvas` element\");\n    /**\n   * Static canvas class\n   * @class fabric.StaticCanvas\n   * @mixes fabric.Collection\n   * @mixes fabric.Observable\n   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}\n   * @see {@link fabric.StaticCanvas#initialize} for constructor definition\n   * @fires before:render\n   * @fires after:render\n   * @fires canvas:cleared\n   * @fires object:added\n   * @fires object:removed\n   */ fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {\n        /**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(el, options) {\n            options || (options = {});\n            this.renderAndResetBound = this.renderAndReset.bind(this);\n            this.requestRenderAllBound = this.requestRenderAll.bind(this);\n            this._initStatic(el, options);\n        },\n        /**\n     * Background color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */ backgroundColor: \"\",\n        /**\n     * Background image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as background, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */ backgroundImage: null,\n        /**\n     * Overlay color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}\n     * @since 1.3.9\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */ overlayColor: \"\",\n        /**\n     * Overlay image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as overlay, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */ overlayImage: null,\n        /**\n     * Indicates whether toObject/toDatalessObject should include default values\n     * if set to false, takes precedence over the object value.\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * Indicates whether objects' state should be saved\n     * @type Boolean\n     * @default\n     */ stateful: false,\n        /**\n     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},\n     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.\n     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once\n     * since the renders are quequed and executed one per frame.\n     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )\n     * Left default to true to do not break documentation and old app, fiddles.\n     * @type Boolean\n     * @default\n     */ renderOnAddRemove: true,\n        /**\n     * Indicates whether object controls (borders/controls) are rendered above overlay image\n     * @type Boolean\n     * @default\n     */ controlsAboveOverlay: false,\n        /**\n     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas\n     * @type Boolean\n     * @default\n     */ allowTouchScrolling: false,\n        /**\n     * Indicates whether this canvas will use image smoothing, this is on by default in browsers\n     * @type Boolean\n     * @default\n     */ imageSmoothingEnabled: true,\n        /**\n     * The transformation (a Canvas 2D API transform matrix) which focuses the viewport\n     * @type Array\n     * @example <caption>Default transform</caption>\n     * canvas.viewportTransform = [1, 0, 0, 1, 0, 0];\n     * @example <caption>Scale by 70% and translate toward bottom-right by 50, without skewing</caption>\n     * canvas.viewportTransform = [0.7, 0, 0, 0.7, 50, 50];\n     * @default\n     */ viewportTransform: fabric.iMatrix.concat(),\n        /**\n     * if set to false background image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ backgroundVpt: true,\n        /**\n     * if set to false overlya image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ overlayVpt: true,\n        /**\n     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens\n     * @type Boolean\n     * @default\n     */ enableRetinaScaling: true,\n        /**\n     * Describe canvas element extension over design\n     * properties are tl,tr,bl,br.\n     * if canvas is not zoomed/panned those points are the four corner of canvas\n     * if canvas is viewportTransformed you those points indicate the extension\n     * of canvas element in plain untrasformed coordinates\n     * The coordinates get updated with @method calcViewportBoundaries.\n     * @memberOf fabric.StaticCanvas.prototype\n     */ vptCoords: {},\n        /**\n     * Based on vptCoords and object.aCoords, skip rendering of objects that\n     * are not included in current viewport.\n     * May greatly help in applications with crowded canvas and use of zoom/pan\n     * If One of the corner of the bounding box of the object is on the canvas\n     * the objects get rendered.\n     * @memberOf fabric.StaticCanvas.prototype\n     * @type Boolean\n     * @default\n     */ skipOffscreen: true,\n        /**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the canvas has rendered, and the context is placed in the\n     * top left corner of the canvas.\n     * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true\n     * @type fabric.Object\n     */ clipPath: undefined,\n        /**\n     * @private\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     */ _initStatic: function(el, options) {\n            var cb = this.requestRenderAllBound;\n            this._objects = [];\n            this._createLowerCanvas(el);\n            this._initOptions(options);\n            // only initialize retina scaling once\n            if (!this.interactive) {\n                this._initRetinaScaling();\n            }\n            if (options.overlayImage) {\n                this.setOverlayImage(options.overlayImage, cb);\n            }\n            if (options.backgroundImage) {\n                this.setBackgroundImage(options.backgroundImage, cb);\n            }\n            if (options.backgroundColor) {\n                this.setBackgroundColor(options.backgroundColor, cb);\n            }\n            if (options.overlayColor) {\n                this.setOverlayColor(options.overlayColor, cb);\n            }\n            this.calcOffset();\n        },\n        /**\n     * @private\n     */ _isRetinaScaling: function() {\n            return fabric.devicePixelRatio > 1 && this.enableRetinaScaling;\n        },\n        /**\n     * @private\n     * @return {Number} retinaScaling if applied, otherwise 1;\n     */ getRetinaScaling: function() {\n            return this._isRetinaScaling() ? Math.max(1, fabric.devicePixelRatio) : 1;\n        },\n        /**\n     * @private\n     */ _initRetinaScaling: function() {\n            if (!this._isRetinaScaling()) {\n                return;\n            }\n            var scaleRatio = fabric.devicePixelRatio;\n            this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);\n            if (this.upperCanvasEl) {\n                this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);\n            }\n        },\n        __initRetinaScaling: function(scaleRatio, canvas, context) {\n            canvas.setAttribute(\"width\", this.width * scaleRatio);\n            canvas.setAttribute(\"height\", this.height * scaleRatio);\n            context.scale(scaleRatio, scaleRatio);\n        },\n        /**\n     * Calculates canvas element offset relative to the document\n     * This method is also attached as \"resize\" event handler of window\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ calcOffset: function() {\n            this._offset = getElementOffset(this.lowerCanvasEl);\n            return this;\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to\n     * @param {Function} callback callback to invoke when image is loaded and set as an overlay\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}\n     * @example <caption>Normal overlayImage with left/top = 0</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage with different properties</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage loaded from cross-origin</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ setOverlayImage: function(image, callback, options) {\n            return this.__setBgOverlayImage(\"overlayImage\", image, callback, options);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}\n     * @example <caption>Normal backgroundImage with left/top = 0</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage with different properties</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage loaded from cross-origin</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ // TODO: fix stretched examples\n        setBackgroundImage: function(image, callback, options) {\n            return this.__setBgOverlayImage(\"backgroundImage\", image, callback, options);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas\n     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to\n     * @param {Function} callback Callback to invoke when foreground color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}\n     * @example <caption>Normal overlayColor - color value</caption>\n     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */ setOverlayColor: function(overlayColor, callback) {\n            return this.__setBgOverlayColor(\"overlayColor\", overlayColor, callback);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas\n     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to\n     * @param {Function} callback Callback to invoke when background color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}\n     * @example <caption>Normal backgroundColor - color value</caption>\n     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */ setBackgroundColor: function(backgroundColor, callback) {\n            return this.__setBgOverlayColor(\"backgroundColor\", backgroundColor, callback);\n        },\n        /**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}\n     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})\n     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.\n     */ __setBgOverlayImage: function(property, image, callback, options) {\n            if (typeof image === \"string\") {\n                fabric.util.loadImage(image, function(img, isError) {\n                    if (img) {\n                        var instance = new fabric.Image(img, options);\n                        this[property] = instance;\n                        instance.canvas = this;\n                    }\n                    callback && callback(img, isError);\n                }, this, options && options.crossOrigin);\n            } else {\n                options && image.setOptions(options);\n                this[property] = image;\n                image && (image.canvas = this);\n                callback && callback(image, false);\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}\n     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})\n     * @param {(Object|String|null)} color Object with pattern information, color value or null\n     * @param {Function} [callback] Callback is invoked when color is set\n     */ __setBgOverlayColor: function(property, color, callback) {\n            this[property] = color;\n            this._initGradient(color, property);\n            this._initPattern(color, property, callback);\n            return this;\n        },\n        /**\n     * @private\n     */ _createCanvasElement: function() {\n            var element = createCanvasElement();\n            if (!element) {\n                throw CANVAS_INIT_ERROR;\n            }\n            if (!element.style) {\n                element.style = {};\n            }\n            if (typeof element.getContext === \"undefined\") {\n                throw CANVAS_INIT_ERROR;\n            }\n            return element;\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options object\n     */ _initOptions: function(options) {\n            var lowerCanvasEl = this.lowerCanvasEl;\n            this._setOptions(options);\n            this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;\n            this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;\n            if (!this.lowerCanvasEl.style) {\n                return;\n            }\n            lowerCanvasEl.width = this.width;\n            lowerCanvasEl.height = this.height;\n            lowerCanvasEl.style.width = this.width + \"px\";\n            lowerCanvasEl.style.height = this.height + \"px\";\n            this.viewportTransform = this.viewportTransform.slice();\n        },\n        /**\n     * Creates a bottom canvas\n     * @private\n     * @param {HTMLElement} [canvasEl]\n     */ _createLowerCanvas: function(canvasEl) {\n            // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node\n            if (canvasEl && canvasEl.getContext) {\n                this.lowerCanvasEl = canvasEl;\n            } else {\n                this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();\n            }\n            fabric.util.addClass(this.lowerCanvasEl, \"lower-canvas\");\n            this._originalCanvasStyle = this.lowerCanvasEl.style;\n            if (this.interactive) {\n                this._applyCanvasStyle(this.lowerCanvasEl);\n            }\n            this.contextContainer = this.lowerCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * Returns canvas width (in px)\n     * @return {Number}\n     */ getWidth: function() {\n            return this.width;\n        },\n        /**\n     * Returns canvas height (in px)\n     * @return {Number}\n     */ getHeight: function() {\n            return this.height;\n        },\n        /**\n     * Sets width of this canvas instance\n     * @param {Number|String} value                         Value to set width to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setWidth: function(value, options) {\n            return this.setDimensions({\n                width: value\n            }, options);\n        },\n        /**\n     * Sets height of this canvas instance\n     * @param {Number|String} value                         Value to set height to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setHeight: function(value, options) {\n            return this.setDimensions({\n                height: value\n            }, options);\n        },\n        /**\n     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\n     * @param {Object}        dimensions                    Object with width/height properties\n     * @param {Number|String} [dimensions.width]            Width of canvas element\n     * @param {Number|String} [dimensions.height]           Height of canvas element\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ setDimensions: function(dimensions, options) {\n            var cssValue;\n            options = options || {};\n            for(var prop in dimensions){\n                cssValue = dimensions[prop];\n                if (!options.cssOnly) {\n                    this._setBackstoreDimension(prop, dimensions[prop]);\n                    cssValue += \"px\";\n                    this.hasLostContext = true;\n                }\n                if (!options.backstoreOnly) {\n                    this._setCssDimension(prop, cssValue);\n                }\n            }\n            if (this._isCurrentlyDrawing) {\n                this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);\n            }\n            this._initRetinaScaling();\n            this.calcOffset();\n            if (!options.cssOnly) {\n                this.requestRenderAll();\n            }\n            return this;\n        },\n        /**\n     * Helper for setting width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {Number} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ _setBackstoreDimension: function(prop, value) {\n            this.lowerCanvasEl[prop] = value;\n            if (this.upperCanvasEl) {\n                this.upperCanvasEl[prop] = value;\n            }\n            if (this.cacheCanvasEl) {\n                this.cacheCanvasEl[prop] = value;\n            }\n            this[prop] = value;\n            return this;\n        },\n        /**\n     * Helper for setting css width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {String} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ _setCssDimension: function(prop, value) {\n            this.lowerCanvasEl.style[prop] = value;\n            if (this.upperCanvasEl) {\n                this.upperCanvasEl.style[prop] = value;\n            }\n            if (this.wrapperEl) {\n                this.wrapperEl.style[prop] = value;\n            }\n            return this;\n        },\n        /**\n     * Returns canvas zoom level\n     * @return {Number}\n     */ getZoom: function() {\n            return this.viewportTransform[0];\n        },\n        /**\n     * Sets viewport transformation of this canvas instance\n     * @param {Array} vpt a Canvas 2D API transform matrix\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setViewportTransform: function(vpt) {\n            var activeObject = this._activeObject, backgroundObject = this.backgroundImage, overlayObject = this.overlayImage, object, i, len;\n            this.viewportTransform = vpt;\n            for(i = 0, len = this._objects.length; i < len; i++){\n                object = this._objects[i];\n                object.group || object.setCoords(true);\n            }\n            if (activeObject) {\n                activeObject.setCoords();\n            }\n            if (backgroundObject) {\n                backgroundObject.setCoords(true);\n            }\n            if (overlayObject) {\n                overlayObject.setCoords(true);\n            }\n            this.calcViewportBoundaries();\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Sets zoom level of this canvas instance, the zoom centered around point\n     * meaning that following zoom to point with the same point will have the visual\n     * effect of the zoom originating from that point. The point won't move.\n     * It has nothing to do with canvas center or visual center of the viewport.\n     * @param {fabric.Point} point to zoom with respect to\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ zoomToPoint: function(point, value) {\n            // TODO: just change the scale, preserve other transformations\n            var before = point, vpt = this.viewportTransform.slice(0);\n            point = transformPoint(point, invertTransform(this.viewportTransform));\n            vpt[0] = value;\n            vpt[3] = value;\n            var after = transformPoint(point, vpt);\n            vpt[4] += before.x - after.x;\n            vpt[5] += before.y - after.y;\n            return this.setViewportTransform(vpt);\n        },\n        /**\n     * Sets zoom level of this canvas instance\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setZoom: function(value) {\n            this.zoomToPoint(new fabric.Point(0, 0), value);\n            return this;\n        },\n        /**\n     * Pan viewport so as to place point at top left corner of canvas\n     * @param {fabric.Point} point to move to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ absolutePan: function(point) {\n            var vpt = this.viewportTransform.slice(0);\n            vpt[4] = -point.x;\n            vpt[5] = -point.y;\n            return this.setViewportTransform(vpt);\n        },\n        /**\n     * Pans viewpoint relatively\n     * @param {fabric.Point} point (position vector) to move by\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ relativePan: function(point) {\n            return this.absolutePan(new fabric.Point(-point.x - this.viewportTransform[4], -point.y - this.viewportTransform[5]));\n        },\n        /**\n     * Returns &lt;canvas> element corresponding to this instance\n     * @return {HTMLCanvasElement}\n     */ getElement: function() {\n            return this.lowerCanvasEl;\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was added\n     */ _onObjectAdded: function(obj) {\n            this.stateful && obj.setupState();\n            obj._set(\"canvas\", this);\n            obj.setCoords();\n            this.fire(\"object:added\", {\n                target: obj\n            });\n            obj.fire(\"added\");\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */ _onObjectRemoved: function(obj) {\n            this.fire(\"object:removed\", {\n                target: obj\n            });\n            obj.fire(\"removed\");\n            delete obj.canvas;\n        },\n        /**\n     * Clears specified context of canvas element\n     * @param {CanvasRenderingContext2D} ctx Context to clear\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clearContext: function(ctx) {\n            ctx.clearRect(0, 0, this.width, this.height);\n            return this;\n        },\n        /**\n     * Returns context of canvas where objects are drawn\n     * @return {CanvasRenderingContext2D}\n     */ getContext: function() {\n            return this.contextContainer;\n        },\n        /**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clear: function() {\n            this.remove.apply(this, this.getObjects());\n            this.backgroundImage = null;\n            this.overlayImage = null;\n            this.backgroundColor = \"\";\n            this.overlayColor = \"\";\n            if (this._hasITextHandlers) {\n                this.off(\"mouse:up\", this._mouseUpITextHandler);\n                this._iTextInstances = null;\n                this._hasITextHandlers = false;\n            }\n            this.clearContext(this.contextContainer);\n            this.fire(\"canvas:cleared\");\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Renders the canvas\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAll: function() {\n            var canvasToDrawOn = this.contextContainer;\n            this.renderCanvas(canvasToDrawOn, this._objects);\n            return this;\n        },\n        /**\n     * Function created to be instance bound at initialization\n     * used in requestAnimationFrame rendering\n     * Let the fabricJS call it. If you call it manually you could have more\n     * animationFrame stacking on to of each other\n     * for an imperative rendering, use canvas.renderAll\n     * @private\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAndReset: function() {\n            this.isRendering = 0;\n            this.renderAll();\n        },\n        /**\n     * Append a renderAll request to next animation frame.\n     * unless one is already in progress, in that case nothing is done\n     * a boolean flag will avoid appending more.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ requestRenderAll: function() {\n            if (!this.isRendering) {\n                this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);\n            }\n            return this;\n        },\n        /**\n     * Calculate the position of the 4 corner of canvas with current viewportTransform.\n     * helps to determinate when an object is in the current rendering viewport using\n     * object absolute coordinates ( aCoords )\n     * @return {Object} points.tl\n     * @chainable\n     */ calcViewportBoundaries: function() {\n            var points = {}, width = this.width, height = this.height, iVpt = invertTransform(this.viewportTransform);\n            points.tl = transformPoint({\n                x: 0,\n                y: 0\n            }, iVpt);\n            points.br = transformPoint({\n                x: width,\n                y: height\n            }, iVpt);\n            points.tr = new fabric.Point(points.br.x, points.tl.y);\n            points.bl = new fabric.Point(points.tl.x, points.br.y);\n            this.vptCoords = points;\n            return points;\n        },\n        cancelRequestedRender: function() {\n            if (this.isRendering) {\n                fabric.util.cancelAnimFrame(this.isRendering);\n                this.isRendering = 0;\n            }\n        },\n        /**\n     * Renders background, objects, overlay and controls.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Array} objects to render\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderCanvas: function(ctx, objects) {\n            var v = this.viewportTransform, path = this.clipPath;\n            this.cancelRequestedRender();\n            this.calcViewportBoundaries();\n            this.clearContext(ctx);\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothingEnabled);\n            this.fire(\"before:render\", {\n                ctx: ctx\n            });\n            this._renderBackground(ctx);\n            ctx.save();\n            //apply viewport transform once for all rendering process\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            this._renderObjects(ctx, objects);\n            ctx.restore();\n            if (!this.controlsAboveOverlay && this.interactive) {\n                this.drawControls(ctx);\n            }\n            if (path) {\n                path.canvas = this;\n                // needed to setup a couple of variables\n                path.shouldCache();\n                path._transformDone = true;\n                path.renderCache({\n                    forClipping: true\n                });\n                this.drawClipPathOnCanvas(ctx);\n            }\n            this._renderOverlay(ctx);\n            if (this.controlsAboveOverlay && this.interactive) {\n                this.drawControls(ctx);\n            }\n            this.fire(\"after:render\", {\n                ctx: ctx\n            });\n        },\n        /**\n     * Paint the cached clipPath on the lowerCanvasEl\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawClipPathOnCanvas: function(ctx) {\n            var v = this.viewportTransform, path = this.clipPath;\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            // DEBUG: uncomment this line, comment the following\n            // ctx.globalAlpha = 0.4;\n            ctx.globalCompositeOperation = \"destination-in\";\n            path.transform(ctx);\n            ctx.scale(1 / path.zoomX, 1 / path.zoomY);\n            ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} objects to render\n     */ _renderObjects: function(ctx, objects) {\n            var i, len;\n            for(i = 0, len = objects.length; i < len; ++i){\n                objects[i] && objects[i].render(ctx);\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {string} property 'background' or 'overlay'\n     */ _renderBackgroundOrOverlay: function(ctx, property) {\n            var fill = this[property + \"Color\"], object = this[property + \"Image\"], v = this.viewportTransform, needsVpt = this[property + \"Vpt\"];\n            if (!fill && !object) {\n                return;\n            }\n            if (fill) {\n                ctx.save();\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(this.width, 0);\n                ctx.lineTo(this.width, this.height);\n                ctx.lineTo(0, this.height);\n                ctx.closePath();\n                ctx.fillStyle = fill.toLive ? fill.toLive(ctx, this) : fill;\n                if (needsVpt) {\n                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n                }\n                ctx.transform(1, 0, 0, 1, fill.offsetX || 0, fill.offsetY || 0);\n                var m = fill.gradientTransform || fill.patternTransform;\n                m && ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n                ctx.fill();\n                ctx.restore();\n            }\n            if (object) {\n                ctx.save();\n                if (needsVpt) {\n                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n                }\n                object.render(ctx);\n                ctx.restore();\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderBackground: function(ctx) {\n            this._renderBackgroundOrOverlay(ctx, \"background\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderOverlay: function(ctx) {\n            this._renderBackgroundOrOverlay(ctx, \"overlay\");\n        },\n        /**\n     * Returns coordinates of a center of canvas.\n     * Returned value is an object with top and left properties\n     * @return {Object} object with \"top\" and \"left\" number values\n     */ getCenter: function() {\n            return {\n                top: this.height / 2,\n                left: this.width / 2\n            };\n        },\n        /**\n     * Centers object horizontally in the canvas\n     * @param {fabric.Object} object Object to center horizontally\n     * @return {fabric.Canvas} thisArg\n     */ centerObjectH: function(object) {\n            return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));\n        },\n        /**\n     * Centers object vertically in the canvas\n     * @param {fabric.Object} object Object to center vertically\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ centerObjectV: function(object) {\n            return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));\n        },\n        /**\n     * Centers object vertically and horizontally in the canvas\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ centerObject: function(object) {\n            var center = this.getCenter();\n            return this._centerObject(object, new fabric.Point(center.left, center.top));\n        },\n        /**\n     * Centers object vertically and horizontally in the viewport\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObject: function(object) {\n            var vpCenter = this.getVpCenter();\n            return this._centerObject(object, vpCenter);\n        },\n        /**\n     * Centers object horizontally in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObjectH: function(object) {\n            var vpCenter = this.getVpCenter();\n            this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));\n            return this;\n        },\n        /**\n     * Centers object Vertically in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObjectV: function(object) {\n            var vpCenter = this.getVpCenter();\n            return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));\n        },\n        /**\n     * Calculate the point in canvas that correspond to the center of actual viewport.\n     * @return {fabric.Point} vpCenter, viewport center\n     * @chainable\n     */ getVpCenter: function() {\n            var center = this.getCenter(), iVpt = invertTransform(this.viewportTransform);\n            return transformPoint({\n                x: center.left,\n                y: center.top\n            }, iVpt);\n        },\n        /**\n     * @private\n     * @param {fabric.Object} object Object to center\n     * @param {fabric.Point} center Center point\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ _centerObject: function(object, center) {\n            object.setPositionByOrigin(center, \"center\", \"center\");\n            object.setCoords();\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Returns dataless JSON representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {String} json string\n     */ toDatalessJSON: function(propertiesToInclude) {\n            return this.toDatalessObject(propertiesToInclude);\n        },\n        /**\n     * Returns object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this._toObjectMethod(\"toObject\", propertiesToInclude);\n        },\n        /**\n     * Returns dataless object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            return this._toObjectMethod(\"toDatalessObject\", propertiesToInclude);\n        },\n        /**\n     * @private\n     */ _toObjectMethod: function(methodName, propertiesToInclude) {\n            var clipPath = this.clipPath, data = {\n                version: fabric.version,\n                objects: this._toObjects(methodName, propertiesToInclude)\n            };\n            if (clipPath && !clipPath.excludeFromExport) {\n                data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);\n            }\n            extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));\n            fabric.util.populateWithProperties(this, data, propertiesToInclude);\n            return data;\n        },\n        /**\n     * @private\n     */ _toObjects: function(methodName, propertiesToInclude) {\n            return this._objects.filter(function(object) {\n                return !object.excludeFromExport;\n            }).map(function(instance) {\n                return this._toObject(instance, methodName, propertiesToInclude);\n            }, this);\n        },\n        /**\n     * @private\n     */ _toObject: function(instance, methodName, propertiesToInclude) {\n            var originalValue;\n            if (!this.includeDefaultValues) {\n                originalValue = instance.includeDefaultValues;\n                instance.includeDefaultValues = false;\n            }\n            var object = instance[methodName](propertiesToInclude);\n            if (!this.includeDefaultValues) {\n                instance.includeDefaultValues = originalValue;\n            }\n            return object;\n        },\n        /**\n     * @private\n     */ __serializeBgOverlay: function(methodName, propertiesToInclude) {\n            var data = {}, bgImage = this.backgroundImage, overlayImage = this.overlayImage, bgColor = this.backgroundColor, overlayColor = this.overlayColor;\n            if (bgColor && bgColor.toObject) {\n                if (!bgColor.excludeFromExport) {\n                    data.background = bgColor.toObject(propertiesToInclude);\n                }\n            } else if (bgColor) {\n                data.background = bgColor;\n            }\n            if (overlayColor && overlayColor.toObject) {\n                if (!overlayColor.excludeFromExport) {\n                    data.overlay = overlayColor.toObject(propertiesToInclude);\n                }\n            } else if (overlayColor) {\n                data.overlay = overlayColor;\n            }\n            if (bgImage && !bgImage.excludeFromExport) {\n                data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);\n            }\n            if (overlayImage && !overlayImage.excludeFromExport) {\n                data.overlayImage = this._toObject(overlayImage, methodName, propertiesToInclude);\n            }\n            return data;\n        },\n        /* _TO_SVG_START_ */ /**\n     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,\n     * a zoomed canvas will then produce zoomed SVG output.\n     * @type Boolean\n     * @default\n     */ svgViewportTransformation: true,\n        /**\n     * Returns SVG representation of canvas\n     * @function\n     * @param {Object} [options] Options object for SVG output\n     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included\n     * @param {Object} [options.viewBox] SVG viewbox object\n     * @param {Number} [options.viewBox.x] x-coordinate of viewbox\n     * @param {Number} [options.viewBox.y] y-coordinate of viewbox\n     * @param {Number} [options.viewBox.width] Width of viewbox\n     * @param {Number} [options.viewBox.height] Height of viewbox\n     * @param {String} [options.encoding=UTF-8] Encoding of SVG output\n     * @param {String} [options.width] desired width of svg with or without units\n     * @param {String} [options.height] desired height of svg with or without units\n     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.\n     * @return {String} SVG string\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}\n     * @example <caption>Normal SVG output</caption>\n     * var svg = canvas.toSVG();\n     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>\n     * var svg = canvas.toSVG({suppressPreamble: true});\n     * @example <caption>SVG output with viewBox attribute</caption>\n     * var svg = canvas.toSVG({\n     *   viewBox: {\n     *     x: 100,\n     *     y: 100,\n     *     width: 200,\n     *     height: 300\n     *   }\n     * });\n     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>\n     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});\n     * @example <caption>Modify SVG output with reviver function</caption>\n     * var svg = canvas.toSVG(null, function(svg) {\n     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');\n     * });\n     */ toSVG: function(options, reviver) {\n            options || (options = {});\n            options.reviver = reviver;\n            var markup = [];\n            this._setSVGPreamble(markup, options);\n            this._setSVGHeader(markup, options);\n            if (this.clipPath) {\n                markup.push('<g clip-path=\"url(#' + this.clipPath.clipPathId + ')\" >\\n');\n            }\n            this._setSVGBgOverlayColor(markup, \"background\");\n            this._setSVGBgOverlayImage(markup, \"backgroundImage\", reviver);\n            this._setSVGObjects(markup, reviver);\n            if (this.clipPath) {\n                markup.push(\"</g>\\n\");\n            }\n            this._setSVGBgOverlayColor(markup, \"overlay\");\n            this._setSVGBgOverlayImage(markup, \"overlayImage\", reviver);\n            markup.push(\"</svg>\");\n            return markup.join(\"\");\n        },\n        /**\n     * @private\n     */ _setSVGPreamble: function(markup, options) {\n            if (options.suppressPreamble) {\n                return;\n            }\n            markup.push('<?xml version=\"1.0\" encoding=\"', options.encoding || \"UTF-8\", '\" standalone=\"no\" ?>\\n', '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ', '\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n');\n        },\n        /**\n     * @private\n     */ _setSVGHeader: function(markup, options) {\n            var width = options.width || this.width, height = options.height || this.height, vpt, viewBox = 'viewBox=\"0 0 ' + this.width + \" \" + this.height + '\" ', NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            if (options.viewBox) {\n                viewBox = 'viewBox=\"' + options.viewBox.x + \" \" + options.viewBox.y + \" \" + options.viewBox.width + \" \" + options.viewBox.height + '\" ';\n            } else {\n                if (this.svgViewportTransformation) {\n                    vpt = this.viewportTransform;\n                    viewBox = 'viewBox=\"' + toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + \" \" + toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + \" \" + toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + \" \" + toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '\" ';\n                }\n            }\n            markup.push(\"<svg \", 'xmlns=\"http://www.w3.org/2000/svg\" ', 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ', 'version=\"1.1\" ', 'width=\"', width, '\" ', 'height=\"', height, '\" ', viewBox, 'xml:space=\"preserve\">\\n', \"<desc>Created with Fabric.js \", fabric.version, \"</desc>\\n\", \"<defs>\\n\", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(options), \"</defs>\\n\");\n        },\n        createSVGClipPathMarkup: function(options) {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                clipPath.clipPathId = \"CLIPPATH_\" + fabric.Object.__uid++;\n                return '<clipPath id=\"' + clipPath.clipPathId + '\" >\\n' + this.clipPath.toClipPathSVG(options.reviver) + \"</clipPath>\\n\";\n            }\n            return \"\";\n        },\n        /**\n     * Creates markup containing SVG referenced elements like patterns, gradients etc.\n     * @return {String}\n     */ createSVGRefElementsMarkup: function() {\n            var _this = this, markup = [\n                \"background\",\n                \"overlay\"\n            ].map(function(prop) {\n                var fill = _this[prop + \"Color\"];\n                if (fill && fill.toLive) {\n                    var shouldTransform = _this[prop + \"Vpt\"], vpt = _this.viewportTransform, object = {\n                        width: _this.width / (shouldTransform ? vpt[0] : 1),\n                        height: _this.height / (shouldTransform ? vpt[3] : 1)\n                    };\n                    return fill.toSVG(object, {\n                        additionalTransform: shouldTransform ? fabric.util.matrixToSVG(vpt) : \"\"\n                    });\n                }\n            });\n            return markup.join(\"\");\n        },\n        /**\n     * Creates markup containing SVG font faces,\n     * font URLs for font faces must be collected by developers\n     * and are not extracted from the DOM by fabricjs\n     * @param {Array} objects Array of fabric objects\n     * @return {String}\n     */ createSVGFontFacesMarkup: function() {\n            var markup = \"\", fontList = {}, obj, fontFamily, style, row, rowIndex, _char, charIndex, i, len, fontPaths = fabric.fontPaths, objects = [];\n            this._objects.forEach(function add(object) {\n                objects.push(object);\n                if (object._objects) {\n                    object._objects.forEach(add);\n                }\n            });\n            for(i = 0, len = objects.length; i < len; i++){\n                obj = objects[i];\n                fontFamily = obj.fontFamily;\n                if (obj.type.indexOf(\"text\") === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {\n                    continue;\n                }\n                fontList[fontFamily] = true;\n                if (!obj.styles) {\n                    continue;\n                }\n                style = obj.styles;\n                for(rowIndex in style){\n                    row = style[rowIndex];\n                    for(charIndex in row){\n                        _char = row[charIndex];\n                        fontFamily = _char.fontFamily;\n                        if (!fontList[fontFamily] && fontPaths[fontFamily]) {\n                            fontList[fontFamily] = true;\n                        }\n                    }\n                }\n            }\n            for(var j in fontList){\n                markup += [\n                    \"\t\t@font-face {\\n\",\n                    \"\t\t\tfont-family: '\",\n                    j,\n                    \"';\\n\",\n                    \"\t\t\tsrc: url('\",\n                    fontPaths[j],\n                    \"');\\n\",\n                    \"\t\t}\\n\"\n                ].join(\"\");\n            }\n            if (markup) {\n                markup = [\n                    '\t<style type=\"text/css\">',\n                    \"<![CDATA[\\n\",\n                    markup,\n                    \"]]>\",\n                    \"</style>\\n\"\n                ].join(\"\");\n            }\n            return markup;\n        },\n        /**\n     * @private\n     */ _setSVGObjects: function(markup, reviver) {\n            var instance, i, len, objects = this._objects;\n            for(i = 0, len = objects.length; i < len; i++){\n                instance = objects[i];\n                if (instance.excludeFromExport) {\n                    continue;\n                }\n                this._setSVGObject(markup, instance, reviver);\n            }\n        },\n        /**\n     * @private\n     */ _setSVGObject: function(markup, instance, reviver) {\n            markup.push(instance.toSVG(reviver));\n        },\n        /**\n     * @private\n     */ _setSVGBgOverlayImage: function(markup, property, reviver) {\n            if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {\n                markup.push(this[property].toSVG(reviver));\n            }\n        },\n        /**\n     * @private\n     */ _setSVGBgOverlayColor: function(markup, property) {\n            var filler = this[property + \"Color\"], vpt = this.viewportTransform, finalWidth = this.width, finalHeight = this.height;\n            if (!filler) {\n                return;\n            }\n            if (filler.toLive) {\n                var repeat = filler.repeat, iVpt = fabric.util.invertTransform(vpt), shouldInvert = this[property + \"Vpt\"], additionalTransform = shouldInvert ? fabric.util.matrixToSVG(iVpt) : \"\";\n                markup.push('<rect transform=\"' + additionalTransform + \" translate(\", finalWidth / 2, \",\", finalHeight / 2, ')\"', ' x=\"', filler.offsetX - finalWidth / 2, '\" y=\"', filler.offsetY - finalHeight / 2, '\" ', 'width=\"', repeat === \"repeat-y\" || repeat === \"no-repeat\" ? filler.source.width : finalWidth, '\" height=\"', repeat === \"repeat-x\" || repeat === \"no-repeat\" ? filler.source.height : finalHeight, '\" fill=\"url(#SVGID_' + filler.id + ')\"', \"></rect>\\n\");\n            } else {\n                markup.push('<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" ', 'fill=\"', filler, '\"', \"></rect>\\n\");\n            }\n        },\n        /* _TO_SVG_END_ */ /**\n     * Moves an object or the objects of a multiple selection\n     * to the bottom of the stack of drawn objects\n     * @param {fabric.Object} object Object to send to back\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ sendToBack: function(object) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, objs;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = objs.length; i--;){\n                    obj = objs[i];\n                    removeFromArray(this._objects, obj);\n                    this._objects.unshift(obj);\n                }\n            } else {\n                removeFromArray(this._objects, object);\n                this._objects.unshift(object);\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Moves an object or the objects of a multiple selection\n     * to the top of the stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ bringToFront: function(object) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, objs;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = 0; i < objs.length; i++){\n                    obj = objs[i];\n                    removeFromArray(this._objects, obj);\n                    this._objects.push(obj);\n                }\n            } else {\n                removeFromArray(this._objects, object);\n                this._objects.push(object);\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Moves an object or a selection down in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in behind\n     * the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ sendBackwards: function(object, intersecting) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = 0; i < objs.length; i++){\n                    obj = objs[i];\n                    idx = this._objects.indexOf(obj);\n                    if (idx > 0 + objsMoved) {\n                        newIdx = idx - 1;\n                        removeFromArray(this._objects, obj);\n                        this._objects.splice(newIdx, 0, obj);\n                    }\n                    objsMoved++;\n                }\n            } else {\n                idx = this._objects.indexOf(object);\n                if (idx !== 0) {\n                    // if object is not on the bottom of stack\n                    newIdx = this._findNewLowerIndex(object, idx, intersecting);\n                    removeFromArray(this._objects, object);\n                    this._objects.splice(newIdx, 0, object);\n                }\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * @private\n     */ _findNewLowerIndex: function(object, idx, intersecting) {\n            var newIdx, i;\n            if (intersecting) {\n                newIdx = idx;\n                // traverse down the stack looking for the nearest intersecting object\n                for(i = idx - 1; i >= 0; --i){\n                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);\n                    if (isIntersecting) {\n                        newIdx = i;\n                        break;\n                    }\n                }\n            } else {\n                newIdx = idx - 1;\n            }\n            return newIdx;\n        },\n        /**\n     * Moves an object or a selection up in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in front\n     * of the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ bringForward: function(object, intersecting) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = objs.length; i--;){\n                    obj = objs[i];\n                    idx = this._objects.indexOf(obj);\n                    if (idx < this._objects.length - 1 - objsMoved) {\n                        newIdx = idx + 1;\n                        removeFromArray(this._objects, obj);\n                        this._objects.splice(newIdx, 0, obj);\n                    }\n                    objsMoved++;\n                }\n            } else {\n                idx = this._objects.indexOf(object);\n                if (idx !== this._objects.length - 1) {\n                    // if object is not on top of stack (last item in an array)\n                    newIdx = this._findNewUpperIndex(object, idx, intersecting);\n                    removeFromArray(this._objects, object);\n                    this._objects.splice(newIdx, 0, object);\n                }\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * @private\n     */ _findNewUpperIndex: function(object, idx, intersecting) {\n            var newIdx, i, len;\n            if (intersecting) {\n                newIdx = idx;\n                // traverse up the stack looking for the nearest intersecting object\n                for(i = idx + 1, len = this._objects.length; i < len; ++i){\n                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);\n                    if (isIntersecting) {\n                        newIdx = i;\n                        break;\n                    }\n                }\n            } else {\n                newIdx = idx + 1;\n            }\n            return newIdx;\n        },\n        /**\n     * Moves an object to specified level in stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @param {Number} index Position to move to\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ moveTo: function(object, index) {\n            removeFromArray(this._objects, object);\n            this._objects.splice(index, 0, object);\n            return this.renderOnAddRemove && this.requestRenderAll();\n        },\n        /**\n     * Clears a canvas element and dispose objects\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ dispose: function() {\n            // cancel eventually ongoing renders\n            if (this.isRendering) {\n                fabric.util.cancelAnimFrame(this.isRendering);\n                this.isRendering = 0;\n            }\n            this.forEachObject(function(object) {\n                object.dispose && object.dispose();\n            });\n            this._objects = [];\n            if (this.backgroundImage && this.backgroundImage.dispose) {\n                this.backgroundImage.dispose();\n            }\n            this.backgroundImage = null;\n            if (this.overlayImage && this.overlayImage.dispose) {\n                this.overlayImage.dispose();\n            }\n            this.overlayImage = null;\n            this._iTextInstances = null;\n            this.contextContainer = null;\n            // restore canvas style\n            this.lowerCanvasEl.classList.remove(\"lower-canvas\");\n            fabric.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle);\n            delete this._originalCanvasStyle;\n            // restore canvas size to original size in case retina scaling was applied\n            this.lowerCanvasEl.setAttribute(\"width\", this.width);\n            this.lowerCanvasEl.setAttribute(\"height\", this.height);\n            fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);\n            this.lowerCanvasEl = undefined;\n            return this;\n        },\n        /**\n     * Returns a string representation of an instance\n     * @return {String} string representation of an instance\n     */ toString: function() {\n            return \"#<fabric.Canvas (\" + this.complexity() + \"): \" + \"{ objects: \" + this._objects.length + \" }>\";\n        }\n    });\n    extend(fabric.StaticCanvas.prototype, fabric.Observable);\n    extend(fabric.StaticCanvas.prototype, fabric.Collection);\n    extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);\n    extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {\n        /**\n     * @static\n     * @type String\n     * @default\n     */ EMPTY_JSON: '{\"objects\": [], \"background\": \"white\"}',\n        /**\n     * Provides a way to check support of some of the canvas methods\n     * (either those of HTMLCanvasElement itself, or rendering context)\n     *\n     * @param {String} methodName Method to check support for;\n     *                            Could be one of \"setLineDash\"\n     * @return {Boolean | null} `true` if method is supported (or at least exists),\n     *                          `null` if canvas element or context can not be initialized\n     */ supports: function(methodName) {\n            var el = createCanvasElement();\n            if (!el || !el.getContext) {\n                return null;\n            }\n            var ctx = el.getContext(\"2d\");\n            if (!ctx) {\n                return null;\n            }\n            switch(methodName){\n                case \"setLineDash\":\n                    return typeof ctx.setLineDash !== \"undefined\";\n                default:\n                    return null;\n            }\n        }\n    });\n    /**\n   * Returns Object representation of canvas\n   * this alias is provided because if you call JSON.stringify on an instance,\n   * the toJSON object will be invoked if it exists.\n   * Having a toJSON method means you can do JSON.stringify(myCanvas)\n   * @function\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} JSON compatible object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}\n   * @example <caption>JSON without additional properties</caption>\n   * var json = canvas.toJSON();\n   * @example <caption>JSON with additional properties included</caption>\n   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY']);\n   * @example <caption>JSON without default values</caption>\n   * canvas.includeDefaultValues = false;\n   * var json = canvas.toJSON();\n   */ fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;\n    if (fabric.isLikelyNode) {\n        fabric.StaticCanvas.prototype.createPNGStream = function() {\n            var impl = getNodeCanvas(this.lowerCanvasEl);\n            return impl && impl.createPNGStream();\n        };\n        fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {\n            var impl = getNodeCanvas(this.lowerCanvasEl);\n            return impl && impl.createJPEGStream(opts);\n        };\n    }\n})();\n/**\n * BaseBrush class\n * @class fabric.BaseBrush\n * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}\n */ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {\n    /**\n   * Color of a brush\n   * @type String\n   * @default\n   */ color: \"rgb(0, 0, 0)\",\n    /**\n   * Width of a brush, has to be a Number, no string literals\n   * @type Number\n   * @default\n   */ width: 1,\n    /**\n   * Shadow object representing shadow of this shape.\n   * <b>Backwards incompatibility note:</b> This property replaces \"shadowColor\" (String), \"shadowOffsetX\" (Number),\n   * \"shadowOffsetY\" (Number) and \"shadowBlur\" (Number) since v1.2.12\n   * @type fabric.Shadow\n   * @default\n   */ shadow: null,\n    /**\n   * Line endings style of a brush (one of \"butt\", \"round\", \"square\")\n   * @type String\n   * @default\n   */ strokeLineCap: \"round\",\n    /**\n   * Corner style of a brush (one of \"bevel\", \"round\", \"miter\")\n   * @type String\n   * @default\n   */ strokeLineJoin: \"round\",\n    /**\n   * Maximum miter length (used for strokeLineJoin = \"miter\") of a brush's\n   * @type Number\n   * @default\n   */ strokeMiterLimit: 10,\n    /**\n   * Stroke Dash Array.\n   * @type Array\n   * @default\n   */ strokeDashArray: null,\n    /**\n   * When `true`, the free drawing is limited to the whiteboard size. Default to false.\n   * @type Boolean\n   * @default false\n  */ limitedToCanvasSize: false,\n    /**\n   * Sets brush styles\n   * @private\n   * @param {CanvasRenderingContext2D} ctx\n   */ _setBrushStyles: function(ctx) {\n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = this.width;\n        ctx.lineCap = this.strokeLineCap;\n        ctx.miterLimit = this.strokeMiterLimit;\n        ctx.lineJoin = this.strokeLineJoin;\n        ctx.setLineDash(this.strokeDashArray || []);\n    },\n    /**\n   * Sets the transformation on given context\n   * @param {RenderingContext2d} ctx context to render on\n   * @private\n   */ _saveAndTransform: function(ctx) {\n        var v = this.canvas.viewportTransform;\n        ctx.save();\n        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n    },\n    /**\n   * Sets brush shadow styles\n   * @private\n   */ _setShadow: function() {\n        if (!this.shadow) {\n            return;\n        }\n        var canvas = this.canvas, shadow = this.shadow, ctx = canvas.contextTop, zoom = canvas.getZoom();\n        if (canvas && canvas._isRetinaScaling()) {\n            zoom *= fabric.devicePixelRatio;\n        }\n        ctx.shadowColor = shadow.color;\n        ctx.shadowBlur = shadow.blur * zoom;\n        ctx.shadowOffsetX = shadow.offsetX * zoom;\n        ctx.shadowOffsetY = shadow.offsetY * zoom;\n    },\n    needsFullRender: function() {\n        var color = new fabric.Color(this.color);\n        return color.getAlpha() < 1 || !!this.shadow;\n    },\n    /**\n   * Removes brush shadow styles\n   * @private\n   */ _resetShadow: function() {\n        var ctx = this.canvas.contextTop;\n        ctx.shadowColor = \"\";\n        ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n    },\n    /**\n   * Check is pointer is outside canvas boundaries\n   * @param {Object} pointer\n   * @private\n  */ _isOutSideCanvas: function(pointer) {\n        return pointer.x < 0 || pointer.x > this.canvas.getWidth() || pointer.y < 0 || pointer.y > this.canvas.getHeight();\n    }\n});\n(function() {\n    /**\n   * PencilBrush class\n   * @class fabric.PencilBrush\n   * @extends fabric.BaseBrush\n   */ fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {\n        /**\n     * Discard points that are less than `decimate` pixel distant from each other\n     * @type Number\n     * @default 0.4\n     */ decimate: 0.4,\n        /**\n     * Draws a straight line between last recorded point to current pointer\n     * Used for `shift` functionality\n     *\n     * @type boolean\n     * @default false\n     */ drawStraightLine: false,\n        /**\n     * The event modifier key that makes the brush draw a straight line.\n     * If `null` or 'none' or any other string that is not a modifier key the feature is disabled.\n     * @type {'altKey' | 'shiftKey' | 'ctrlKey' | 'none' | undefined | null}\n     */ straightLineKey: \"shiftKey\",\n        /**\n     * Constructor\n     * @param {fabric.Canvas} canvas\n     * @return {fabric.PencilBrush} Instance of a pencil brush\n     */ initialize: function(canvas) {\n            this.canvas = canvas;\n            this._points = [];\n        },\n        needsFullRender: function() {\n            return this.callSuper(\"needsFullRender\") || this._hasStraightLine;\n        },\n        /**\n     * Invoked inside on mouse down and mouse move\n     * @param {Object} pointer\n     */ _drawSegment: function(ctx, p1, p2) {\n            var midPoint = p1.midPointFrom(p2);\n            ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n            return midPoint;\n        },\n        /**\n     * Invoked on mouse down\n     * @param {Object} pointer\n     */ onMouseDown: function(pointer, options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return;\n            }\n            this.drawStraightLine = options.e[this.straightLineKey];\n            this._prepareForDrawing(pointer);\n            // capture coordinates immediately\n            // this allows to draw dots (when movement never occurs)\n            this._captureDrawingPath(pointer);\n            this._render();\n        },\n        /**\n     * Invoked on mouse move\n     * @param {Object} pointer\n     */ onMouseMove: function(pointer, options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return;\n            }\n            this.drawStraightLine = options.e[this.straightLineKey];\n            if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n                return;\n            }\n            if (this._captureDrawingPath(pointer) && this._points.length > 1) {\n                if (this.needsFullRender()) {\n                    // redraw curve\n                    // clear top canvas\n                    this.canvas.clearContext(this.canvas.contextTop);\n                    this._render();\n                } else {\n                    var points = this._points, length = points.length, ctx = this.canvas.contextTop;\n                    // draw the curve update\n                    this._saveAndTransform(ctx);\n                    if (this.oldEnd) {\n                        ctx.beginPath();\n                        ctx.moveTo(this.oldEnd.x, this.oldEnd.y);\n                    }\n                    this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);\n                    ctx.stroke();\n                    ctx.restore();\n                }\n            }\n        },\n        /**\n     * Invoked on mouse up\n     */ onMouseUp: function(options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return true;\n            }\n            this.drawStraightLine = false;\n            this.oldEnd = undefined;\n            this._finalizeAndAddPath();\n            return false;\n        },\n        /**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */ _prepareForDrawing: function(pointer) {\n            var p = new fabric.Point(pointer.x, pointer.y);\n            this._reset();\n            this._addPoint(p);\n            this.canvas.contextTop.moveTo(p.x, p.y);\n        },\n        /**\n     * @private\n     * @param {fabric.Point} point Point to be added to points array\n     */ _addPoint: function(point) {\n            if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {\n                return false;\n            }\n            if (this.drawStraightLine && this._points.length > 1) {\n                this._hasStraightLine = true;\n                this._points.pop();\n            }\n            this._points.push(point);\n            return true;\n        },\n        /**\n     * Clear points array and set contextTop canvas style.\n     * @private\n     */ _reset: function() {\n            this._points = [];\n            this._setBrushStyles(this.canvas.contextTop);\n            this._setShadow();\n            this._hasStraightLine = false;\n        },\n        /**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */ _captureDrawingPath: function(pointer) {\n            var pointerPoint = new fabric.Point(pointer.x, pointer.y);\n            return this._addPoint(pointerPoint);\n        },\n        /**\n     * Draw a smooth path on the topCanvas using quadraticCurveTo\n     * @private\n     * @param {CanvasRenderingContext2D} [ctx]\n     */ _render: function(ctx) {\n            var i, len, p1 = this._points[0], p2 = this._points[1];\n            ctx = ctx || this.canvas.contextTop;\n            this._saveAndTransform(ctx);\n            ctx.beginPath();\n            //if we only have 2 points in the path and they are the same\n            //it means that the user only clicked the canvas without moving the mouse\n            //then we should be drawing a dot. A path isn't drawn between two identical dots\n            //that's why we set them apart a bit\n            if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {\n                var width = this.width / 1000;\n                p1 = new fabric.Point(p1.x, p1.y);\n                p2 = new fabric.Point(p2.x, p2.y);\n                p1.x -= width;\n                p2.x += width;\n            }\n            ctx.moveTo(p1.x, p1.y);\n            for(i = 1, len = this._points.length; i < len; i++){\n                // we pick the point between pi + 1 & pi + 2 as the\n                // end point and p1 as our control point.\n                this._drawSegment(ctx, p1, p2);\n                p1 = this._points[i];\n                p2 = this._points[i + 1];\n            }\n            // Draw last line as a straight line while\n            // we wait for the next point to be able to calculate\n            // the bezier control point\n            ctx.lineTo(p1.x, p1.y);\n            ctx.stroke();\n            ctx.restore();\n        },\n        /**\n     * Converts points to SVG path\n     * @param {Array} points Array of points\n     * @return {(string|number)[][]} SVG path commands\n     */ convertPointsToSVGPath: function(points) {\n            var correction = this.width / 1000;\n            return fabric.util.getSmoothPathFromPoints(points, correction);\n        },\n        /**\n     * @private\n     * @param {(string|number)[][]} pathData SVG path commands\n     * @returns {boolean}\n     */ _isEmptySVGPath: function(pathData) {\n            var pathString = fabric.util.joinPath(pathData);\n            return pathString === \"M 0 0 Q 0 0 0 0 L 0 0\";\n        },\n        /**\n     * Creates fabric.Path object to add on canvas\n     * @param {(string|number)[][]} pathData Path data\n     * @return {fabric.Path} Path to add on canvas\n     */ createPath: function(pathData) {\n            var path = new fabric.Path(pathData, {\n                fill: null,\n                stroke: this.color,\n                strokeWidth: this.width,\n                strokeLineCap: this.strokeLineCap,\n                strokeMiterLimit: this.strokeMiterLimit,\n                strokeLineJoin: this.strokeLineJoin,\n                strokeDashArray: this.strokeDashArray\n            });\n            if (this.shadow) {\n                this.shadow.affectStroke = true;\n                path.shadow = new fabric.Shadow(this.shadow);\n            }\n            return path;\n        },\n        /**\n     * Decimate points array with the decimate value\n     */ decimatePoints: function(points, distance) {\n            if (points.length <= 2) {\n                return points;\n            }\n            var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance / zoom, 2), i, l = points.length - 1, lastPoint = points[0], newPoints = [\n                lastPoint\n            ], cDistance;\n            for(i = 1; i < l - 1; i++){\n                cDistance = Math.pow(lastPoint.x - points[i].x, 2) + Math.pow(lastPoint.y - points[i].y, 2);\n                if (cDistance >= adjustedDistance) {\n                    lastPoint = points[i];\n                    newPoints.push(lastPoint);\n                }\n            }\n            /**\n       * Add the last point from the original line to the end of the array.\n       * This ensures decimate doesn't delete the last point on the line, and ensures the line is > 1 point.\n       */ newPoints.push(points[l]);\n            return newPoints;\n        },\n        /**\n     * On mouseup after drawing the path on contextTop canvas\n     * we use the points captured to create an new fabric path object\n     * and add it to the fabric canvas.\n     */ _finalizeAndAddPath: function() {\n            var ctx = this.canvas.contextTop;\n            ctx.closePath();\n            if (this.decimate) {\n                this._points = this.decimatePoints(this._points, this.decimate);\n            }\n            var pathData = this.convertPointsToSVGPath(this._points);\n            if (this._isEmptySVGPath(pathData)) {\n                // do not create 0 width/height paths, as they are\n                // rendered inconsistently across browsers\n                // Firefox 4, for example, renders a dot,\n                // whereas Chrome 10 renders nothing\n                this.canvas.requestRenderAll();\n                return;\n            }\n            var path = this.createPath(pathData);\n            this.canvas.clearContext(this.canvas.contextTop);\n            this.canvas.fire(\"before:path:created\", {\n                path: path\n            });\n            this.canvas.add(path);\n            this.canvas.requestRenderAll();\n            path.setCoords();\n            this._resetShadow();\n            // fire event 'path' created\n            this.canvas.fire(\"path:created\", {\n                path: path\n            });\n        }\n    });\n})();\n/**\n * CircleBrush class\n * @class fabric.CircleBrush\n */ fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {\n    /**\n   * Width of a brush\n   * @type Number\n   * @default\n   */ width: 10,\n    /**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.CircleBrush} Instance of a circle brush\n   */ initialize: function(canvas) {\n        this.canvas = canvas;\n        this.points = [];\n    },\n    /**\n   * Invoked inside on mouse down and mouse move\n   * @param {Object} pointer\n   */ drawDot: function(pointer) {\n        var point = this.addPoint(pointer), ctx = this.canvas.contextTop;\n        this._saveAndTransform(ctx);\n        this.dot(ctx, point);\n        ctx.restore();\n    },\n    dot: function(ctx, point) {\n        ctx.fillStyle = point.fill;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);\n        ctx.closePath();\n        ctx.fill();\n    },\n    /**\n   * Invoked on mouse down\n   */ onMouseDown: function(pointer) {\n        this.points.length = 0;\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._setShadow();\n        this.drawDot(pointer);\n    },\n    /**\n   * Render the full state of the brush\n   * @private\n   */ _render: function() {\n        var ctx = this.canvas.contextTop, i, len, points = this.points;\n        this._saveAndTransform(ctx);\n        for(i = 0, len = points.length; i < len; i++){\n            this.dot(ctx, points[i]);\n        }\n        ctx.restore();\n    },\n    /**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */ onMouseMove: function(pointer) {\n        if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n            return;\n        }\n        if (this.needsFullRender()) {\n            this.canvas.clearContext(this.canvas.contextTop);\n            this.addPoint(pointer);\n            this._render();\n        } else {\n            this.drawDot(pointer);\n        }\n    },\n    /**\n   * Invoked on mouse up\n   */ onMouseUp: function() {\n        var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;\n        this.canvas.renderOnAddRemove = false;\n        var circles = [];\n        for(i = 0, len = this.points.length; i < len; i++){\n            var point = this.points[i], circle = new fabric.Circle({\n                radius: point.radius,\n                left: point.x,\n                top: point.y,\n                originX: \"center\",\n                originY: \"center\",\n                fill: point.fill\n            });\n            this.shadow && (circle.shadow = new fabric.Shadow(this.shadow));\n            circles.push(circle);\n        }\n        var group = new fabric.Group(circles);\n        group.canvas = this.canvas;\n        this.canvas.fire(\"before:path:created\", {\n            path: group\n        });\n        this.canvas.add(group);\n        this.canvas.fire(\"path:created\", {\n            path: group\n        });\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._resetShadow();\n        this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\n        this.canvas.requestRenderAll();\n    },\n    /**\n   * @param {Object} pointer\n   * @return {fabric.Point} Just added pointer point\n   */ addPoint: function(pointer) {\n        var pointerPoint = new fabric.Point(pointer.x, pointer.y), circleRadius = fabric.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, circleColor = new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0, 100) / 100).toRgba();\n        pointerPoint.radius = circleRadius;\n        pointerPoint.fill = circleColor;\n        this.points.push(pointerPoint);\n        return pointerPoint;\n    }\n});\n/**\n * SprayBrush class\n * @class fabric.SprayBrush\n */ fabric.SprayBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {\n    /**\n   * Width of a spray\n   * @type Number\n   * @default\n   */ width: 10,\n    /**\n   * Density of a spray (number of dots per chunk)\n   * @type Number\n   * @default\n   */ density: 20,\n    /**\n   * Width of spray dots\n   * @type Number\n   * @default\n   */ dotWidth: 1,\n    /**\n   * Width variance of spray dots\n   * @type Number\n   * @default\n   */ dotWidthVariance: 1,\n    /**\n   * Whether opacity of a dot should be random\n   * @type Boolean\n   * @default\n   */ randomOpacity: false,\n    /**\n   * Whether overlapping dots (rectangles) should be removed (for performance reasons)\n   * @type Boolean\n   * @default\n   */ optimizeOverlapping: true,\n    /**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.SprayBrush} Instance of a spray brush\n   */ initialize: function(canvas) {\n        this.canvas = canvas;\n        this.sprayChunks = [];\n    },\n    /**\n   * Invoked on mouse down\n   * @param {Object} pointer\n   */ onMouseDown: function(pointer) {\n        this.sprayChunks.length = 0;\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._setShadow();\n        this.addSprayChunk(pointer);\n        this.render(this.sprayChunkPoints);\n    },\n    /**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */ onMouseMove: function(pointer) {\n        if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n            return;\n        }\n        this.addSprayChunk(pointer);\n        this.render(this.sprayChunkPoints);\n    },\n    /**\n   * Invoked on mouse up\n   */ onMouseUp: function() {\n        var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\n        this.canvas.renderOnAddRemove = false;\n        var rects = [];\n        for(var i = 0, ilen = this.sprayChunks.length; i < ilen; i++){\n            var sprayChunk = this.sprayChunks[i];\n            for(var j = 0, jlen = sprayChunk.length; j < jlen; j++){\n                var rect = new fabric.Rect({\n                    width: sprayChunk[j].width,\n                    height: sprayChunk[j].width,\n                    left: sprayChunk[j].x + 1,\n                    top: sprayChunk[j].y + 1,\n                    originX: \"center\",\n                    originY: \"center\",\n                    fill: this.color\n                });\n                rects.push(rect);\n            }\n        }\n        if (this.optimizeOverlapping) {\n            rects = this._getOptimizedRects(rects);\n        }\n        var group = new fabric.Group(rects);\n        this.shadow && group.set(\"shadow\", new fabric.Shadow(this.shadow));\n        this.canvas.fire(\"before:path:created\", {\n            path: group\n        });\n        this.canvas.add(group);\n        this.canvas.fire(\"path:created\", {\n            path: group\n        });\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._resetShadow();\n        this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\n        this.canvas.requestRenderAll();\n    },\n    /**\n   * @private\n   * @param {Array} rects\n   */ _getOptimizedRects: function(rects) {\n        // avoid creating duplicate rects at the same coordinates\n        var uniqueRects = {}, key, i, len;\n        for(i = 0, len = rects.length; i < len; i++){\n            key = rects[i].left + \"\" + rects[i].top;\n            if (!uniqueRects[key]) {\n                uniqueRects[key] = rects[i];\n            }\n        }\n        var uniqueRectsArray = [];\n        for(key in uniqueRects){\n            uniqueRectsArray.push(uniqueRects[key]);\n        }\n        return uniqueRectsArray;\n    },\n    /**\n   * Render new chunk of spray brush\n   */ render: function(sprayChunk) {\n        var ctx = this.canvas.contextTop, i, len;\n        ctx.fillStyle = this.color;\n        this._saveAndTransform(ctx);\n        for(i = 0, len = sprayChunk.length; i < len; i++){\n            var point = sprayChunk[i];\n            if (typeof point.opacity !== \"undefined\") {\n                ctx.globalAlpha = point.opacity;\n            }\n            ctx.fillRect(point.x, point.y, point.width, point.width);\n        }\n        ctx.restore();\n    },\n    /**\n   * Render all spray chunks\n   */ _render: function() {\n        var ctx = this.canvas.contextTop, i, ilen;\n        ctx.fillStyle = this.color;\n        this._saveAndTransform(ctx);\n        for(i = 0, ilen = this.sprayChunks.length; i < ilen; i++){\n            this.render(this.sprayChunks[i]);\n        }\n        ctx.restore();\n    },\n    /**\n   * @param {Object} pointer\n   */ addSprayChunk: function(pointer) {\n        this.sprayChunkPoints = [];\n        var x, y, width, radius = this.width / 2, i;\n        for(i = 0; i < this.density; i++){\n            x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);\n            y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);\n            if (this.dotWidthVariance) {\n                width = fabric.util.getRandomInt(// bottom clamp width to 1\n                Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance);\n            } else {\n                width = this.dotWidth;\n            }\n            var point = new fabric.Point(x, y);\n            point.width = width;\n            if (this.randomOpacity) {\n                point.opacity = fabric.util.getRandomInt(0, 100) / 100;\n            }\n            this.sprayChunkPoints.push(point);\n        }\n        this.sprayChunks.push(this.sprayChunkPoints);\n    }\n});\n/**\n * PatternBrush class\n * @class fabric.PatternBrush\n * @extends fabric.BaseBrush\n */ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {\n    getPatternSrc: function() {\n        var dotWidth = 20, dotDistance = 5, patternCanvas = fabric.util.createCanvasElement(), patternCtx = patternCanvas.getContext(\"2d\");\n        patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;\n        patternCtx.fillStyle = this.color;\n        patternCtx.beginPath();\n        patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);\n        patternCtx.closePath();\n        patternCtx.fill();\n        return patternCanvas;\n    },\n    getPatternSrcFunction: function() {\n        return String(this.getPatternSrc).replace(\"this.color\", '\"' + this.color + '\"');\n    },\n    /**\n   * Creates \"pattern\" instance property\n   * @param {CanvasRenderingContext2D} ctx\n   */ getPattern: function(ctx) {\n        return ctx.createPattern(this.source || this.getPatternSrc(), \"repeat\");\n    },\n    /**\n   * Sets brush styles\n   * @param {CanvasRenderingContext2D} ctx\n   */ _setBrushStyles: function(ctx) {\n        this.callSuper(\"_setBrushStyles\", ctx);\n        ctx.strokeStyle = this.getPattern(ctx);\n    },\n    /**\n   * Creates path\n   */ createPath: function(pathData) {\n        var path = this.callSuper(\"createPath\", pathData), topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);\n        path.stroke = new fabric.Pattern({\n            source: this.source || this.getPatternSrcFunction(),\n            offsetX: -topLeft.x,\n            offsetY: -topLeft.y\n        });\n        return path;\n    }\n});\n(function() {\n    var getPointer = fabric.util.getPointer, degreesToRadians = fabric.util.degreesToRadians, isTouchEvent = fabric.util.isTouchEvent;\n    /**\n   * Canvas class\n   * @class fabric.Canvas\n   * @extends fabric.StaticCanvas\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}\n   * @see {@link fabric.Canvas#initialize} for constructor definition\n   *\n   * @fires object:modified at the end of a transform or any change when statefull is true\n   * @fires object:rotating while an object is being rotated from the control\n   * @fires object:scaling while an object is being scaled by controls\n   * @fires object:moving while an object is being dragged\n   * @fires object:skewing while an object is being skewed from the controls\n   *\n   * @fires before:transform before a transform is is started\n   * @fires before:selection:cleared\n   * @fires selection:cleared\n   * @fires selection:updated\n   * @fires selection:created\n   *\n   * @fires path:created after a drawing operation ends and the path is added\n   * @fires mouse:down\n   * @fires mouse:move\n   * @fires mouse:up\n   * @fires mouse:down:before  on mouse down, before the inner fabric logic runs\n   * @fires mouse:move:before on mouse move, before the inner fabric logic runs\n   * @fires mouse:up:before on mouse up, before the inner fabric logic runs\n   * @fires mouse:over\n   * @fires mouse:out\n   * @fires mouse:dblclick whenever a native dbl click event fires on the canvas.\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop:before before drop event. same native event. This is added to handle edge cases\n   * @fires drop\n   * @fires after:render at the end of the render process, receives the context in the callback\n   * @fires before:render at start the render process, receives the context in the callback\n   *\n   */ fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(el, options) {\n            options || (options = {});\n            this.renderAndResetBound = this.renderAndReset.bind(this);\n            this.requestRenderAllBound = this.requestRenderAll.bind(this);\n            this._initStatic(el, options);\n            this._initInteractive();\n            this._createCacheCanvas();\n        },\n        /**\n     * When true, objects can be transformed by one side (unproportionally)\n     * when dragged on the corners that normally would not do that.\n     * @type Boolean\n     * @default\n     * @since fabric 4.0 // changed name and default value\n     */ uniformScaling: true,\n        /**\n     * Indicates which key switches uniform scaling.\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * totally wrong named. this sounds like `uniform scaling`\n     * if Canvas.uniformScaling is true, pressing this will set it to false\n     * and viceversa.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ uniScaleKey: \"shiftKey\",\n        /**\n     * When true, objects use center point as the origin of scale transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredScaling: false,\n        /**\n     * When true, objects use center point as the origin of rotate transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredRotation: false,\n        /**\n     * Indicates which key enable centered Transform\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ centeredKey: \"altKey\",\n        /**\n     * Indicates which key enable alternate action on corner\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ altActionKey: \"shiftKey\",\n        /**\n     * Indicates that canvas is interactive. This property should not be changed.\n     * @type Boolean\n     * @default\n     */ interactive: true,\n        /**\n     * Indicates whether group selection should be enabled\n     * @type Boolean\n     * @default\n     */ selection: true,\n        /**\n     * Indicates which key or keys enable multiple click selection\n     * Pass value as a string or array of strings\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or empty or containing any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.2\n     * @type String|Array\n     * @default\n     */ selectionKey: \"shiftKey\",\n        /**\n     * Indicates which key enable alternative selection\n     * in case of target overlapping with active object\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * For a series of reason that come from the general expectations on how\n     * things should work, this feature works only for preserveObjectStacking true.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.5\n     * @type null|String\n     * @default\n     */ altSelectionKey: null,\n        /**\n     * Color of selection\n     * @type String\n     * @default\n     */ selectionColor: \"rgba(100, 100, 255, 0.3)\",\n        /**\n     * Default dash array pattern\n     * If not empty the selection border is dashed\n     * @type Array\n     */ selectionDashArray: [],\n        /**\n     * Color of the border of selection (usually slightly darker than color of selection itself)\n     * @type String\n     * @default\n     */ selectionBorderColor: \"rgba(255, 255, 255, 0.3)\",\n        /**\n     * Width of a line used in object/group selection\n     * @type Number\n     * @default\n     */ selectionLineWidth: 1,\n        /**\n     * Select only shapes that are fully contained in the dragged selection rectangle.\n     * @type Boolean\n     * @default\n     */ selectionFullyContained: false,\n        /**\n     * Default cursor value used when hovering over an object on canvas\n     * @type String\n     * @default\n     */ hoverCursor: \"move\",\n        /**\n     * Default cursor value used when moving an object on canvas\n     * @type String\n     * @default\n     */ moveCursor: \"move\",\n        /**\n     * Default cursor value used for the entire canvas\n     * @type String\n     * @default\n     */ defaultCursor: \"default\",\n        /**\n     * Cursor value used during free drawing\n     * @type String\n     * @default\n     */ freeDrawingCursor: \"crosshair\",\n        /**\n     * Cursor value used for disabled elements ( corners with disabled action )\n     * @type String\n     * @since 2.0.0\n     * @default\n     */ notAllowedCursor: \"not-allowed\",\n        /**\n     * Default element class that's given to wrapper (div) element of canvas\n     * @type String\n     * @default\n     */ containerClass: \"canvas-container\",\n        /**\n     * When true, object detection happens on per-pixel basis rather than on per-bounding-box\n     * @type Boolean\n     * @default\n     */ perPixelTargetFind: false,\n        /**\n     * Number of pixels around target pixel to tolerate (consider active) during object detection\n     * @type Number\n     * @default\n     */ targetFindTolerance: 0,\n        /**\n     * When true, target detection is skipped. Target detection will return always undefined.\n     * click selection won't work anymore, events will fire with no targets.\n     * if something is selected before setting it to true, it will be deselected at the first click.\n     * area selection will still work. check the `selection` property too.\n     * if you deactivate both, you should look into staticCanvas.\n     * @type Boolean\n     * @default\n     */ skipTargetFind: false,\n        /**\n     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.\n     * After mousedown, mousemove creates a shape,\n     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}\n     * @type Boolean\n     * @default\n     */ isDrawingMode: false,\n        /**\n     * Indicates whether objects should remain in current stack position when selected.\n     * When false objects are brought to top and rendered as part of the selection group\n     * @type Boolean\n     * @default\n     */ preserveObjectStacking: false,\n        /**\n     * Indicates the angle that an object will lock to while rotating.\n     * @type Number\n     * @since 1.6.7\n     * @default\n     */ snapAngle: 0,\n        /**\n     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.\n     * When `null`, the snapThreshold will default to the snapAngle.\n     * @type null|Number\n     * @since 1.6.7\n     * @default\n     */ snapThreshold: null,\n        /**\n     * Indicates if the right click on canvas can output the context menu or not\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */ stopContextMenu: false,\n        /**\n     * Indicates if the canvas can fire right click events\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */ fireRightClick: false,\n        /**\n     * Indicates if the canvas can fire middle click events\n     * @type Boolean\n     * @since 1.7.8\n     * @default\n     */ fireMiddleClick: false,\n        /**\n     * Keep track of the subTargets for Mouse Events\n     * @type fabric.Object[]\n     */ targets: [],\n        /**\n     * When the option is enabled, PointerEvent is used instead of MouseEvent.\n     * @type Boolean\n     * @default\n     */ enablePointerEvents: false,\n        /**\n     * Keep track of the hovered target\n     * @type fabric.Object\n     * @private\n     */ _hoveredTarget: null,\n        /**\n     * hold the list of nested targets hovered\n     * @type fabric.Object[]\n     * @private\n     */ _hoveredTargets: [],\n        /**\n     * @private\n     */ _initInteractive: function() {\n            this._currentTransform = null;\n            this._groupSelector = null;\n            this._initWrapperElement();\n            this._createUpperCanvas();\n            this._initEventListeners();\n            this._initRetinaScaling();\n            this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);\n            this.calcOffset();\n        },\n        /**\n     * Divides objects in two groups, one to render immediately\n     * and one to render as activeGroup.\n     * @return {Array} objects to render immediately and pushes the other in the activeGroup.\n     */ _chooseObjectsToRender: function() {\n            var activeObjects = this.getActiveObjects(), object, objsToRender, activeGroupObjects;\n            if (activeObjects.length > 0 && !this.preserveObjectStacking) {\n                objsToRender = [];\n                activeGroupObjects = [];\n                for(var i = 0, length = this._objects.length; i < length; i++){\n                    object = this._objects[i];\n                    if (activeObjects.indexOf(object) === -1) {\n                        objsToRender.push(object);\n                    } else {\n                        activeGroupObjects.push(object);\n                    }\n                }\n                if (activeObjects.length > 1) {\n                    this._activeObject._objects = activeGroupObjects;\n                }\n                objsToRender.push.apply(objsToRender, activeGroupObjects);\n            } else {\n                objsToRender = this._objects;\n            }\n            return objsToRender;\n        },\n        /**\n     * Renders both the top canvas and the secondary container canvas.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAll: function() {\n            if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {\n                this.clearContext(this.contextTop);\n                this.contextTopDirty = false;\n            }\n            if (this.hasLostContext) {\n                this.renderTopLayer(this.contextTop);\n                this.hasLostContext = false;\n            }\n            var canvasToDrawOn = this.contextContainer;\n            this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());\n            return this;\n        },\n        renderTopLayer: function(ctx) {\n            ctx.save();\n            if (this.isDrawingMode && this._isCurrentlyDrawing) {\n                this.freeDrawingBrush && this.freeDrawingBrush._render();\n                this.contextTopDirty = true;\n            }\n            // we render the top context - last object\n            if (this.selection && this._groupSelector) {\n                this._drawSelection(ctx);\n                this.contextTopDirty = true;\n            }\n            ctx.restore();\n        },\n        /**\n     * Method to render only the top canvas.\n     * Also used to render the group selection box.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ renderTop: function() {\n            var ctx = this.contextTop;\n            this.clearContext(ctx);\n            this.renderTopLayer(ctx);\n            this.fire(\"after:render\");\n            return this;\n        },\n        /**\n     * @private\n     */ _normalizePointer: function(object, pointer) {\n            var m = object.calcTransformMatrix(), invertedM = fabric.util.invertTransform(m), vptPointer = this.restorePointerVpt(pointer);\n            return fabric.util.transformPoint(vptPointer, invertedM);\n        },\n        /**\n     * Returns true if object is transparent at a certain location\n     * @param {fabric.Object} target Object to check\n     * @param {Number} x Left coordinate\n     * @param {Number} y Top coordinate\n     * @return {Boolean}\n     */ isTargetTransparent: function(target, x, y) {\n            // in case the target is the activeObject, we cannot execute this optimization\n            // because we need to draw controls too.\n            if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {\n                var normalizedPointer = this._normalizePointer(target, {\n                    x: x,\n                    y: y\n                }), targetRelativeX = Math.max(target.cacheTranslationX + normalizedPointer.x * target.zoomX, 0), targetRelativeY = Math.max(target.cacheTranslationY + normalizedPointer.y * target.zoomY, 0);\n                var isTransparent = fabric.util.isTransparent(target._cacheContext, Math.round(targetRelativeX), Math.round(targetRelativeY), this.targetFindTolerance);\n                return isTransparent;\n            }\n            var ctx = this.contextCache, originalColor = target.selectionBackgroundColor, v = this.viewportTransform;\n            target.selectionBackgroundColor = \"\";\n            this.clearContext(ctx);\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            target.render(ctx);\n            ctx.restore();\n            target.selectionBackgroundColor = originalColor;\n            var isTransparent = fabric.util.isTransparent(ctx, x, y, this.targetFindTolerance);\n            return isTransparent;\n        },\n        /**\n     * takes an event and determines if selection key has been pressed\n     * @private\n     * @param {Event} e Event object\n     */ _isSelectionKeyPressed: function(e) {\n            var selectionKeyPressed = false;\n            if (Object.prototype.toString.call(this.selectionKey) === \"[object Array]\") {\n                selectionKeyPressed = !!this.selectionKey.find(function(key) {\n                    return e[key] === true;\n                });\n            } else {\n                selectionKeyPressed = e[this.selectionKey];\n            }\n            return selectionKeyPressed;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _shouldClearSelection: function(e, target) {\n            var activeObjects = this.getActiveObjects(), activeObject = this._activeObject;\n            return !target || target && activeObject && activeObjects.length > 1 && activeObjects.indexOf(target) === -1 && activeObject !== target && !this._isSelectionKeyPressed(e) || target && !target.evented || target && !target.selectable && activeObject && activeObject !== target;\n        },\n        /**\n     * centeredScaling from object can't override centeredScaling from canvas.\n     * this should be fixed, since object setting should take precedence over canvas.\n     * also this should be something that will be migrated in the control properties.\n     * as ability to define the origin of the transformation that the control provide.\n     * @private\n     * @param {fabric.Object} target\n     * @param {String} action\n     * @param {Boolean} altKey\n     */ _shouldCenterTransform: function(target, action, altKey) {\n            if (!target) {\n                return;\n            }\n            var centerTransform;\n            if (action === \"scale\" || action === \"scaleX\" || action === \"scaleY\" || action === \"resizing\") {\n                centerTransform = this.centeredScaling || target.centeredScaling;\n            } else if (action === \"rotate\") {\n                centerTransform = this.centeredRotation || target.centeredRotation;\n            }\n            return centerTransform ? !altKey : altKey;\n        },\n        /**\n     * should disappear before release 4.0\n     * @private\n     */ _getOriginFromCorner: function(target, corner) {\n            var origin = {\n                x: target.originX,\n                y: target.originY\n            };\n            if (corner === \"ml\" || corner === \"tl\" || corner === \"bl\") {\n                origin.x = \"right\";\n            } else if (corner === \"mr\" || corner === \"tr\" || corner === \"br\") {\n                origin.x = \"left\";\n            }\n            if (corner === \"tl\" || corner === \"mt\" || corner === \"tr\") {\n                origin.y = \"bottom\";\n            } else if (corner === \"bl\" || corner === \"mb\" || corner === \"br\") {\n                origin.y = \"top\";\n            }\n            return origin;\n        },\n        /**\n     * @private\n     * @param {Boolean} alreadySelected true if target is already selected\n     * @param {String} corner a string representing the corner ml, mr, tl ...\n     * @param {Event} e Event object\n     * @param {fabric.Object} [target] inserted back to help overriding. Unused\n     */ _getActionFromCorner: function(alreadySelected, corner, e, target) {\n            if (!corner || !alreadySelected) {\n                return \"drag\";\n            }\n            var control = target.controls[corner];\n            return control.getActionName(e, control, target);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _setupCurrentTransform: function(e, target, alreadySelected) {\n            if (!target) {\n                return;\n            }\n            var pointer = this.getPointer(e), corner = target.__corner, control = target.controls[corner], actionHandler = alreadySelected && corner ? control.getActionHandler(e, target, control) : fabric.controlsUtils.dragHandler, action = this._getActionFromCorner(alreadySelected, corner, e, target), origin = this._getOriginFromCorner(target, corner), altKey = e[this.centeredKey], transform = {\n                target: target,\n                action: action,\n                actionHandler: actionHandler,\n                corner: corner,\n                scaleX: target.scaleX,\n                scaleY: target.scaleY,\n                skewX: target.skewX,\n                skewY: target.skewY,\n                // used by transation\n                offsetX: pointer.x - target.left,\n                offsetY: pointer.y - target.top,\n                originX: origin.x,\n                originY: origin.y,\n                ex: pointer.x,\n                ey: pointer.y,\n                lastX: pointer.x,\n                lastY: pointer.y,\n                // unsure they are useful anymore.\n                // left: target.left,\n                // top: target.top,\n                theta: degreesToRadians(target.angle),\n                // end of unsure\n                width: target.width * target.scaleX,\n                shiftKey: e.shiftKey,\n                altKey: altKey,\n                original: fabric.util.saveObjectTransform(target)\n            };\n            if (this._shouldCenterTransform(target, action, altKey)) {\n                transform.originX = \"center\";\n                transform.originY = \"center\";\n            }\n            transform.original.originX = origin.x;\n            transform.original.originY = origin.y;\n            this._currentTransform = transform;\n            this._beforeTransform(e);\n        },\n        /**\n     * Set the cursor type of the canvas element\n     * @param {String} value Cursor type of the canvas element.\n     * @see http://www.w3.org/TR/css3-ui/#cursor\n     */ setCursor: function(value) {\n            this.upperCanvasEl.style.cursor = value;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx to draw the selection on\n     */ _drawSelection: function(ctx) {\n            var selector = this._groupSelector, viewportStart = new fabric.Point(selector.ex, selector.ey), start = fabric.util.transformPoint(viewportStart, this.viewportTransform), viewportExtent = new fabric.Point(selector.ex + selector.left, selector.ey + selector.top), extent = fabric.util.transformPoint(viewportExtent, this.viewportTransform), minX = Math.min(start.x, extent.x), minY = Math.min(start.y, extent.y), maxX = Math.max(start.x, extent.x), maxY = Math.max(start.y, extent.y), strokeOffset = this.selectionLineWidth / 2;\n            if (this.selectionColor) {\n                ctx.fillStyle = this.selectionColor;\n                ctx.fillRect(minX, minY, maxX - minX, maxY - minY);\n            }\n            if (!this.selectionLineWidth || !this.selectionBorderColor) {\n                return;\n            }\n            ctx.lineWidth = this.selectionLineWidth;\n            ctx.strokeStyle = this.selectionBorderColor;\n            minX += strokeOffset;\n            minY += strokeOffset;\n            maxX -= strokeOffset;\n            maxY -= strokeOffset;\n            // selection border\n            fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);\n            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);\n        },\n        /**\n     * Method that determines what object we are clicking on\n     * the skipGroup parameter is for internal use, is needed for shift+click action\n     * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target\n     * or the outside part of the corner.\n     * @param {Event} e mouse event\n     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through\n     * @return {fabric.Object} the target found\n     */ findTarget: function(e, skipGroup) {\n            if (this.skipTargetFind) {\n                return;\n            }\n            var ignoreZoom = true, pointer = this.getPointer(e, ignoreZoom), activeObject = this._activeObject, aObjects = this.getActiveObjects(), activeTarget, activeTargetSubs, isTouch = isTouchEvent(e), shouldLookForActive = aObjects.length > 1 && !skipGroup || aObjects.length === 1;\n            // first check current group (if one exists)\n            // active group does not check sub targets like normal groups.\n            // if active group just exits.\n            this.targets = [];\n            // if we hit the corner of an activeObject, let's return that.\n            if (shouldLookForActive && activeObject._findTargetCorner(pointer, isTouch)) {\n                return activeObject;\n            }\n            if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([\n                activeObject\n            ], pointer)) {\n                return activeObject;\n            }\n            if (aObjects.length === 1 && activeObject === this._searchPossibleTargets([\n                activeObject\n            ], pointer)) {\n                if (!this.preserveObjectStacking) {\n                    return activeObject;\n                } else {\n                    activeTarget = activeObject;\n                    activeTargetSubs = this.targets;\n                    this.targets = [];\n                }\n            }\n            var target = this._searchPossibleTargets(this._objects, pointer);\n            if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {\n                target = activeTarget;\n                this.targets = activeTargetSubs;\n            }\n            return target;\n        },\n        /**\n     * Checks point is inside the object.\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @param {fabric.Object} obj Object to test against\n     * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.\n     * @return {Boolean} true if point is contained within an area of given object\n     * @private\n     */ _checkTarget: function(pointer, obj, globalPointer) {\n            if (obj && obj.visible && obj.evented && // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html\n            // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html\n            obj.containsPoint(pointer)) {\n                if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {\n                    var isTransparent = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);\n                    if (!isTransparent) {\n                        return true;\n                    }\n                } else {\n                    return true;\n                }\n            }\n        },\n        /**\n     * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted\n     * @param {Array} [objects] objects array to look into\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @return {fabric.Object} object that contains pointer\n     * @private\n     */ _searchPossibleTargets: function(objects, pointer) {\n            // Cache all targets where their bounding box contains point.\n            var target, i = objects.length, subTarget;\n            // Do not check for currently grouped objects, since we check the parent group itself.\n            // until we call this function specifically to search inside the activeGroup\n            while(i--){\n                var objToCheck = objects[i];\n                var pointerToUse = objToCheck.group ? this._normalizePointer(objToCheck.group, pointer) : pointer;\n                if (this._checkTarget(pointerToUse, objToCheck, pointer)) {\n                    target = objects[i];\n                    if (target.subTargetCheck && target instanceof fabric.Group) {\n                        subTarget = this._searchPossibleTargets(target._objects, pointer);\n                        subTarget && this.targets.push(subTarget);\n                    }\n                    break;\n                }\n            }\n            return target;\n        },\n        /**\n     * Returns pointer coordinates without the effect of the viewport\n     * @param {Object} pointer with \"x\" and \"y\" number values\n     * @return {Object} object with \"x\" and \"y\" number values\n     */ restorePointerVpt: function(pointer) {\n            return fabric.util.transformPoint(pointer, fabric.util.invertTransform(this.viewportTransform));\n        },\n        /**\n     * Returns pointer coordinates relative to canvas.\n     * Can return coordinates with or without viewportTransform.\n     * ignoreZoom false gives back coordinates that represent\n     * the point clicked on canvas element.\n     * ignoreZoom true gives back coordinates after being processed\n     * by the viewportTransform ( sort of coordinates of what is displayed\n     * on the canvas where you are clicking.\n     * ignoreZoom true = HTMLElement coordinates relative to top,left\n     * ignoreZoom false, default = fabric space coordinates, the same used for shape position\n     * To interact with your shapes top and left you want to use ignoreZoom true\n     * most of the time, while ignoreZoom false will give you coordinates\n     * compatible with the object.oCoords system.\n     * of the time.\n     * @param {Event} e\n     * @param {Boolean} ignoreZoom\n     * @return {Object} object with \"x\" and \"y\" number values\n     */ getPointer: function(e, ignoreZoom) {\n            // return cached values if we are in the event processing chain\n            if (this._absolutePointer && !ignoreZoom) {\n                return this._absolutePointer;\n            }\n            if (this._pointer && ignoreZoom) {\n                return this._pointer;\n            }\n            var pointer = getPointer(e), upperCanvasEl = this.upperCanvasEl, bounds = upperCanvasEl.getBoundingClientRect(), boundsWidth = bounds.width || 0, boundsHeight = bounds.height || 0, cssScale;\n            if (!boundsWidth || !boundsHeight) {\n                if (\"top\" in bounds && \"bottom\" in bounds) {\n                    boundsHeight = Math.abs(bounds.top - bounds.bottom);\n                }\n                if (\"right\" in bounds && \"left\" in bounds) {\n                    boundsWidth = Math.abs(bounds.right - bounds.left);\n                }\n            }\n            this.calcOffset();\n            pointer.x = pointer.x - this._offset.left;\n            pointer.y = pointer.y - this._offset.top;\n            if (!ignoreZoom) {\n                pointer = this.restorePointerVpt(pointer);\n            }\n            var retinaScaling = this.getRetinaScaling();\n            if (retinaScaling !== 1) {\n                pointer.x /= retinaScaling;\n                pointer.y /= retinaScaling;\n            }\n            if (boundsWidth === 0 || boundsHeight === 0) {\n                // If bounds are not available (i.e. not visible), do not apply scale.\n                cssScale = {\n                    width: 1,\n                    height: 1\n                };\n            } else {\n                cssScale = {\n                    width: upperCanvasEl.width / boundsWidth,\n                    height: upperCanvasEl.height / boundsHeight\n                };\n            }\n            return {\n                x: pointer.x * cssScale.width,\n                y: pointer.y * cssScale.height\n            };\n        },\n        /**\n     * @private\n     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized\n     */ _createUpperCanvas: function() {\n            var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\\s*lower-canvas\\s*/, \"\"), lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;\n            // there is no need to create a new upperCanvas element if we have already one.\n            if (upperCanvasEl) {\n                upperCanvasEl.className = \"\";\n            } else {\n                upperCanvasEl = this._createCanvasElement();\n                this.upperCanvasEl = upperCanvasEl;\n            }\n            fabric.util.addClass(upperCanvasEl, \"upper-canvas \" + lowerCanvasClass);\n            this.wrapperEl.appendChild(upperCanvasEl);\n            this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);\n            this._applyCanvasStyle(upperCanvasEl);\n            this.contextTop = upperCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * @private\n     */ _createCacheCanvas: function() {\n            this.cacheCanvasEl = this._createCanvasElement();\n            this.cacheCanvasEl.setAttribute(\"width\", this.width);\n            this.cacheCanvasEl.setAttribute(\"height\", this.height);\n            this.contextCache = this.cacheCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * @private\n     */ _initWrapperElement: function() {\n            this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, \"div\", {\n                \"class\": this.containerClass\n            });\n            fabric.util.setStyle(this.wrapperEl, {\n                width: this.width + \"px\",\n                height: this.height + \"px\",\n                position: \"relative\"\n            });\n            fabric.util.makeElementUnselectable(this.wrapperEl);\n        },\n        /**\n     * @private\n     * @param {HTMLElement} element canvas element to apply styles on\n     */ _applyCanvasStyle: function(element) {\n            var width = this.width || element.width, height = this.height || element.height;\n            fabric.util.setStyle(element, {\n                position: \"absolute\",\n                width: width + \"px\",\n                height: height + \"px\",\n                left: 0,\n                top: 0,\n                \"touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\",\n                \"-ms-touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\"\n            });\n            element.width = width;\n            element.height = height;\n            fabric.util.makeElementUnselectable(element);\n        },\n        /**\n     * Copy the entire inline style from one element (fromEl) to another (toEl)\n     * @private\n     * @param {Element} fromEl Element style is copied from\n     * @param {Element} toEl Element copied style is applied to\n     */ _copyCanvasStyle: function(fromEl, toEl) {\n            toEl.style.cssText = fromEl.style.cssText;\n        },\n        /**\n     * Returns context of canvas where object selection is drawn\n     * @return {CanvasRenderingContext2D}\n     */ getSelectionContext: function() {\n            return this.contextTop;\n        },\n        /**\n     * Returns &lt;canvas> element on which object selection is drawn\n     * @return {HTMLCanvasElement}\n     */ getSelectionElement: function() {\n            return this.upperCanvasEl;\n        },\n        /**\n     * Returns currently active object\n     * @return {fabric.Object} active object\n     */ getActiveObject: function() {\n            return this._activeObject;\n        },\n        /**\n     * Returns an array with the current selected objects\n     * @return {fabric.Object} active object\n     */ getActiveObjects: function() {\n            var active = this._activeObject;\n            if (active) {\n                if (active.type === \"activeSelection\" && active._objects) {\n                    return active._objects.slice(0);\n                } else {\n                    return [\n                        active\n                    ];\n                }\n            }\n            return [];\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */ _onObjectRemoved: function(obj) {\n            // removing active object should fire \"selection:cleared\" events\n            if (obj === this._activeObject) {\n                this.fire(\"before:selection:cleared\", {\n                    target: obj\n                });\n                this._discardActiveObject();\n                this.fire(\"selection:cleared\", {\n                    target: obj\n                });\n                obj.fire(\"deselected\");\n            }\n            if (obj === this._hoveredTarget) {\n                this._hoveredTarget = null;\n                this._hoveredTargets = [];\n            }\n            this.callSuper(\"_onObjectRemoved\", obj);\n        },\n        /**\n     * @private\n     * Compares the old activeObject with the current one and fires correct events\n     * @param {fabric.Object} obj old activeObject\n     */ _fireSelectionEvents: function(oldObjects, e) {\n            var somethingChanged = false, objects = this.getActiveObjects(), added = [], removed = [];\n            oldObjects.forEach(function(oldObject) {\n                if (objects.indexOf(oldObject) === -1) {\n                    somethingChanged = true;\n                    oldObject.fire(\"deselected\", {\n                        e: e,\n                        target: oldObject\n                    });\n                    removed.push(oldObject);\n                }\n            });\n            objects.forEach(function(object) {\n                if (oldObjects.indexOf(object) === -1) {\n                    somethingChanged = true;\n                    object.fire(\"selected\", {\n                        e: e,\n                        target: object\n                    });\n                    added.push(object);\n                }\n            });\n            if (oldObjects.length > 0 && objects.length > 0) {\n                somethingChanged && this.fire(\"selection:updated\", {\n                    e: e,\n                    selected: added,\n                    deselected: removed\n                });\n            } else if (objects.length > 0) {\n                this.fire(\"selection:created\", {\n                    e: e,\n                    selected: added\n                });\n            } else if (oldObjects.length > 0) {\n                this.fire(\"selection:cleared\", {\n                    e: e,\n                    deselected: removed\n                });\n            }\n        },\n        /**\n     * Sets given object as the only active object on canvas\n     * @param {fabric.Object} object Object to set as an active one\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ setActiveObject: function(object, e) {\n            var currentActives = this.getActiveObjects();\n            this._setActiveObject(object, e);\n            this._fireSelectionEvents(currentActives, e);\n            return this;\n        },\n        /**\n     * This is a private method for now.\n     * This is supposed to be equivalent to setActiveObject but without firing\n     * any event. There is commitment to have this stay this way.\n     * This is the functional part of setActiveObject.\n     * @private\n     * @param {Object} object to set as active\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {Boolean} true if the selection happened\n     */ _setActiveObject: function(object, e) {\n            if (this._activeObject === object) {\n                return false;\n            }\n            if (!this._discardActiveObject(e, object)) {\n                return false;\n            }\n            if (object.onSelect({\n                e: e\n            })) {\n                return false;\n            }\n            this._activeObject = object;\n            return true;\n        },\n        /**\n     * This is a private method for now.\n     * This is supposed to be equivalent to discardActiveObject but without firing\n     * any events. There is commitment to have this stay this way.\n     * This is the functional part of discardActiveObject.\n     * @param {Event} [e] Event (passed along when firing \"object:deselected\")\n     * @param {Object} object to set as active\n     * @return {Boolean} true if the selection happened\n     * @private\n     */ _discardActiveObject: function(e, object) {\n            var obj = this._activeObject;\n            if (obj) {\n                // onDeselect return TRUE to cancel selection;\n                if (obj.onDeselect({\n                    e: e,\n                    object: object\n                })) {\n                    return false;\n                }\n                this._activeObject = null;\n            }\n            return true;\n        },\n        /**\n     * Discards currently active object and fire events. If the function is called by fabric\n     * as a consequence of a mouse event, the event is passed as a parameter and\n     * sent to the fire function for the custom events. When used as a method the\n     * e param does not have any application.\n     * @param {event} e\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ discardActiveObject: function(e) {\n            var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();\n            if (currentActives.length) {\n                this.fire(\"before:selection:cleared\", {\n                    target: activeObject,\n                    e: e\n                });\n            }\n            this._discardActiveObject(e);\n            this._fireSelectionEvents(currentActives, e);\n            return this;\n        },\n        /**\n     * Clears a canvas element and removes all event listeners\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ dispose: function() {\n            var wrapper = this.wrapperEl;\n            this.removeListeners();\n            wrapper.removeChild(this.upperCanvasEl);\n            wrapper.removeChild(this.lowerCanvasEl);\n            this.contextCache = null;\n            this.contextTop = null;\n            [\n                \"upperCanvasEl\",\n                \"cacheCanvasEl\"\n            ].forEach((function(element) {\n                fabric.util.cleanUpJsdomNode(this[element]);\n                this[element] = undefined;\n            }).bind(this));\n            if (wrapper.parentNode) {\n                wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);\n            }\n            delete this.wrapperEl;\n            fabric.StaticCanvas.prototype.dispose.call(this);\n            return this;\n        },\n        /**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clear: function() {\n            // this.discardActiveGroup();\n            this.discardActiveObject();\n            this.clearContext(this.contextTop);\n            return this.callSuper(\"clear\");\n        },\n        /**\n     * Draws objects' controls (borders/controls)\n     * @param {CanvasRenderingContext2D} ctx Context to render controls on\n     */ drawControls: function(ctx) {\n            var activeObject = this._activeObject;\n            if (activeObject) {\n                activeObject._renderControls(ctx);\n            }\n        },\n        /**\n     * @private\n     */ _toObject: function(instance, methodName, propertiesToInclude) {\n            //If the object is part of the current selection group, it should\n            //be transformed appropriately\n            //i.e. it should be serialised as it would appear if the selection group\n            //were to be destroyed.\n            var originalProperties = this._realizeGroupTransformOnObject(instance), object = this.callSuper(\"_toObject\", instance, methodName, propertiesToInclude);\n            //Undo the damage we did by changing all of its properties\n            this._unwindGroupTransformOnObject(instance, originalProperties);\n            return object;\n        },\n        /**\n     * Realises an object's group transformation on it\n     * @private\n     * @param {fabric.Object} [instance] the object to transform (gets mutated)\n     * @returns the original values of instance which were changed\n     */ _realizeGroupTransformOnObject: function(instance) {\n            if (instance.group && instance.group.type === \"activeSelection\" && this._activeObject === instance.group) {\n                var layoutProps = [\n                    \"angle\",\n                    \"flipX\",\n                    \"flipY\",\n                    \"left\",\n                    \"scaleX\",\n                    \"scaleY\",\n                    \"skewX\",\n                    \"skewY\",\n                    \"top\"\n                ];\n                //Copy all the positionally relevant properties across now\n                var originalValues = {};\n                layoutProps.forEach(function(prop) {\n                    originalValues[prop] = instance[prop];\n                });\n                fabric.util.addTransformToObject(instance, this._activeObject.calcOwnMatrix());\n                return originalValues;\n            } else {\n                return null;\n            }\n        },\n        /**\n     * Restores the changed properties of instance\n     * @private\n     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)\n     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject\n     */ _unwindGroupTransformOnObject: function(instance, originalValues) {\n            if (originalValues) {\n                instance.set(originalValues);\n            }\n        },\n        /**\n     * @private\n     */ _setSVGObject: function(markup, instance, reviver) {\n            //If the object is in a selection group, simulate what would happen to that\n            //object when the group is deselected\n            var originalProperties = this._realizeGroupTransformOnObject(instance);\n            this.callSuper(\"_setSVGObject\", markup, instance, reviver);\n            this._unwindGroupTransformOnObject(instance, originalProperties);\n        },\n        setViewportTransform: function(vpt) {\n            if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {\n                this._activeObject.clearContextTop();\n            }\n            fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);\n        }\n    });\n    // copying static properties manually to work around Opera's bug,\n    // where \"prototype\" property is enumerable and overrides existing prototype\n    for(var prop in fabric.StaticCanvas){\n        if (prop !== \"prototype\") {\n            fabric.Canvas[prop] = fabric.StaticCanvas[prop];\n        }\n    }\n})();\n(function() {\n    var addListener = fabric.util.addListener, removeListener = fabric.util.removeListener, RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1, addEventOptions = {\n        passive: false\n    };\n    function checkClick(e, value) {\n        return e.button && e.button === value - 1;\n    }\n    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * Contains the id of the touch event that owns the fabric transform\n     * @type Number\n     * @private\n     */ mainTouchId: null,\n        /**\n     * Adds mouse listeners to canvas\n     * @private\n     */ _initEventListeners: function() {\n            // in case we initialized the class twice. This should not happen normally\n            // but in some kind of applications where the canvas element may be changed\n            // this is a workaround to having double listeners.\n            this.removeListeners();\n            this._bindEvents();\n            this.addOrRemove(addListener, \"add\");\n        },\n        /**\n     * return an event prefix pointer or mouse.\n     * @private\n     */ _getEventPrefix: function() {\n            return this.enablePointerEvents ? \"pointer\" : \"mouse\";\n        },\n        addOrRemove: function(functor, eventjsFunctor) {\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            functor(fabric.window, \"resize\", this._onResize);\n            functor(canvasElement, eventTypePrefix + \"down\", this._onMouseDown);\n            functor(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            functor(canvasElement, eventTypePrefix + \"out\", this._onMouseOut);\n            functor(canvasElement, eventTypePrefix + \"enter\", this._onMouseEnter);\n            functor(canvasElement, \"wheel\", this._onMouseWheel);\n            functor(canvasElement, \"contextmenu\", this._onContextMenu);\n            functor(canvasElement, \"dblclick\", this._onDoubleClick);\n            functor(canvasElement, \"dragover\", this._onDragOver);\n            functor(canvasElement, \"dragenter\", this._onDragEnter);\n            functor(canvasElement, \"dragleave\", this._onDragLeave);\n            functor(canvasElement, \"drop\", this._onDrop);\n            if (!this.enablePointerEvents) {\n                functor(canvasElement, \"touchstart\", this._onTouchStart, addEventOptions);\n            }\n            if (typeof eventjs !== \"undefined\" && eventjsFunctor in eventjs) {\n                eventjs[eventjsFunctor](canvasElement, \"gesture\", this._onGesture);\n                eventjs[eventjsFunctor](canvasElement, \"drag\", this._onDrag);\n                eventjs[eventjsFunctor](canvasElement, \"orientation\", this._onOrientationChange);\n                eventjs[eventjsFunctor](canvasElement, \"shake\", this._onShake);\n                eventjs[eventjsFunctor](canvasElement, \"longpress\", this._onLongPress);\n            }\n        },\n        /**\n     * Removes all event listeners\n     */ removeListeners: function() {\n            this.addOrRemove(removeListener, \"remove\");\n            // if you dispose on a mouseDown, before mouse up, you need to clean document to...\n            var eventTypePrefix = this._getEventPrefix();\n            removeListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n            removeListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            removeListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            removeListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n        },\n        /**\n     * @private\n     */ _bindEvents: function() {\n            if (this.eventsBound) {\n                // for any reason we pass here twice we do not want to bind events twice.\n                return;\n            }\n            this._onMouseDown = this._onMouseDown.bind(this);\n            this._onTouchStart = this._onTouchStart.bind(this);\n            this._onMouseMove = this._onMouseMove.bind(this);\n            this._onMouseUp = this._onMouseUp.bind(this);\n            this._onTouchEnd = this._onTouchEnd.bind(this);\n            this._onResize = this._onResize.bind(this);\n            this._onGesture = this._onGesture.bind(this);\n            this._onDrag = this._onDrag.bind(this);\n            this._onShake = this._onShake.bind(this);\n            this._onLongPress = this._onLongPress.bind(this);\n            this._onOrientationChange = this._onOrientationChange.bind(this);\n            this._onMouseWheel = this._onMouseWheel.bind(this);\n            this._onMouseOut = this._onMouseOut.bind(this);\n            this._onMouseEnter = this._onMouseEnter.bind(this);\n            this._onContextMenu = this._onContextMenu.bind(this);\n            this._onDoubleClick = this._onDoubleClick.bind(this);\n            this._onDragOver = this._onDragOver.bind(this);\n            this._onDragEnter = this._simpleEventHandler.bind(this, \"dragenter\");\n            this._onDragLeave = this._simpleEventHandler.bind(this, \"dragleave\");\n            this._onDrop = this._onDrop.bind(this);\n            this.eventsBound = true;\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js gesture\n     * @param {Event} [self] Inner Event object\n     */ _onGesture: function(e, self) {\n            this.__onTransformGesture && this.__onTransformGesture(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js drag\n     * @param {Event} [self] Inner Event object\n     */ _onDrag: function(e, self) {\n            this.__onDrag && this.__onDrag(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on wheel event\n     */ _onMouseWheel: function(e) {\n            this.__onMouseWheel(e);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseOut: function(e) {\n            var target = this._hoveredTarget;\n            this.fire(\"mouse:out\", {\n                target: target,\n                e: e\n            });\n            this._hoveredTarget = null;\n            target && target.fire(\"mouseout\", {\n                e: e\n            });\n            var _this = this;\n            this._hoveredTargets.forEach(function(_target) {\n                _this.fire(\"mouse:out\", {\n                    target: target,\n                    e: e\n                });\n                _target && target.fire(\"mouseout\", {\n                    e: e\n                });\n            });\n            this._hoveredTargets = [];\n            if (this._iTextInstances) {\n                this._iTextInstances.forEach(function(obj) {\n                    if (obj.isEditing) {\n                        obj.hiddenTextarea.focus();\n                    }\n                });\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseenter\n     */ _onMouseEnter: function(e) {\n            // This find target and consequent 'mouse:over' is used to\n            // clear old instances on hovered target.\n            // calling findTarget has the side effect of killing target.__corner.\n            // as a short term fix we are not firing this if we are currently transforming.\n            // as a long term fix we need to separate the action of finding a target with the\n            // side effects we added to it.\n            if (!this._currentTransform && !this.findTarget(e)) {\n                this.fire(\"mouse:over\", {\n                    target: null,\n                    e: e\n                });\n                this._hoveredTarget = null;\n                this._hoveredTargets = [];\n            }\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js orientation change\n     * @param {Event} [self] Inner Event object\n     */ _onOrientationChange: function(e, self) {\n            this.__onOrientationChange && this.__onOrientationChange(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */ _onShake: function(e, self) {\n            this.__onShake && this.__onShake(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */ _onLongPress: function(e, self) {\n            this.__onLongPress && this.__onLongPress(e, self);\n        },\n        /**\n     * prevent default to allow drop event to be fired\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     */ _onDragOver: function(e) {\n            e.preventDefault();\n            var target = this._simpleEventHandler(\"dragover\", e);\n            this._fireEnterLeaveEvents(target, e);\n        },\n        /**\n     * `drop:before` is a an event that allow you to schedule logic\n     * before the `drop` event. Prefer `drop` event always, but if you need\n     * to run some drop-disabling logic on an event, since there is no way\n     * to handle event handlers ordering, use `drop:before`\n     * @param {Event} e\n     */ _onDrop: function(e) {\n            this._simpleEventHandler(\"drop:before\", e);\n            return this._simpleEventHandler(\"drop\", e);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onContextMenu: function(e) {\n            if (this.stopContextMenu) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n            return false;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onDoubleClick: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"dblclick\");\n            this._resetTransformEventData(e);\n        },\n        /**\n     * Return a the id of an event.\n     * returns either the pointerId or the identifier or 0 for the mouse event\n     * @private\n     * @param {Event} evt Event object\n     */ getPointerId: function(evt) {\n            var changedTouches = evt.changedTouches;\n            if (changedTouches) {\n                return changedTouches[0] && changedTouches[0].identifier;\n            }\n            if (this.enablePointerEvents) {\n                return evt.pointerId;\n            }\n            return -1;\n        },\n        /**\n     * Determines if an event has the id of the event that is considered main\n     * @private\n     * @param {evt} event Event object\n     */ _isMainEvent: function(evt) {\n            if (evt.isPrimary === true) {\n                return true;\n            }\n            if (evt.isPrimary === false) {\n                return false;\n            }\n            if (evt.type === \"touchend\" && evt.touches.length === 0) {\n                return true;\n            }\n            if (evt.changedTouches) {\n                return evt.changedTouches[0].identifier === this.mainTouchId;\n            }\n            return true;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onTouchStart: function(e) {\n            e.preventDefault();\n            if (this.mainTouchId === null) {\n                this.mainTouchId = this.getPointerId(e);\n            }\n            this.__onMouseDown(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            addListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            addListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n            // Unbind mousedown to prevent double triggers from touch devices\n            removeListener(canvasElement, eventTypePrefix + \"down\", this._onMouseDown);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseDown: function(e) {\n            this.__onMouseDown(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            removeListener(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            addListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n            addListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onTouchEnd: function(e) {\n            if (e.touches.length > 0) {\n                // if there are still touches stop here\n                return;\n            }\n            this.__onMouseUp(e);\n            this._resetTransformEventData();\n            this.mainTouchId = null;\n            var eventTypePrefix = this._getEventPrefix();\n            removeListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            removeListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n            var _this = this;\n            if (this._willAddMouseDown) {\n                clearTimeout(this._willAddMouseDown);\n            }\n            this._willAddMouseDown = setTimeout(function() {\n                // Wait 400ms before rebinding mousedown to prevent double triggers\n                // from touch devices\n                addListener(_this.upperCanvasEl, eventTypePrefix + \"down\", _this._onMouseDown);\n                _this._willAddMouseDown = 0;\n            }, 400);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ _onMouseUp: function(e) {\n            this.__onMouseUp(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            if (this._isMainEvent(e)) {\n                removeListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n                removeListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n                addListener(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ _onMouseMove: function(e) {\n            !this.allowTouchScrolling && e.preventDefault && e.preventDefault();\n            this.__onMouseMove(e);\n        },\n        /**\n     * @private\n     */ _onResize: function() {\n            this.calcOffset();\n        },\n        /**\n     * Decides whether the canvas should be redrawn in mouseup and mousedown events.\n     * @private\n     * @param {Object} target\n     */ _shouldRender: function(target) {\n            var activeObject = this._activeObject;\n            if (!!activeObject !== !!target || activeObject && target && activeObject !== target) {\n                // this covers: switch of target, from target to no target, selection of target\n                // multiSelection with key and mouse\n                return true;\n            } else if (activeObject && activeObject.isEditing) {\n                // if we mouse up/down over a editing textbox a cursor change,\n                // there is no need to re render\n                return false;\n            }\n            return false;\n        },\n        /**\n     * Method that defines the actions when mouse is released on canvas.\n     * The method resets the currentTransform parameters, store the image corner\n     * position in the image object and render the canvas on top.\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ __onMouseUp: function(e) {\n            var target, transform = this._currentTransform, groupSelector = this._groupSelector, shouldRender = false, isClick = !groupSelector || groupSelector.left === 0 && groupSelector.top === 0;\n            this._cacheTransformEventData(e);\n            target = this._target;\n            this._handleEvent(e, \"up:before\");\n            // if right/middle click just fire events and return\n            // target undefined will make the _handleEvent search the target\n            if (checkClick(e, RIGHT_CLICK)) {\n                if (this.fireRightClick) {\n                    this._handleEvent(e, \"up\", RIGHT_CLICK, isClick);\n                }\n                return;\n            }\n            if (checkClick(e, MIDDLE_CLICK)) {\n                if (this.fireMiddleClick) {\n                    this._handleEvent(e, \"up\", MIDDLE_CLICK, isClick);\n                }\n                this._resetTransformEventData();\n                return;\n            }\n            if (this.isDrawingMode && this._isCurrentlyDrawing) {\n                this._onMouseUpInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            if (transform) {\n                this._finalizeCurrentTransform(e);\n                shouldRender = transform.actionPerformed;\n            }\n            if (!isClick) {\n                var targetWasActive = target === this._activeObject;\n                this._maybeGroupObjects(e);\n                if (!shouldRender) {\n                    shouldRender = this._shouldRender(target) || !targetWasActive && target === this._activeObject;\n                }\n            }\n            var corner, pointer;\n            if (target) {\n                corner = target._findTargetCorner(this.getPointer(e, true), fabric.util.isTouchEvent(e));\n                if (target.selectable && target !== this._activeObject && target.activeOn === \"up\") {\n                    this.setActiveObject(target, e);\n                    shouldRender = true;\n                } else {\n                    var control = target.controls[corner], mouseUpHandler = control && control.getMouseUpHandler(e, target, control);\n                    if (mouseUpHandler) {\n                        pointer = this.getPointer(e);\n                        mouseUpHandler(e, transform, pointer.x, pointer.y);\n                    }\n                }\n                target.isMoving = false;\n            }\n            // if we are ending up a transform on a different control or a new object\n            // fire the original mouse up from the corner that started the transform\n            if (transform && (transform.target !== target || transform.corner !== corner)) {\n                var originalControl = transform.target && transform.target.controls[transform.corner], originalMouseUpHandler = originalControl && originalControl.getMouseUpHandler(e, target, control);\n                pointer = pointer || this.getPointer(e);\n                originalMouseUpHandler && originalMouseUpHandler(e, transform, pointer.x, pointer.y);\n            }\n            this._setCursorFromEvent(e, target);\n            this._handleEvent(e, \"up\", LEFT_CLICK, isClick);\n            this._groupSelector = null;\n            this._currentTransform = null;\n            // reset the target information about which corner is selected\n            target && (target.__corner = 0);\n            if (shouldRender) {\n                this.requestRenderAll();\n            } else if (!isClick) {\n                this.renderTop();\n            }\n        },\n        /**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @return {Fabric.Object} target return the the target found, for internal reasons.\n     */ _simpleEventHandler: function(eventType, e) {\n            var target = this.findTarget(e), targets = this.targets, options = {\n                e: e,\n                target: target,\n                subTargets: targets\n            };\n            this.fire(eventType, options);\n            target && target.fire(eventType, options);\n            if (!targets) {\n                return target;\n            }\n            for(var i = 0; i < targets.length; i++){\n                targets[i].fire(eventType, options);\n            }\n            return target;\n        },\n        /**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @param {fabric.Object} targetObj receiving event\n     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right\n     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.\n     */ _handleEvent: function(e, eventType, button, isClick) {\n            var target = this._target, targets = this.targets || [], options = {\n                e: e,\n                target: target,\n                subTargets: targets,\n                button: button || LEFT_CLICK,\n                isClick: isClick || false,\n                pointer: this._pointer,\n                absolutePointer: this._absolutePointer,\n                transform: this._currentTransform\n            };\n            if (eventType === \"up\") {\n                options.currentTarget = this.findTarget(e);\n                options.currentSubTargets = this.targets;\n            }\n            this.fire(\"mouse:\" + eventType, options);\n            target && target.fire(\"mouse\" + eventType, options);\n            for(var i = 0; i < targets.length; i++){\n                targets[i].fire(\"mouse\" + eventType, options);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event\n     */ _finalizeCurrentTransform: function(e) {\n            var transform = this._currentTransform, target = transform.target, options = {\n                e: e,\n                target: target,\n                transform: transform,\n                action: transform.action\n            };\n            if (target._scaling) {\n                target._scaling = false;\n            }\n            target.setCoords();\n            if (transform.actionPerformed || this.stateful && target.hasStateChanged()) {\n                this._fire(\"modified\", options);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseDownInDrawingMode: function(e) {\n            this._isCurrentlyDrawing = true;\n            if (this.getActiveObject()) {\n                this.discardActiveObject(e).requestRenderAll();\n            }\n            var pointer = this.getPointer(e);\n            this.freeDrawingBrush.onMouseDown(pointer, {\n                e: e,\n                pointer: pointer\n            });\n            this._handleEvent(e, \"down\");\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ _onMouseMoveInDrawingMode: function(e) {\n            if (this._isCurrentlyDrawing) {\n                var pointer = this.getPointer(e);\n                this.freeDrawingBrush.onMouseMove(pointer, {\n                    e: e,\n                    pointer: pointer\n                });\n            }\n            this.setCursor(this.freeDrawingCursor);\n            this._handleEvent(e, \"move\");\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ _onMouseUpInDrawingMode: function(e) {\n            var pointer = this.getPointer(e);\n            this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({\n                e: e,\n                pointer: pointer\n            });\n            this._handleEvent(e, \"up\");\n        },\n        /**\n     * Method that defines the actions when mouse is clicked on canvas.\n     * The method inits the currentTransform parameters and renders all the\n     * canvas so the current image can be placed on the top canvas and the rest\n     * in on the container one.\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ __onMouseDown: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"down:before\");\n            var target = this._target;\n            // if right click just fire events\n            if (checkClick(e, RIGHT_CLICK)) {\n                if (this.fireRightClick) {\n                    this._handleEvent(e, \"down\", RIGHT_CLICK);\n                }\n                return;\n            }\n            if (checkClick(e, MIDDLE_CLICK)) {\n                if (this.fireMiddleClick) {\n                    this._handleEvent(e, \"down\", MIDDLE_CLICK);\n                }\n                return;\n            }\n            if (this.isDrawingMode) {\n                this._onMouseDownInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            // ignore if some object is being transformed at this moment\n            if (this._currentTransform) {\n                return;\n            }\n            var pointer = this._pointer;\n            // save pointer for check in __onMouseUp event\n            this._previousPointer = pointer;\n            var shouldRender = this._shouldRender(target), shouldGroup = this._shouldGroup(e, target);\n            if (this._shouldClearSelection(e, target)) {\n                this.discardActiveObject(e);\n            } else if (shouldGroup) {\n                this._handleGrouping(e, target);\n                target = this._activeObject;\n            }\n            if (this.selection && (!target || !target.selectable && !target.isEditing && target !== this._activeObject)) {\n                this._groupSelector = {\n                    ex: this._absolutePointer.x,\n                    ey: this._absolutePointer.y,\n                    top: 0,\n                    left: 0\n                };\n            }\n            if (target) {\n                var alreadySelected = target === this._activeObject;\n                if (target.selectable && target.activeOn === \"down\") {\n                    this.setActiveObject(target, e);\n                }\n                var corner = target._findTargetCorner(this.getPointer(e, true), fabric.util.isTouchEvent(e));\n                target.__corner = corner;\n                if (target === this._activeObject && (corner || !shouldGroup)) {\n                    this._setupCurrentTransform(e, target, alreadySelected);\n                    var control = target.controls[corner], pointer = this.getPointer(e), mouseDownHandler = control && control.getMouseDownHandler(e, target, control);\n                    if (mouseDownHandler) {\n                        mouseDownHandler(e, this._currentTransform, pointer.x, pointer.y);\n                    }\n                }\n            }\n            this._handleEvent(e, \"down\");\n            // we must renderAll so that we update the visuals\n            (shouldRender || shouldGroup) && this.requestRenderAll();\n        },\n        /**\n     * reset cache form common information needed during event processing\n     * @private\n     */ _resetTransformEventData: function() {\n            this._target = null;\n            this._pointer = null;\n            this._absolutePointer = null;\n        },\n        /**\n     * Cache common information needed during event processing\n     * @private\n     * @param {Event} e Event object fired on event\n     */ _cacheTransformEventData: function(e) {\n            // reset in order to avoid stale caching\n            this._resetTransformEventData();\n            this._pointer = this.getPointer(e, true);\n            this._absolutePointer = this.restorePointerVpt(this._pointer);\n            this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;\n        },\n        /**\n     * @private\n     */ _beforeTransform: function(e) {\n            var t = this._currentTransform;\n            this.stateful && t.target.saveState();\n            this.fire(\"before:transform\", {\n                e: e,\n                transform: t\n            });\n        },\n        /**\n     * Method that defines the actions when mouse is hovering the canvas.\n     * The currentTransform parameter will define whether the user is rotating/scaling/translating\n     * an image or neither of them (only hovering). A group selection is also possible and would cancel\n     * all any other type of action.\n     * In case of an image transformation only the top canvas will be rendered.\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ __onMouseMove: function(e) {\n            this._handleEvent(e, \"move:before\");\n            this._cacheTransformEventData(e);\n            var target, pointer;\n            if (this.isDrawingMode) {\n                this._onMouseMoveInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            var groupSelector = this._groupSelector;\n            // We initially clicked in an empty area, so we draw a box for multiple selection\n            if (groupSelector) {\n                pointer = this._absolutePointer;\n                groupSelector.left = pointer.x - groupSelector.ex;\n                groupSelector.top = pointer.y - groupSelector.ey;\n                this.renderTop();\n            } else if (!this._currentTransform) {\n                target = this.findTarget(e) || null;\n                this._setCursorFromEvent(e, target);\n                this._fireOverOutEvents(target, e);\n            } else {\n                this._transformObject(e);\n            }\n            this._handleEvent(e, \"move\");\n            this._resetTransformEventData();\n        },\n        /**\n     * Manage the mouseout, mouseover events for the fabric object on the canvas\n     * @param {Fabric.Object} target the target where the target from the mousemove event\n     * @param {Event} e Event object fired on mousemove\n     * @private\n     */ _fireOverOutEvents: function(target, e) {\n            var _hoveredTarget = this._hoveredTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);\n            this.fireSyntheticInOutEvents(target, e, {\n                oldTarget: _hoveredTarget,\n                evtOut: \"mouseout\",\n                canvasEvtOut: \"mouse:out\",\n                evtIn: \"mouseover\",\n                canvasEvtIn: \"mouse:over\"\n            });\n            for(var i = 0; i < length; i++){\n                this.fireSyntheticInOutEvents(targets[i], e, {\n                    oldTarget: _hoveredTargets[i],\n                    evtOut: \"mouseout\",\n                    evtIn: \"mouseover\"\n                });\n            }\n            this._hoveredTarget = target;\n            this._hoveredTargets = this.targets.concat();\n        },\n        /**\n     * Manage the dragEnter, dragLeave events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the onDrag event\n     * @param {Event} e Event object fired on ondrag\n     * @private\n     */ _fireEnterLeaveEvents: function(target, e) {\n            var _draggedoverTarget = this._draggedoverTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);\n            this.fireSyntheticInOutEvents(target, e, {\n                oldTarget: _draggedoverTarget,\n                evtOut: \"dragleave\",\n                evtIn: \"dragenter\"\n            });\n            for(var i = 0; i < length; i++){\n                this.fireSyntheticInOutEvents(targets[i], e, {\n                    oldTarget: _hoveredTargets[i],\n                    evtOut: \"dragleave\",\n                    evtIn: \"dragenter\"\n                });\n            }\n            this._draggedoverTarget = target;\n        },\n        /**\n     * Manage the synthetic in/out events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the supported events\n     * @param {Event} e Event object fired\n     * @param {Object} config configuration for the function to work\n     * @param {String} config.targetName property on the canvas where the old target is stored\n     * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out\n     * @param {String} config.evtOut name of the event to fire for out\n     * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in\n     * @param {String} config.evtIn name of the event to fire for in\n     * @private\n     */ fireSyntheticInOutEvents: function(target, e, config) {\n            var inOpt, outOpt, oldTarget = config.oldTarget, outFires, inFires, targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;\n            if (targetChanged) {\n                inOpt = {\n                    e: e,\n                    target: target,\n                    previousTarget: oldTarget\n                };\n                outOpt = {\n                    e: e,\n                    target: oldTarget,\n                    nextTarget: target\n                };\n            }\n            inFires = target && targetChanged;\n            outFires = oldTarget && targetChanged;\n            if (outFires) {\n                canvasEvtOut && this.fire(canvasEvtOut, outOpt);\n                oldTarget.fire(config.evtOut, outOpt);\n            }\n            if (inFires) {\n                canvasEvtIn && this.fire(canvasEvtIn, inOpt);\n                target.fire(config.evtIn, inOpt);\n            }\n        },\n        /**\n     * Method that defines actions when an Event Mouse Wheel\n     * @param {Event} e Event object fired on mouseup\n     */ __onMouseWheel: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"wheel\");\n            this._resetTransformEventData();\n        },\n        /**\n     * @private\n     * @param {Event} e Event fired on mousemove\n     */ _transformObject: function(e) {\n            var pointer = this.getPointer(e), transform = this._currentTransform;\n            transform.reset = false;\n            transform.shiftKey = e.shiftKey;\n            transform.altKey = e[this.centeredKey];\n            this._performTransformAction(e, transform, pointer);\n            transform.actionPerformed && this.requestRenderAll();\n        },\n        /**\n     * @private\n     */ _performTransformAction: function(e, transform, pointer) {\n            var x = pointer.x, y = pointer.y, action = transform.action, actionPerformed = false, actionHandler = transform.actionHandler;\n            // this object could be created from the function in the control handlers\n            if (actionHandler) {\n                actionPerformed = actionHandler(e, transform, x, y);\n            }\n            if (action === \"drag\" && actionPerformed) {\n                transform.target.isMoving = true;\n                this.setCursor(transform.target.moveCursor || this.moveCursor);\n            }\n            transform.actionPerformed = transform.actionPerformed || actionPerformed;\n        },\n        /**\n     * @private\n     */ _fire: fabric.controlsUtils.fireEvent,\n        /**\n     * Sets the cursor depending on where the canvas is being hovered.\n     * Note: very buggy in Opera\n     * @param {Event} e Event object\n     * @param {Object} target Object that the mouse is hovering, if so.\n     */ _setCursorFromEvent: function(e, target) {\n            if (!target) {\n                this.setCursor(this.defaultCursor);\n                return false;\n            }\n            var hoverCursor = target.hoverCursor || this.hoverCursor, activeSelection = this._activeObject && this._activeObject.type === \"activeSelection\" ? this._activeObject : null, // only show proper corner when group selection is not active\n            corner = (!activeSelection || !activeSelection.contains(target)) && target._findTargetCorner(this.getPointer(e, true));\n            if (!corner) {\n                if (target.subTargetCheck) {\n                    // hoverCursor should come from top-most subTarget,\n                    // so we walk the array backwards\n                    this.targets.concat().reverse().map(function(_target) {\n                        hoverCursor = _target.hoverCursor || hoverCursor;\n                    });\n                }\n                this.setCursor(hoverCursor);\n            } else {\n                this.setCursor(this.getCornerCursor(corner, target, e));\n            }\n        },\n        /**\n     * @private\n     */ getCornerCursor: function(corner, target, e) {\n            var control = target.controls[corner];\n            return control.cursorStyleHandler(e, control, target);\n        }\n    });\n})();\n(function() {\n    var min = Math.min, max = Math.max;\n    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     * @return {Boolean}\n     */ _shouldGroup: function(e, target) {\n            var activeObject = this._activeObject;\n            return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection && (activeObject !== target || activeObject.type === \"activeSelection\") && !target.onSelect({\n                e: e\n            });\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _handleGrouping: function(e, target) {\n            var activeObject = this._activeObject;\n            // avoid multi select when shift click on a corner\n            if (activeObject.__corner) {\n                return;\n            }\n            if (target === activeObject) {\n                // if it's a group, find target again, using activeGroup objects\n                target = this.findTarget(e, true);\n                // if even object is not found or we are on activeObjectCorner, bail out\n                if (!target || !target.selectable) {\n                    return;\n                }\n            }\n            if (activeObject && activeObject.type === \"activeSelection\") {\n                this._updateActiveSelection(target, e);\n            } else {\n                this._createActiveSelection(target, e);\n            }\n        },\n        /**\n     * @private\n     */ _updateActiveSelection: function(target, e) {\n            var activeSelection = this._activeObject, currentActiveObjects = activeSelection._objects.slice(0);\n            if (activeSelection.contains(target)) {\n                activeSelection.removeWithUpdate(target);\n                this._hoveredTarget = target;\n                this._hoveredTargets = this.targets.concat();\n                if (activeSelection.size() === 1) {\n                    // activate last remaining object\n                    this._setActiveObject(activeSelection.item(0), e);\n                }\n            } else {\n                activeSelection.addWithUpdate(target);\n                this._hoveredTarget = activeSelection;\n                this._hoveredTargets = this.targets.concat();\n            }\n            this._fireSelectionEvents(currentActiveObjects, e);\n        },\n        /**\n     * @private\n     */ _createActiveSelection: function(target, e) {\n            var currentActives = this.getActiveObjects(), group = this._createGroup(target);\n            this._hoveredTarget = group;\n            // ISSUE 4115: should we consider subTargets here?\n            // this._hoveredTargets = [];\n            // this._hoveredTargets = this.targets.concat();\n            this._setActiveObject(group, e);\n            this._fireSelectionEvents(currentActives, e);\n        },\n        /**\n     * @private\n     * @param {Object} target\n     */ _createGroup: function(target) {\n            var objects = this._objects, isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target), groupObjects = isActiveLower ? [\n                this._activeObject,\n                target\n            ] : [\n                target,\n                this._activeObject\n            ];\n            this._activeObject.isEditing && this._activeObject.exitEditing();\n            return new fabric.ActiveSelection(groupObjects, {\n                canvas: this\n            });\n        },\n        /**\n     * @private\n     * @param {Event} e mouse event\n     */ _groupSelectedObjects: function(e) {\n            var group = this._collectObjects(e), aGroup;\n            // do not create group for 1 element only\n            if (group.length === 1) {\n                this.setActiveObject(group[0], e);\n            } else if (group.length > 1) {\n                aGroup = new fabric.ActiveSelection(group.reverse(), {\n                    canvas: this\n                });\n                this.setActiveObject(aGroup, e);\n            }\n        },\n        /**\n     * @private\n     */ _collectObjects: function(e) {\n            var group = [], currentObject, x1 = this._groupSelector.ex, y1 = this._groupSelector.ey, x2 = x1 + this._groupSelector.left, y2 = y1 + this._groupSelector.top, selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)), selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)), allowIntersect = !this.selectionFullyContained, isClick = x1 === x2 && y1 === y2;\n            // we iterate reverse order to collect top first in case of click.\n            for(var i = this._objects.length; i--;){\n                currentObject = this._objects[i];\n                if (!currentObject || !currentObject.selectable || !currentObject.visible) {\n                    continue;\n                }\n                if (allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2, true) || currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2, true) || allowIntersect && currentObject.containsPoint(selectionX1Y1, null, true) || allowIntersect && currentObject.containsPoint(selectionX2Y2, null, true)) {\n                    group.push(currentObject);\n                    // only add one object if it's a click\n                    if (isClick) {\n                        break;\n                    }\n                }\n            }\n            if (group.length > 1) {\n                group = group.filter(function(object) {\n                    return !object.onSelect({\n                        e: e\n                    });\n                });\n            }\n            return group;\n        },\n        /**\n     * @private\n     */ _maybeGroupObjects: function(e) {\n            if (this.selection && this._groupSelector) {\n                this._groupSelectedObjects(e);\n            }\n            this.setCursor(this.defaultCursor);\n            // clear selection and current transformation\n            this._groupSelector = null;\n        }\n    });\n})();\n(function() {\n    fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n        /**\n     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately\n     * @param {Object} [options] Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}\n     * @example <caption>Generate jpeg dataURL with lower quality</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'jpeg',\n     *   quality: 0.8\n     * });\n     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   left: 100,\n     *   top: 100,\n     *   width: 200,\n     *   height: 200\n     * });\n     * @example <caption>Generate double scaled png dataURL</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   multiplier: 2\n     * });\n     */ toDataURL: function(options) {\n            options || (options = {});\n            var format = options.format || \"png\", quality = options.quality || 1, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1), canvasEl = this.toCanvasElement(multiplier, options);\n            return fabric.util.toDataURL(canvasEl, format, quality);\n        },\n        /**\n     * Create a new HTMLCanvas element painted with the current canvas content.\n     * No need to resize the actual one or repaint it.\n     * Will transfer object ownership to a new canvas, paint it, and set everything back.\n     * This is an intermediary step used to get to a dataUrl but also it is useful to\n     * create quick image copies of a canvas without passing for the dataUrl string\n     * @param {Number} [multiplier] a zoom factor.\n     * @param {Object} [cropping] Cropping informations\n     * @param {Number} [cropping.left] Cropping left offset.\n     * @param {Number} [cropping.top] Cropping top offset.\n     * @param {Number} [cropping.width] Cropping width.\n     * @param {Number} [cropping.height] Cropping height.\n     */ toCanvasElement: function(multiplier, cropping) {\n            multiplier = multiplier || 1;\n            cropping = cropping || {};\n            var scaledWidth = (cropping.width || this.width) * multiplier, scaledHeight = (cropping.height || this.height) * multiplier, zoom = this.getZoom(), originalWidth = this.width, originalHeight = this.height, newZoom = zoom * multiplier, vp = this.viewportTransform, translateX = (vp[4] - (cropping.left || 0)) * multiplier, translateY = (vp[5] - (cropping.top || 0)) * multiplier, originalInteractive = this.interactive, newVp = [\n                newZoom,\n                0,\n                0,\n                newZoom,\n                translateX,\n                translateY\n            ], originalRetina = this.enableRetinaScaling, canvasEl = fabric.util.createCanvasElement(), originalContextTop = this.contextTop;\n            canvasEl.width = scaledWidth;\n            canvasEl.height = scaledHeight;\n            this.contextTop = null;\n            this.enableRetinaScaling = false;\n            this.interactive = false;\n            this.viewportTransform = newVp;\n            this.width = scaledWidth;\n            this.height = scaledHeight;\n            this.calcViewportBoundaries();\n            this.renderCanvas(canvasEl.getContext(\"2d\"), this._objects);\n            this.viewportTransform = vp;\n            this.width = originalWidth;\n            this.height = originalHeight;\n            this.calcViewportBoundaries();\n            this.interactive = originalInteractive;\n            this.enableRetinaScaling = originalRetina;\n            this.contextTop = originalContextTop;\n            return canvasEl;\n        }\n    });\n})();\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Populates canvas with data from the specified JSON.\n   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}\n   * @param {String|Object} json JSON string or object\n   * @param {Function} callback Callback, invoked when json is parsed\n   *                            and corresponding objects (e.g: {@link fabric.Image})\n   *                            are initialized\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\n   * @return {fabric.Canvas} instance\n   * @chainable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}\n   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}\n   * @example <caption>loadFromJSON</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));\n   * @example <caption>loadFromJSON with reviver</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {\n   *   // `o` = json object\n   *   // `object` = fabric.Object instance\n   *   // ... do some stuff ...\n   * });\n   */ loadFromJSON: function(json, callback, reviver) {\n        if (!json) {\n            return;\n        }\n        // serialize if it wasn't already\n        var serialized = typeof json === \"string\" ? JSON.parse(json) : fabric.util.object.clone(json);\n        var _this = this, clipPath = serialized.clipPath, renderOnAddRemove = this.renderOnAddRemove;\n        this.renderOnAddRemove = false;\n        delete serialized.clipPath;\n        this._enlivenObjects(serialized.objects, function(enlivenedObjects) {\n            _this.clear();\n            _this._setBgOverlay(serialized, function() {\n                if (clipPath) {\n                    _this._enlivenObjects([\n                        clipPath\n                    ], function(enlivenedCanvasClip) {\n                        _this.clipPath = enlivenedCanvasClip[0];\n                        _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);\n                    });\n                } else {\n                    _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);\n                }\n            });\n        }, reviver);\n        return this;\n    },\n    /**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Array} restored canvas objects\n   * @param {Function} cached renderOnAddRemove callback\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */ __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {\n        var _this = this;\n        enlivenedObjects.forEach(function(obj, index) {\n            // we splice the array just in case some custom classes restored from JSON\n            // will add more object to canvas at canvas init.\n            _this.insertAt(obj, index);\n        });\n        this.renderOnAddRemove = renderOnAddRemove;\n        // remove parts i cannot set as options\n        delete serialized.objects;\n        delete serialized.backgroundImage;\n        delete serialized.overlayImage;\n        delete serialized.background;\n        delete serialized.overlay;\n        // this._initOptions does too many things to just\n        // call it. Normally loading an Object from JSON\n        // create the Object instance. Here the Canvas is\n        // already an instance and we are just loading things over it\n        this._setOptions(serialized);\n        this.renderAll();\n        callback && callback();\n    },\n    /**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */ _setBgOverlay: function(serialized, callback) {\n        var loaded = {\n            backgroundColor: false,\n            overlayColor: false,\n            backgroundImage: false,\n            overlayImage: false\n        };\n        if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {\n            callback && callback();\n            return;\n        }\n        var cbIfLoaded = function() {\n            if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {\n                callback && callback();\n            }\n        };\n        this.__setBgOverlay(\"backgroundImage\", serialized.backgroundImage, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"overlayImage\", serialized.overlayImage, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"backgroundColor\", serialized.background, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"overlayColor\", serialized.overlay, loaded, cbIfLoaded);\n    },\n    /**\n   * @private\n   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)\n   * @param {(Object|String)} value Value to set\n   * @param {Object} loaded Set loaded property to true if property is set\n   * @param {Object} callback Callback function to invoke after property is set\n   */ __setBgOverlay: function(property, value, loaded, callback) {\n        var _this = this;\n        if (!value) {\n            loaded[property] = true;\n            callback && callback();\n            return;\n        }\n        if (property === \"backgroundImage\" || property === \"overlayImage\") {\n            fabric.util.enlivenObjects([\n                value\n            ], function(enlivedObject) {\n                _this[property] = enlivedObject[0];\n                loaded[property] = true;\n                callback && callback();\n            });\n        } else {\n            this[\"set\" + fabric.util.string.capitalize(property, true)](value, function() {\n                loaded[property] = true;\n                callback && callback();\n            });\n        }\n    },\n    /**\n   * @private\n   * @param {Array} objects\n   * @param {Function} callback\n   * @param {Function} [reviver]\n   */ _enlivenObjects: function(objects, callback, reviver) {\n        if (!objects || objects.length === 0) {\n            callback && callback([]);\n            return;\n        }\n        fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\n            callback && callback(enlivenedObjects);\n        }, null, reviver);\n    },\n    /**\n   * @private\n   * @param {String} format\n   * @param {Function} callback\n   */ _toDataURL: function(format, callback) {\n        this.clone(function(clone) {\n            callback(clone.toDataURL(format));\n        });\n    },\n    /**\n   * @private\n   * @param {String} format\n   * @param {Number} multiplier\n   * @param {Function} callback\n   */ _toDataURLWithMultiplier: function(format, multiplier, callback) {\n        this.clone(function(clone) {\n            callback(clone.toDataURLWithMultiplier(format, multiplier));\n        });\n    },\n    /**\n   * Clones canvas instance\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   * @param {Array} [properties] Array of properties to include in the cloned canvas and children\n   */ clone: function(callback, properties) {\n        var data = JSON.stringify(this.toJSON(properties));\n        this.cloneWithoutData(function(clone) {\n            clone.loadFromJSON(data, function() {\n                callback && callback(clone);\n            });\n        });\n    },\n    /**\n   * Clones canvas instance without cloning existing data.\n   * This essentially copies canvas dimensions, clipping properties, etc.\n   * but leaves data empty (so that you can populate it with your own)\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   */ cloneWithoutData: function(callback) {\n        var el = fabric.util.createCanvasElement();\n        el.width = this.width;\n        el.height = this.height;\n        var clone = new fabric.Canvas(el);\n        if (this.backgroundImage) {\n            clone.setBackgroundImage(this.backgroundImage.src, function() {\n                clone.renderAll();\n                callback && callback(clone);\n            });\n            clone.backgroundImageOpacity = this.backgroundImageOpacity;\n            clone.backgroundImageStretch = this.backgroundImageStretch;\n        } else {\n            callback && callback(clone);\n        }\n    }\n});\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed, capitalize = fabric.util.string.capitalize, degreesToRadians = fabric.util.degreesToRadians, objectCaching = !fabric.isLikelyNode, ALIASING_LIMIT = 2;\n    if (fabric.Object) {\n        return;\n    }\n    /**\n   * Root object class from which all 2d shape classes inherit from\n   * @class fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}\n   * @see {@link fabric.Object#initialize} for constructor definition\n   *\n   * @fires added\n   * @fires removed\n   *\n   * @fires selected\n   * @fires deselected\n   * @fires modified\n   * @fires modified\n   * @fires moved\n   * @fires scaled\n   * @fires rotated\n   * @fires skewed\n   *\n   * @fires rotating\n   * @fires scaling\n   * @fires moving\n   * @fires skewing\n   *\n   * @fires mousedown\n   * @fires mouseup\n   * @fires mouseover\n   * @fires mouseout\n   * @fires mousewheel\n   * @fires mousedblclick\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop\n   */ fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {\n        /**\n     * Type of an object (rect, circle, path, etc.).\n     * Note that this property is meant to be read-only and not meant to be modified.\n     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.\n     * @type String\n     * @default\n     */ type: \"object\",\n        /**\n     * Horizontal origin of transformation of an object (one of \"left\", \"right\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */ originX: \"left\",\n        /**\n     * Vertical origin of transformation of an object (one of \"top\", \"bottom\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */ originY: \"top\",\n        /**\n     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}\n     * @type Number\n     * @default\n     */ top: 0,\n        /**\n     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}\n     * @type Number\n     * @default\n     */ left: 0,\n        /**\n     * Object width\n     * @type Number\n     * @default\n     */ width: 0,\n        /**\n     * Object height\n     * @type Number\n     * @default\n     */ height: 0,\n        /**\n     * Object scale factor (horizontal)\n     * @type Number\n     * @default\n     */ scaleX: 1,\n        /**\n     * Object scale factor (vertical)\n     * @type Number\n     * @default\n     */ scaleY: 1,\n        /**\n     * When true, an object is rendered as flipped horizontally\n     * @type Boolean\n     * @default\n     */ flipX: false,\n        /**\n     * When true, an object is rendered as flipped vertically\n     * @type Boolean\n     * @default\n     */ flipY: false,\n        /**\n     * Opacity of an object\n     * @type Number\n     * @default\n     */ opacity: 1,\n        /**\n     * Angle of rotation of an object (in degrees)\n     * @type Number\n     * @default\n     */ angle: 0,\n        /**\n     * Angle of skew on x axes of an object (in degrees)\n     * @type Number\n     * @default\n     */ skewX: 0,\n        /**\n     * Angle of skew on y axes of an object (in degrees)\n     * @type Number\n     * @default\n     */ skewY: 0,\n        /**\n     * Size of object's controlling corners (in pixels)\n     * @type Number\n     * @default\n     */ cornerSize: 13,\n        /**\n     * Size of object's controlling corners when touch interaction is detected\n     * @type Number\n     * @default\n     */ touchCornerSize: 24,\n        /**\n     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)\n     * @type Boolean\n     * @default\n     */ transparentCorners: true,\n        /**\n     * Default cursor value used when hovering over this object on canvas\n     * @type String\n     * @default\n     */ hoverCursor: null,\n        /**\n     * Default cursor value used when moving this object on canvas\n     * @type String\n     * @default\n     */ moveCursor: null,\n        /**\n     * Padding between object and its controlling borders (in pixels)\n     * @type Number\n     * @default\n     */ padding: 0,\n        /**\n     * Color of controlling borders of an object (when it's active)\n     * @type String\n     * @default\n     */ borderColor: \"rgb(178,204,255)\",\n        /**\n     * Array specifying dash pattern of an object's borders (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */ borderDashArray: null,\n        /**\n     * Color of controlling corners of an object (when it's active)\n     * @type String\n     * @default\n     */ cornerColor: \"rgb(178,204,255)\",\n        /**\n     * Color of controlling corners of an object (when it's active and transparentCorners false)\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ cornerStrokeColor: null,\n        /**\n     * Specify style of control, 'rect' or 'circle'\n     * @since 1.6.2\n     * @type String\n     */ cornerStyle: \"rect\",\n        /**\n     * Array specifying dash pattern of an object's control (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */ cornerDashArray: null,\n        /**\n     * When true, this object will use center point as the origin of transformation\n     * when being scaled via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredScaling: false,\n        /**\n     * When true, this object will use center point as the origin of transformation\n     * when being rotated via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredRotation: true,\n        /**\n     * Color of object's fill\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ fill: \"rgb(0,0,0)\",\n        /**\n     * Fill rule used to fill an object\n     * accepted values are nonzero, evenodd\n     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)\n     * @type String\n     * @default\n     */ fillRule: \"nonzero\",\n        /**\n     * Composite rule used for canvas globalCompositeOperation\n     * @type String\n     * @default\n     */ globalCompositeOperation: \"source-over\",\n        /**\n     * Background color of an object.\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ backgroundColor: \"\",\n        /**\n     * Selection Background color of an object. colored layer behind the object when it is active.\n     * does not mix good with globalCompositeOperation methods.\n     * @type String\n     * @default\n     */ selectionBackgroundColor: \"\",\n        /**\n     * When defined, an object is rendered via stroke and this property specifies its color\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ stroke: null,\n        /**\n     * Width of a stroke used to render this object\n     * @type Number\n     * @default\n     */ strokeWidth: 1,\n        /**\n     * Array specifying dash pattern of an object's stroke (stroke must be defined)\n     * @type Array\n     */ strokeDashArray: null,\n        /**\n     * Line offset of an object's stroke\n     * @type Number\n     * @default\n     */ strokeDashOffset: 0,\n        /**\n     * Line endings style of an object's stroke (one of \"butt\", \"round\", \"square\")\n     * @type String\n     * @default\n     */ strokeLineCap: \"butt\",\n        /**\n     * Corner style of an object's stroke (one of \"bevel\", \"round\", \"miter\")\n     * @type String\n     * @default\n     */ strokeLineJoin: \"miter\",\n        /**\n     * Maximum miter length (used for strokeLineJoin = \"miter\") of an object's stroke\n     * @type Number\n     * @default\n     */ strokeMiterLimit: 4,\n        /**\n     * Shadow object representing shadow of this shape\n     * @type fabric.Shadow\n     * @default\n     */ shadow: null,\n        /**\n     * Opacity of object's controlling borders when object is active and moving\n     * @type Number\n     * @default\n     */ borderOpacityWhenMoving: 0.4,\n        /**\n     * Scale factor of object's controlling borders\n     * bigger number will make a thicker border\n     * border is 1, so this is basically a border thickness\n     * since there is no way to change the border itself.\n     * @type Number\n     * @default\n     */ borderScaleFactor: 1,\n        /**\n     * Minimum allowed scale value of an object\n     * @type Number\n     * @default\n     */ minScaleLimit: 0,\n        /**\n     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).\n     * But events still fire on it.\n     * @type Boolean\n     * @default\n     */ selectable: true,\n        /**\n     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4\n     * @type Boolean\n     * @default\n     */ evented: true,\n        /**\n     * When set to `false`, an object is not rendered on canvas\n     * @type Boolean\n     * @default\n     */ visible: true,\n        /**\n     * When set to `false`, object's controls are not displayed and can not be used to manipulate object\n     * @type Boolean\n     * @default\n     */ hasControls: true,\n        /**\n     * When set to `false`, object's controlling borders are not rendered\n     * @type Boolean\n     * @default\n     */ hasBorders: true,\n        /**\n     * When set to `true`, objects are \"found\" on canvas on per-pixel basis rather than according to bounding box\n     * @type Boolean\n     * @default\n     */ perPixelTargetFind: false,\n        /**\n     * When `false`, default object's values are not included in its serialization\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * When `true`, object horizontal movement is locked\n     * @type Boolean\n     * @default\n     */ lockMovementX: false,\n        /**\n     * When `true`, object vertical movement is locked\n     * @type Boolean\n     * @default\n     */ lockMovementY: false,\n        /**\n     * When `true`, object rotation is locked\n     * @type Boolean\n     * @default\n     */ lockRotation: false,\n        /**\n     * When `true`, object horizontal scaling is locked\n     * @type Boolean\n     * @default\n     */ lockScalingX: false,\n        /**\n     * When `true`, object vertical scaling is locked\n     * @type Boolean\n     * @default\n     */ lockScalingY: false,\n        /**\n     * When `true`, object horizontal skewing is locked\n     * @type Boolean\n     * @default\n     */ lockSkewingX: false,\n        /**\n     * When `true`, object vertical skewing is locked\n     * @type Boolean\n     * @default\n     */ lockSkewingY: false,\n        /**\n     * When `true`, object cannot be flipped by scaling into negative values\n     * @type Boolean\n     * @default\n     */ lockScalingFlip: false,\n        /**\n     * When `true`, object is not exported in OBJECT/JSON\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ excludeFromExport: false,\n        /**\n     * When `true`, object is cached on an additional canvas.\n     * When `false`, object is not cached unless necessary ( clipPath )\n     * default to true\n     * @since 1.7.0\n     * @type Boolean\n     * @default true\n     */ objectCaching: objectCaching,\n        /**\n     * When `true`, object properties are checked for cache invalidation. In some particular\n     * situation you may want this to be disabled ( spray brush, very big, groups)\n     * or if your application does not allow you to modify properties for groups child you want\n     * to disable it for groups.\n     * default to false\n     * since 1.7.0\n     * @type Boolean\n     * @default false\n     */ statefullCache: false,\n        /**\n     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled\n     * too much and will be redrawn with correct details at the end of scaling.\n     * this setting is performance and application dependant.\n     * default to true\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */ noScaleCache: true,\n        /**\n     * When `false`, the stoke width will scale with the object.\n     * When `true`, the stroke will always match the exact pixel size entered for stroke width.\n     * this Property does not work on Text classes or drawing call that uses strokeText,fillText methods\n     * default to false\n     * @since 2.6.0\n     * @type Boolean\n     * @default false\n     * @type Boolean\n     * @default false\n     */ strokeUniform: false,\n        /**\n     * When set to `true`, object's cache will be rerendered next render call.\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */ dirty: true,\n        /**\n     * keeps the value of the last hovered corner during mouse move.\n     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..\n     * It should be private, but there is no harm in using it as\n     * a read-only property.\n     * @type number|string|any\n     * @default 0\n     */ __corner: 0,\n        /**\n     * Determines if the fill or the stroke is drawn first (one of \"fill\" or \"stroke\")\n     * @type String\n     * @default\n     */ paintFirst: \"fill\",\n        /**\n     * When 'down', object is set to active on mousedown/touchstart\n     * When 'up', object is set to active on mouseup/touchend\n     * Experimental. Let's see if this breaks anything before supporting officially\n     * @private\n     * since 4.4.0\n     * @type String\n     * @default 'down'\n     */ activeOn: \"down\",\n        /**\n     * List of properties to consider when checking if state\n     * of an object is changed (fabric.Object#hasStateChanged)\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: (\"top left width height scaleX scaleY flipX flipY originX originY transformMatrix \" + \"stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit \" + \"angle opacity fill globalCompositeOperation shadow visible backgroundColor \" + \"skewX skewY fillRule paintFirst clipPath strokeUniform\").split(\" \"),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */ cacheProperties: (\"fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform\" + \" strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath\").split(\" \"),\n        /**\n     * List of properties to consider for animating colors.\n     * @type Array\n     */ colorProperties: \"fill stroke backgroundColor\".split(\" \"),\n        /**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the object has rendered, and the context is placed in the center\n     * of the object cacheCanvas.\n     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'\n     * @type fabric.Object\n     */ clipPath: undefined,\n        /**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will make the object clip to the outside of the clipPath\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */ inverted: false,\n        /**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will have its top and left relative to canvas, and will\n     * not be influenced by the object transform. This will make the clipPath relative\n     * to the canvas, but clipping just a particular object.\n     * WARNING this is beta, this feature may change or be renamed.\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */ absolutePositioned: false,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            if (options) {\n                this.setOptions(options);\n            }\n        },\n        /**\n     * Create a the canvas used to keep the cached copy of the object\n     * @private\n     */ _createCacheCanvas: function() {\n            this._cacheProperties = {};\n            this._cacheCanvas = fabric.util.createCanvasElement();\n            this._cacheContext = this._cacheCanvas.getContext(\"2d\");\n            this._updateCacheCanvas();\n            // if canvas gets created, is empty, so dirty.\n            this.dirty = true;\n        },\n        /**\n     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal\n     * and each side do not cross fabric.cacheSideLimit\n     * those numbers are configurable so that you can get as much detail as you want\n     * making bargain with performances.\n     * @param {Object} dims\n     * @param {Object} dims.width width of canvas\n     * @param {Object} dims.height height of canvas\n     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _limitCacheSize: function(dims) {\n            var perfLimitSizeTotal = fabric.perfLimitSizeTotal, width = dims.width, height = dims.height, max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;\n            if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {\n                if (width < min) {\n                    dims.width = min;\n                }\n                if (height < min) {\n                    dims.height = min;\n                }\n                return dims;\n            }\n            var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal), capValue = fabric.util.capValue, x = capValue(min, limitedDims.x, max), y = capValue(min, limitedDims.y, max);\n            if (width > x) {\n                dims.zoomX /= width / x;\n                dims.width = x;\n                dims.capped = true;\n            }\n            if (height > y) {\n                dims.zoomY /= height / y;\n                dims.height = y;\n                dims.capped = true;\n            }\n            return dims;\n        },\n        /**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @return {Object}.x width of object to be cached\n     * @return {Object}.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _getCacheCanvasDimensions: function() {\n            var objectScale = this.getTotalObjectScaling(), // caculate dimensions without skewing\n            dim = this._getTransformedDimensions(0, 0), neededX = dim.x * objectScale.scaleX / this.scaleX, neededY = dim.y * objectScale.scaleY / this.scaleY;\n            return {\n                // for sure this ALIASING_LIMIT is slightly creating problem\n                // in situation in which the cache canvas gets an upper limit\n                // also objectScale contains already scaleX and scaleY\n                width: neededX + ALIASING_LIMIT,\n                height: neededY + ALIASING_LIMIT,\n                zoomX: objectScale.scaleX,\n                zoomY: objectScale.scaleY,\n                x: neededX,\n                y: neededY\n            };\n        },\n        /**\n     * Update width and height of the canvas for cache\n     * returns true or false if canvas needed resize.\n     * @private\n     * @return {Boolean} true if the canvas has been resized\n     */ _updateCacheCanvas: function() {\n            var targetCanvas = this.canvas;\n            if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {\n                var target = targetCanvas._currentTransform.target, action = targetCanvas._currentTransform.action;\n                if (this === target && action.slice && action.slice(0, 5) === \"scale\") {\n                    return false;\n                }\n            }\n            var canvas = this._cacheCanvas, dims = this._limitCacheSize(this._getCacheCanvasDimensions()), minCacheSize = fabric.minCacheSideLimit, width = dims.width, height = dims.height, drawingWidth, drawingHeight, zoomX = dims.zoomX, zoomY = dims.zoomY, dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight, zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY, shouldRedraw = dimensionsChanged || zoomChanged, additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;\n            if (dimensionsChanged) {\n                var canvasWidth = this._cacheCanvas.width, canvasHeight = this._cacheCanvas.height, sizeGrowing = width > canvasWidth || height > canvasHeight, sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) && canvasWidth > minCacheSize && canvasHeight > minCacheSize;\n                shouldResizeCanvas = sizeGrowing || sizeShrinking;\n                if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {\n                    additionalWidth = width * 0.1;\n                    additionalHeight = height * 0.1;\n                }\n            }\n            if (this instanceof fabric.Text && this.path) {\n                shouldRedraw = true;\n                shouldResizeCanvas = true;\n                additionalWidth += this.getHeightOfLine(0) * this.zoomX;\n                additionalHeight += this.getHeightOfLine(0) * this.zoomY;\n            }\n            if (shouldRedraw) {\n                if (shouldResizeCanvas) {\n                    canvas.width = Math.ceil(width + additionalWidth);\n                    canvas.height = Math.ceil(height + additionalHeight);\n                } else {\n                    this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);\n                    this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);\n                }\n                drawingWidth = dims.x / 2;\n                drawingHeight = dims.y / 2;\n                this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;\n                this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;\n                this.cacheWidth = width;\n                this.cacheHeight = height;\n                this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);\n                this._cacheContext.scale(zoomX, zoomY);\n                this.zoomX = zoomX;\n                this.zoomY = zoomY;\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Sets object's properties from options\n     * @param {Object} [options] Options object\n     */ setOptions: function(options) {\n            this._setOptions(options);\n            this._initGradient(options.fill, \"fill\");\n            this._initGradient(options.stroke, \"stroke\");\n            this._initPattern(options.fill, \"fill\");\n            this._initPattern(options.stroke, \"stroke\");\n        },\n        /**\n     * Transforms context when rendering an object\n     * @param {CanvasRenderingContext2D} ctx Context\n     */ transform: function(ctx) {\n            var needFullTransform = this.group && !this.group._transformDone || this.group && this.canvas && ctx === this.canvas.contextTop;\n            var m = this.calcTransformMatrix(!needFullTransform);\n            ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n        },\n        /**\n     * Returns an object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, object = {\n                type: this.type,\n                version: fabric.version,\n                originX: this.originX,\n                originY: this.originY,\n                left: toFixed(this.left, NUM_FRACTION_DIGITS),\n                top: toFixed(this.top, NUM_FRACTION_DIGITS),\n                width: toFixed(this.width, NUM_FRACTION_DIGITS),\n                height: toFixed(this.height, NUM_FRACTION_DIGITS),\n                fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,\n                stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,\n                strokeWidth: toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),\n                strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,\n                strokeLineCap: this.strokeLineCap,\n                strokeDashOffset: this.strokeDashOffset,\n                strokeLineJoin: this.strokeLineJoin,\n                strokeUniform: this.strokeUniform,\n                strokeMiterLimit: toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),\n                scaleX: toFixed(this.scaleX, NUM_FRACTION_DIGITS),\n                scaleY: toFixed(this.scaleY, NUM_FRACTION_DIGITS),\n                angle: toFixed(this.angle, NUM_FRACTION_DIGITS),\n                flipX: this.flipX,\n                flipY: this.flipY,\n                opacity: toFixed(this.opacity, NUM_FRACTION_DIGITS),\n                shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,\n                visible: this.visible,\n                backgroundColor: this.backgroundColor,\n                fillRule: this.fillRule,\n                paintFirst: this.paintFirst,\n                globalCompositeOperation: this.globalCompositeOperation,\n                skewX: toFixed(this.skewX, NUM_FRACTION_DIGITS),\n                skewY: toFixed(this.skewY, NUM_FRACTION_DIGITS)\n            };\n            if (this.clipPath && !this.clipPath.excludeFromExport) {\n                object.clipPath = this.clipPath.toObject(propertiesToInclude);\n                object.clipPath.inverted = this.clipPath.inverted;\n                object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;\n            }\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            if (!this.includeDefaultValues) {\n                object = this._removeDefaultValues(object);\n            }\n            return object;\n        },\n        /**\n     * Returns (dataless) object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            // will be overwritten by subclasses\n            return this.toObject(propertiesToInclude);\n        },\n        /**\n     * @private\n     * @param {Object} object\n     */ _removeDefaultValues: function(object) {\n            var prototype = fabric.util.getKlass(object.type).prototype, stateProperties = prototype.stateProperties;\n            stateProperties.forEach(function(prop) {\n                if (prop === \"left\" || prop === \"top\") {\n                    return;\n                }\n                if (object[prop] === prototype[prop]) {\n                    delete object[prop];\n                }\n                var isArray = Object.prototype.toString.call(object[prop]) === \"[object Array]\" && Object.prototype.toString.call(prototype[prop]) === \"[object Array]\";\n                // basically a check for [] === []\n                if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {\n                    delete object[prop];\n                }\n            });\n            return object;\n        },\n        /**\n     * Returns a string representation of an instance\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.\" + capitalize(this.type) + \">\";\n        },\n        /**\n     * Return the object scale factor counting also the group scaling\n     * @return {Object} object with scaleX and scaleY properties\n     */ getObjectScaling: function() {\n            // if the object is a top level one, on the canvas, we go for simple aritmetic\n            // otherwise the complex method with angles will return approximations and decimals\n            // and will likely kill the cache when not needed\n            // https://github.com/fabricjs/fabric.js/issues/7157\n            if (!this.group) {\n                return {\n                    scaleX: this.scaleX,\n                    scaleY: this.scaleY\n                };\n            }\n            // if we are inside a group total zoom calculation is complex, we defer to generic matrices\n            var options = fabric.util.qrDecompose(this.calcTransformMatrix());\n            return {\n                scaleX: Math.abs(options.scaleX),\n                scaleY: Math.abs(options.scaleY)\n            };\n        },\n        /**\n     * Return the object scale factor counting also the group scaling, zoom and retina\n     * @return {Object} object with scaleX and scaleY properties\n     */ getTotalObjectScaling: function() {\n            var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;\n            if (this.canvas) {\n                var zoom = this.canvas.getZoom();\n                var retina = this.canvas.getRetinaScaling();\n                scaleX *= zoom * retina;\n                scaleY *= zoom * retina;\n            }\n            return {\n                scaleX: scaleX,\n                scaleY: scaleY\n            };\n        },\n        /**\n     * Return the object opacity counting also the group property\n     * @return {Number}\n     */ getObjectOpacity: function() {\n            var opacity = this.opacity;\n            if (this.group) {\n                opacity *= this.group.getObjectOpacity();\n            }\n            return opacity;\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Object} thisArg\n     */ _set: function(key, value) {\n            var shouldConstrainValue = key === \"scaleX\" || key === \"scaleY\", isChanged = this[key] !== value, groupNeedsUpdate = false;\n            if (shouldConstrainValue) {\n                value = this._constrainScale(value);\n            }\n            if (key === \"scaleX\" && value < 0) {\n                this.flipX = !this.flipX;\n                value *= -1;\n            } else if (key === \"scaleY\" && value < 0) {\n                this.flipY = !this.flipY;\n                value *= -1;\n            } else if (key === \"shadow\" && value && !(value instanceof fabric.Shadow)) {\n                value = new fabric.Shadow(value);\n            } else if (key === \"dirty\" && this.group) {\n                this.group.set(\"dirty\", value);\n            }\n            this[key] = value;\n            if (isChanged) {\n                groupNeedsUpdate = this.group && this.group.isOnACache();\n                if (this.cacheProperties.indexOf(key) > -1) {\n                    this.dirty = true;\n                    groupNeedsUpdate && this.group.set(\"dirty\", true);\n                } else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {\n                    this.group.set(\"dirty\", true);\n                }\n            }\n            return this;\n        },\n        /**\n     * This callback function is called by the parent group of an object every\n     * time a non-delegated property changes on the group. It is passed the key\n     * and value as parameters. Not adding in this function's signature to avoid\n     * Travis build error about unused variables.\n     */ setOnGroup: function() {\n        // implemented by sub-classes, as needed.\n        },\n        /**\n     * Retrieves viewportTransform from Object's canvas if possible\n     * @method getViewportTransform\n     * @memberOf fabric.Object.prototype\n     * @return {Array}\n     */ getViewportTransform: function() {\n            if (this.canvas && this.canvas.viewportTransform) {\n                return this.canvas.viewportTransform;\n            }\n            return fabric.iMatrix.concat();\n        },\n        /*\n     * @private\n     * return if the object would be visible in rendering\n     * @memberOf fabric.Object.prototype\n     * @return {Boolean}\n     */ isNotVisible: function() {\n            return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;\n        },\n        /**\n     * Renders an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            // do not render if width/height are zeros or object is not visible\n            if (this.isNotVisible()) {\n                return;\n            }\n            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {\n                return;\n            }\n            ctx.save();\n            this._setupCompositeOperation(ctx);\n            this.drawSelectionBackground(ctx);\n            this.transform(ctx);\n            this._setOpacity(ctx);\n            this._setShadow(ctx, this);\n            if (this.shouldCache()) {\n                this.renderCache();\n                this.drawCacheOnCanvas(ctx);\n            } else {\n                this._removeCacheCanvas();\n                this.dirty = false;\n                this.drawObject(ctx);\n                if (this.objectCaching && this.statefullCache) {\n                    this.saveState({\n                        propertySet: \"cacheProperties\"\n                    });\n                }\n            }\n            ctx.restore();\n        },\n        renderCache: function(options) {\n            options = options || {};\n            if (!this._cacheCanvas) {\n                this._createCacheCanvas();\n            }\n            if (this.isCacheDirty()) {\n                this.statefullCache && this.saveState({\n                    propertySet: \"cacheProperties\"\n                });\n                this.drawObject(this._cacheContext, options.forClipping);\n                this.dirty = false;\n            }\n        },\n        /**\n     * Remove cacheCanvas and its dimensions from the objects\n     */ _removeCacheCanvas: function() {\n            this._cacheCanvas = null;\n            this.cacheWidth = 0;\n            this.cacheHeight = 0;\n        },\n        /**\n     * return true if the object will draw a stroke\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when stroke happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the stroke is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */ hasStroke: function() {\n            return this.stroke && this.stroke !== \"transparent\" && this.strokeWidth !== 0;\n        },\n        /**\n     * return true if the object will draw a fill\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when fill happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the fill is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */ hasFill: function() {\n            return this.fill && this.fill !== \"transparent\";\n        },\n        /**\n     * When set to `true`, force the object to have its own cache, even if it is inside a group\n     * it may be needed when your object behave in a particular way on the cache and always needs\n     * its own isolated canvas to render correctly.\n     * Created to be overridden\n     * since 1.7.12\n     * @returns Boolean\n     */ needsItsOwnCache: function() {\n            if (this.paintFirst === \"stroke\" && this.hasFill() && this.hasStroke() && typeof this.shadow === \"object\") {\n                return true;\n            }\n            if (this.clipPath) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache());\n            return this.ownCaching;\n        },\n        /**\n     * Check if this object or a child object will cast a shadow\n     * used by Group.shouldCache to know if child has a shadow recursively\n     * @return {Boolean}\n     */ willDrawShadow: function() {\n            return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);\n        },\n        /**\n     * Execute the drawing operation for an object clipPath\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Object} clipPath\n     */ drawClipPathOnCache: function(ctx, clipPath) {\n            ctx.save();\n            // DEBUG: uncomment this line, comment the following\n            // ctx.globalAlpha = 0.4\n            if (clipPath.inverted) {\n                ctx.globalCompositeOperation = \"destination-out\";\n            } else {\n                ctx.globalCompositeOperation = \"destination-in\";\n            }\n            //ctx.scale(1 / 2, 1 / 2);\n            if (clipPath.absolutePositioned) {\n                var m = fabric.util.invertTransform(this.calcTransformMatrix());\n                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            }\n            clipPath.transform(ctx);\n            ctx.scale(1 / clipPath.zoomX, 1 / clipPath.zoomY);\n            ctx.drawImage(clipPath._cacheCanvas, -clipPath.cacheTranslationX, -clipPath.cacheTranslationY);\n            ctx.restore();\n        },\n        /**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawObject: function(ctx, forClipping) {\n            var originalFill = this.fill, originalStroke = this.stroke;\n            if (forClipping) {\n                this.fill = \"black\";\n                this.stroke = \"\";\n                this._setClippingProperties(ctx);\n            } else {\n                this._renderBackground(ctx);\n            }\n            this._render(ctx);\n            this._drawClipPath(ctx, this.clipPath);\n            this.fill = originalFill;\n            this.stroke = originalStroke;\n        },\n        /**\n     * Prepare clipPath state and cache and draw it on instance's cache\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {fabric.Object} clipPath\n     */ _drawClipPath: function(ctx, clipPath) {\n            if (!clipPath) {\n                return;\n            }\n            // needed to setup a couple of variables\n            // path canvas gets overridden with this one.\n            // TODO find a better solution?\n            clipPath.canvas = this.canvas;\n            clipPath.shouldCache();\n            clipPath._transformDone = true;\n            clipPath.renderCache({\n                forClipping: true\n            });\n            this.drawClipPathOnCache(ctx, clipPath);\n        },\n        /**\n     * Paint the cached copy of the object on the target context.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawCacheOnCanvas: function(ctx) {\n            ctx.scale(1 / this.zoomX, 1 / this.zoomY);\n            ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);\n        },\n        /**\n     * Check if cache is dirty\n     * @param {Boolean} skipCanvas skip canvas checks because this object is painted\n     * on parent canvas.\n     */ isCacheDirty: function(skipCanvas) {\n            if (this.isNotVisible()) {\n                return false;\n            }\n            if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {\n                // in this case the context is already cleared.\n                return true;\n            } else {\n                if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged(\"cacheProperties\")) {\n                    if (this._cacheCanvas && !skipCanvas) {\n                        var width = this.cacheWidth / this.zoomX;\n                        var height = this.cacheHeight / this.zoomY;\n                        this._cacheContext.clearRect(-width / 2, -height / 2, width, height);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Draws a background for the object big as its untransformed dimensions\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderBackground: function(ctx) {\n            if (!this.backgroundColor) {\n                return;\n            }\n            var dim = this._getNonTransformedDimensions();\n            ctx.fillStyle = this.backgroundColor;\n            ctx.fillRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);\n            // if there is background color no other shadows\n            // should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _setOpacity: function(ctx) {\n            if (this.group && !this.group._transformDone) {\n                ctx.globalAlpha = this.getObjectOpacity();\n            } else {\n                ctx.globalAlpha *= this.opacity;\n            }\n        },\n        _setStrokeStyles: function(ctx, decl) {\n            var stroke = decl.stroke;\n            if (stroke) {\n                ctx.lineWidth = decl.strokeWidth;\n                ctx.lineCap = decl.strokeLineCap;\n                ctx.lineDashOffset = decl.strokeDashOffset;\n                ctx.lineJoin = decl.strokeLineJoin;\n                ctx.miterLimit = decl.strokeMiterLimit;\n                if (stroke.toLive) {\n                    if (stroke.gradientUnits === \"percentage\" || stroke.gradientTransform || stroke.patternTransform) {\n                        // need to transform gradient in a pattern.\n                        // this is a slow process. If you are hitting this codepath, and the object\n                        // is not using caching, you should consider switching it on.\n                        // we need a canvas as big as the current object caching canvas.\n                        this._applyPatternForTransformedGradient(ctx, stroke);\n                    } else {\n                        // is a simple gradient or pattern\n                        ctx.strokeStyle = stroke.toLive(ctx, this);\n                        this._applyPatternGradientTransform(ctx, stroke);\n                    }\n                } else {\n                    // is a color\n                    ctx.strokeStyle = decl.stroke;\n                }\n            }\n        },\n        _setFillStyles: function(ctx, decl) {\n            var fill = decl.fill;\n            if (fill) {\n                if (fill.toLive) {\n                    ctx.fillStyle = fill.toLive(ctx, this);\n                    this._applyPatternGradientTransform(ctx, decl.fill);\n                } else {\n                    ctx.fillStyle = fill;\n                }\n            }\n        },\n        _setClippingProperties: function(ctx) {\n            ctx.globalAlpha = 1;\n            ctx.strokeStyle = \"transparent\";\n            ctx.fillStyle = \"#000000\";\n        },\n        /**\n     * @private\n     * Sets line dash\n     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on\n     * @param {Array} dashArray array representing dashes\n     */ _setLineDash: function(ctx, dashArray) {\n            if (!dashArray || dashArray.length === 0) {\n                return;\n            }\n            // Spec requires the concatenation of two copies the dash list when the number of elements is odd\n            if (1 & dashArray.length) {\n                dashArray.push.apply(dashArray, dashArray);\n            }\n            ctx.setLineDash(dashArray);\n        },\n        /**\n     * Renders controls and borders for the object\n     * the context here is not transformed\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     */ _renderControls: function(ctx, styleOverride) {\n            var vpt = this.getViewportTransform(), matrix = this.calcTransformMatrix(), options, drawBorders, drawControls;\n            styleOverride = styleOverride || {};\n            drawBorders = typeof styleOverride.hasBorders !== \"undefined\" ? styleOverride.hasBorders : this.hasBorders;\n            drawControls = typeof styleOverride.hasControls !== \"undefined\" ? styleOverride.hasControls : this.hasControls;\n            matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);\n            options = fabric.util.qrDecompose(matrix);\n            ctx.save();\n            ctx.translate(options.translateX, options.translateY);\n            ctx.lineWidth = 1 * this.borderScaleFactor;\n            if (!this.group) {\n                ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n            }\n            if (this.flipX) {\n                options.angle -= 180;\n            }\n            ctx.rotate(degreesToRadians(this.group ? options.angle : this.angle));\n            if (styleOverride.forActiveSelection || this.group) {\n                drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);\n            } else {\n                drawBorders && this.drawBorders(ctx, styleOverride);\n            }\n            drawControls && this.drawControls(ctx, styleOverride);\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _setShadow: function(ctx) {\n            if (!this.shadow) {\n                return;\n            }\n            var shadow = this.shadow, canvas = this.canvas, scaling, multX = canvas && canvas.viewportTransform[0] || 1, multY = canvas && canvas.viewportTransform[3] || 1;\n            if (shadow.nonScaling) {\n                scaling = {\n                    scaleX: 1,\n                    scaleY: 1\n                };\n            } else {\n                scaling = this.getObjectScaling();\n            }\n            if (canvas && canvas._isRetinaScaling()) {\n                multX *= fabric.devicePixelRatio;\n                multY *= fabric.devicePixelRatio;\n            }\n            ctx.shadowColor = shadow.color;\n            ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;\n            ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;\n            ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _removeShadow: function(ctx) {\n            if (!this.shadow) {\n                return;\n            }\n            ctx.shadowColor = \"\";\n            ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} filler fabric.Pattern or fabric.Gradient\n     * @return {Object} offset.offsetX offset for text rendering\n     * @return {Object} offset.offsetY offset for text rendering\n     */ _applyPatternGradientTransform: function(ctx, filler) {\n            if (!filler || !filler.toLive) {\n                return {\n                    offsetX: 0,\n                    offsetY: 0\n                };\n            }\n            var t = filler.gradientTransform || filler.patternTransform;\n            var offsetX = -this.width / 2 + filler.offsetX || 0, offsetY = -this.height / 2 + filler.offsetY || 0;\n            if (filler.gradientUnits === \"percentage\") {\n                ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);\n            } else {\n                ctx.transform(1, 0, 0, 1, offsetX, offsetY);\n            }\n            if (t) {\n                ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);\n            }\n            return {\n                offsetX: offsetX,\n                offsetY: offsetY\n            };\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderPaintInOrder: function(ctx) {\n            if (this.paintFirst === \"stroke\") {\n                this._renderStroke(ctx);\n                this._renderFill(ctx);\n            } else {\n                this._renderFill(ctx);\n                this._renderStroke(ctx);\n            }\n        },\n        /**\n     * @private\n     * function that actually render something on the context.\n     * empty here to allow Obects to work on tests to benchmark fabric functionalites\n     * not related to rendering\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function() {},\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderFill: function(ctx) {\n            if (!this.fill) {\n                return;\n            }\n            ctx.save();\n            this._setFillStyles(ctx, this);\n            if (this.fillRule === \"evenodd\") {\n                ctx.fill(\"evenodd\");\n            } else {\n                ctx.fill();\n            }\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderStroke: function(ctx) {\n            if (!this.stroke || this.strokeWidth === 0) {\n                return;\n            }\n            if (this.shadow && !this.shadow.affectStroke) {\n                this._removeShadow(ctx);\n            }\n            ctx.save();\n            if (this.strokeUniform && this.group) {\n                var scaling = this.getObjectScaling();\n                ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);\n            } else if (this.strokeUniform) {\n                ctx.scale(1 / this.scaleX, 1 / this.scaleY);\n            }\n            this._setLineDash(ctx, this.strokeDashArray);\n            this._setStrokeStyles(ctx, this);\n            ctx.stroke();\n            ctx.restore();\n        },\n        /**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     */ _applyPatternForTransformedGradient: function(ctx, filler) {\n            var dims = this._limitCacheSize(this._getCacheCanvasDimensions()), pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(), width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;\n            pCanvas.width = width;\n            pCanvas.height = height;\n            pCtx = pCanvas.getContext(\"2d\");\n            pCtx.beginPath();\n            pCtx.moveTo(0, 0);\n            pCtx.lineTo(width, 0);\n            pCtx.lineTo(width, height);\n            pCtx.lineTo(0, height);\n            pCtx.closePath();\n            pCtx.translate(width / 2, height / 2);\n            pCtx.scale(dims.zoomX / this.scaleX / retinaScaling, dims.zoomY / this.scaleY / retinaScaling);\n            this._applyPatternGradientTransform(pCtx, filler);\n            pCtx.fillStyle = filler.toLive(ctx);\n            pCtx.fill();\n            ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);\n            ctx.scale(retinaScaling * this.scaleX / dims.zoomX, retinaScaling * this.scaleY / dims.zoomY);\n            ctx.strokeStyle = pCtx.createPattern(pCanvas, \"no-repeat\");\n        },\n        /**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */ _findCenterFromElement: function() {\n            return {\n                x: this.left + this.width / 2,\n                y: this.top + this.height / 2\n            };\n        },\n        /**\n     * This function is an helper for svg import. it decompose the transformMatrix\n     * and assign properties to object.\n     * untransformed coordinates\n     * @private\n     * @chainable\n     */ _assignTransformMatrixProps: function() {\n            if (this.transformMatrix) {\n                var options = fabric.util.qrDecompose(this.transformMatrix);\n                this.flipX = false;\n                this.flipY = false;\n                this.set(\"scaleX\", options.scaleX);\n                this.set(\"scaleY\", options.scaleY);\n                this.angle = options.angle;\n                this.skewX = options.skewX;\n                this.skewY = 0;\n            }\n        },\n        /**\n     * This function is an helper for svg import. it removes the transform matrix\n     * and set to object properties that fabricjs can handle\n     * @private\n     * @param {Object} preserveAspectRatioOptions\n     * @return {thisArg}\n     */ _removeTransformMatrix: function(preserveAspectRatioOptions) {\n            var center = this._findCenterFromElement();\n            if (this.transformMatrix) {\n                this._assignTransformMatrixProps();\n                center = fabric.util.transformPoint(center, this.transformMatrix);\n            }\n            this.transformMatrix = null;\n            if (preserveAspectRatioOptions) {\n                this.scaleX *= preserveAspectRatioOptions.scaleX;\n                this.scaleY *= preserveAspectRatioOptions.scaleY;\n                this.cropX = preserveAspectRatioOptions.cropX;\n                this.cropY = preserveAspectRatioOptions.cropY;\n                center.x += preserveAspectRatioOptions.offsetLeft;\n                center.y += preserveAspectRatioOptions.offsetTop;\n                this.width = preserveAspectRatioOptions.width;\n                this.height = preserveAspectRatioOptions.height;\n            }\n            this.setPositionByOrigin(center, \"center\", \"center\");\n        },\n        /**\n     * Clones an instance, using a callback method will work for every object.\n     * @param {Function} callback Callback is invoked with a clone as a first argument\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     */ clone: function(callback, propertiesToInclude) {\n            var objectForm = this.toObject(propertiesToInclude);\n            if (this.constructor.fromObject) {\n                this.constructor.fromObject(objectForm, callback);\n            } else {\n                fabric.Object._fromObject(\"Object\", objectForm, callback);\n            }\n        },\n        /**\n     * Creates an instance of fabric.Image out of an object\n     * makes use of toCanvasElement.\n     * Once this method was based on toDataUrl and loadImage, so it also had a quality\n     * and format option. toCanvasElement is faster and produce no loss of quality.\n     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.\n     * toCanvasElement and then toBlob from the obtained canvas is also a good option.\n     * This method is sync now, but still support the callback because we did not want to break.\n     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.\n     * @param {Function} callback callback, invoked with an instance as a first argument\n     * @param {Object} [options] for clone as image, passed to toDataURL\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {fabric.Object} thisArg\n     */ cloneAsImage: function(callback, options) {\n            var canvasEl = this.toCanvasElement(options);\n            if (callback) {\n                callback(new fabric.Image(canvasEl));\n            }\n            return this;\n        },\n        /**\n     * Converts an object into a HTMLCanvas element\n     * @param {Object} options Options object\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object\n     */ toCanvasElement: function(options) {\n            options || (options = {});\n            var utils = fabric.util, origParams = utils.saveObjectTransform(this), originalGroup = this.group, originalShadow = this.shadow, abs = Math.abs, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);\n            delete this.group;\n            if (options.withoutTransform) {\n                utils.resetObjectTransform(this);\n            }\n            if (options.withoutShadow) {\n                this.shadow = null;\n            }\n            var el = fabric.util.createCanvasElement(), // skip canvas zoom and calculate with setCoords now.\n            boundingRect = this.getBoundingRect(true, true), shadow = this.shadow, scaling, shadowOffset = {\n                x: 0,\n                y: 0\n            }, shadowBlur, width, height;\n            if (shadow) {\n                shadowBlur = shadow.blur;\n                if (shadow.nonScaling) {\n                    scaling = {\n                        scaleX: 1,\n                        scaleY: 1\n                    };\n                } else {\n                    scaling = this.getObjectScaling();\n                }\n                // consider non scaling shadow.\n                shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * abs(scaling.scaleX);\n                shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * abs(scaling.scaleY);\n            }\n            width = boundingRect.width + shadowOffset.x;\n            height = boundingRect.height + shadowOffset.y;\n            // if the current width/height is not an integer\n            // we need to make it so.\n            el.width = Math.ceil(width);\n            el.height = Math.ceil(height);\n            var canvas = new fabric.StaticCanvas(el, {\n                enableRetinaScaling: false,\n                renderOnAddRemove: false,\n                skipOffscreen: false\n            });\n            if (options.format === \"jpeg\") {\n                canvas.backgroundColor = \"#fff\";\n            }\n            this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), \"center\", \"center\");\n            var originalCanvas = this.canvas;\n            canvas.add(this);\n            var canvasEl = canvas.toCanvasElement(multiplier || 1, options);\n            this.shadow = originalShadow;\n            this.set(\"canvas\", originalCanvas);\n            if (originalGroup) {\n                this.group = originalGroup;\n            }\n            this.set(origParams).setCoords();\n            // canvas.dispose will call image.dispose that will nullify the elements\n            // since this canvas is a simple element for the process, we remove references\n            // to objects in this way in order to avoid object trashing.\n            canvas._objects = [];\n            canvas.dispose();\n            canvas = null;\n            return canvasEl;\n        },\n        /**\n     * Converts an object into a data-url-like string\n     * @param {Object} options Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     */ toDataURL: function(options) {\n            options || (options = {});\n            return fabric.util.toDataURL(this.toCanvasElement(options), options.format || \"png\", options.quality || 1);\n        },\n        /**\n     * Returns true if specified type is identical to the type of an instance\n     * @param {String} type Type to check against\n     * @return {Boolean}\n     */ isType: function(type) {\n            return this.type === type;\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance (is 1 unless subclassed)\n     */ complexity: function() {\n            return 1;\n        },\n        /**\n     * Returns a JSON representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} JSON\n     */ toJSON: function(propertiesToInclude) {\n            // delegate, not alias\n            return this.toObject(propertiesToInclude);\n        },\n        /**\n     * Sets \"angle\" of an instance with centered rotation\n     * @param {Number} angle Angle value (in degrees)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ rotate: function(angle) {\n            var shouldCenterOrigin = (this.originX !== \"center\" || this.originY !== \"center\") && this.centeredRotation;\n            if (shouldCenterOrigin) {\n                this._setOriginToCenter();\n            }\n            this.set(\"angle\", angle);\n            if (shouldCenterOrigin) {\n                this._resetOrigin();\n            }\n            return this;\n        },\n        /**\n     * Centers object horizontally on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ centerH: function() {\n            this.canvas && this.canvas.centerObjectH(this);\n            return this;\n        },\n        /**\n     * Centers object horizontally on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenterH: function() {\n            this.canvas && this.canvas.viewportCenterObjectH(this);\n            return this;\n        },\n        /**\n     * Centers object vertically on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ centerV: function() {\n            this.canvas && this.canvas.centerObjectV(this);\n            return this;\n        },\n        /**\n     * Centers object vertically on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenterV: function() {\n            this.canvas && this.canvas.viewportCenterObjectV(this);\n            return this;\n        },\n        /**\n     * Centers object vertically and horizontally on canvas to which is was added last\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ center: function() {\n            this.canvas && this.canvas.centerObject(this);\n            return this;\n        },\n        /**\n     * Centers object on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenter: function() {\n            this.canvas && this.canvas.viewportCenterObject(this);\n            return this;\n        },\n        /**\n     * Returns coordinates of a pointer relative to an object\n     * @param {Event} e Event to operate upon\n     * @param {Object} [pointer] Pointer to operate upon (instead of event)\n     * @return {Object} Coordinates of a pointer (x, y)\n     */ getLocalPointer: function(e, pointer) {\n            pointer = pointer || this.canvas.getPointer(e);\n            var pClicked = new fabric.Point(pointer.x, pointer.y), objectLeftTop = this._getLeftTopCoords();\n            if (this.angle) {\n                pClicked = fabric.util.rotatePoint(pClicked, objectLeftTop, degreesToRadians(-this.angle));\n            }\n            return {\n                x: pClicked.x - objectLeftTop.x,\n                y: pClicked.y - objectLeftTop.y\n            };\n        },\n        /**\n     * Sets canvas globalCompositeOperation for specific object\n     * custom composition operation for the particular object can be specified using globalCompositeOperation property\n     * @param {CanvasRenderingContext2D} ctx Rendering canvas context\n     */ _setupCompositeOperation: function(ctx) {\n            if (this.globalCompositeOperation) {\n                ctx.globalCompositeOperation = this.globalCompositeOperation;\n            }\n        },\n        /**\n     * cancel instance's running animations\n     * override if necessary to dispose artifacts such as `clipPath`\n     */ dispose: function() {\n            if (fabric.runningAnimations) {\n                fabric.runningAnimations.cancelByTarget(this);\n            }\n        }\n    });\n    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);\n    extend(fabric.Object.prototype, fabric.Observable);\n    /**\n   * Defines the number of fraction digits to use when serializing object values.\n   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type Number\n   */ fabric.Object.NUM_FRACTION_DIGITS = 2;\n    /**\n   * Defines which properties should be enlivened from the object passed to {@link fabric.Object._fromObject}\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type string[]\n   */ fabric.Object.ENLIVEN_PROPS = [\n        \"clipPath\"\n    ];\n    fabric.Object._fromObject = function(className, object, callback, extraParam) {\n        var klass = fabric[className];\n        object = clone(object, true);\n        fabric.util.enlivenPatterns([\n            object.fill,\n            object.stroke\n        ], function(patterns) {\n            if (typeof patterns[0] !== \"undefined\") {\n                object.fill = patterns[0];\n            }\n            if (typeof patterns[1] !== \"undefined\") {\n                object.stroke = patterns[1];\n            }\n            fabric.util.enlivenObjectEnlivables(object, object, function() {\n                var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);\n                callback && callback(instance);\n            });\n        });\n    };\n    /**\n   * Unique id used internally when creating SVG elements\n   * @static\n   * @memberOf fabric.Object\n   * @type Number\n   */ fabric.Object.__uid = 0;\n})( true ? exports : 0);\n(function() {\n    var degreesToRadians = fabric.util.degreesToRadians, originXOffset = {\n        left: -0.5,\n        center: 0,\n        right: 0.5\n    }, originYOffset = {\n        top: -0.5,\n        center: 0,\n        bottom: 0.5\n    };\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Translates the coordinates from a set of origin to another (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {\n            var x = point.x, y = point.y, offsetX, offsetY, dim;\n            if (typeof fromOriginX === \"string\") {\n                fromOriginX = originXOffset[fromOriginX];\n            } else {\n                fromOriginX -= 0.5;\n            }\n            if (typeof toOriginX === \"string\") {\n                toOriginX = originXOffset[toOriginX];\n            } else {\n                toOriginX -= 0.5;\n            }\n            offsetX = toOriginX - fromOriginX;\n            if (typeof fromOriginY === \"string\") {\n                fromOriginY = originYOffset[fromOriginY];\n            } else {\n                fromOriginY -= 0.5;\n            }\n            if (typeof toOriginY === \"string\") {\n                toOriginY = originYOffset[toOriginY];\n            } else {\n                toOriginY -= 0.5;\n            }\n            offsetY = toOriginY - fromOriginY;\n            if (offsetX || offsetY) {\n                dim = this._getTransformedDimensions();\n                x = point.x + offsetX * dim.x;\n                y = point.y + offsetY * dim.y;\n            }\n            return new fabric.Point(x, y);\n        },\n        /**\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToCenterPoint: function(point, originX, originY) {\n            var p = this.translateToGivenOrigin(point, originX, originY, \"center\", \"center\");\n            if (this.angle) {\n                return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));\n            }\n            return p;\n        },\n        /**\n     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)\n     * @param {fabric.Point} center The point which corresponds to center of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToOriginPoint: function(center, originX, originY) {\n            var p = this.translateToGivenOrigin(center, \"center\", \"center\", originX, originY);\n            if (this.angle) {\n                return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));\n            }\n            return p;\n        },\n        /**\n     * Returns the real center coordinates of the object\n     * @return {fabric.Point}\n     */ getCenterPoint: function() {\n            var leftTop = new fabric.Point(this.left, this.top);\n            return this.translateToCenterPoint(leftTop, this.originX, this.originY);\n        },\n        /**\n     * Returns the coordinates of the object based on center coordinates\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @return {fabric.Point}\n     */ // getOriginPoint: function(center) {\n        //   return this.translateToOriginPoint(center, this.originX, this.originY);\n        // },\n        /**\n     * Returns the coordinates of the object as if it has a different origin\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ getPointByOrigin: function(originX, originY) {\n            var center = this.getCenterPoint();\n            return this.translateToOriginPoint(center, originX, originY);\n        },\n        /**\n     * Returns the point in local coordinates\n     * @param {fabric.Point} point The point relative to the global coordinate system\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ toLocalPoint: function(point, originX, originY) {\n            var center = this.getCenterPoint(), p, p2;\n            if (typeof originX !== \"undefined\" && typeof originY !== \"undefined\") {\n                p = this.translateToGivenOrigin(center, \"center\", \"center\", originX, originY);\n            } else {\n                p = new fabric.Point(this.left, this.top);\n            }\n            p2 = new fabric.Point(point.x, point.y);\n            if (this.angle) {\n                p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));\n            }\n            return p2.subtractEquals(p);\n        },\n        /**\n     * Returns the point in global coordinates\n     * @param {fabric.Point} The point relative to the local coordinate system\n     * @return {fabric.Point}\n     */ // toGlobalPoint: function(point) {\n        //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));\n        // },\n        /**\n     * Sets the position of the object taking into consideration the object's origin\n     * @param {fabric.Point} pos The new position of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {void}\n     */ setPositionByOrigin: function(pos, originX, originY) {\n            var center = this.translateToCenterPoint(pos, originX, originY), position = this.translateToOriginPoint(center, this.originX, this.originY);\n            this.set(\"left\", position.x);\n            this.set(\"top\", position.y);\n        },\n        /**\n     * @param {String} to One of 'left', 'center', 'right'\n     */ adjustPosition: function(to) {\n            var angle = degreesToRadians(this.angle), hypotFull = this.getScaledWidth(), xFull = fabric.util.cos(angle) * hypotFull, yFull = fabric.util.sin(angle) * hypotFull, offsetFrom, offsetTo;\n            //TODO: this function does not consider mixed situation like top, center.\n            if (typeof this.originX === \"string\") {\n                offsetFrom = originXOffset[this.originX];\n            } else {\n                offsetFrom = this.originX - 0.5;\n            }\n            if (typeof to === \"string\") {\n                offsetTo = originXOffset[to];\n            } else {\n                offsetTo = to - 0.5;\n            }\n            this.left += xFull * (offsetTo - offsetFrom);\n            this.top += yFull * (offsetTo - offsetFrom);\n            this.setCoords();\n            this.originX = to;\n        },\n        /**\n     * Sets the origin/position of the object to it's center point\n     * @private\n     * @return {void}\n     */ _setOriginToCenter: function() {\n            this._originalOriginX = this.originX;\n            this._originalOriginY = this.originY;\n            var center = this.getCenterPoint();\n            this.originX = \"center\";\n            this.originY = \"center\";\n            this.left = center.x;\n            this.top = center.y;\n        },\n        /**\n     * Resets the origin/position of the object to it's original origin\n     * @private\n     * @return {void}\n     */ _resetOrigin: function() {\n            var originPoint = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY);\n            this.originX = this._originalOriginX;\n            this.originY = this._originalOriginY;\n            this.left = originPoint.x;\n            this.top = originPoint.y;\n            this._originalOriginX = null;\n            this._originalOriginY = null;\n        },\n        /**\n     * @private\n     */ _getLeftTopCoords: function() {\n            return this.translateToOriginPoint(this.getCenterPoint(), \"left\", \"top\");\n        }\n    });\n})();\n(function() {\n    function arrayFromCoords(coords) {\n        return [\n            new fabric.Point(coords.tl.x, coords.tl.y),\n            new fabric.Point(coords.tr.x, coords.tr.y),\n            new fabric.Point(coords.br.x, coords.br.y),\n            new fabric.Point(coords.bl.x, coords.bl.y)\n        ];\n    }\n    var util = fabric.util, degreesToRadians = util.degreesToRadians, multiplyMatrices = util.multiplyTransformMatrices, transformPoint = util.transformPoint;\n    util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Describe object's corner position in canvas element coordinates.\n     * properties are depending on control keys and padding the main controls.\n     * each property is an object with x, y and corner.\n     * The `corner` property contains in a similar manner the 4 points of the\n     * interactive area of the corner.\n     * The coordinates depends from the controls positionHandler and are used\n     * to draw and locate controls\n     * @memberOf fabric.Object.prototype\n     */ oCoords: null,\n        /**\n     * Describe object's corner position in canvas object absolute coordinates\n     * properties are tl,tr,bl,br and describe the four main corner.\n     * each property is an object with x, y, instance of Fabric.Point.\n     * The coordinates depends from this properties: width, height, scaleX, scaleY\n     * skewX, skewY, angle, strokeWidth, top, left.\n     * Those coordinates are useful to understand where an object is. They get updated\n     * with oCoords but they do not need to be updated when zoom or panning change.\n     * The coordinates get updated with @method setCoords.\n     * You can calculate them without updating with @method calcACoords();\n     * @memberOf fabric.Object.prototype\n     */ aCoords: null,\n        /**\n     * Describe object's corner position in canvas element coordinates.\n     * includes padding. Used of object detection.\n     * set and refreshed with setCoords.\n     * @memberOf fabric.Object.prototype\n     */ lineCoords: null,\n        /**\n     * storage for object transform matrix\n     */ ownMatrixCache: null,\n        /**\n     * storage for object full transform matrix\n     */ matrixCache: null,\n        /**\n     * custom controls interface\n     * controls are added by default_controls.js\n     */ controls: {},\n        /**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * @param {Boolean} absolute will return aCoords if true or lineCoords\n     * @return {Object} {tl, tr, br, bl} points\n     */ _getCoords: function(absolute, calculate) {\n            if (calculate) {\n                return absolute ? this.calcACoords() : this.calcLineCoords();\n            }\n            if (!this.aCoords || !this.lineCoords) {\n                this.setCoords(true);\n            }\n            return absolute ? this.aCoords : this.lineCoords;\n        },\n        /**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * The coords are returned in an array.\n     * @return {Array} [tl, tr, br, bl] of points\n     */ getCoords: function(absolute, calculate) {\n            return arrayFromCoords(this._getCoords(absolute, calculate));\n        },\n        /**\n     * Checks if object intersects with an area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with an area formed by 2 points\n     */ intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {\n            var coords = this.getCoords(absolute, calculate), intersection = fabric.Intersection.intersectPolygonRectangle(coords, pointTL, pointBR);\n            return intersection.status === \"Intersection\";\n        },\n        /**\n     * Checks if object intersects with another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with another object\n     */ intersectsWithObject: function(other, absolute, calculate) {\n            var intersection = fabric.Intersection.intersectPolygonPolygon(this.getCoords(absolute, calculate), other.getCoords(absolute, calculate));\n            return intersection.status === \"Intersection\" || other.isContainedWithinObject(this, absolute, calculate) || this.isContainedWithinObject(other, absolute, calculate);\n        },\n        /**\n     * Checks if object is fully contained within area of another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area of another object\n     */ isContainedWithinObject: function(other, absolute, calculate) {\n            var points = this.getCoords(absolute, calculate), otherCoords = absolute ? other.aCoords : other.lineCoords, i = 0, lines = other._getImageLines(otherCoords);\n            for(; i < 4; i++){\n                if (!other.containsPoint(points[i], lines)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        /**\n     * Checks if object is fully contained within area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area formed by 2 points\n     */ isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {\n            var boundingRect = this.getBoundingRect(absolute, calculate);\n            return boundingRect.left >= pointTL.x && boundingRect.left + boundingRect.width <= pointBR.x && boundingRect.top >= pointTL.y && boundingRect.top + boundingRect.height <= pointBR.y;\n        },\n        /**\n     * Checks if point is inside the object\n     * @param {fabric.Point} point Point to check against\n     * @param {Object} [lines] object returned from @method _getImageLines\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if point is inside the object\n     */ containsPoint: function(point, lines, absolute, calculate) {\n            var coords = this._getCoords(absolute, calculate), lines = lines || this._getImageLines(coords), xPoints = this._findCrossPoints(point, lines);\n            // if xPoints is odd then point is inside the object\n            return xPoints !== 0 && xPoints % 2 === 1;\n        },\n        /**\n     * Checks if object is contained within the canvas with current viewportTransform\n     * the check is done stopping at first point that appears on screen\n     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords\n     * @return {Boolean} true if object is fully or partially contained within canvas\n     */ isOnScreen: function(calculate) {\n            if (!this.canvas) {\n                return false;\n            }\n            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;\n            var points = this.getCoords(true, calculate);\n            // if some point is on screen, the object is on screen.\n            if (points.some(function(point) {\n                return point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y;\n            })) {\n                return true;\n            }\n            // no points on screen, check intersection with absolute coordinates\n            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {\n                return true;\n            }\n            return this._containsCenterOfCanvas(pointTL, pointBR, calculate);\n        },\n        /**\n     * Checks if the object contains the midpoint between canvas extremities\n     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen\n     * @private\n     * @param {Fabric.Point} pointTL Top Left point\n     * @param {Fabric.Point} pointBR Top Right point\n     * @param {Boolean} calculate use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if the object contains the point\n     */ _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {\n            // worst case scenario the object is so big that contains the screen\n            var centerPoint = {\n                x: (pointTL.x + pointBR.x) / 2,\n                y: (pointTL.y + pointBR.y) / 2\n            };\n            if (this.containsPoint(centerPoint, null, true, calculate)) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Checks if object is partially contained within the canvas with current viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is partially contained within canvas\n     */ isPartiallyOnScreen: function(calculate) {\n            if (!this.canvas) {\n                return false;\n            }\n            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;\n            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {\n                return true;\n            }\n            var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {\n                return (point.x >= pointBR.x || point.x <= pointTL.x) && (point.y >= pointBR.y || point.y <= pointTL.y);\n            });\n            return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);\n        },\n        /**\n     * Method that returns an object with the object edges in it, given the coordinates of the corners\n     * @private\n     * @param {Object} oCoords Coordinates of the object corners\n     */ _getImageLines: function(oCoords) {\n            var lines = {\n                topline: {\n                    o: oCoords.tl,\n                    d: oCoords.tr\n                },\n                rightline: {\n                    o: oCoords.tr,\n                    d: oCoords.br\n                },\n                bottomline: {\n                    o: oCoords.br,\n                    d: oCoords.bl\n                },\n                leftline: {\n                    o: oCoords.bl,\n                    d: oCoords.tl\n                }\n            };\n            // // debugging\n            // if (this.canvas.contextTop) {\n            //   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n            // }\n            return lines;\n        },\n        /**\n     * Helper method to determine how many cross points are between the 4 object edges\n     * and the horizontal line determined by a point on canvas\n     * @private\n     * @param {fabric.Point} point Point to check\n     * @param {Object} lines Coordinates of the object being evaluated\n     */ // remove yi, not used but left code here just in case.\n        _findCrossPoints: function(point, lines) {\n            var b1, b2, a1, a2, xi, xcount = 0, iLine;\n            for(var lineKey in lines){\n                iLine = lines[lineKey];\n                // optimisation 1: line below point. no cross\n                if (iLine.o.y < point.y && iLine.d.y < point.y) {\n                    continue;\n                }\n                // optimisation 2: line above point. no cross\n                if (iLine.o.y >= point.y && iLine.d.y >= point.y) {\n                    continue;\n                }\n                // optimisation 3: vertical line case\n                if (iLine.o.x === iLine.d.x && iLine.o.x >= point.x) {\n                    xi = iLine.o.x;\n                // yi = point.y;\n                } else {\n                    b1 = 0;\n                    b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);\n                    a1 = point.y - b1 * point.x;\n                    a2 = iLine.o.y - b2 * iLine.o.x;\n                    xi = -(a1 - a2) / (b1 - b2);\n                // yi = a1 + b1 * xi;\n                }\n                // dont count xi < point.x cases\n                if (xi >= point.x) {\n                    xcount += 1;\n                }\n                // optimisation 4: specific for square images\n                if (xcount === 2) {\n                    break;\n                }\n            }\n            return xcount;\n        },\n        /**\n     * Returns coordinates of object's bounding rectangle (left, top, width, height)\n     * the box is intended as aligned to axis of canvas.\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords\n     * @return {Object} Object with left, top, width, height properties\n     */ getBoundingRect: function(absolute, calculate) {\n            var coords = this.getCoords(absolute, calculate);\n            return util.makeBoundingBoxFromPoints(coords);\n        },\n        /**\n     * Returns width of an object's bounding box counting transformations\n     * before 2.0 it was named getWidth();\n     * @return {Number} width value\n     */ getScaledWidth: function() {\n            return this._getTransformedDimensions().x;\n        },\n        /**\n     * Returns height of an object bounding box counting transformations\n     * before 2.0 it was named getHeight();\n     * @return {Number} height value\n     */ getScaledHeight: function() {\n            return this._getTransformedDimensions().y;\n        },\n        /**\n     * Makes sure the scale is valid and modifies it if necessary\n     * @private\n     * @param {Number} value\n     * @return {Number}\n     */ _constrainScale: function(value) {\n            if (Math.abs(value) < this.minScaleLimit) {\n                if (value < 0) {\n                    return -this.minScaleLimit;\n                } else {\n                    return this.minScaleLimit;\n                }\n            } else if (value === 0) {\n                return 0.0001;\n            }\n            return value;\n        },\n        /**\n     * Scales an object (equally by x and y)\n     * @param {Number} value Scale factor\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scale: function(value) {\n            this._set(\"scaleX\", value);\n            this._set(\"scaleY\", value);\n            return this.setCoords();\n        },\n        /**\n     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New width value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scaleToWidth: function(value, absolute) {\n            // adjust to bounding rect factor so that rotated shapes would fit as well\n            var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();\n            return this.scale(value / this.width / boundingRectFactor);\n        },\n        /**\n     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New height value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scaleToHeight: function(value, absolute) {\n            // adjust to bounding rect factor so that rotated shapes would fit as well\n            var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();\n            return this.scale(value / this.height / boundingRectFactor);\n        },\n        calcLineCoords: function() {\n            var vpt = this.getViewportTransform(), padding = this.padding, angle = degreesToRadians(this.angle), cos = util.cos(angle), sin = util.sin(angle), cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP, cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();\n            var lineCoords = {\n                tl: transformPoint(aCoords.tl, vpt),\n                tr: transformPoint(aCoords.tr, vpt),\n                bl: transformPoint(aCoords.bl, vpt),\n                br: transformPoint(aCoords.br, vpt)\n            };\n            if (padding) {\n                lineCoords.tl.x -= cosPMinusSinP;\n                lineCoords.tl.y -= cosPSinP;\n                lineCoords.tr.x += cosPSinP;\n                lineCoords.tr.y -= cosPMinusSinP;\n                lineCoords.bl.x -= cosPSinP;\n                lineCoords.bl.y += cosPMinusSinP;\n                lineCoords.br.x += cosPMinusSinP;\n                lineCoords.br.y += cosPSinP;\n            }\n            return lineCoords;\n        },\n        calcOCoords: function() {\n            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), vpt = this.getViewportTransform(), startMatrix = multiplyMatrices(vpt, translateMatrix), finalMatrix = multiplyMatrices(startMatrix, rotateMatrix), finalMatrix = multiplyMatrices(finalMatrix, [\n                1 / vpt[0],\n                0,\n                0,\n                1 / vpt[3],\n                0,\n                0\n            ]), dim = this._calculateCurrentDimensions(), coords = {};\n            this.forEachControl(function(control, key, fabricObject) {\n                coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);\n            });\n            // debug code\n            // var canvas = this.canvas;\n            // setTimeout(function() {\n            //   canvas.contextTop.clearRect(0, 0, 700, 700);\n            //   canvas.contextTop.fillStyle = 'green';\n            //   Object.keys(coords).forEach(function(key) {\n            //     var control = coords[key];\n            //     canvas.contextTop.fillRect(control.x, control.y, 3, 3);\n            //   });\n            // }, 50);\n            return coords;\n        },\n        calcACoords: function() {\n            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix), dim = this._getTransformedDimensions(), w = dim.x / 2, h = dim.y / 2;\n            return {\n                // corners\n                tl: transformPoint({\n                    x: -w,\n                    y: -h\n                }, finalMatrix),\n                tr: transformPoint({\n                    x: w,\n                    y: -h\n                }, finalMatrix),\n                bl: transformPoint({\n                    x: -w,\n                    y: h\n                }, finalMatrix),\n                br: transformPoint({\n                    x: w,\n                    y: h\n                }, finalMatrix)\n            };\n        },\n        /**\n     * Sets corner and controls position coordinates based on current angle, width and height, left and top.\n     * oCoords are used to find the corners\n     * aCoords are used to quickly find an object on the canvas\n     * lineCoords are used to quickly find object during pointer events.\n     * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}\n     *\n     * @param {Boolean} [skipCorners] skip calculation of oCoords.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setCoords: function(skipCorners) {\n            this.aCoords = this.calcACoords();\n            // in case we are in a group, for how the inner group target check works,\n            // lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.\n            this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();\n            if (skipCorners) {\n                return this;\n            }\n            // set coordinates of the draggable boxes in the corners used to scale/rotate the image\n            this.oCoords = this.calcOCoords();\n            this._setCornerCoords && this._setCornerCoords();\n            return this;\n        },\n        /**\n     * calculate rotation matrix of an object\n     * @return {Array} rotation matrix for the object\n     */ _calcRotateMatrix: function() {\n            return util.calcRotateMatrix(this);\n        },\n        /**\n     * calculate the translation matrix for an object transform\n     * @return {Array} rotation matrix for the object\n     */ _calcTranslateMatrix: function() {\n            var center = this.getCenterPoint();\n            return [\n                1,\n                0,\n                0,\n                1,\n                center.x,\n                center.y\n            ];\n        },\n        transformMatrixKey: function(skipGroup) {\n            var sep = \"_\", prefix = \"\";\n            if (!skipGroup && this.group) {\n                prefix = this.group.transformMatrixKey(skipGroup) + sep;\n            }\n            ;\n            return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY + sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY + sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;\n        },\n        /**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties.\n     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations\n     * There are some situation in which this is useful to avoid the fake rotation.\n     * @return {Array} transform matrix for the object\n     */ calcTransformMatrix: function(skipGroup) {\n            var matrix = this.calcOwnMatrix();\n            if (skipGroup || !this.group) {\n                return matrix;\n            }\n            var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});\n            if (cache.key === key) {\n                return cache.value;\n            }\n            if (this.group) {\n                matrix = multiplyMatrices(this.group.calcTransformMatrix(false), matrix);\n            }\n            cache.key = key;\n            cache.value = matrix;\n            return matrix;\n        },\n        /**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties, this matrix does not include the group transformation\n     * @return {Array} transform matrix for the object\n     */ calcOwnMatrix: function() {\n            var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});\n            if (cache.key === key) {\n                return cache.value;\n            }\n            var tMatrix = this._calcTranslateMatrix(), options = {\n                angle: this.angle,\n                translateX: tMatrix[4],\n                translateY: tMatrix[5],\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                skewX: this.skewX,\n                skewY: this.skewY,\n                flipX: this.flipX,\n                flipY: this.flipY\n            };\n            cache.key = key;\n            cache.value = util.composeMatrix(options);\n            return cache.value;\n        },\n        /*\n     * Calculate object dimensions from its properties\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */ _getNonTransformedDimensions: function() {\n            var strokeWidth = this.strokeWidth, w = this.width + strokeWidth, h = this.height + strokeWidth;\n            return {\n                x: w,\n                y: h\n            };\n        },\n        /*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param {Number} skewX, a value to override current skewX\n     * @param {Number} skewY, a value to override current skewY\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */ _getTransformedDimensions: function(skewX, skewY) {\n            if (typeof skewX === \"undefined\") {\n                skewX = this.skewX;\n            }\n            if (typeof skewY === \"undefined\") {\n                skewY = this.skewY;\n            }\n            var dimensions, dimX, dimY, noSkew = skewX === 0 && skewY === 0;\n            if (this.strokeUniform) {\n                dimX = this.width;\n                dimY = this.height;\n            } else {\n                dimensions = this._getNonTransformedDimensions();\n                dimX = dimensions.x;\n                dimY = dimensions.y;\n            }\n            if (noSkew) {\n                return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);\n            }\n            var bbox = util.sizeAfterTransform(dimX, dimY, {\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                skewX: skewX,\n                skewY: skewY\n            });\n            return this._finalizeDimensions(bbox.x, bbox.y);\n        },\n        /*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param Number width width of the bbox\n     * @param Number height height of the bbox\n     * @private\n     * @return {Object} .x finalized width dimension\n     * @return {Object} .y finalized height dimension\n     */ _finalizeDimensions: function(width, height) {\n            return this.strokeUniform ? {\n                x: width + this.strokeWidth,\n                y: height + this.strokeWidth\n            } : {\n                x: width,\n                y: height\n            };\n        },\n        /*\n     * Calculate object dimensions for controls box, including padding and canvas zoom.\n     * and active selection\n     * private\n     */ _calculateCurrentDimensions: function() {\n            var vpt = this.getViewportTransform(), dim = this._getTransformedDimensions(), p = transformPoint(dim, vpt, true);\n            return p.scalarAdd(2 * this.padding);\n        }\n    });\n})();\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * Moves an object to the bottom of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ sendToBack: function() {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);\n        } else if (this.canvas) {\n            this.canvas.sendToBack(this);\n        }\n        return this;\n    },\n    /**\n   * Moves an object to the top of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ bringToFront: function() {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);\n        } else if (this.canvas) {\n            this.canvas.bringToFront(this);\n        }\n        return this;\n    },\n    /**\n   * Moves an object down in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ sendBackwards: function(intersecting) {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);\n        } else if (this.canvas) {\n            this.canvas.sendBackwards(this, intersecting);\n        }\n        return this;\n    },\n    /**\n   * Moves an object up in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ bringForward: function(intersecting) {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);\n        } else if (this.canvas) {\n            this.canvas.bringForward(this, intersecting);\n        }\n        return this;\n    },\n    /**\n   * Moves an object to specified level in stack of drawn objects\n   * @param {Number} index New position of object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ moveTo: function(index) {\n        if (this.group && this.group.type !== \"activeSelection\") {\n            fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);\n        } else if (this.canvas) {\n            this.canvas.moveTo(this, index);\n        }\n        return this;\n    }\n});\n/* _TO_SVG_START_ */ (function() {\n    function getSvgColorString(prop, value) {\n        if (!value) {\n            return prop + \": none; \";\n        } else if (value.toLive) {\n            return prop + \": url(#SVGID_\" + value.id + \"); \";\n        } else {\n            var color = new fabric.Color(value), str = prop + \": \" + color.toRgb() + \"; \", opacity = color.getAlpha();\n            if (opacity !== 1) {\n                //change the color in rgb + opacity\n                str += prop + \"-opacity: \" + opacity.toString() + \"; \";\n            }\n            return str;\n        }\n    }\n    var toFixed = fabric.util.toFixed;\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */ getSvgStyles: function(skipShadow) {\n            var fillRule = this.fillRule ? this.fillRule : \"nonzero\", strokeWidth = this.strokeWidth ? this.strokeWidth : \"0\", strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(\" \") : \"none\", strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : \"0\", strokeLineCap = this.strokeLineCap ? this.strokeLineCap : \"butt\", strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : \"miter\", strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : \"4\", opacity = typeof this.opacity !== \"undefined\" ? this.opacity : \"1\", visibility = this.visible ? \"\" : \" visibility: hidden;\", filter = skipShadow ? \"\" : this.getSvgFilter(), fill = getSvgColorString(\"fill\", this.fill), stroke = getSvgColorString(\"stroke\", this.stroke);\n            return [\n                stroke,\n                \"stroke-width: \",\n                strokeWidth,\n                \"; \",\n                \"stroke-dasharray: \",\n                strokeDashArray,\n                \"; \",\n                \"stroke-linecap: \",\n                strokeLineCap,\n                \"; \",\n                \"stroke-dashoffset: \",\n                strokeDashOffset,\n                \"; \",\n                \"stroke-linejoin: \",\n                strokeLineJoin,\n                \"; \",\n                \"stroke-miterlimit: \",\n                strokeMiterLimit,\n                \"; \",\n                fill,\n                \"fill-rule: \",\n                fillRule,\n                \"; \",\n                \"opacity: \",\n                opacity,\n                \";\",\n                filter,\n                visibility\n            ].join(\"\");\n        },\n        /**\n     * Returns styles-string for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.\n     * @return {String}\n     */ getSvgSpanStyles: function(style, useWhiteSpace) {\n            var term = \"; \";\n            var fontFamily = style.fontFamily ? \"font-family: \" + (style.fontFamily.indexOf(\"'\") === -1 && style.fontFamily.indexOf('\"') === -1 ? \"'\" + style.fontFamily + \"'\" : style.fontFamily) + term : \"\";\n            var strokeWidth = style.strokeWidth ? \"stroke-width: \" + style.strokeWidth + term : \"\", fontFamily = fontFamily, fontSize = style.fontSize ? \"font-size: \" + style.fontSize + \"px\" + term : \"\", fontStyle = style.fontStyle ? \"font-style: \" + style.fontStyle + term : \"\", fontWeight = style.fontWeight ? \"font-weight: \" + style.fontWeight + term : \"\", fill = style.fill ? getSvgColorString(\"fill\", style.fill) : \"\", stroke = style.stroke ? getSvgColorString(\"stroke\", style.stroke) : \"\", textDecoration = this.getSvgTextDecoration(style), deltaY = style.deltaY ? \"baseline-shift: \" + -style.deltaY + \"; \" : \"\";\n            if (textDecoration) {\n                textDecoration = \"text-decoration: \" + textDecoration + term;\n            }\n            return [\n                stroke,\n                strokeWidth,\n                fontFamily,\n                fontSize,\n                fontStyle,\n                fontWeight,\n                textDecoration,\n                fill,\n                deltaY,\n                useWhiteSpace ? \"white-space: pre; \" : \"\"\n            ].join(\"\");\n        },\n        /**\n     * Returns text-decoration property for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @return {String}\n     */ getSvgTextDecoration: function(style) {\n            return [\n                \"overline\",\n                \"underline\",\n                \"line-through\"\n            ].filter(function(decoration) {\n                return style[decoration.replace(\"-\", \"\")];\n            }).join(\" \");\n        },\n        /**\n     * Returns filter for svg shadow\n     * @return {String}\n     */ getSvgFilter: function() {\n            return this.shadow ? \"filter: url(#SVGID_\" + this.shadow.id + \");\" : \"\";\n        },\n        /**\n     * Returns id attribute for svg output\n     * @return {String}\n     */ getSvgCommons: function() {\n            return [\n                this.id ? 'id=\"' + this.id + '\" ' : \"\",\n                this.clipPath ? 'clip-path=\"url(#' + this.clipPath.clipPathId + ')\" ' : \"\"\n            ].join(\"\");\n        },\n        /**\n     * Returns transform-string for svg-export\n     * @param {Boolean} use the full transform or the single object one.\n     * @return {String}\n     */ getSvgTransform: function(full, additionalTransform) {\n            var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(), svgTransform = 'transform=\"' + fabric.util.matrixToSVG(transform);\n            return svgTransform + (additionalTransform || \"\") + '\" ';\n        },\n        _setSVGBg: function(textBgRects) {\n            if (this.backgroundColor) {\n                var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n                textBgRects.push(\"\t\t<rect \", this._getFillAttributes(this.backgroundColor), ' x=\"', toFixed(-this.width / 2, NUM_FRACTION_DIGITS), '\" y=\"', toFixed(-this.height / 2, NUM_FRACTION_DIGITS), '\" width=\"', toFixed(this.width, NUM_FRACTION_DIGITS), '\" height=\"', toFixed(this.height, NUM_FRACTION_DIGITS), '\"></rect>\\n');\n            }\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            return this._createBaseSVGMarkup(this._toSVG(reviver), {\n                reviver: reviver\n            });\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), {\n                reviver: reviver\n            });\n        },\n        /**\n     * @private\n     */ _createBaseClipPathSVGMarkup: function(objectMarkup, options) {\n            options = options || {};\n            var reviver = options.reviver, additionalTransform = options.additionalTransform || \"\", commonPieces = [\n                this.getSvgTransform(true, additionalTransform),\n                this.getSvgCommons()\n            ].join(\"\"), // insert commons in the markup, style and svgCommons\n            index = objectMarkup.indexOf(\"COMMON_PARTS\");\n            objectMarkup[index] = commonPieces;\n            return reviver ? reviver(objectMarkup.join(\"\")) : objectMarkup.join(\"\");\n        },\n        /**\n     * @private\n     */ _createBaseSVGMarkup: function(objectMarkup, options) {\n            options = options || {};\n            var noStyle = options.noStyle, reviver = options.reviver, styleInfo = noStyle ? \"\" : 'style=\"' + this.getSvgStyles() + '\" ', shadowInfo = options.withShadow ? 'style=\"' + this.getSvgFilter() + '\" ' : \"\", clipPath = this.clipPath, vectorEffect = this.strokeUniform ? 'vector-effect=\"non-scaling-stroke\" ' : \"\", absoluteClipPath = clipPath && clipPath.absolutePositioned, stroke = this.stroke, fill = this.fill, shadow = this.shadow, commonPieces, markup = [], clipPathMarkup, // insert commons in the markup, style and svgCommons\n            index = objectMarkup.indexOf(\"COMMON_PARTS\"), additionalTransform = options.additionalTransform;\n            if (clipPath) {\n                clipPath.clipPathId = \"CLIPPATH_\" + fabric.Object.__uid++;\n                clipPathMarkup = '<clipPath id=\"' + clipPath.clipPathId + '\" >\\n' + clipPath.toClipPathSVG(reviver) + \"</clipPath>\\n\";\n            }\n            if (absoluteClipPath) {\n                markup.push(\"<g \", shadowInfo, this.getSvgCommons(), \" >\\n\");\n            }\n            markup.push(\"<g \", this.getSvgTransform(false), !absoluteClipPath ? shadowInfo + this.getSvgCommons() : \"\", \" >\\n\");\n            commonPieces = [\n                styleInfo,\n                vectorEffect,\n                noStyle ? \"\" : this.addPaintOrder(),\n                \" \",\n                additionalTransform ? 'transform=\"' + additionalTransform + '\" ' : \"\"\n            ].join(\"\");\n            objectMarkup[index] = commonPieces;\n            if (fill && fill.toLive) {\n                markup.push(fill.toSVG(this));\n            }\n            if (stroke && stroke.toLive) {\n                markup.push(stroke.toSVG(this));\n            }\n            if (shadow) {\n                markup.push(shadow.toSVG(this));\n            }\n            if (clipPath) {\n                markup.push(clipPathMarkup);\n            }\n            markup.push(objectMarkup.join(\"\"));\n            markup.push(\"</g>\\n\");\n            absoluteClipPath && markup.push(\"</g>\\n\");\n            return reviver ? reviver(markup.join(\"\")) : markup.join(\"\");\n        },\n        addPaintOrder: function() {\n            return this.paintFirst !== \"fill\" ? ' paint-order=\"' + this.paintFirst + '\" ' : \"\";\n        }\n    });\n})();\n/* _TO_SVG_END_ */ (function() {\n    var extend = fabric.util.object.extend, originalSet = \"stateProperties\";\n    /*\n    Depends on `stateProperties`\n  */ function saveProps(origin, destination, props) {\n        var tmpObj = {}, deep = true;\n        props.forEach(function(prop) {\n            tmpObj[prop] = origin[prop];\n        });\n        extend(origin[destination], tmpObj, deep);\n    }\n    function _isEqual(origValue, currentValue, firstPass) {\n        if (origValue === currentValue) {\n            // if the objects are identical, return\n            return true;\n        } else if (Array.isArray(origValue)) {\n            if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {\n                return false;\n            }\n            for(var i = 0, len = origValue.length; i < len; i++){\n                if (!_isEqual(origValue[i], currentValue[i])) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (origValue && typeof origValue === \"object\") {\n            var keys = Object.keys(origValue), key;\n            if (!currentValue || typeof currentValue !== \"object\" || !firstPass && keys.length !== Object.keys(currentValue).length) {\n                return false;\n            }\n            for(var i = 0, len = keys.length; i < len; i++){\n                key = keys[i];\n                // since clipPath is in the statefull cache list and the clipPath objects\n                // would be iterated as an object, this would lead to possible infinite recursion\n                // we do not want to compare those.\n                if (key === \"canvas\" || key === \"group\") {\n                    continue;\n                }\n                if (!_isEqual(origValue[key], currentValue[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Returns true if object state (one of its state properties) was changed\n     * @param {String} [propertySet] optional name for the set of property we want to save\n     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called\n     */ hasStateChanged: function(propertySet) {\n            propertySet = propertySet || originalSet;\n            var dashedPropertySet = \"_\" + propertySet;\n            if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {\n                return true;\n            }\n            return !_isEqual(this[dashedPropertySet], this, true);\n        },\n        /**\n     * Saves state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */ saveState: function(options) {\n            var propertySet = options && options.propertySet || originalSet, destination = \"_\" + propertySet;\n            if (!this[destination]) {\n                return this.setupState(options);\n            }\n            saveProps(this, destination, this[propertySet]);\n            if (options && options.stateProperties) {\n                saveProps(this, destination, options.stateProperties);\n            }\n            return this;\n        },\n        /**\n     * Setups state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */ setupState: function(options) {\n            options = options || {};\n            var propertySet = options.propertySet || originalSet;\n            options.propertySet = propertySet;\n            this[\"_\" + propertySet] = {};\n            this.saveState(options);\n            return this;\n        }\n    });\n})();\n(function() {\n    var degreesToRadians = fabric.util.degreesToRadians;\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Determines which corner has been clicked\n     * @private\n     * @param {Object} pointer The pointer indicating the mouse position\n     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found\n     */ _findTargetCorner: function(pointer, forTouch) {\n            // objects in group, anykind, are not self modificable,\n            // must not return an hovered corner.\n            if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) {\n                return false;\n            }\n            var ex = pointer.x, ey = pointer.y, xPoints, lines, keys = Object.keys(this.oCoords), j = keys.length - 1, i;\n            this.__corner = 0;\n            // cycle in reverse order so we pick first the one on top\n            for(; j >= 0; j--){\n                i = keys[j];\n                if (!this.isControlVisible(i)) {\n                    continue;\n                }\n                lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);\n                // // debugging\n                //\n                // this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n                xPoints = this._findCrossPoints({\n                    x: ex,\n                    y: ey\n                }, lines);\n                if (xPoints !== 0 && xPoints % 2 === 1) {\n                    this.__corner = i;\n                    return i;\n                }\n            }\n            return false;\n        },\n        /**\n     * Calls a function for each control. The function gets called,\n     * with the control, the object that is calling the iterator and the control's key\n     * @param {Function} fn function to iterate over the controls over\n     */ forEachControl: function(fn) {\n            for(var i in this.controls){\n                fn(this.controls[i], i, this);\n            }\n            ;\n        },\n        /**\n     * Sets the coordinates of the draggable boxes in the corners of\n     * the image used to scale/rotate it.\n     * note: if we would switch to ROUND corner area, all of this would disappear.\n     * everything would resolve to a single point and a pythagorean theorem for the distance\n     * @private\n     */ _setCornerCoords: function() {\n            var coords = this.oCoords;\n            for(var control in coords){\n                var controlObject = this.controls[control];\n                coords[control].corner = controlObject.calcCornerCoords(this.angle, this.cornerSize, coords[control].x, coords[control].y, false);\n                coords[control].touchCorner = controlObject.calcCornerCoords(this.angle, this.touchCornerSize, coords[control].x, coords[control].y, true);\n            }\n        },\n        /**\n     * Draws a colored layer behind the object, inside its selection borders.\n     * Requires public options: padding, selectionBackgroundColor\n     * this function is called when the context is transformed\n     * has checks to be skipped when the object is on a staticCanvas\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawSelectionBackground: function(ctx) {\n            if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) {\n                return this;\n            }\n            ctx.save();\n            var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(), vpt = this.canvas.viewportTransform;\n            ctx.translate(center.x, center.y);\n            ctx.scale(1 / vpt[0], 1 / vpt[3]);\n            ctx.rotate(degreesToRadians(this.angle));\n            ctx.fillStyle = this.selectionBackgroundColor;\n            ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws borders of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawBorders: function(ctx, styleOverride) {\n            styleOverride = styleOverride || {};\n            var wh = this._calculateCurrentDimensions(), strokeWidth = this.borderScaleFactor, width = wh.x + strokeWidth, height = wh.y + strokeWidth, hasControls = typeof styleOverride.hasControls !== \"undefined\" ? styleOverride.hasControls : this.hasControls, shouldStroke = false;\n            ctx.save();\n            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;\n            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);\n            ctx.strokeRect(-width / 2, -height / 2, width, height);\n            if (hasControls) {\n                ctx.beginPath();\n                this.forEachControl(function(control, key, fabricObject) {\n                    // in this moment, the ctx is centered on the object.\n                    // width and height of the above function are the size of the bbox.\n                    if (control.withConnection && control.getVisibility(fabricObject, key)) {\n                        // reset movement for each control\n                        shouldStroke = true;\n                        ctx.moveTo(control.x * width, control.y * height);\n                        ctx.lineTo(control.x * width + control.offsetX, control.y * height + control.offsetY);\n                    }\n                });\n                if (shouldStroke) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws borders of an object's bounding box when it is inside a group.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {object} options object representing current object parameters\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawBordersInGroup: function(ctx, options, styleOverride) {\n            styleOverride = styleOverride || {};\n            var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options), strokeWidth = this.strokeWidth, strokeUniform = this.strokeUniform, borderScaleFactor = this.borderScaleFactor, width = bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor, height = bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;\n            ctx.save();\n            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);\n            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;\n            ctx.strokeRect(-width / 2, -height / 2, width, height);\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws corners of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: cornerSize, padding\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawControls: function(ctx, styleOverride) {\n            styleOverride = styleOverride || {};\n            ctx.save();\n            var retinaScaling = this.canvas.getRetinaScaling(), matrix, p;\n            ctx.setTransform(retinaScaling, 0, 0, retinaScaling, 0, 0);\n            ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;\n            if (!this.transparentCorners) {\n                ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;\n            }\n            this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray);\n            this.setCoords();\n            if (this.group) {\n                // fabricJS does not really support drawing controls inside groups,\n                // this piece of code here helps having at least the control in places.\n                // If an application needs to show some objects as selected because of some UI state\n                // can still call Object._renderControls() on any object they desire, independently of groups.\n                // using no padding, circular controls and hiding the rotating cursor is higly suggested,\n                matrix = this.group.calcTransformMatrix();\n            }\n            this.forEachControl(function(control, key, fabricObject) {\n                p = fabricObject.oCoords[key];\n                if (control.getVisibility(fabricObject, key)) {\n                    if (matrix) {\n                        p = fabric.util.transformPoint(p, matrix);\n                    }\n                    control.render(ctx, p.x, p.y, styleOverride, fabricObject);\n                }\n            });\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Returns true if the specified control is visible, false otherwise.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @returns {Boolean} true if the specified control is visible, false otherwise\n     */ isControlVisible: function(controlKey) {\n            return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);\n        },\n        /**\n     * Sets the visibility of the specified control.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @param {Boolean} visible true to set the specified control visible, false otherwise\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setControlVisible: function(controlKey, visible) {\n            if (!this._controlsVisibility) {\n                this._controlsVisibility = {};\n            }\n            this._controlsVisibility[controlKey] = visible;\n            return this;\n        },\n        /**\n     * Sets the visibility state of object controls.\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it\n     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it\n     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it\n     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it\n     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it\n     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it\n     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it\n     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it\n     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setControlsVisibility: function(options) {\n            options || (options = {});\n            for(var p in options){\n                this.setControlVisible(p, options[p]);\n            }\n            return this;\n        },\n        /**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to deselect this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */ onDeselect: function() {\n        // implemented by sub-classes, as needed.\n        },\n        /**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to select this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */ onSelect: function() {\n        // implemented by sub-classes, as needed.\n        }\n    });\n})();\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Animation duration (in ms) for fx* methods\n   * @type Number\n   * @default\n   */ FX_DURATION: 500,\n    /**\n   * Centers object horizontally with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxCenterObjectH: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.left,\n            endValue: this.getCenter().left,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"left\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                object.setCoords();\n                onComplete();\n            }\n        });\n    },\n    /**\n   * Centers object vertically with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxCenterObjectV: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.top,\n            endValue: this.getCenter().top,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"top\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                object.setCoords();\n                onComplete();\n            }\n        });\n    },\n    /**\n   * Same as `fabric.Canvas#remove` but animated\n   * @param {fabric.Object} object Object to remove\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxRemove: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.opacity,\n            endValue: 0,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"opacity\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                _this.remove(object);\n                onComplete();\n            }\n        });\n    }\n});\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * Animates object's properties\n   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)\n   * @param {Number|Object} value Value to animate property to (if string was given first) or options object\n   * @return {fabric.Object} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}\n   * @return {fabric.AnimationContext | fabric.AnimationContext[]} animation context (or an array if passed multiple properties)\n   *\n   * As object — multiple properties\n   *\n   * object.animate({ left: ..., top: ... });\n   * object.animate({ left: ..., top: ... }, { duration: ... });\n   *\n   * As string — one property\n   *\n   * object.animate('left', ...);\n   * object.animate('left', { duration: ... });\n   *\n   */ animate: function() {\n        if (arguments[0] && typeof arguments[0] === \"object\") {\n            var propsToAnimate = [], prop, skipCallbacks, out = [];\n            for(prop in arguments[0]){\n                propsToAnimate.push(prop);\n            }\n            for(var i = 0, len = propsToAnimate.length; i < len; i++){\n                prop = propsToAnimate[i];\n                skipCallbacks = i !== len - 1;\n                out.push(this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks));\n            }\n            return out;\n        } else {\n            return this._animate.apply(this, arguments);\n        }\n    },\n    /**\n   * @private\n   * @param {String} property Property to animate\n   * @param {String} to Value to animate to\n   * @param {Object} [options] Options object\n   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked\n   */ _animate: function(property, to, options, skipCallbacks) {\n        var _this = this, propPair;\n        to = to.toString();\n        if (!options) {\n            options = {};\n        } else {\n            options = fabric.util.object.clone(options);\n        }\n        if (~property.indexOf(\".\")) {\n            propPair = property.split(\".\");\n        }\n        var propIsColor = _this.colorProperties.indexOf(property) > -1 || propPair && _this.colorProperties.indexOf(propPair[1]) > -1;\n        var currentValue = propPair ? this.get(propPair[0])[propPair[1]] : this.get(property);\n        if (!(\"from\" in options)) {\n            options.from = currentValue;\n        }\n        if (!propIsColor) {\n            if (~to.indexOf(\"=\")) {\n                to = currentValue + parseFloat(to.replace(\"=\", \"\"));\n            } else {\n                to = parseFloat(to);\n            }\n        }\n        var _options = {\n            target: this,\n            startValue: options.from,\n            endValue: to,\n            byValue: options.by,\n            easing: options.easing,\n            duration: options.duration,\n            abort: options.abort && function(value, valueProgress, timeProgress) {\n                return options.abort.call(_this, value, valueProgress, timeProgress);\n            },\n            onChange: function(value, valueProgress, timeProgress) {\n                if (propPair) {\n                    _this[propPair[0]][propPair[1]] = value;\n                } else {\n                    _this.set(property, value);\n                }\n                if (skipCallbacks) {\n                    return;\n                }\n                options.onChange && options.onChange(value, valueProgress, timeProgress);\n            },\n            onComplete: function(value, valueProgress, timeProgress) {\n                if (skipCallbacks) {\n                    return;\n                }\n                _this.setCoords();\n                options.onComplete && options.onComplete(value, valueProgress, timeProgress);\n            }\n        };\n        if (propIsColor) {\n            return fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);\n        } else {\n            return fabric.util.animate(_options);\n        }\n    }\n});\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, coordProps = {\n        x1: 1,\n        x2: 1,\n        y1: 1,\n        y2: 1\n    };\n    if (fabric.Line) {\n        fabric.warn(\"fabric.Line is already defined\");\n        return;\n    }\n    /**\n   * Line class\n   * @class fabric.Line\n   * @extends fabric.Object\n   * @see {@link fabric.Line#initialize} for constructor definition\n   */ fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"line\",\n        /**\n     * x value or first line edge\n     * @type Number\n     * @default\n     */ x1: 0,\n        /**\n     * y value or first line edge\n     * @type Number\n     * @default\n     */ y1: 0,\n        /**\n     * x value or second line edge\n     * @type Number\n     * @default\n     */ x2: 0,\n        /**\n     * y value or second line edge\n     * @type Number\n     * @default\n     */ y2: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"x1\", \"x2\", \"y1\", \"y2\"),\n        /**\n     * Constructor\n     * @param {Array} [points] Array of points\n     * @param {Object} [options] Options object\n     * @return {fabric.Line} thisArg\n     */ initialize: function(points, options) {\n            if (!points) {\n                points = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            this.callSuper(\"initialize\", options);\n            this.set(\"x1\", points[0]);\n            this.set(\"y1\", points[1]);\n            this.set(\"x2\", points[2]);\n            this.set(\"y2\", points[3]);\n            this._setWidthHeight(options);\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options\n     */ _setWidthHeight: function(options) {\n            options || (options = {});\n            this.width = Math.abs(this.x2 - this.x1);\n            this.height = Math.abs(this.y2 - this.y1);\n            this.left = \"left\" in options ? options.left : this._getLeftToOriginX();\n            this.top = \"top\" in options ? options.top : this._getTopToOriginY();\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            if (typeof coordProps[key] !== \"undefined\") {\n                this._setWidthHeight();\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.\n     */ _getLeftToOriginX: makeEdgeToOriginGetter({\n            origin: \"originX\",\n            axis1: \"x1\",\n            axis2: \"x2\",\n            dimension: \"width\"\n        }, {\n            nearest: \"left\",\n            center: \"center\",\n            farthest: \"right\"\n        }),\n        /**\n     * @private\n     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.\n     */ _getTopToOriginY: makeEdgeToOriginGetter({\n            origin: \"originY\",\n            axis1: \"y1\",\n            axis2: \"y2\",\n            dimension: \"height\"\n        }, {\n            nearest: \"top\",\n            center: \"center\",\n            farthest: \"bottom\"\n        }),\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            var p = this.calcLinePoints();\n            ctx.moveTo(p.x1, p.y1);\n            ctx.lineTo(p.x2, p.y2);\n            ctx.lineWidth = this.strokeWidth;\n            // TODO: test this\n            // make sure setting \"fill\" changes color of a line\n            // (by copying fillStyle to strokeStyle, since line is stroked, not filled)\n            var origStrokeStyle = ctx.strokeStyle;\n            ctx.strokeStyle = this.stroke || ctx.fillStyle;\n            this.stroke && this._renderStroke(ctx);\n            ctx.strokeStyle = origStrokeStyle;\n        },\n        /**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */ _findCenterFromElement: function() {\n            return {\n                x: (this.x1 + this.x2) / 2,\n                y: (this.y1 + this.y2) / 2\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), this.calcLinePoints());\n        },\n        /*\n     * Calculate object dimensions from its properties\n     * @private\n     */ _getNonTransformedDimensions: function() {\n            var dim = this.callSuper(\"_getNonTransformedDimensions\");\n            if (this.strokeLineCap === \"butt\") {\n                if (this.width === 0) {\n                    dim.y -= this.strokeWidth;\n                }\n                if (this.height === 0) {\n                    dim.x -= this.strokeWidth;\n                }\n            }\n            return dim;\n        },\n        /**\n     * Recalculates line points given width and height\n     * @private\n     */ calcLinePoints: function() {\n            var xMult = this.x1 <= this.x2 ? -1 : 1, yMult = this.y1 <= this.y2 ? -1 : 1, x1 = xMult * this.width * 0.5, y1 = yMult * this.height * 0.5, x2 = xMult * this.width * -0.5, y2 = yMult * this.height * -0.5;\n            return {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var p = this.calcLinePoints();\n            return [\n                \"<line \",\n                \"COMMON_PARTS\",\n                'x1=\"',\n                p.x1,\n                '\" y1=\"',\n                p.y1,\n                '\" x2=\"',\n                p.x2,\n                '\" y2=\"',\n                p.y2,\n                '\" />\\n'\n            ];\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})\n   * @static\n   * @memberOf fabric.Line\n   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement\n   */ fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x1 y1 x2 y2\".split(\" \"));\n    /**\n   * Returns fabric.Line instance from an SVG element\n   * @static\n   * @memberOf fabric.Line\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] callback function invoked after parsing\n   */ fabric.Line.fromElement = function(element, callback, options) {\n        options = options || {};\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES), points = [\n            parsedAttributes.x1 || 0,\n            parsedAttributes.y1 || 0,\n            parsedAttributes.x2 || 0,\n            parsedAttributes.y2 || 0\n        ];\n        callback(new fabric.Line(points, extend(parsedAttributes, options)));\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Line instance from an object representation\n   * @static\n   * @memberOf fabric.Line\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */ fabric.Line.fromObject = function(object, callback) {\n        function _callback(instance) {\n            delete instance.points;\n            callback && callback(instance);\n        }\n        ;\n        var options = clone(object, true);\n        options.points = [\n            object.x1,\n            object.y1,\n            object.x2,\n            object.y2\n        ];\n        fabric.Object._fromObject(\"Line\", options, _callback, \"points\");\n    };\n    /**\n   * Produces a function that calculates distance from canvas edge to Line origin.\n   */ function makeEdgeToOriginGetter(propertyNames, originValues) {\n        var origin = propertyNames.origin, axis1 = propertyNames.axis1, axis2 = propertyNames.axis2, dimension = propertyNames.dimension, nearest = originValues.nearest, center = originValues.center, farthest = originValues.farthest;\n        return function() {\n            switch(this.get(origin)){\n                case nearest:\n                    return Math.min(this.get(axis1), this.get(axis2));\n                case center:\n                    return Math.min(this.get(axis1), this.get(axis2)) + 0.5 * this.get(dimension);\n                case farthest:\n                    return Math.max(this.get(axis1), this.get(axis2));\n            }\n        };\n    }\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), degreesToRadians = fabric.util.degreesToRadians;\n    if (fabric.Circle) {\n        fabric.warn(\"fabric.Circle is already defined.\");\n        return;\n    }\n    /**\n   * Circle class\n   * @class fabric.Circle\n   * @extends fabric.Object\n   * @see {@link fabric.Circle#initialize} for constructor definition\n   */ fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"circle\",\n        /**\n     * Radius of this circle\n     * @type Number\n     * @default\n     */ radius: 0,\n        /**\n     * degrees of start of the circle.\n     * probably will change to degrees in next major version\n     * @type Number 0 - 359\n     * @default 0\n     */ startAngle: 0,\n        /**\n     * End angle of the circle\n     * probably will change to degrees in next major version\n     * @type Number 1 - 360\n     * @default 360\n     */ endAngle: 360,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"radius\", \"startAngle\", \"endAngle\"),\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Circle} thisArg\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            if (key === \"radius\") {\n                this.setRadius(value);\n            }\n            return this;\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"radius\",\n                \"startAngle\",\n                \"endAngle\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var svgString, x = 0, y = 0, angle = (this.endAngle - this.startAngle) % 360;\n            if (angle === 0) {\n                svgString = [\n                    \"<circle \",\n                    \"COMMON_PARTS\",\n                    'cx=\"' + x + '\" cy=\"' + y + '\" ',\n                    'r=\"',\n                    this.radius,\n                    '\" />\\n'\n                ];\n            } else {\n                var start = degreesToRadians(this.startAngle), end = degreesToRadians(this.endAngle), radius = this.radius, startX = fabric.util.cos(start) * radius, startY = fabric.util.sin(start) * radius, endX = fabric.util.cos(end) * radius, endY = fabric.util.sin(end) * radius, largeFlag = angle > 180 ? \"1\" : \"0\";\n                svgString = [\n                    '<path d=\"M ' + startX + \" \" + startY,\n                    \" A \" + radius + \" \" + radius,\n                    \" 0 \",\n                    +largeFlag + \" 1\",\n                    \" \" + endX + \" \" + endY,\n                    '\" ',\n                    \"COMMON_PARTS\",\n                    \" />\\n\"\n                ];\n            }\n            return svgString;\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            ctx.arc(0, 0, this.radius, degreesToRadians(this.startAngle), degreesToRadians(this.endAngle), false);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRadiusX: function() {\n            return this.get(\"radius\") * this.get(\"scaleX\");\n        },\n        /**\n     * Returns vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRadiusY: function() {\n            return this.get(\"radius\") * this.get(\"scaleY\");\n        },\n        /**\n     * Sets radius of an object (and updates width accordingly)\n     * @return {fabric.Circle} thisArg\n     */ setRadius: function(value) {\n            this.radius = value;\n            return this.set(\"width\", value * 2).set(\"height\", value * 2);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})\n   * @static\n   * @memberOf fabric.Circle\n   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement\n   */ fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"cx cy r\".split(\" \"));\n    /**\n   * Returns {@link fabric.Circle} instance from an SVG element\n   * @static\n   * @memberOf fabric.Circle\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @param {Object} [options] Options object\n   * @throws {Error} If value of `r` attribute is missing or invalid\n   */ fabric.Circle.fromElement = function(element, callback) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);\n        if (!isValidRadius(parsedAttributes)) {\n            throw new Error(\"value of `r` attribute is required and can not be negative\");\n        }\n        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;\n        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;\n        callback(new fabric.Circle(parsedAttributes));\n    };\n    /**\n   * @private\n   */ function isValidRadius(attributes) {\n        return \"radius\" in attributes && attributes.radius >= 0;\n    }\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Circle} instance from an object representation\n   * @static\n   * @memberOf fabric.Circle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */ fabric.Circle.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Circle\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Triangle) {\n        fabric.warn(\"fabric.Triangle is already defined\");\n        return;\n    }\n    /**\n   * Triangle class\n   * @class fabric.Triangle\n   * @extends fabric.Object\n   * @return {fabric.Triangle} thisArg\n   * @see {@link fabric.Triangle#initialize} for constructor definition\n   */ fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"triangle\",\n        /**\n     * Width is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */ width: 100,\n        /**\n     * Height is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */ height: 100,\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            var widthBy2 = this.width / 2, heightBy2 = this.height / 2;\n            ctx.beginPath();\n            ctx.moveTo(-widthBy2, heightBy2);\n            ctx.lineTo(0, -heightBy2);\n            ctx.lineTo(widthBy2, heightBy2);\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var widthBy2 = this.width / 2, heightBy2 = this.height / 2, points = [\n                -widthBy2 + \" \" + heightBy2,\n                \"0 \" + -heightBy2,\n                widthBy2 + \" \" + heightBy2\n            ].join(\",\");\n            return [\n                \"<polygon \",\n                \"COMMON_PARTS\",\n                'points=\"',\n                points,\n                '\" />'\n            ];\n        }\n    });\n    /**\n   * Returns {@link fabric.Triangle} instance from an object representation\n   * @static\n   * @memberOf fabric.Triangle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */ fabric.Triangle.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Triangle\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), piBy2 = Math.PI * 2;\n    if (fabric.Ellipse) {\n        fabric.warn(\"fabric.Ellipse is already defined.\");\n        return;\n    }\n    /**\n   * Ellipse class\n   * @class fabric.Ellipse\n   * @extends fabric.Object\n   * @return {fabric.Ellipse} thisArg\n   * @see {@link fabric.Ellipse#initialize} for constructor definition\n   */ fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"ellipse\",\n        /**\n     * Horizontal radius\n     * @type Number\n     * @default\n     */ rx: 0,\n        /**\n     * Vertical radius\n     * @type Number\n     * @default\n     */ ry: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {fabric.Ellipse} thisArg\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            this.set(\"rx\", options && options.rx || 0);\n            this.set(\"ry\", options && options.ry || 0);\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Ellipse} thisArg\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            switch(key){\n                case \"rx\":\n                    this.rx = value;\n                    this.set(\"width\", value * 2);\n                    break;\n                case \"ry\":\n                    this.ry = value;\n                    this.set(\"height\", value * 2);\n                    break;\n            }\n            return this;\n        },\n        /**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRx: function() {\n            return this.get(\"rx\") * this.get(\"scaleX\");\n        },\n        /**\n     * Returns Vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRy: function() {\n            return this.get(\"ry\") * this.get(\"scaleY\");\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"rx\",\n                \"ry\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            return [\n                \"<ellipse \",\n                \"COMMON_PARTS\",\n                'cx=\"0\" cy=\"0\" ',\n                'rx=\"',\n                this.rx,\n                '\" ry=\"',\n                this.ry,\n                '\" />\\n'\n            ];\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            ctx.save();\n            ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);\n            ctx.arc(0, 0, this.rx, 0, piBy2, false);\n            ctx.restore();\n            this._renderPaintInOrder(ctx);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})\n   * @static\n   * @memberOf fabric.Ellipse\n   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement\n   */ fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"cx cy rx ry\".split(\" \"));\n    /**\n   * Returns {@link fabric.Ellipse} instance from an SVG element\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @return {fabric.Ellipse}\n   */ fabric.Ellipse.fromElement = function(element, callback) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);\n        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;\n        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;\n        callback(new fabric.Ellipse(parsedAttributes));\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Ellipse} instance from an object representation\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */ fabric.Ellipse.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Ellipse\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend;\n    if (fabric.Rect) {\n        fabric.warn(\"fabric.Rect is already defined\");\n        return;\n    }\n    /**\n   * Rectangle class\n   * @class fabric.Rect\n   * @extends fabric.Object\n   * @return {fabric.Rect} thisArg\n   * @see {@link fabric.Rect#initialize} for constructor definition\n   */ fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {\n        /**\n     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"rect\",\n        /**\n     * Horizontal border radius\n     * @type Number\n     * @default\n     */ rx: 0,\n        /**\n     * Vertical border radius\n     * @type Number\n     * @default\n     */ ry: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            this._initRxRy();\n        },\n        /**\n     * Initializes rx/ry attributes\n     * @private\n     */ _initRxRy: function() {\n            if (this.rx && !this.ry) {\n                this.ry = this.rx;\n            } else if (this.ry && !this.rx) {\n                this.rx = this.ry;\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            // 1x1 case (used in spray brush) optimization was removed because\n            // with caching and higher zoom level this makes more damage than help\n            var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0, ry = this.ry ? Math.min(this.ry, this.height / 2) : 0, w = this.width, h = this.height, x = -this.width / 2, y = -this.height / 2, isRounded = rx !== 0 || ry !== 0, /* \"magic number\" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */ k = 1 - 0.5522847498;\n            ctx.beginPath();\n            ctx.moveTo(x + rx, y);\n            ctx.lineTo(x + w - rx, y);\n            isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);\n            ctx.lineTo(x + w, y + h - ry);\n            isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);\n            ctx.lineTo(x + rx, y + h);\n            isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);\n            ctx.lineTo(x, y + ry);\n            isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"rx\",\n                \"ry\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var x = -this.width / 2, y = -this.height / 2;\n            return [\n                \"<rect \",\n                \"COMMON_PARTS\",\n                'x=\"',\n                x,\n                '\" y=\"',\n                y,\n                '\" rx=\"',\n                this.rx,\n                '\" ry=\"',\n                this.ry,\n                '\" width=\"',\n                this.width,\n                '\" height=\"',\n                this.height,\n                '\" />\\n'\n            ];\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)\n   * @static\n   * @memberOf fabric.Rect\n   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement\n   */ fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y rx ry width height\".split(\" \"));\n    /**\n   * Returns {@link fabric.Rect} instance from an SVG element\n   * @static\n   * @memberOf fabric.Rect\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Rect.fromElement = function(element, callback, options) {\n        if (!element) {\n            return callback(null);\n        }\n        options = options || {};\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);\n        parsedAttributes.left = parsedAttributes.left || 0;\n        parsedAttributes.top = parsedAttributes.top || 0;\n        parsedAttributes.height = parsedAttributes.height || 0;\n        parsedAttributes.width = parsedAttributes.width || 0;\n        var rect = new fabric.Rect(extend(options ? fabric.util.object.clone(options) : {}, parsedAttributes));\n        rect.visible = rect.visible && rect.width > 0 && rect.height > 0;\n        callback(rect);\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Rect} instance from an object representation\n   * @static\n   * @memberOf fabric.Rect\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created\n   */ fabric.Rect.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Rect\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, min = fabric.util.array.min, max = fabric.util.array.max, toFixed = fabric.util.toFixed, projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;\n    if (fabric.Polyline) {\n        fabric.warn(\"fabric.Polyline is already defined\");\n        return;\n    }\n    /**\n   * Polyline class\n   * @class fabric.Polyline\n   * @extends fabric.Object\n   * @see {@link fabric.Polyline#initialize} for constructor definition\n   */ fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"polyline\",\n        /**\n     * Points array\n     * @type Array\n     * @default\n     */ points: null,\n        /**\n     * WARNING: Feature in progress\n     * Calculate the exact bounding box taking in account strokeWidth on acute angles\n     * this will be turned to true by default on fabric 6.0\n     * maybe will be left in as an optimization since calculations may be slow\n     * @deprecated\n     * @type Boolean\n     * @default false\n     */ exactBoundingBox: false,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"points\"),\n        /**\n     * Constructor\n     * @param {Array} points Array of points (where each point is an object with x and y)\n     * @param {Object} [options] Options object\n     * @return {fabric.Polyline} thisArg\n     * @example\n     * var poly = new fabric.Polyline([\n     *     { x: 10, y: 10 },\n     *     { x: 50, y: 30 },\n     *     { x: 40, y: 70 },\n     *     { x: 60, y: 50 },\n     *     { x: 100, y: 150 },\n     *     { x: 40, y: 100 }\n     *   ], {\n     *   stroke: 'red',\n     *   left: 100,\n     *   top: 100\n     * });\n     */ initialize: function(points, options) {\n            options = options || {};\n            this.points = points || [];\n            this.callSuper(\"initialize\", options);\n            this._setPositionDimensions(options);\n        },\n        /**\n     * @private\n     */ _projectStrokeOnPoints: function() {\n            return projectStrokeOnPoints(this.points, this, true);\n        },\n        _setPositionDimensions: function(options) {\n            var calcDim = this._calcDimensions(options), correctLeftTop, correctSize = this.exactBoundingBox ? this.strokeWidth : 0;\n            this.width = calcDim.width - correctSize;\n            this.height = calcDim.height - correctSize;\n            if (!options.fromSVG) {\n                correctLeftTop = this.translateToGivenOrigin({\n                    // this looks bad, but is one way to keep it optional for now.\n                    x: calcDim.left - this.strokeWidth / 2 + correctSize / 2,\n                    y: calcDim.top - this.strokeWidth / 2 + correctSize / 2\n                }, \"left\", \"top\", this.originX, this.originY);\n            }\n            if (typeof options.left === \"undefined\") {\n                this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;\n            }\n            if (typeof options.top === \"undefined\") {\n                this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;\n            }\n            this.pathOffset = {\n                x: calcDim.left + this.width / 2 + correctSize / 2,\n                y: calcDim.top + this.height / 2 + correctSize / 2\n            };\n        },\n        /**\n     * Calculate the polygon min and max point from points array,\n     * returning an object with left, top, width, height to measure the\n     * polygon size\n     * @return {Object} object.left X coordinate of the polygon leftmost point\n     * @return {Object} object.top Y coordinate of the polygon topmost point\n     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point\n     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point\n     * @private\n     */ _calcDimensions: function() {\n            var points = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, minX = min(points, \"x\") || 0, minY = min(points, \"y\") || 0, maxX = max(points, \"x\") || 0, maxY = max(points, \"y\") || 0, width = maxX - minX, height = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: width,\n                height: height\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), {\n                points: this.points.concat()\n            });\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            for(var i = 0, len = this.points.length; i < len; i++){\n                points.push(toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), \",\", toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), \" \");\n            }\n            return [\n                \"<\" + this.type + \" \",\n                \"COMMON_PARTS\",\n                'points=\"',\n                points.join(\"\"),\n                '\" />\\n'\n            ];\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ commonRender: function(ctx) {\n            var point, len = this.points.length, x = this.pathOffset.x, y = this.pathOffset.y;\n            if (!len || isNaN(this.points[len - 1].y)) {\n                // do not draw if no points or odd points\n                // NaN comes from parseFloat of a empty string in parser\n                return false;\n            }\n            ctx.beginPath();\n            ctx.moveTo(this.points[0].x - x, this.points[0].y - y);\n            for(var i = 0; i < len; i++){\n                point = this.points[i];\n                ctx.lineTo(point.x - x, point.y - y);\n            }\n            return true;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            if (!this.commonRender(ctx)) {\n                return;\n            }\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance\n     */ complexity: function() {\n            return this.get(\"points\").length;\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})\n   * @static\n   * @memberOf fabric.Polyline\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement\n   */ fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\n    /**\n   * Returns fabric.Polyline instance from an SVG element\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {SVGElement} element Element to parser\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Polyline.fromElementGenerator = function(_class) {\n        return function(element, callback, options) {\n            if (!element) {\n                return callback(null);\n            }\n            options || (options = {});\n            var points = fabric.parsePointsAttribute(element.getAttribute(\"points\")), parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);\n            parsedAttributes.fromSVG = true;\n            callback(new fabric[_class](points, extend(parsedAttributes, options)));\n        };\n    };\n    fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator(\"Polyline\");\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polyline instance from an object representation\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */ fabric.Polyline.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Polyline\", object, callback, \"points\");\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;\n    if (fabric.Polygon) {\n        fabric.warn(\"fabric.Polygon is already defined\");\n        return;\n    }\n    /**\n   * Polygon class\n   * @class fabric.Polygon\n   * @extends fabric.Polyline\n   * @see {@link fabric.Polygon#initialize} for constructor definition\n   */ fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"polygon\",\n        /**\n     * @private\n     */ _projectStrokeOnPoints: function() {\n            return projectStrokeOnPoints(this.points, this);\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            if (!this.commonRender(ctx)) {\n                return;\n            }\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)\n   * @static\n   * @memberOf fabric.Polygon\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement\n   */ fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\n    /**\n   * Returns {@link fabric.Polygon} instance from an SVG element\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator(\"Polygon\");\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polygon instance from an object representation\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   * @return {void}\n   */ fabric.Polygon.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Polygon\", object, callback, \"points\");\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), min = fabric.util.array.min, max = fabric.util.array.max, extend = fabric.util.object.extend, clone = fabric.util.object.clone, _toString = Object.prototype.toString, toFixed = fabric.util.toFixed;\n    if (fabric.Path) {\n        fabric.warn(\"fabric.Path is already defined\");\n        return;\n    }\n    /**\n   * Path class\n   * @class fabric.Path\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}\n   * @see {@link fabric.Path#initialize} for constructor definition\n   */ fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"path\",\n        /**\n     * Array of path points\n     * @type Array\n     * @default\n     */ path: null,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"path\", \"fillRule\"),\n        stateProperties: fabric.Object.prototype.stateProperties.concat(\"path\"),\n        /**\n     * Constructor\n     * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n     * @param {Object} [options] Options object\n     * @return {fabric.Path} thisArg\n     */ initialize: function(path, options) {\n            options = clone(options || {});\n            delete options.path;\n            this.callSuper(\"initialize\", options);\n            this._setPath(path || [], options);\n        },\n        /**\n    * @private\n    * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n    * @param {Object} [options] Options object\n    */ _setPath: function(path, options) {\n            var fromArray = _toString.call(path) === \"[object Array]\";\n            this.path = fabric.util.makePathSimpler(fromArray ? path : fabric.util.parsePath(path));\n            fabric.Polyline.prototype._setPositionDimensions.call(this, options || {});\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */ _renderPathCommands: function(ctx) {\n            var current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, controlX = 0, controlY = 0, l = -this.pathOffset.x, t = -this.pathOffset.y;\n            ctx.beginPath();\n            for(var i = 0, len = this.path.length; i < len; ++i){\n                current = this.path[i];\n                switch(current[0]){\n                    case \"L\":\n                        x = current[1];\n                        y = current[2];\n                        ctx.lineTo(x + l, y + t);\n                        break;\n                    case \"M\":\n                        x = current[1];\n                        y = current[2];\n                        subpathStartX = x;\n                        subpathStartY = y;\n                        ctx.moveTo(x + l, y + t);\n                        break;\n                    case \"C\":\n                        x = current[5];\n                        y = current[6];\n                        controlX = current[3];\n                        controlY = current[4];\n                        ctx.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n                        break;\n                    case \"Q\":\n                        ctx.quadraticCurveTo(current[1] + l, current[2] + t, current[3] + l, current[4] + t);\n                        x = current[3];\n                        y = current[4];\n                        controlX = current[1];\n                        controlY = current[2];\n                        break;\n                    case \"z\":\n                    case \"Z\":\n                        x = subpathStartX;\n                        y = subpathStartY;\n                        ctx.closePath();\n                        break;\n                }\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */ _render: function(ctx) {\n            this._renderPathCommands(ctx);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} string representation of an instance\n     */ toString: function() {\n            return \"#<fabric.Path (\" + this.complexity() + '): { \"top\": ' + this.top + ', \"left\": ' + this.left + \" }>\";\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), {\n                path: this.path.map(function(item) {\n                    return item.slice();\n                })\n            });\n        },\n        /**\n     * Returns dataless object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            var o = this.toObject([\n                \"sourcePath\"\n            ].concat(propertiesToInclude));\n            if (o.sourcePath) {\n                delete o.path;\n            }\n            return o;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var path = fabric.util.joinPath(this.path);\n            return [\n                \"<path \",\n                \"COMMON_PARTS\",\n                'd=\"',\n                path,\n                '\" stroke-linecap=\"round\" ',\n                \"/>\\n\"\n            ];\n        },\n        _getOffsetTransform: function() {\n            var digits = fabric.Object.NUM_FRACTION_DIGITS;\n            return \" translate(\" + toFixed(-this.pathOffset.x, digits) + \", \" + toFixed(-this.pathOffset.y, digits) + \")\";\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            var additionalTransform = this._getOffsetTransform();\n            return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                additionalTransform: additionalTransform\n            });\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            var additionalTransform = this._getOffsetTransform();\n            return this._createBaseSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                additionalTransform: additionalTransform\n            });\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns number representation of an instance complexity\n     * @return {Number} complexity of this instance\n     */ complexity: function() {\n            return this.path.length;\n        },\n        /**\n     * @private\n     */ _calcDimensions: function() {\n            var aX = [], aY = [], current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, bounds;\n            for(var i = 0, len = this.path.length; i < len; ++i){\n                current = this.path[i];\n                switch(current[0]){\n                    case \"L\":\n                        x = current[1];\n                        y = current[2];\n                        bounds = [];\n                        break;\n                    case \"M\":\n                        x = current[1];\n                        y = current[2];\n                        subpathStartX = x;\n                        subpathStartY = y;\n                        bounds = [];\n                        break;\n                    case \"C\":\n                        bounds = fabric.util.getBoundsOfCurve(x, y, current[1], current[2], current[3], current[4], current[5], current[6]);\n                        x = current[5];\n                        y = current[6];\n                        break;\n                    case \"Q\":\n                        bounds = fabric.util.getBoundsOfCurve(x, y, current[1], current[2], current[1], current[2], current[3], current[4]);\n                        x = current[3];\n                        y = current[4];\n                        break;\n                    case \"z\":\n                    case \"Z\":\n                        x = subpathStartX;\n                        y = subpathStartY;\n                        break;\n                }\n                bounds.forEach(function(point) {\n                    aX.push(point.x);\n                    aY.push(point.y);\n                });\n                aX.push(x);\n                aY.push(y);\n            }\n            var minX = min(aX) || 0, minY = min(aY) || 0, maxX = max(aX) || 0, maxY = max(aY) || 0, deltaX = maxX - minX, deltaY = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: deltaX,\n                height: deltaY\n            };\n        }\n    });\n    /**\n   * Creates an instance of fabric.Path from an object\n   * @static\n   * @memberOf fabric.Path\n   * @param {Object} object\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */ fabric.Path.fromObject = function(object, callback) {\n        if (typeof object.sourcePath === \"string\") {\n            var pathUrl = object.sourcePath;\n            fabric.loadSVGFromURL(pathUrl, function(elements) {\n                var path = elements[0];\n                path.setOptions(object);\n                callback && callback(path);\n            });\n        } else {\n            fabric.Object._fromObject(\"Path\", object, callback, \"path\");\n        }\n    };\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)\n   * @static\n   * @memberOf fabric.Path\n   * @see http://www.w3.org/TR/SVG/paths.html#PathElement\n   */ fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat([\n        \"d\"\n    ]);\n    /**\n   * Creates an instance of fabric.Path from an SVG <path> element\n   * @static\n   * @memberOf fabric.Path\n   * @param {SVGElement} element to parse\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   */ fabric.Path.fromElement = function(element, callback, options) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);\n        parsedAttributes.fromSVG = true;\n        callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));\n    };\n/* _FROM_SVG_END_ */ })( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), min = fabric.util.array.min, max = fabric.util.array.max;\n    if (fabric.Group) {\n        return;\n    }\n    /**\n   * Group class\n   * @class fabric.Group\n   * @extends fabric.Object\n   * @mixes fabric.Collection\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.Group#initialize} for constructor definition\n   */ fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"group\",\n        /**\n     * Width of stroke\n     * @type Number\n     * @default\n     */ strokeWidth: 0,\n        /**\n     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets\n     * @type Boolean\n     * @default\n     */ subTargetCheck: false,\n        /**\n     * Groups are container, do not render anything on theyr own, ence no cache properties\n     * @type Array\n     * @default\n     */ cacheProperties: [],\n        /**\n     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still\n     * available setting this boolean to true.\n     * @type Boolean\n     * @since 2.0.0\n     * @default\n     */ useSetOnGroup: false,\n        /**\n     * Constructor\n     * @param {Object} objects Group objects\n     * @param {Object} [options] Options object\n     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.\n     * @return {Object} thisArg\n     */ initialize: function(objects, options, isAlreadyGrouped) {\n            options = options || {};\n            this._objects = [];\n            // if objects enclosed in a group have been grouped already,\n            // we cannot change properties of objects.\n            // Thus we need to set options to group without objects,\n            isAlreadyGrouped && this.callSuper(\"initialize\", options);\n            this._objects = objects || [];\n            for(var i = this._objects.length; i--;){\n                this._objects[i].group = this;\n            }\n            if (!isAlreadyGrouped) {\n                var center = options && options.centerPoint;\n                // we want to set origins before calculating the bounding box.\n                // so that the topleft can be set with that in mind.\n                // if specific top and left are passed, are overwritten later\n                // with the callSuper('initialize', options)\n                if (options.originX !== undefined) {\n                    this.originX = options.originX;\n                }\n                if (options.originY !== undefined) {\n                    this.originY = options.originY;\n                }\n                // if coming from svg i do not want to calc bounds.\n                // i assume width and height are passed along options\n                center || this._calcBounds();\n                this._updateObjectsCoords(center);\n                delete options.centerPoint;\n                this.callSuper(\"initialize\", options);\n            } else {\n                this._updateObjectsACoords();\n            }\n            this.setCoords();\n        },\n        /**\n     * @private\n     */ _updateObjectsACoords: function() {\n            var skipControls = true;\n            for(var i = this._objects.length; i--;){\n                this._objects[i].setCoords(skipControls);\n            }\n        },\n        /**\n     * @private\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change\n     */ _updateObjectsCoords: function(center) {\n            var center = center || this.getCenterPoint();\n            for(var i = this._objects.length; i--;){\n                this._updateObjectCoords(this._objects[i], center);\n            }\n        },\n        /**\n     * @private\n     * @param {Object} object\n     * @param {fabric.Point} center, current center of group.\n     */ _updateObjectCoords: function(object, center) {\n            var objectLeft = object.left, objectTop = object.top, skipControls = true;\n            object.set({\n                left: objectLeft - center.x,\n                top: objectTop - center.y\n            });\n            object.group = this;\n            object.setCoords(skipControls);\n        },\n        /**\n     * Returns string represenation of a group\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.Group: (\" + this.complexity() + \")>\";\n        },\n        /**\n     * Adds an object to a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ addWithUpdate: function(object) {\n            var nested = !!this.group;\n            this._restoreObjectsState();\n            fabric.util.resetObjectTransform(this);\n            if (object) {\n                if (nested) {\n                    // if this group is inside another group, we need to pre transform the object\n                    fabric.util.removeTransformFromObject(object, this.group.calcTransformMatrix());\n                }\n                this._objects.push(object);\n                object.group = this;\n                object._set(\"canvas\", this.canvas);\n            }\n            this._calcBounds();\n            this._updateObjectsCoords();\n            this.dirty = true;\n            if (nested) {\n                this.group.addWithUpdate();\n            } else {\n                this.setCoords();\n            }\n            return this;\n        },\n        /**\n     * Removes an object from a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ removeWithUpdate: function(object) {\n            this._restoreObjectsState();\n            fabric.util.resetObjectTransform(this);\n            this.remove(object);\n            this._calcBounds();\n            this._updateObjectsCoords();\n            this.setCoords();\n            this.dirty = true;\n            return this;\n        },\n        /**\n     * @private\n     */ _onObjectAdded: function(object) {\n            this.dirty = true;\n            object.group = this;\n            object._set(\"canvas\", this.canvas);\n        },\n        /**\n     * @private\n     */ _onObjectRemoved: function(object) {\n            this.dirty = true;\n            delete object.group;\n        },\n        /**\n     * @private\n     */ _set: function(key, value) {\n            var i = this._objects.length;\n            if (this.useSetOnGroup) {\n                while(i--){\n                    this._objects[i].setOnGroup(key, value);\n                }\n            }\n            if (key === \"canvas\") {\n                while(i--){\n                    this._objects[i]._set(key, value);\n                }\n            }\n            fabric.Object.prototype._set.call(this, key, value);\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var _includeDefaultValues = this.includeDefaultValues;\n            var objsToObject = this._objects.filter(function(obj) {\n                return !obj.excludeFromExport;\n            }).map(function(obj) {\n                var originalDefaults = obj.includeDefaultValues;\n                obj.includeDefaultValues = _includeDefaultValues;\n                var _obj = obj.toObject(propertiesToInclude);\n                obj.includeDefaultValues = originalDefaults;\n                return _obj;\n            });\n            var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);\n            obj.objects = objsToObject;\n            return obj;\n        },\n        /**\n     * Returns object representation of an instance, in dataless mode.\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            var objsToObject, sourcePath = this.sourcePath;\n            if (sourcePath) {\n                objsToObject = sourcePath;\n            } else {\n                var _includeDefaultValues = this.includeDefaultValues;\n                objsToObject = this._objects.map(function(obj) {\n                    var originalDefaults = obj.includeDefaultValues;\n                    obj.includeDefaultValues = _includeDefaultValues;\n                    var _obj = obj.toDatalessObject(propertiesToInclude);\n                    obj.includeDefaultValues = originalDefaults;\n                    return _obj;\n                });\n            }\n            var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);\n            obj.objects = objsToObject;\n            return obj;\n        },\n        /**\n     * Renders instance on a given context\n     * @param {CanvasRenderingContext2D} ctx context to render instance on\n     */ render: function(ctx) {\n            this._transformDone = true;\n            this.callSuper(\"render\", ctx);\n            this._transformDone = false;\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group is already cached.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            var ownCache = fabric.Object.prototype.shouldCache.call(this);\n            if (ownCache) {\n                for(var i = 0, len = this._objects.length; i < len; i++){\n                    if (this._objects[i].willDrawShadow()) {\n                        this.ownCaching = false;\n                        return false;\n                    }\n                }\n            }\n            return ownCache;\n        },\n        /**\n     * Check if this object or a child object will cast a shadow\n     * @return {Boolean}\n     */ willDrawShadow: function() {\n            if (fabric.Object.prototype.willDrawShadow.call(this)) {\n                return true;\n            }\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                if (this._objects[i].willDrawShadow()) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */ isOnACache: function() {\n            return this.ownCaching || this.group && this.group.isOnACache();\n        },\n        /**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawObject: function(ctx) {\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                this._objects[i].render(ctx);\n            }\n            this._drawClipPath(ctx, this.clipPath);\n        },\n        /**\n     * Check if cache is dirty\n     */ isCacheDirty: function(skipCanvas) {\n            if (this.callSuper(\"isCacheDirty\", skipCanvas)) {\n                return true;\n            }\n            if (!this.statefullCache) {\n                return false;\n            }\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                if (this._objects[i].isCacheDirty(true)) {\n                    if (this._cacheCanvas) {\n                        // if this group has not a cache canvas there is nothing to clean\n                        var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;\n                        this._cacheContext.clearRect(-x / 2, -y / 2, x, y);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Restores original state of each of group objects (original state is that which was before group was created).\n     * if the nested boolean is true, the original state will be restored just for the\n     * first group and not for all the group chain\n     * @private\n     * @param {Boolean} nested tell the function to restore object state up to the parent group and not more\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ _restoreObjectsState: function() {\n            var groupMatrix = this.calcOwnMatrix();\n            this._objects.forEach(function(object) {\n                // instead of using _this = this;\n                fabric.util.addTransformToObject(object, groupMatrix);\n                delete object.group;\n                object.setCoords();\n            });\n            return this;\n        },\n        /**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ destroy: function() {\n            // when group is destroyed objects needs to get a repaint to be eventually\n            // displayed on canvas.\n            this._objects.forEach(function(object) {\n                object.set(\"dirty\", true);\n            });\n            return this._restoreObjectsState();\n        },\n        dispose: function() {\n            this.callSuper(\"dispose\");\n            this.forEachObject(function(object) {\n                object.dispose && object.dispose();\n            });\n            this._objects = [];\n        },\n        /**\n     * make a group an active selection, remove the group from canvas\n     * the group has to be on canvas for this to work.\n     * @return {fabric.ActiveSelection} thisArg\n     * @chainable\n     */ toActiveSelection: function() {\n            if (!this.canvas) {\n                return;\n            }\n            var objects = this._objects, canvas = this.canvas;\n            this._objects = [];\n            var options = this.toObject();\n            delete options.objects;\n            var activeSelection = new fabric.ActiveSelection([]);\n            activeSelection.set(options);\n            activeSelection.type = \"activeSelection\";\n            canvas.remove(this);\n            objects.forEach(function(object) {\n                object.group = activeSelection;\n                object.dirty = true;\n                canvas.add(object);\n            });\n            activeSelection.canvas = canvas;\n            activeSelection._objects = objects;\n            canvas._activeObject = activeSelection;\n            activeSelection.setCoords();\n            return activeSelection;\n        },\n        /**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ ungroupOnCanvas: function() {\n            return this._restoreObjectsState();\n        },\n        /**\n     * Sets coordinates of all objects inside group\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ setObjectsCoords: function() {\n            var skipControls = true;\n            this.forEachObject(function(object) {\n                object.setCoords(skipControls);\n            });\n            return this;\n        },\n        /**\n     * @private\n     */ _calcBounds: function(onlyWidthHeight) {\n            var aX = [], aY = [], o, prop, coords, props = [\n                \"tr\",\n                \"br\",\n                \"bl\",\n                \"tl\"\n            ], i = 0, iLen = this._objects.length, j, jLen = props.length;\n            for(; i < iLen; ++i){\n                o = this._objects[i];\n                coords = o.calcACoords();\n                for(j = 0; j < jLen; j++){\n                    prop = props[j];\n                    aX.push(coords[prop].x);\n                    aY.push(coords[prop].y);\n                }\n                o.aCoords = coords;\n            }\n            this._getBounds(aX, aY, onlyWidthHeight);\n        },\n        /**\n     * @private\n     */ _getBounds: function(aX, aY, onlyWidthHeight) {\n            var minXY = new fabric.Point(min(aX), min(aY)), maxXY = new fabric.Point(max(aX), max(aY)), top = minXY.y || 0, left = minXY.x || 0, width = maxXY.x - minXY.x || 0, height = maxXY.y - minXY.y || 0;\n            this.width = width;\n            this.height = height;\n            if (!onlyWidthHeight) {\n                // the bounding box always finds the topleft most corner.\n                // whatever is the group origin, we set up here the left/top position.\n                this.setPositionByOrigin({\n                    x: left,\n                    y: top\n                }, \"left\", \"top\");\n            }\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ _toSVG: function(reviver) {\n            var svgString = [\n                \"<g \",\n                \"COMMON_PARTS\",\n                \" >\\n\"\n            ];\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                svgString.push(\"\t\t\", this._objects[i].toSVG(reviver));\n            }\n            svgString.push(\"</g>\\n\");\n            return svgString;\n        },\n        /**\n     * Returns styles-string for svg-export, specific version for group\n     * @return {String}\n     */ getSvgStyles: function() {\n            var opacity = typeof this.opacity !== \"undefined\" && this.opacity !== 1 ? \"opacity: \" + this.opacity + \";\" : \"\", visibility = this.visible ? \"\" : \" visibility: hidden;\";\n            return [\n                opacity,\n                this.getSvgFilter(),\n                visibility\n            ].join(\"\");\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            var svgString = [];\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                svgString.push(\"\t\", this._objects[i].toClipPathSVG(reviver));\n            }\n            return this._createBaseClipPathSVGMarkup(svgString, {\n                reviver: reviver\n            });\n        }\n    });\n    /**\n   * Returns {@link fabric.Group} instance from an object representation\n   * @static\n   * @memberOf fabric.Group\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an group instance is created\n   */ fabric.Group.fromObject = function(object, callback) {\n        var objects = object.objects, options = fabric.util.object.clone(object, true);\n        delete options.objects;\n        if (typeof objects === \"string\") {\n            // it has to be an url or something went wrong.\n            fabric.loadSVGFromURL(objects, function(elements) {\n                var group = fabric.util.groupSVGElements(elements, object, objects);\n                group.set(options);\n                callback && callback(group);\n            });\n            return;\n        }\n        fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\n            var options = fabric.util.object.clone(object, true);\n            delete options.objects;\n            fabric.util.enlivenObjectEnlivables(object, options, function() {\n                callback && callback(new fabric.Group(enlivenedObjects, options, true));\n            });\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.ActiveSelection) {\n        return;\n    }\n    /**\n   * Group class\n   * @class fabric.ActiveSelection\n   * @extends fabric.Group\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.ActiveSelection#initialize} for constructor definition\n   */ fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"activeSelection\",\n        /**\n     * Constructor\n     * @param {Object} objects ActiveSelection objects\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(objects, options) {\n            options = options || {};\n            this._objects = objects || [];\n            for(var i = this._objects.length; i--;){\n                this._objects[i].group = this;\n            }\n            if (options.originX) {\n                this.originX = options.originX;\n            }\n            if (options.originY) {\n                this.originY = options.originY;\n            }\n            this._calcBounds();\n            this._updateObjectsCoords();\n            fabric.Object.prototype.initialize.call(this, options);\n            this.setCoords();\n        },\n        /**\n     * Change te activeSelection to a normal group,\n     * High level function that automatically adds it to canvas as\n     * active object. no events fired.\n     * @since 2.0.0\n     * @return {fabric.Group}\n     */ toGroup: function() {\n            var objects = this._objects.concat();\n            this._objects = [];\n            var options = fabric.Object.prototype.toObject.call(this);\n            var newGroup = new fabric.Group([]);\n            delete options.type;\n            newGroup.set(options);\n            objects.forEach(function(object) {\n                object.canvas.remove(object);\n                object.group = newGroup;\n            });\n            newGroup._objects = objects;\n            if (!this.canvas) {\n                return newGroup;\n            }\n            var canvas = this.canvas;\n            canvas.add(newGroup);\n            canvas._activeObject = newGroup;\n            newGroup.setCoords();\n            return newGroup;\n        },\n        /**\n     * If returns true, deselection is cancelled.\n     * @since 2.0.0\n     * @return {Boolean} [cancel]\n     */ onDeselect: function() {\n            this.destroy();\n            return false;\n        },\n        /**\n     * Returns string representation of a group\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.ActiveSelection: (\" + this.complexity() + \")>\";\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            return false;\n        },\n        /**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */ isOnACache: function() {\n            return false;\n        },\n        /**\n     * Renders controls and borders for the object\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     * @param {Object} [childrenOverride] properties to override the children overrides\n     */ _renderControls: function(ctx, styleOverride, childrenOverride) {\n            ctx.save();\n            ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n            this.callSuper(\"_renderControls\", ctx, styleOverride);\n            childrenOverride = childrenOverride || {};\n            if (typeof childrenOverride.hasControls === \"undefined\") {\n                childrenOverride.hasControls = false;\n            }\n            childrenOverride.forActiveSelection = true;\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                this._objects[i]._renderControls(ctx, childrenOverride);\n            }\n            ctx.restore();\n        }\n    });\n    /**\n   * Returns {@link fabric.ActiveSelection} instance from an object representation\n   * @static\n   * @memberOf fabric.ActiveSelection\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created\n   */ fabric.ActiveSelection.fromObject = function(object, callback) {\n        fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {\n            delete object.objects;\n            callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var extend = fabric.util.object.extend;\n    if (!global.fabric) {\n        global.fabric = {};\n    }\n    if (global.fabric.Image) {\n        fabric.warn(\"fabric.Image is already defined.\");\n        return;\n    }\n    /**\n   * Image class\n   * @class fabric.Image\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}\n   * @see {@link fabric.Image#initialize} for constructor definition\n   */ fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"image\",\n        /**\n     * Width of a stroke.\n     * For image quality a stroke multiple of 2 gives better results.\n     * @type Number\n     * @default\n     */ strokeWidth: 0,\n        /**\n     * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.\n     * This allows for relative urls as image src.\n     * @since 2.7.0\n     * @type Boolean\n     * @default\n     */ srcFromAttribute: false,\n        /**\n     * private\n     * contains last value of scaleX to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */ _lastScaleX: 1,\n        /**\n     * private\n     * contains last value of scaleY to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */ _lastScaleY: 1,\n        /**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */ _filterScalingX: 1,\n        /**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */ _filterScalingY: 1,\n        /**\n     * minimum scale factor under which any resizeFilter is triggered to resize the image\n     * 0 will disable the automatic resize. 1 will trigger automatically always.\n     * number bigger than 1 are not implemented yet.\n     * @type Number\n     */ minimumScaleTrigger: 0.5,\n        /**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(\"cropX\", \"cropY\"),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */ cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"cropX\", \"cropY\"),\n        /**\n     * key used to retrieve the texture representing this image\n     * @since 2.0.0\n     * @type String\n     * @default\n     */ cacheKey: \"\",\n        /**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */ cropX: 0,\n        /**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */ cropY: 0,\n        /**\n     * Indicates whether this canvas will use image smoothing when painting this image.\n     * Also influence if the cacheCanvas for this image uses imageSmoothing\n     * @since 4.0.0-beta.11\n     * @type Boolean\n     * @default\n     */ imageSmoothing: true,\n        /**\n     * Constructor\n     * Image can be initialized with any canvas drawable or a string.\n     * The string should be a url and will be loaded as an image.\n     * Canvas and Image element work out of the box, while videos require extra code to work.\n     * Please check video element events for seeking.\n     * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} element Image element\n     * @param {Object} [options] Options object\n     * @param {function} [callback] callback function to call after eventual filters applied.\n     * @return {fabric.Image} thisArg\n     */ initialize: function(element, options) {\n            options || (options = {});\n            this.filters = [];\n            this.cacheKey = \"texture\" + fabric.Object.__uid++;\n            this.callSuper(\"initialize\", options);\n            this._initElement(element, options);\n        },\n        /**\n     * Returns image element which this instance if based on\n     * @return {HTMLImageElement} Image element\n     */ getElement: function() {\n            return this._element || {};\n        },\n        /**\n     * Sets image element for this instance to a specified one.\n     * If filters defined they are applied to new image.\n     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.\n     * @param {HTMLImageElement} element\n     * @param {Object} [options] Options object\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */ setElement: function(element, options) {\n            this.removeTexture(this.cacheKey);\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            this._element = element;\n            this._originalElement = element;\n            this._initConfig(options);\n            if (this.filters.length !== 0) {\n                this.applyFilters();\n            }\n            // resizeFilters work on the already filtered copy.\n            // we need to apply resizeFilters AFTER normal filters.\n            // applyResizeFilters is run more often than normal filters\n            // and is triggered by user interactions rather than dev code\n            if (this.resizeFilter) {\n                this.applyResizeFilters();\n            }\n            return this;\n        },\n        /**\n     * Delete a single texture if in webgl mode\n     */ removeTexture: function(key) {\n            var backend = fabric.filterBackend;\n            if (backend && backend.evictCachesForKey) {\n                backend.evictCachesForKey(key);\n            }\n        },\n        /**\n     * Delete textures, reference to elements and eventually JSDOM cleanup\n     */ dispose: function() {\n            this.callSuper(\"dispose\");\n            this.removeTexture(this.cacheKey);\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            this._cacheContext = undefined;\n            [\n                \"_originalElement\",\n                \"_element\",\n                \"_filteredEl\",\n                \"_cacheCanvas\"\n            ].forEach((function(element) {\n                fabric.util.cleanUpJsdomNode(this[element]);\n                this[element] = undefined;\n            }).bind(this));\n        },\n        /**\n     * Get the crossOrigin value (of the corresponding image element)\n     */ getCrossOrigin: function() {\n            return this._originalElement && (this._originalElement.crossOrigin || null);\n        },\n        /**\n     * Returns original size of an image\n     * @return {Object} Object with \"width\" and \"height\" properties\n     */ getOriginalSize: function() {\n            var element = this.getElement();\n            return {\n                width: element.naturalWidth || element.width,\n                height: element.naturalHeight || element.height\n            };\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _stroke: function(ctx) {\n            if (!this.stroke || this.strokeWidth === 0) {\n                return;\n            }\n            var w = this.width / 2, h = this.height / 2;\n            ctx.beginPath();\n            ctx.moveTo(-w, -h);\n            ctx.lineTo(w, -h);\n            ctx.lineTo(w, h);\n            ctx.lineTo(-w, h);\n            ctx.lineTo(-w, -h);\n            ctx.closePath();\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var filters = [];\n            this.filters.forEach(function(filterObj) {\n                if (filterObj) {\n                    filters.push(filterObj.toObject());\n                }\n            });\n            var object = extend(this.callSuper(\"toObject\", [\n                \"cropX\",\n                \"cropY\"\n            ].concat(propertiesToInclude)), {\n                src: this.getSrc(),\n                crossOrigin: this.getCrossOrigin(),\n                filters: filters\n            });\n            if (this.resizeFilter) {\n                object.resizeFilter = this.resizeFilter.toObject();\n            }\n            return object;\n        },\n        /**\n     * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.\n     * @return {Boolean}\n     */ hasCrop: function() {\n            return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var svgString = [], imageMarkup = [], strokeSvg, element = this._element, x = -this.width / 2, y = -this.height / 2, clipPath = \"\", imageRendering = \"\";\n            if (!element) {\n                return [];\n            }\n            if (this.hasCrop()) {\n                var clipPathId = fabric.Object.__uid++;\n                svgString.push('<clipPath id=\"imageCrop_' + clipPathId + '\">\\n', '\t<rect x=\"' + x + '\" y=\"' + y + '\" width=\"' + this.width + '\" height=\"' + this.height + '\" />\\n', \"</clipPath>\\n\");\n                clipPath = ' clip-path=\"url(#imageCrop_' + clipPathId + ')\" ';\n            }\n            if (!this.imageSmoothing) {\n                imageRendering = '\" image-rendering=\"optimizeSpeed';\n            }\n            imageMarkup.push(\"\t<image \", \"COMMON_PARTS\", 'xlink:href=\"', this.getSvgSrc(true), '\" x=\"', x - this.cropX, '\" y=\"', y - this.cropY, // we're essentially moving origin of transformation from top/left corner to the center of the shape\n            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left\n            // so that object's center aligns with container's left/top\n            '\" width=\"', element.width || element.naturalWidth, '\" height=\"', element.height || element.height, imageRendering, '\"', clipPath, \"></image>\\n\");\n            if (this.stroke || this.strokeDashArray) {\n                var origFill = this.fill;\n                this.fill = null;\n                strokeSvg = [\n                    \"\t<rect \",\n                    'x=\"',\n                    x,\n                    '\" y=\"',\n                    y,\n                    '\" width=\"',\n                    this.width,\n                    '\" height=\"',\n                    this.height,\n                    '\" style=\"',\n                    this.getSvgStyles(),\n                    '\"/>\\n'\n                ];\n                this.fill = origFill;\n            }\n            if (this.paintFirst !== \"fill\") {\n                svgString = svgString.concat(strokeSvg, imageMarkup);\n            } else {\n                svgString = svgString.concat(imageMarkup, strokeSvg);\n            }\n            return svgString;\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns source of an image\n     * @param {Boolean} filtered indicates if the src is needed for svg\n     * @return {String} Source of an image\n     */ getSrc: function(filtered) {\n            var element = filtered ? this._element : this._originalElement;\n            if (element) {\n                if (element.toDataURL) {\n                    return element.toDataURL();\n                }\n                if (this.srcFromAttribute) {\n                    return element.getAttribute(\"src\");\n                } else {\n                    return element.src;\n                }\n            } else {\n                return this.src || \"\";\n            }\n        },\n        /**\n     * Sets source of an image\n     * @param {String} src Source string (URL)\n     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)\n     * @param {Object} [options] Options object\n     * @param {String} [options.crossOrigin] crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */ setSrc: function(src, callback, options) {\n            fabric.util.loadImage(src, function(img, isError) {\n                this.setElement(img, options);\n                this._setWidthHeight();\n                callback && callback(this, isError);\n            }, this, options && options.crossOrigin);\n            return this;\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} String representation of an instance\n     */ toString: function() {\n            return '#<fabric.Image: { src: \"' + this.getSrc() + '\" }>';\n        },\n        applyResizeFilters: function() {\n            var filter = this.resizeFilter, minimumScale = this.minimumScaleTrigger, objectScale = this.getTotalObjectScaling(), scaleX = objectScale.scaleX, scaleY = objectScale.scaleY, elementToFilter = this._filteredEl || this._originalElement;\n            if (this.group) {\n                this.set(\"dirty\", true);\n            }\n            if (!filter || scaleX > minimumScale && scaleY > minimumScale) {\n                this._element = elementToFilter;\n                this._filterScalingX = 1;\n                this._filterScalingY = 1;\n                this._lastScaleX = scaleX;\n                this._lastScaleY = scaleY;\n                return;\n            }\n            if (!fabric.filterBackend) {\n                fabric.filterBackend = fabric.initFilterBackend();\n            }\n            var canvasEl = fabric.util.createCanvasElement(), cacheKey = this._filteredEl ? this.cacheKey + \"_filtered\" : this.cacheKey, sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;\n            canvasEl.width = sourceWidth;\n            canvasEl.height = sourceHeight;\n            this._element = canvasEl;\n            this._lastScaleX = filter.scaleX = scaleX;\n            this._lastScaleY = filter.scaleY = scaleY;\n            fabric.filterBackend.applyFilters([\n                filter\n            ], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);\n            this._filterScalingX = canvasEl.width / this._originalElement.width;\n            this._filterScalingY = canvasEl.height / this._originalElement.height;\n        },\n        /**\n     * Applies filters assigned to this image (from \"filters\" array) or from filter param\n     * @method applyFilters\n     * @param {Array} filters to be applied\n     * @param {Boolean} forResizing specify if the filter operation is a resize operation\n     * @return {thisArg} return the fabric.Image object\n     * @chainable\n     */ applyFilters: function(filters) {\n            filters = filters || this.filters || [];\n            filters = filters.filter(function(filter) {\n                return filter && !filter.isNeutralState();\n            });\n            this.set(\"dirty\", true);\n            // needs to clear out or WEBGL will not resize correctly\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            if (filters.length === 0) {\n                this._element = this._originalElement;\n                this._filteredEl = null;\n                this._filterScalingX = 1;\n                this._filterScalingY = 1;\n                return this;\n            }\n            var imgElement = this._originalElement, sourceWidth = imgElement.naturalWidth || imgElement.width, sourceHeight = imgElement.naturalHeight || imgElement.height;\n            if (this._element === this._originalElement) {\n                // if the element is the same we need to create a new element\n                var canvasEl = fabric.util.createCanvasElement();\n                canvasEl.width = sourceWidth;\n                canvasEl.height = sourceHeight;\n                this._element = canvasEl;\n                this._filteredEl = canvasEl;\n            } else {\n                // clear the existing element to get new filter data\n                // also dereference the eventual resized _element\n                this._element = this._filteredEl;\n                this._filteredEl.getContext(\"2d\").clearRect(0, 0, sourceWidth, sourceHeight);\n                // we also need to resize again at next renderAll, so remove saved _lastScaleX/Y\n                this._lastScaleX = 1;\n                this._lastScaleY = 1;\n            }\n            if (!fabric.filterBackend) {\n                fabric.filterBackend = fabric.initFilterBackend();\n            }\n            fabric.filterBackend.applyFilters(filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);\n            if (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) {\n                this._filterScalingX = this._element.width / this._originalElement.width;\n                this._filterScalingY = this._element.height / this._originalElement.height;\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothing);\n            if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {\n                this.applyResizeFilters();\n            }\n            this._stroke(ctx);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Paint the cached copy of the object on the target context.\n     * it will set the imageSmoothing for the draw operation\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawCacheOnCanvas: function(ctx) {\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothing);\n            fabric.Object.prototype.drawCacheOnCanvas.call(this, ctx);\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * This is the special image version where we would like to avoid caching where possible.\n     * Essentially images do not benefit from caching. They may require caching, and in that\n     * case we do it. Also caching an image usually ends in a loss of details.\n     * A full performance audit should be done.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            return this.needsItsOwnCache();\n        },\n        _renderFill: function(ctx) {\n            var elementToDraw = this._element;\n            if (!elementToDraw) {\n                return;\n            }\n            var scaleX = this._filterScalingX, scaleY = this._filterScalingY, w = this.width, h = this.height, min = Math.min, max = Math.max, // crop values cannot be lesser than 0.\n            cropX = max(this.cropX, 0), cropY = max(this.cropY, 0), elWidth = elementToDraw.naturalWidth || elementToDraw.width, elHeight = elementToDraw.naturalHeight || elementToDraw.height, sX = cropX * scaleX, sY = cropY * scaleY, // the width height cannot exceed element width/height, starting from the crop offset.\n            sW = min(w * scaleX, elWidth - sX), sH = min(h * scaleY, elHeight - sY), x = -w / 2, y = -h / 2, maxDestW = min(w, elWidth / scaleX - cropX), maxDestH = min(h, elHeight / scaleY - cropY);\n            elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, maxDestW, maxDestH);\n        },\n        /**\n     * needed to check if image needs resize\n     * @private\n     */ _needsResize: function() {\n            var scale = this.getTotalObjectScaling();\n            return scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY;\n        },\n        /**\n     * @private\n     */ _resetWidthHeight: function() {\n            this.set(this.getOriginalSize());\n        },\n        /**\n     * The Image class's initialization method. This method is automatically\n     * called by the constructor.\n     * @private\n     * @param {HTMLImageElement|String} element The element representing the image\n     * @param {Object} [options] Options object\n     */ _initElement: function(element, options) {\n            this.setElement(fabric.util.getById(element), options);\n            fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options object\n     */ _initConfig: function(options) {\n            options || (options = {});\n            this.setOptions(options);\n            this._setWidthHeight(options);\n        },\n        /**\n     * @private\n     * @param {Array} filters to be initialized\n     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created\n     */ _initFilters: function(filters, callback) {\n            if (filters && filters.length) {\n                fabric.util.enlivenObjects(filters, function(enlivenedObjects) {\n                    callback && callback(enlivenedObjects);\n                }, \"fabric.Image.filters\");\n            } else {\n                callback && callback();\n            }\n        },\n        /**\n     * @private\n     * Set the width and the height of the image object, using the element or the\n     * options.\n     * @param {Object} [options] Object with width/height properties\n     */ _setWidthHeight: function(options) {\n            options || (options = {});\n            var el = this.getElement();\n            this.width = options.width || el.naturalWidth || el.width || 0;\n            this.height = options.height || el.naturalHeight || el.height || 0;\n        },\n        /**\n     * Calculate offset for center and scale factor for the image in order to respect\n     * the preserveAspectRatio attribute\n     * @private\n     * @return {Object}\n     */ parsePreserveAspectRatioAttribute: function() {\n            var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || \"\"), rWidth = this._element.width, rHeight = this._element.height, scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0, offset, pWidth = this.width, pHeight = this.height, parsedAttributes = {\n                width: pWidth,\n                height: pHeight\n            };\n            if (pAR && (pAR.alignX !== \"none\" || pAR.alignY !== \"none\")) {\n                if (pAR.meetOrSlice === \"meet\") {\n                    scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);\n                    offset = (pWidth - rWidth * scaleX) / 2;\n                    if (pAR.alignX === \"Min\") {\n                        offsetLeft = -offset;\n                    }\n                    if (pAR.alignX === \"Max\") {\n                        offsetLeft = offset;\n                    }\n                    offset = (pHeight - rHeight * scaleY) / 2;\n                    if (pAR.alignY === \"Min\") {\n                        offsetTop = -offset;\n                    }\n                    if (pAR.alignY === \"Max\") {\n                        offsetTop = offset;\n                    }\n                }\n                if (pAR.meetOrSlice === \"slice\") {\n                    scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);\n                    offset = rWidth - pWidth / scaleX;\n                    if (pAR.alignX === \"Mid\") {\n                        cropX = offset / 2;\n                    }\n                    if (pAR.alignX === \"Max\") {\n                        cropX = offset;\n                    }\n                    offset = rHeight - pHeight / scaleY;\n                    if (pAR.alignY === \"Mid\") {\n                        cropY = offset / 2;\n                    }\n                    if (pAR.alignY === \"Max\") {\n                        cropY = offset;\n                    }\n                    rWidth = pWidth / scaleX;\n                    rHeight = pHeight / scaleY;\n                }\n            } else {\n                scaleX = pWidth / rWidth;\n                scaleY = pHeight / rHeight;\n            }\n            return {\n                width: rWidth,\n                height: rHeight,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                offsetLeft: offsetLeft,\n                offsetTop: offsetTop,\n                cropX: cropX,\n                cropY: cropY\n            };\n        }\n    });\n    /**\n   * Default CSS class name for canvas\n   * @static\n   * @type String\n   * @default\n   */ fabric.Image.CSS_CANVAS = \"canvas-img\";\n    /**\n   * Alias for getSrc\n   * @static\n   */ fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;\n    /**\n   * Creates an instance of fabric.Image from its object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} callback Callback to invoke when an image instance is created\n   */ fabric.Image.fromObject = function(_object, callback) {\n        var object = fabric.util.object.clone(_object);\n        fabric.util.loadImage(object.src, function(img, isError) {\n            if (isError) {\n                callback && callback(null, true);\n                return;\n            }\n            fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {\n                object.filters = filters || [];\n                fabric.Image.prototype._initFilters.call(object, [\n                    object.resizeFilter\n                ], function(resizeFilters) {\n                    object.resizeFilter = resizeFilters[0];\n                    fabric.util.enlivenObjectEnlivables(object, object, function() {\n                        var image = new fabric.Image(img, object);\n                        callback(image, false);\n                    });\n                });\n            });\n        }, null, object.crossOrigin);\n    };\n    /**\n   * Creates an instance of fabric.Image from an URL string\n   * @static\n   * @param {String} url URL to create an image from\n   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument). Second argument is a boolean indicating if an error occurred or not.\n   * @param {Object} [imgOptions] Options object\n   */ fabric.Image.fromURL = function(url, callback, imgOptions) {\n        fabric.util.loadImage(url, function(img, isError) {\n            callback && callback(new fabric.Image(img, imgOptions), isError);\n        }, null, imgOptions && imgOptions.crossOrigin);\n    };\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})\n   * @static\n   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}\n   */ fabric.Image.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y width height preserveAspectRatio xlink:href crossOrigin image-rendering\".split(\" \"));\n    /**\n   * Returns {@link fabric.Image} instance from an SVG element\n   * @static\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} callback Callback to execute when fabric.Image object is created\n   * @return {fabric.Image} Instance of fabric.Image\n   */ fabric.Image.fromElement = function(element, callback, options) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);\n        fabric.Image.fromURL(parsedAttributes[\"xlink:href\"], callback, extend(options ? fabric.util.object.clone(options) : {}, parsedAttributes));\n    };\n/* _FROM_SVG_END_ */ })( true ? exports : 0);\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * @private\n   * @return {Number} angle value\n   */ _getAngleValueForStraighten: function() {\n        var angle = this.angle % 360;\n        if (angle > 0) {\n            return Math.round((angle - 1) / 90) * 90;\n        }\n        return Math.round(angle / 90) * 90;\n    },\n    /**\n   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ straighten: function() {\n        return this.rotate(this._getAngleValueForStraighten());\n    },\n    /**\n   * Same as {@link fabric.Object.prototype.straighten} but with animation\n   * @param {Object} callbacks Object with callback functions\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.Object} thisArg\n   */ fxStraighten: function(callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: this.get(\"angle\"),\n            endValue: this._getAngleValueForStraighten(),\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                _this.rotate(value);\n                onChange();\n            },\n            onComplete: function() {\n                _this.setCoords();\n                onComplete();\n            }\n        });\n    }\n});\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Straightens object, then rerenders canvas\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   * @chainable\n   */ straightenObject: function(object) {\n        object.straighten();\n        this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   */ fxStraightenObject: function(object) {\n        return object.fxStraighten({\n            onChange: this.requestRenderAllBound\n        });\n    }\n});\n(function() {\n    \"use strict\";\n    /**\n   * Tests if webgl supports certain precision\n   * @param {WebGL} Canvas WebGL context to test on\n   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'\n   * @returns {Boolean} Whether the user's browser WebGL supports given precision.\n   */ function testPrecision(gl, precision) {\n        var fragmentSource = \"precision \" + precision + \" float;\\nvoid main(){}\";\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentSource);\n        gl.compileShader(fragmentShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Indicate whether this filtering backend is supported by the user's browser.\n   * @param {Number} tileSize check if the tileSize is supported\n   * @returns {Boolean} Whether the user's browser supports WebGL.\n   */ fabric.isWebglSupported = function(tileSize) {\n        if (fabric.isLikelyNode) {\n            return false;\n        }\n        tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;\n        var canvas = document.createElement(\"canvas\");\n        var gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n        var isSupported = false;\n        // eslint-disable-next-line\n        if (gl) {\n            fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n            isSupported = fabric.maxTextureSize >= tileSize;\n            var precisions = [\n                \"highp\",\n                \"mediump\",\n                \"lowp\"\n            ];\n            for(var i = 0; i < 3; i++){\n                if (testPrecision(gl, precisions[i])) {\n                    fabric.webGlPrecision = precisions[i];\n                    break;\n                }\n                ;\n            }\n        }\n        this.isSupported = isSupported;\n        return isSupported;\n    };\n    fabric.WebglFilterBackend = WebglFilterBackend;\n    /**\n   * WebGL filter backend.\n   */ function WebglFilterBackend(options) {\n        if (options && options.tileSize) {\n            this.tileSize = options.tileSize;\n        }\n        this.setupGLContext(this.tileSize, this.tileSize);\n        this.captureGPUInfo();\n    }\n    ;\n    WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {\n        tileSize: 2048,\n        /**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/ resources: {},\n        /**\n     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.\n     */ setupGLContext: function(width, height) {\n            this.dispose();\n            this.createWebGLCanvas(width, height);\n            // eslint-disable-next-line\n            this.aPosition = new Float32Array([\n                0,\n                0,\n                0,\n                1,\n                1,\n                0,\n                1,\n                1\n            ]);\n            this.chooseFastestCopyGLTo2DMethod(width, height);\n        },\n        /**\n     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using\n     * putImageData is faster than drawImage for that specific operation.\n     */ chooseFastestCopyGLTo2DMethod: function(width, height) {\n            var canMeasurePerf = typeof window.performance !== \"undefined\", canUseImageData;\n            try {\n                new ImageData(1, 1);\n                canUseImageData = true;\n            } catch (e) {\n                canUseImageData = false;\n            }\n            // eslint-disable-next-line no-undef\n            var canUseArrayBuffer = typeof ArrayBuffer !== \"undefined\";\n            // eslint-disable-next-line no-undef\n            var canUseUint8Clamped = typeof Uint8ClampedArray !== \"undefined\";\n            if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {\n                return;\n            }\n            var targetCanvas = fabric.util.createCanvasElement();\n            // eslint-disable-next-line no-undef\n            var imageBuffer = new ArrayBuffer(width * height * 4);\n            if (fabric.forceGLPutImageData) {\n                this.imageBuffer = imageBuffer;\n                this.copyGLTo2D = copyGLTo2DPutImageData;\n                return;\n            }\n            var testContext = {\n                imageBuffer: imageBuffer,\n                destinationWidth: width,\n                destinationHeight: height,\n                targetCanvas: targetCanvas\n            };\n            var startTime, drawImageTime, putImageDataTime;\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            startTime = window.performance.now();\n            copyGLTo2DDrawImage.call(testContext, this.gl, testContext);\n            drawImageTime = window.performance.now() - startTime;\n            startTime = window.performance.now();\n            copyGLTo2DPutImageData.call(testContext, this.gl, testContext);\n            putImageDataTime = window.performance.now() - startTime;\n            if (drawImageTime > putImageDataTime) {\n                this.imageBuffer = imageBuffer;\n                this.copyGLTo2D = copyGLTo2DPutImageData;\n            } else {\n                this.copyGLTo2D = copyGLTo2DDrawImage;\n            }\n        },\n        /**\n     * Create a canvas element and associated WebGL context and attaches them as\n     * class properties to the GLFilterBackend class.\n     */ createWebGLCanvas: function(width, height) {\n            var canvas = fabric.util.createCanvasElement();\n            canvas.width = width;\n            canvas.height = height;\n            var glOptions = {\n                alpha: true,\n                premultipliedAlpha: false,\n                depth: false,\n                stencil: false,\n                antialias: false\n            }, gl = canvas.getContext(\"webgl\", glOptions);\n            if (!gl) {\n                gl = canvas.getContext(\"experimental-webgl\", glOptions);\n            }\n            if (!gl) {\n                return;\n            }\n            gl.clearColor(0, 0, 0, 0);\n            // this canvas can fire webglcontextlost and webglcontextrestored\n            this.canvas = canvas;\n            this.gl = gl;\n        },\n        /**\n     * Attempts to apply the requested filters to the source provided, drawing the filtered output\n     * to the provided target canvas.\n     *\n     * @param {Array} filters The filters to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.\n     * @param {Number} width The width of the source input.\n     * @param {Number} height The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If\n     * omitted, caching will be skipped.\n     */ applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {\n            var gl = this.gl;\n            var cachedTexture;\n            if (cacheKey) {\n                cachedTexture = this.getCachedTexture(cacheKey, source);\n            }\n            var pipelineState = {\n                originalWidth: source.width || source.originalWidth,\n                originalHeight: source.height || source.originalHeight,\n                sourceWidth: width,\n                sourceHeight: height,\n                destinationWidth: width,\n                destinationHeight: height,\n                context: gl,\n                sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),\n                targetTexture: this.createTexture(gl, width, height),\n                originalTexture: cachedTexture || this.createTexture(gl, width, height, !cachedTexture && source),\n                passes: filters.length,\n                webgl: true,\n                aPosition: this.aPosition,\n                programCache: this.programCache,\n                pass: 0,\n                filterBackend: this,\n                targetCanvas: targetCanvas\n            };\n            var tempFbo = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);\n            filters.forEach(function(filter) {\n                filter && filter.applyTo(pipelineState);\n            });\n            resizeCanvasIfNeeded(pipelineState);\n            this.copyGLTo2D(gl, pipelineState);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            gl.deleteTexture(pipelineState.sourceTexture);\n            gl.deleteTexture(pipelineState.targetTexture);\n            gl.deleteFramebuffer(tempFbo);\n            targetCanvas.getContext(\"2d\").setTransform(1, 0, 0, 1, 0, 0);\n            return pipelineState;\n        },\n        /**\n     * Detach event listeners, remove references, and clean up caches.\n     */ dispose: function() {\n            if (this.canvas) {\n                this.canvas = null;\n                this.gl = null;\n            }\n            this.clearWebGLCaches();\n        },\n        /**\n     * Wipe out WebGL-related caches.\n     */ clearWebGLCaches: function() {\n            this.programCache = {};\n            this.textureCache = {};\n        },\n        /**\n     * Create a WebGL texture object.\n     *\n     * Accepts specific dimensions to initialize the texture to or a source image.\n     *\n     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.\n     * @param {Number} width The width to initialize the texture at.\n     * @param {Number} height The height to initialize the texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.\n     * @returns {WebGLTexture}\n     */ createTexture: function(gl, width, height, textureImageSource) {\n            var texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            if (textureImageSource) {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);\n            } else {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            }\n            return texture;\n        },\n        /**\n     * Can be optionally used to get a texture from the cache array\n     *\n     * If an existing texture is not found, a new texture is created and cached.\n     *\n     * @param {String} uniqueId A cache key to use to find an existing texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the\n     * texture cache entry if one does not already exist.\n     */ getCachedTexture: function(uniqueId, textureImageSource) {\n            if (this.textureCache[uniqueId]) {\n                return this.textureCache[uniqueId];\n            } else {\n                var texture = this.createTexture(this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);\n                this.textureCache[uniqueId] = texture;\n                return texture;\n            }\n        },\n        /**\n     * Clear out cached resources related to a source image that has been\n     * filtered previously.\n     *\n     * @param {String} cacheKey The cache key provided when the source image was filtered.\n     */ evictCachesForKey: function(cacheKey) {\n            if (this.textureCache[cacheKey]) {\n                this.gl.deleteTexture(this.textureCache[cacheKey]);\n                delete this.textureCache[cacheKey];\n            }\n        },\n        copyGLTo2D: copyGLTo2DDrawImage,\n        /**\n     * Attempt to extract GPU information strings from a WebGL context.\n     *\n     * Useful information when debugging or blacklisting specific GPUs.\n     *\n     * @returns {Object} A GPU info object with renderer and vendor strings.\n     */ captureGPUInfo: function() {\n            if (this.gpuInfo) {\n                return this.gpuInfo;\n            }\n            var gl = this.gl, gpuInfo = {\n                renderer: \"\",\n                vendor: \"\"\n            };\n            if (!gl) {\n                return gpuInfo;\n            }\n            var ext = gl.getExtension(\"WEBGL_debug_renderer_info\");\n            if (ext) {\n                var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);\n                var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);\n                if (renderer) {\n                    gpuInfo.renderer = renderer.toLowerCase();\n                }\n                if (vendor) {\n                    gpuInfo.vendor = vendor.toLowerCase();\n                }\n            }\n            this.gpuInfo = gpuInfo;\n            return gpuInfo;\n        }\n    };\n})();\nfunction resizeCanvasIfNeeded(pipelineState) {\n    var targetCanvas = pipelineState.targetCanvas, width = targetCanvas.width, height = targetCanvas.height, dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight;\n    if (width !== dWidth || height !== dHeight) {\n        targetCanvas.width = dWidth;\n        targetCanvas.height = dHeight;\n    }\n}\n/**\n * Copy an input WebGL canvas on to an output 2D canvas.\n *\n * The WebGL canvas is assumed to be upside down, with the top-left pixel of the\n * desired output image appearing in the bottom-left corner of the WebGL canvas.\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */ function copyGLTo2DDrawImage(gl, pipelineState) {\n    var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext(\"2d\");\n    ctx.translate(0, targetCanvas.height); // move it down again\n    ctx.scale(1, -1); // vertical flip\n    // where is my image on the big glcanvas?\n    var sourceY = glCanvas.height - targetCanvas.height;\n    ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0, targetCanvas.width, targetCanvas.height);\n}\n/**\n * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData\n * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */ function copyGLTo2DPutImageData(gl, pipelineState) {\n    var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext(\"2d\"), dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight, numBytes = dWidth * dHeight * 4;\n    // eslint-disable-next-line no-undef\n    var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);\n    // eslint-disable-next-line no-undef\n    var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);\n    gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);\n    var imgData = new ImageData(u8Clamped, dWidth, dHeight);\n    ctx.putImageData(imgData, 0, 0);\n}\n(function() {\n    \"use strict\";\n    var noop = function() {};\n    fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;\n    /**\n   * Canvas 2D filter backend.\n   */ function Canvas2dFilterBackend() {}\n    ;\n    Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {\n        evictCachesForKey: noop,\n        dispose: noop,\n        clearWebGLCaches: noop,\n        /**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/ resources: {},\n        /**\n     * Apply a set of filters against a source image and draw the filtered output\n     * to the provided destination canvas.\n     *\n     * @param {EnhancedFilter} filters The filter to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.\n     * @param {Number} sourceWidth The width of the source input.\n     * @param {Number} sourceHeight The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     */ applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {\n            var ctx = targetCanvas.getContext(\"2d\");\n            ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);\n            var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n            var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n            var pipelineState = {\n                sourceWidth: sourceWidth,\n                sourceHeight: sourceHeight,\n                imageData: imageData,\n                originalEl: sourceElement,\n                originalImageData: originalImageData,\n                canvasEl: targetCanvas,\n                ctx: ctx,\n                filterBackend: this\n            };\n            filters.forEach(function(filter) {\n                filter.applyTo(pipelineState);\n            });\n            if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {\n                targetCanvas.width = pipelineState.imageData.width;\n                targetCanvas.height = pipelineState.imageData.height;\n            }\n            ctx.putImageData(pipelineState.imageData, 0, 0);\n            return pipelineState;\n        }\n    };\n})();\n/**\n * @namespace fabric.Image.filters\n * @memberOf fabric.Image\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}\n * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n */ fabric.Image = fabric.Image || {};\nfabric.Image.filters = fabric.Image.filters || {};\n/**\n * Root filter class from which all filter classes inherit from\n * @class fabric.Image.filters.BaseFilter\n * @memberOf fabric.Image.filters\n */ fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {\n    /**\n   * Filter type\n   * @param {String} type\n   * @default\n   */ type: \"BaseFilter\",\n    /**\n   * Array of attributes to send with buffers. do not modify\n   * @private\n   */ vertexSource: \"attribute vec2 aPosition;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vTexCoord = aPosition;\\n\" + \"gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n\" + \"}\",\n    fragmentSource: \"precision highp float;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"void main() {\\n\" + \"gl_FragColor = texture2D(uTexture, vTexCoord);\\n\" + \"}\",\n    /**\n   * Constructor\n   * @param {Object} [options] Options object\n   */ initialize: function(options) {\n        if (options) {\n            this.setOptions(options);\n        }\n    },\n    /**\n   * Sets filter's properties from options\n   * @param {Object} [options] Options object\n   */ setOptions: function(options) {\n        for(var prop in options){\n            this[prop] = options[prop];\n        }\n    },\n    /**\n   * Compile this filter's shader program.\n   *\n   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.\n   * @param {String} fragmentSource fragmentShader source for compilation\n   * @param {String} vertexSource vertexShader source for compilation\n   */ createProgram: function(gl, fragmentSource, vertexSource) {\n        fragmentSource = fragmentSource || this.fragmentSource;\n        vertexSource = vertexSource || this.vertexSource;\n        if (fabric.webGlPrecision !== \"highp\") {\n            fragmentSource = fragmentSource.replace(/precision highp float/g, \"precision \" + fabric.webGlPrecision + \" float\");\n        }\n        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, vertexSource);\n        gl.compileShader(vertexShader);\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            \"Vertex shader compile error for \" + this.type + \": \" + gl.getShaderInfoLog(vertexShader));\n        }\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentSource);\n        gl.compileShader(fragmentShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            \"Fragment shader compile error for \" + this.type + \": \" + gl.getShaderInfoLog(fragmentShader));\n        }\n        var program = gl.createProgram();\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            'Shader link error for \"${this.type}\" ' + gl.getProgramInfoLog(program));\n        }\n        var attributeLocations = this.getAttributeLocations(gl, program);\n        var uniformLocations = this.getUniformLocations(gl, program) || {};\n        uniformLocations.uStepW = gl.getUniformLocation(program, \"uStepW\");\n        uniformLocations.uStepH = gl.getUniformLocation(program, \"uStepH\");\n        return {\n            program: program,\n            attributeLocations: attributeLocations,\n            uniformLocations: uniformLocations\n        };\n    },\n    /**\n   * Return a map of attribute names to WebGLAttributeLocation objects.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.\n   * @returns {Object} A map of attribute names to attribute locations.\n   */ getAttributeLocations: function(gl, program) {\n        return {\n            aPosition: gl.getAttribLocation(program, \"aPosition\")\n        };\n    },\n    /**\n   * Return a map of uniform names to WebGLUniformLocation objects.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.\n   * @returns {Object} A map of uniform names to uniform locations.\n   */ getUniformLocations: function() {\n        // in case i do not need any special uniform i need to return an empty object\n        return {};\n    },\n    /**\n   * Send attribute data from this filter to its shader program on the GPU.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} attributeLocations A map of shader attribute names to their locations.\n   */ sendAttributeData: function(gl, attributeLocations, aPositionData) {\n        var attributeLocation = attributeLocations.aPosition;\n        var buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.enableVertexAttribArray(attributeLocation);\n        gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);\n    },\n    _setupFrameBuffer: function(options) {\n        var gl = options.context, width, height;\n        if (options.passes > 1) {\n            width = options.destinationWidth;\n            height = options.destinationHeight;\n            if (options.sourceWidth !== width || options.sourceHeight !== height) {\n                gl.deleteTexture(options.targetTexture);\n                options.targetTexture = options.filterBackend.createTexture(gl, width, height);\n            }\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, options.targetTexture, 0);\n        } else {\n            // draw last filter on canvas and not to framebuffer.\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            gl.finish();\n        }\n    },\n    _swapTextures: function(options) {\n        options.passes--;\n        options.pass++;\n        var temp = options.targetTexture;\n        options.targetTexture = options.sourceTexture;\n        options.sourceTexture = temp;\n    },\n    /**\n   * Generic isNeutral implementation for one parameter based filters.\n   * Used only in image applyFilters to discard filters that will not have an effect\n   * on the image\n   * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )\n   * @param {Object} options\n   **/ isNeutralState: function() {\n        var main = this.mainParameter, _class = fabric.Image.filters[this.type].prototype;\n        if (main) {\n            if (Array.isArray(_class[main])) {\n                for(var i = _class[main].length; i--;){\n                    if (this[main][i] !== _class[main][i]) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return _class[main] === this[main];\n            }\n        } else {\n            return false;\n        }\n    },\n    /**\n   * Apply this filter to the input image data provided.\n   *\n   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ applyTo: function(options) {\n        if (options.webgl) {\n            this._setupFrameBuffer(options);\n            this.applyToWebGL(options);\n            this._swapTextures(options);\n        } else {\n            this.applyTo2d(options);\n        }\n    },\n    /**\n   * Retrieves the cached shader.\n   * @param {Object} options\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ retrieveShader: function(options) {\n        if (!options.programCache.hasOwnProperty(this.type)) {\n            options.programCache[this.type] = this.createProgram(options.context);\n        }\n        return options.programCache[this.type];\n    },\n    /**\n   * Apply this filter using webgl.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.originalTexture The texture of the original input image.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ applyToWebGL: function(options) {\n        var gl = options.context;\n        var shader = this.retrieveShader(options);\n        if (options.pass === 0 && options.originalTexture) {\n            gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);\n        } else {\n            gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);\n        }\n        gl.useProgram(shader.program);\n        this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);\n        gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);\n        gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);\n        this.sendUniformData(gl, shader.uniformLocations);\n        gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    },\n    bindAdditionalTexture: function(gl, texture, textureUnit) {\n        gl.activeTexture(textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        // reset active texture to 0 as usual\n        gl.activeTexture(gl.TEXTURE0);\n    },\n    unbindAdditionalTexture: function(gl, textureUnit) {\n        gl.activeTexture(textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.activeTexture(gl.TEXTURE0);\n    },\n    getMainParameter: function() {\n        return this[this.mainParameter];\n    },\n    setMainParameter: function(value) {\n        this[this.mainParameter] = value;\n    },\n    /**\n   * Send uniform data from this filter to its shader program on the GPU.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} uniformLocations A map of shader uniform names to their locations.\n   */ sendUniformData: function() {\n    // Intentionally left blank.  Override me in subclasses.\n    },\n    /**\n   * If needed by a 2d filter, this functions can create an helper canvas to be used\n   * remember that options.targetCanvas is available for use till end of chain.\n   */ createHelpLayer: function(options) {\n        if (!options.helpLayer) {\n            var helpLayer = document.createElement(\"canvas\");\n            helpLayer.width = options.sourceWidth;\n            helpLayer.height = options.sourceHeight;\n            options.helpLayer = helpLayer;\n        }\n    },\n    /**\n   * Returns object representation of an instance\n   * @return {Object} Object representation of an instance\n   */ toObject: function() {\n        var object = {\n            type: this.type\n        }, mainP = this.mainParameter;\n        if (mainP) {\n            object[mainP] = this[mainP];\n        }\n        return object;\n    },\n    /**\n   * Returns a JSON representation of an instance\n   * @return {Object} JSON\n   */ toJSON: function() {\n        // delegate, not alias\n        return this.toObject();\n    }\n});\nfabric.Image.filters.BaseFilter.fromObject = function(object, callback) {\n    var filter = new fabric.Image.filters[object.type](object);\n    callback && callback(filter);\n    return filter;\n};\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Color Matrix filter class\n   * @class fabric.Image.filters.ColorMatrix\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}\n   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}\n   * @example <caption>Kodachrome filter</caption>\n   * var filter = new fabric.Image.filters.ColorMatrix({\n   *  matrix: [\n       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,\n       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,\n       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,\n       0, 0, 0, 1, 0\n      ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"ColorMatrix\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"uniform mat4 uColorMatrix;\\n\" + \"uniform vec4 uConstants;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color *= uColorMatrix;\\n\" + \"color += uConstants;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Colormatrix for pixels.\n     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n     * outside the -1, 1 range.\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Array} matrix array of 20 numbers.\n     * @default\n     */ matrix: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        mainParameter: \"matrix\",\n        /**\n     * Lock the colormatrix on the color part, skipping alpha, mainly for non webgl scenario\n     * to save some calculation\n     * @type Boolean\n     * @default true\n     */ colorsOnly: true,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            // create a new array instead mutating the prototype with push\n            this.matrix = this.matrix.slice(0);\n        },\n        /**\n     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = data.length, m = this.matrix, r, g, b, a, i, colorsOnly = this.colorsOnly;\n            for(i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                if (colorsOnly) {\n                    data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;\n                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;\n                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;\n                } else {\n                    a = data[i + 3];\n                    data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;\n                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;\n                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;\n                    data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uColorMatrix: gl.getUniformLocation(program, \"uColorMatrix\"),\n                uConstants: gl.getUniformLocation(program, \"uConstants\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var m = this.matrix, matrix = [\n                m[0],\n                m[1],\n                m[2],\n                m[3],\n                m[5],\n                m[6],\n                m[7],\n                m[8],\n                m[10],\n                m[11],\n                m[12],\n                m[13],\n                m[15],\n                m[16],\n                m[17],\n                m[18]\n            ], constants = [\n                m[4],\n                m[9],\n                m[14],\n                m[19]\n            ];\n            gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);\n            gl.uniform4fv(uniformLocations.uConstants, constants);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] function to invoke after filter creation\n   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix\n   */ fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Brightness filter class\n   * @class fabric.Image.filters.Brightness\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Brightness({\n   *   brightness: 0.05\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Brightness\",\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uBrightness;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color.rgb += uBrightness;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Brightness value, from -1 to 1.\n     * translated to -255 to 255 for 2d\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Number} brightness\n     * @default\n     */ brightness: 0,\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"brightness\",\n        /**\n    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n    *\n    * @param {Object} options\n    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n    */ applyTo2d: function(options) {\n            if (this.brightness === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, brightness = Math.round(this.brightness * 255);\n            for(i = 0; i < len; i += 4){\n                data[i] = data[i] + brightness;\n                data[i + 1] = data[i + 1] + brightness;\n                data[i + 2] = data[i + 2] + brightness;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uBrightness: gl.getUniformLocation(program, \"uBrightness\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uBrightness, this.brightness);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness\n   */ fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Adapted from <a href=\"http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\">html5rocks article</a>\n   * @class fabric.Image.filters.Convolute\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example <caption>Sharpen filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 0, -1,  0,\n   *            -1,  5, -1,\n   *             0, -1,  0 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Blur filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter with opaqueness</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   opaque: true,\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Convolute\",\n        /*\n     * Opaque value (true/false)\n     */ opaque: false,\n        /*\n     * matrix for the filter, max 9x9\n     */ matrix: [\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0\n        ],\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: {\n            Convolute_3_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[9];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 3.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 3.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_3_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[9];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 3.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 3.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_5_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[25];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 5.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 5.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_5_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[25];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 5.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 5.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_7_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[49];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 7.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 7.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_7_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[49];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 7.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 7.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_9_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[81];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 9.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 9.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_9_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[81];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 9.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 9.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\"\n        },\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Convolute.prototype\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.opaque=false] Opaque value (true/false)\n     * @param {Array} [options.matrix] Filter matrix\n     */ /**\n    * Retrieves the cached shader.\n    * @param {Object} options\n    * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n    */ retrieveShader: function(options) {\n            var size = Math.sqrt(this.matrix.length);\n            var cacheKey = this.type + \"_\" + size + \"_\" + (this.opaque ? 1 : 0);\n            var shaderSource = this.fragmentSource[cacheKey];\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, weights = this.matrix, side = Math.round(Math.sqrt(weights.length)), halfSide = Math.floor(side / 2), sw = imageData.width, sh = imageData.height, output = options.ctx.createImageData(sw, sh), dst = output.data, // go through the destination image pixels\n            alphaFac = this.opaque ? 1 : 0, r, g, b, a, dstOff, scx, scy, srcOff, wt, x, y, cx, cy;\n            for(y = 0; y < sh; y++){\n                for(x = 0; x < sw; x++){\n                    dstOff = (y * sw + x) * 4;\n                    // calculate the weighed sum of the source image pixels that\n                    // fall under the convolution matrix\n                    r = 0;\n                    g = 0;\n                    b = 0;\n                    a = 0;\n                    for(cy = 0; cy < side; cy++){\n                        for(cx = 0; cx < side; cx++){\n                            scy = y + cy - halfSide;\n                            scx = x + cx - halfSide;\n                            // eslint-disable-next-line max-depth\n                            if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {\n                                continue;\n                            }\n                            srcOff = (scy * sw + scx) * 4;\n                            wt = weights[cy * side + cx];\n                            r += data[srcOff] * wt;\n                            g += data[srcOff + 1] * wt;\n                            b += data[srcOff + 2] * wt;\n                            // eslint-disable-next-line max-depth\n                            if (!alphaFac) {\n                                a += data[srcOff + 3] * wt;\n                            }\n                        }\n                    }\n                    dst[dstOff] = r;\n                    dst[dstOff + 1] = g;\n                    dst[dstOff + 2] = b;\n                    if (!alphaFac) {\n                        dst[dstOff + 3] = a;\n                    } else {\n                        dst[dstOff + 3] = data[dstOff + 3];\n                    }\n                }\n            }\n            options.imageData = output;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uMatrix: gl.getUniformLocation(program, \"uMatrix\"),\n                uOpaque: gl.getUniformLocation(program, \"uOpaque\"),\n                uHalfSize: gl.getUniformLocation(program, \"uHalfSize\"),\n                uSize: gl.getUniformLocation(program, \"uSize\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1fv(uniformLocations.uMatrix, this.matrix);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                opaque: this.opaque,\n                matrix: this.matrix\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute\n   */ fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Grayscale image filter class\n   * @class fabric.Image.filters.Grayscale\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Grayscale();\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Grayscale\",\n        fragmentSource: {\n            average: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float average = (color.r + color.b + color.g) / 3.0;\\n\" + \"gl_FragColor = vec4(average, average, average, color.a);\\n\" + \"}\",\n            lightness: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uMode;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 col = texture2D(uTexture, vTexCoord);\\n\" + \"float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\\n\" + \"gl_FragColor = vec4(average, average, average, col.a);\\n\" + \"}\",\n            luminosity: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uMode;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 col = texture2D(uTexture, vTexCoord);\\n\" + \"float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\\n\" + \"gl_FragColor = vec4(average, average, average, col.a);\\n\" + \"}\"\n        },\n        /**\n     * Grayscale mode, between 'average', 'lightness', 'luminosity'\n     * @param {String} type\n     * @default\n     */ mode: \"average\",\n        mainParameter: \"mode\",\n        /**\n     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, value, mode = this.mode;\n            for(i = 0; i < len; i += 4){\n                if (mode === \"average\") {\n                    value = (data[i] + data[i + 1] + data[i + 2]) / 3;\n                } else if (mode === \"lightness\") {\n                    value = (Math.min(data[i], data[i + 1], data[i + 2]) + Math.max(data[i], data[i + 1], data[i + 2])) / 2;\n                } else if (mode === \"luminosity\") {\n                    value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];\n                }\n                data[i] = value;\n                data[i + 1] = value;\n                data[i + 2] = value;\n            }\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                var shaderSource = this.fragmentSource[this.mode];\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uMode: gl.getUniformLocation(program, \"uMode\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            // default average mode.\n            var mode = 1;\n            gl.uniform1i(uniformLocations.uMode, mode);\n        },\n        /**\n     * Grayscale filter isNeutralState implementation\n     * The filter is never neutral\n     * on the image\n     **/ isNeutralState: function() {\n            return false;\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale\n   */ fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Invert filter class\n   * @class fabric.Image.filters.Invert\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Invert();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */ filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Invert\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uInvert;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"if (uInvert == 1) {\\n\" + \"gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\\n\" + \"} else {\\n\" + \"gl_FragColor = color;\\n\" + \"}\\n\" + \"}\",\n        /**\n     * Filter invert. if false, does nothing\n     * @param {Boolean} invert\n     * @default\n     */ invert: true,\n        mainParameter: \"invert\",\n        /**\n     * Apply the Invert operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, len = data.length;\n            for(i = 0; i < len; i += 4){\n                data[i] = 255 - data[i];\n                data[i + 1] = 255 - data[i + 1];\n                data[i + 2] = 255 - data[i + 2];\n            }\n        },\n        /**\n     * Invert filter isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/ isNeutralState: function() {\n            return !this.invert;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uInvert: gl.getUniformLocation(program, \"uInvert\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1i(uniformLocations.uInvert, this.invert);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert\n   */ fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Noise filter class\n   * @class fabric.Image.filters.Noise\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Noise({\n   *   noise: 700\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Noise\",\n        /**\n     * Fragment source for the noise program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uStepH;\\n\" + \"uniform float uNoise;\\n\" + \"uniform float uSeed;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"float rand(vec2 co, float seed, float vScale) {\\n\" + \"return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\\n\" + \"}\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"noise\",\n        /**\n     * Noise value, from\n     * @param {Number} noise\n     * @default\n     */ noise: 0,\n        /**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.noise === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, noise = this.noise, rand;\n            for(i = 0, len = data.length; i < len; i += 4){\n                rand = (0.5 - Math.random()) * noise;\n                data[i] += rand;\n                data[i + 1] += rand;\n                data[i + 2] += rand;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uNoise: gl.getUniformLocation(program, \"uNoise\"),\n                uSeed: gl.getUniformLocation(program, \"uSeed\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uNoise, this.noise / 255);\n            gl.uniform1f(uniformLocations.uSeed, Math.random());\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                noise: this.noise\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise\n   */ fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Pixelate filter class\n   * @class fabric.Image.filters.Pixelate\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Pixelate({\n   *   blocksize: 8\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Pixelate\",\n        blocksize: 4,\n        mainParameter: \"blocksize\",\n        /**\n     * Fragment source for the Pixelate program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uBlocksize;\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"float blockW = uBlocksize * uStepW;\\n\" + \"float blockH = uBlocksize * uStepW;\\n\" + \"int posX = int(vTexCoord.x / blockW);\\n\" + \"int posY = int(vTexCoord.y / blockH);\\n\" + \"float fposX = float(posX);\\n\" + \"float fposY = float(posY);\\n\" + \"vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\\n\" + \"vec4 color = texture2D(uTexture, squareCoords);\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = imageData.height, jLen = imageData.width, index, i, j, r, g, b, a, _i, _j, _iLen, _jLen;\n            for(i = 0; i < iLen; i += this.blocksize){\n                for(j = 0; j < jLen; j += this.blocksize){\n                    index = i * 4 * jLen + j * 4;\n                    r = data[index];\n                    g = data[index + 1];\n                    b = data[index + 2];\n                    a = data[index + 3];\n                    _iLen = Math.min(i + this.blocksize, iLen);\n                    _jLen = Math.min(j + this.blocksize, jLen);\n                    for(_i = i; _i < _iLen; _i++){\n                        for(_j = j; _j < _jLen; _j++){\n                            index = _i * 4 * jLen + _j * 4;\n                            data[index] = r;\n                            data[index + 1] = g;\n                            data[index + 2] = b;\n                            data[index + 3] = a;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Indicate when the filter is not gonna apply changes to the image\n     **/ isNeutralState: function() {\n            return this.blocksize === 1;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uBlocksize: gl.getUniformLocation(program, \"uBlocksize\"),\n                uStepW: gl.getUniformLocation(program, \"uStepW\"),\n                uStepH: gl.getUniformLocation(program, \"uStepH\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate\n   */ fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Remove white filter class\n   * @class fabric.Image.filters.RemoveColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.RemoveColor({\n   *   threshold: 0.2,\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"RemoveColor\",\n        /**\n     * Color to remove, in any format understood by fabric.Color.\n     * @param {String} type\n     * @default\n     */ color: \"#FFFFFF\",\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec4 uLow;\\n\" + \"uniform vec4 uHigh;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"gl_FragColor = texture2D(uTexture, vTexCoord);\\n\" + \"if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\\n\" + \"gl_FragColor.a = 0.0;\\n\" + \"}\\n\" + \"}\",\n        /**\n     * distance to actual color, as value up or down from each r,g,b\n     * between 0 and 1\n     **/ distance: 0.02,\n        /**\n     * For color to remove inside distance, use alpha channel for a smoother deletion\n     * NOT IMPLEMENTED YET\n     **/ useAlpha: false,\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.RemoveWhite.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.color=#RRGGBB] Threshold value\n     * @param {Number} [options.distance=10] Distance value\n     */ /**\n     * Applies filter to canvas element\n     * @param {Object} canvasEl Canvas element to apply filter to\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, distance = this.distance * 255, r, g, b, source = new fabric.Color(this.color).getSource(), lowC = [\n                source[0] - distance,\n                source[1] - distance,\n                source[2] - distance\n            ], highC = [\n                source[0] + distance,\n                source[1] + distance,\n                source[2] + distance\n            ];\n            for(i = 0; i < data.length; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                if (r > lowC[0] && g > lowC[1] && b > lowC[2] && r < highC[0] && g < highC[1] && b < highC[2]) {\n                    data[i + 3] = 0;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uLow: gl.getUniformLocation(program, \"uLow\"),\n                uHigh: gl.getUniformLocation(program, \"uHigh\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var source = new fabric.Color(this.color).getSource(), distance = parseFloat(this.distance), lowC = [\n                0 + source[0] / 255 - distance,\n                0 + source[1] / 255 - distance,\n                0 + source[2] / 255 - distance,\n                1\n            ], highC = [\n                source[0] / 255 + distance,\n                source[1] / 255 + distance,\n                source[2] / 255 + distance,\n                1\n            ];\n            gl.uniform4fv(uniformLocations.uLow, lowC);\n            gl.uniform4fv(uniformLocations.uHigh, highC);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                color: this.color,\n                distance: this.distance\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite\n   */ fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    var matrices = {\n        Brownie: [\n            0.59970,\n            0.34553,\n            -0.27082,\n            0,\n            0.186,\n            -0.03770,\n            0.86095,\n            0.15059,\n            0,\n            -0.1449,\n            0.24113,\n            -0.07441,\n            0.44972,\n            0,\n            -0.02965,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Vintage: [\n            0.62793,\n            0.32021,\n            -0.03965,\n            0,\n            0.03784,\n            0.02578,\n            0.64411,\n            0.03259,\n            0,\n            0.02926,\n            0.04660,\n            -0.08512,\n            0.52416,\n            0,\n            0.02023,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Kodachrome: [\n            1.12855,\n            -0.39673,\n            -0.03992,\n            0,\n            0.24991,\n            -0.16404,\n            1.08352,\n            -0.05498,\n            0,\n            0.09698,\n            -0.16786,\n            -0.56034,\n            1.60148,\n            0,\n            0.13972,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Technicolor: [\n            1.91252,\n            -0.85453,\n            -0.09155,\n            0,\n            0.04624,\n            -0.30878,\n            1.76589,\n            -0.10601,\n            0,\n            -0.27589,\n            -0.23110,\n            -0.75018,\n            1.84759,\n            0,\n            0.12137,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Polaroid: [\n            1.438,\n            -0.062,\n            -0.062,\n            0,\n            0,\n            -0.122,\n            1.378,\n            -0.122,\n            0,\n            0,\n            -0.016,\n            -0.016,\n            1.483,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Sepia: [\n            0.393,\n            0.769,\n            0.189,\n            0,\n            0,\n            0.349,\n            0.686,\n            0.168,\n            0,\n            0,\n            0.272,\n            0.534,\n            0.131,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        BlackWhite: [\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            0,\n            0,\n            0,\n            1,\n            0\n        ]\n    };\n    for(var key in matrices){\n        filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {\n            /**\n       * Filter type\n       * @param {String} type\n       * @default\n       */ type: key,\n            /**\n       * Colormatrix for the effect\n       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n       * outside the -1, 1 range.\n       * @param {Array} matrix array of 20 numbers.\n       * @default\n       */ matrix: matrices[key],\n            /**\n       * Lock the matrix export for this kind of static, parameter less filters.\n       */ mainParameter: false,\n            /**\n       * Lock the colormatrix on the color part, skipping alpha\n       */ colorsOnly: true\n        });\n        fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;\n    }\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Color Blend filter class\n   * @class fabric.Image.filter.BlendColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {\n        type: \"BlendColor\",\n        /**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     * @type String\n     * @default\n     **/ color: \"#F95C63\",\n        /**\n     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,\n     * darken, lighten, overlay, exclusion, tint.\n     * @type String\n     * @default\n     **/ mode: \"multiply\",\n        /**\n     * alpha value. represent the strength of the blend color operation.\n     * @type Number\n     * @default\n     **/ alpha: 1,\n        /**\n     * Fragment source for the Multiply program\n     */ fragmentSource: {\n            multiply: \"gl_FragColor.rgb *= uColor.rgb;\\n\",\n            screen: \"gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\\n\",\n            add: \"gl_FragColor.rgb += uColor.rgb;\\n\",\n            diff: \"gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\\n\",\n            subtract: \"gl_FragColor.rgb -= uColor.rgb;\\n\",\n            lighten: \"gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\\n\",\n            darken: \"gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\\n\",\n            exclusion: \"gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\\n\",\n            overlay: \"if (uColor.r < 0.5) {\\n\" + \"gl_FragColor.r *= 2.0 * uColor.r;\\n\" + \"} else {\\n\" + \"gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\\n\" + \"}\\n\" + \"if (uColor.g < 0.5) {\\n\" + \"gl_FragColor.g *= 2.0 * uColor.g;\\n\" + \"} else {\\n\" + \"gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\\n\" + \"}\\n\" + \"if (uColor.b < 0.5) {\\n\" + \"gl_FragColor.b *= 2.0 * uColor.b;\\n\" + \"} else {\\n\" + \"gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\\n\" + \"}\\n\",\n            tint: \"gl_FragColor.rgb *= (1.0 - uColor.a);\\n\" + \"gl_FragColor.rgb += uColor.rgb;\\n\"\n        },\n        /**\n     * build the fragment source for the filters, joining the common part with\n     * the specific one.\n     * @param {String} mode the mode of the filter, a key of this.fragmentSource\n     * @return {String} the source to be compiled\n     * @private\n     */ buildSource: function(mode) {\n            return \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"gl_FragColor = color;\\n\" + \"if (color.a > 0.0) {\\n\" + this.fragmentSource[mode] + \"}\\n\" + \"}\";\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode, shaderSource;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                shaderSource = this.buildSource(this.mode);\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = data.length, tr, tg, tb, r, g, b, source, alpha1 = 1 - this.alpha;\n            source = new fabric.Color(this.color).getSource();\n            tr = source[0] * this.alpha;\n            tg = source[1] * this.alpha;\n            tb = source[2] * this.alpha;\n            for(var i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                switch(this.mode){\n                    case \"multiply\":\n                        data[i] = r * tr / 255;\n                        data[i + 1] = g * tg / 255;\n                        data[i + 2] = b * tb / 255;\n                        break;\n                    case \"screen\":\n                        data[i] = 255 - (255 - r) * (255 - tr) / 255;\n                        data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;\n                        data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;\n                        break;\n                    case \"add\":\n                        data[i] = r + tr;\n                        data[i + 1] = g + tg;\n                        data[i + 2] = b + tb;\n                        break;\n                    case \"diff\":\n                    case \"difference\":\n                        data[i] = Math.abs(r - tr);\n                        data[i + 1] = Math.abs(g - tg);\n                        data[i + 2] = Math.abs(b - tb);\n                        break;\n                    case \"subtract\":\n                        data[i] = r - tr;\n                        data[i + 1] = g - tg;\n                        data[i + 2] = b - tb;\n                        break;\n                    case \"darken\":\n                        data[i] = Math.min(r, tr);\n                        data[i + 1] = Math.min(g, tg);\n                        data[i + 2] = Math.min(b, tb);\n                        break;\n                    case \"lighten\":\n                        data[i] = Math.max(r, tr);\n                        data[i + 1] = Math.max(g, tg);\n                        data[i + 2] = Math.max(b, tb);\n                        break;\n                    case \"overlay\":\n                        data[i] = tr < 128 ? 2 * r * tr / 255 : 255 - 2 * (255 - r) * (255 - tr) / 255;\n                        data[i + 1] = tg < 128 ? 2 * g * tg / 255 : 255 - 2 * (255 - g) * (255 - tg) / 255;\n                        data[i + 2] = tb < 128 ? 2 * b * tb / 255 : 255 - 2 * (255 - b) * (255 - tb) / 255;\n                        break;\n                    case \"exclusion\":\n                        data[i] = tr + r - 2 * tr * r / 255;\n                        data[i + 1] = tg + g - 2 * tg * g / 255;\n                        data[i + 2] = tb + b - 2 * tb * b / 255;\n                        break;\n                    case \"tint\":\n                        data[i] = tr + r * alpha1;\n                        data[i + 1] = tg + g * alpha1;\n                        data[i + 2] = tb + b * alpha1;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uColor: gl.getUniformLocation(program, \"uColor\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var source = new fabric.Color(this.color).getSource();\n            source[0] = this.alpha * source[0] / 255;\n            source[1] = this.alpha * source[1] / 255;\n            source[2] = this.alpha * source[2] / 255;\n            source[3] = this.alpha;\n            gl.uniform4fv(uniformLocations.uColor, source);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                color: this.color,\n                mode: this.mode,\n                alpha: this.alpha\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor\n   */ fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Image Blend filter class\n   * @class fabric.Image.filter.BlendImage\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {\n        type: \"BlendImage\",\n        /**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     **/ image: null,\n        /**\n     * Blend mode for the filter (one of \"multiply\", \"mask\")\n     * @type String\n     * @default\n     **/ mode: \"multiply\",\n        /**\n     * alpha value. represent the strength of the blend image operation.\n     * not implemented.\n     **/ alpha: 1,\n        vertexSource: \"attribute vec2 aPosition;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"uniform mat3 uTransformMatrix;\\n\" + \"void main() {\\n\" + \"vTexCoord = aPosition;\\n\" + \"vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\\n\" + \"gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n\" + \"}\",\n        /**\n     * Fragment source for the Multiply program\n     */ fragmentSource: {\n            multiply: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform sampler2D uImage;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec4 color2 = texture2D(uImage, vTexCoord2);\\n\" + \"color.rgba *= color2.rgba;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            mask: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform sampler2D uImage;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec4 color2 = texture2D(uImage, vTexCoord2);\\n\" + \"color.a = color2.a;\\n\" + \"gl_FragColor = color;\\n\" + \"}\"\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode;\n            var shaderSource = this.fragmentSource[this.mode];\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        applyToWebGL: function(options) {\n            // load texture to blend.\n            var gl = options.context, texture = this.createTexture(options.filterBackend, this.image);\n            this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);\n            this.callSuper(\"applyToWebGL\", options);\n            this.unbindAdditionalTexture(gl, gl.TEXTURE1);\n        },\n        createTexture: function(backend, image) {\n            return backend.getCachedTexture(image.cacheKey, image._element);\n        },\n        /**\n     * Calculate a transformMatrix to adapt the image to blend over\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ calculateMatrix: function() {\n            var image = this.image, width = image._element.width, height = image._element.height;\n            return [\n                1 / image.scaleX,\n                0,\n                0,\n                0,\n                1 / image.scaleY,\n                0,\n                -image.left / width,\n                -image.top / height,\n                1\n            ];\n        },\n        /**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, resources = options.filterBackend.resources, data = imageData.data, iLen = data.length, width = imageData.width, height = imageData.height, tr, tg, tb, ta, r, g, b, a, canvas1, context, image = this.image, blendData;\n            if (!resources.blendImage) {\n                resources.blendImage = fabric.util.createCanvasElement();\n            }\n            canvas1 = resources.blendImage;\n            context = canvas1.getContext(\"2d\");\n            if (canvas1.width !== width || canvas1.height !== height) {\n                canvas1.width = width;\n                canvas1.height = height;\n            } else {\n                context.clearRect(0, 0, width, height);\n            }\n            context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);\n            context.drawImage(image._element, 0, 0, width, height);\n            blendData = context.getImageData(0, 0, width, height).data;\n            for(var i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                a = data[i + 3];\n                tr = blendData[i];\n                tg = blendData[i + 1];\n                tb = blendData[i + 2];\n                ta = blendData[i + 3];\n                switch(this.mode){\n                    case \"multiply\":\n                        data[i] = r * tr / 255;\n                        data[i + 1] = g * tg / 255;\n                        data[i + 2] = b * tb / 255;\n                        data[i + 3] = a * ta / 255;\n                        break;\n                    case \"mask\":\n                        data[i + 3] = ta;\n                        break;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uTransformMatrix: gl.getUniformLocation(program, \"uTransformMatrix\"),\n                uImage: gl.getUniformLocation(program, \"uImage\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var matrix = this.calculateMatrix();\n            gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.\n            gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                image: this.image && this.image.toObject(),\n                mode: this.mode,\n                alpha: this.alpha\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} callback to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage\n   */ fabric.Image.filters.BlendImage.fromObject = function(object, callback) {\n        fabric.Image.fromObject(object.image, function(image) {\n            var options = fabric.util.object.clone(object);\n            options.image = image;\n            callback(new fabric.Image.filters.BlendImage(options));\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), pow = Math.pow, floor = Math.floor, sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin, ceil = Math.ceil, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Resize image filter class\n   * @class fabric.Image.filters.Resize\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Resize();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */ filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Resize\",\n        /**\n     * Resize type\n     * for webgl resizeType is just lanczos, for canvas2d can be:\n     * bilinear, hermite, sliceHack, lanczos.\n     * @param {String} resizeType\n     * @default\n     */ resizeType: \"hermite\",\n        /**\n     * Scale factor for resizing, x axis\n     * @param {Number} scaleX\n     * @default\n     */ scaleX: 1,\n        /**\n     * Scale factor for resizing, y axis\n     * @param {Number} scaleY\n     * @default\n     */ scaleY: 1,\n        /**\n     * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos\n     * @param {Number} lanczosLobes\n     * @default\n     */ lanczosLobes: 3,\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uDelta: gl.getUniformLocation(program, \"uDelta\"),\n                uTaps: gl.getUniformLocation(program, \"uTaps\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [\n                1 / this.width,\n                0\n            ] : [\n                0,\n                1 / this.height\n            ]);\n            gl.uniform1fv(uniformLocations.uTaps, this.taps);\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var filterWindow = this.getFilterWindow(), cacheKey = this.type + \"_\" + filterWindow;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                var fragmentShader = this.generateShader(filterWindow);\n                options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);\n            }\n            return options.programCache[cacheKey];\n        },\n        getFilterWindow: function() {\n            var scale = this.tempScale;\n            return Math.ceil(this.lanczosLobes / scale);\n        },\n        getTaps: function() {\n            var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale, filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);\n            for(var i = 1; i <= filterWindow; i++){\n                taps[i - 1] = lobeFunction(i * scale);\n            }\n            return taps;\n        },\n        /**\n     * Generate vertex and shader sources from the necessary steps numbers\n     * @param {Number} filterWindow\n     */ generateShader: function(filterWindow) {\n            var offsets = new Array(filterWindow), fragmentShader = this.fragmentSourceTOP, filterWindow;\n            for(var i = 1; i <= filterWindow; i++){\n                offsets[i - 1] = i + \".0 * uDelta\";\n            }\n            fragmentShader += \"uniform float uTaps[\" + filterWindow + \"];\\n\";\n            fragmentShader += \"void main() {\\n\";\n            fragmentShader += \"  vec4 color = texture2D(uTexture, vTexCoord);\\n\";\n            fragmentShader += \"  float sum = 1.0;\\n\";\n            offsets.forEach(function(offset, i) {\n                fragmentShader += \"  color += texture2D(uTexture, vTexCoord + \" + offset + \") * uTaps[\" + i + \"];\\n\";\n                fragmentShader += \"  color += texture2D(uTexture, vTexCoord - \" + offset + \") * uTaps[\" + i + \"];\\n\";\n                fragmentShader += \"  sum += 2.0 * uTaps[\" + i + \"];\\n\";\n            });\n            fragmentShader += \"  gl_FragColor = color / sum;\\n\";\n            fragmentShader += \"}\";\n            return fragmentShader;\n        },\n        fragmentSourceTOP: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec2 uDelta;\\n\" + \"varying vec2 vTexCoord;\\n\",\n        /**\n     * Apply the resize filter to the image\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ applyTo: function(options) {\n            if (options.webgl) {\n                options.passes++;\n                this.width = options.sourceWidth;\n                this.horizontal = true;\n                this.dW = Math.round(this.width * this.scaleX);\n                this.dH = options.sourceHeight;\n                this.tempScale = this.dW / this.width;\n                this.taps = this.getTaps();\n                options.destinationWidth = this.dW;\n                this._setupFrameBuffer(options);\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                options.sourceWidth = options.destinationWidth;\n                this.height = options.sourceHeight;\n                this.horizontal = false;\n                this.dH = Math.round(this.height * this.scaleY);\n                this.tempScale = this.dH / this.height;\n                this.taps = this.getTaps();\n                options.destinationHeight = this.dH;\n                this._setupFrameBuffer(options);\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                options.sourceHeight = options.destinationHeight;\n            } else {\n                this.applyTo2d(options);\n            }\n        },\n        isNeutralState: function() {\n            return this.scaleX === 1 && this.scaleY === 1;\n        },\n        lanczosCreate: function(lobes) {\n            return function(x) {\n                if (x >= lobes || x <= -lobes) {\n                    return 0.0;\n                }\n                if (x < 1.19209290E-07 && x > -1.19209290E-07) {\n                    return 1.0;\n                }\n                x *= Math.PI;\n                var xx = x / lobes;\n                return sin(x) / x * sin(xx) / xx;\n            };\n        },\n        /**\n     * Applies filter to canvas element\n     * @memberOf fabric.Image.filters.Resize.prototype\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} scaleX\n     * @param {Number} scaleY\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, scaleX = this.scaleX, scaleY = this.scaleY;\n            this.rcpScaleX = 1 / scaleX;\n            this.rcpScaleY = 1 / scaleY;\n            var oW = imageData.width, oH = imageData.height, dW = round(oW * scaleX), dH = round(oH * scaleY), newData;\n            if (this.resizeType === \"sliceHack\") {\n                newData = this.sliceByTwo(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"hermite\") {\n                newData = this.hermiteFastResize(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"bilinear\") {\n                newData = this.bilinearFiltering(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"lanczos\") {\n                newData = this.lanczosResize(options, oW, oH, dW, dH);\n            }\n            options.imageData = newData;\n        },\n        /**\n     * Filter sliceByTwo\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ sliceByTwo: function(options, oW, oH, dW, dH) {\n            var imageData = options.imageData, mult = 0.5, doneW = false, doneH = false, stepW = oW * mult, stepH = oH * mult, resources = fabric.filterBackend.resources, tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;\n            if (!resources.sliceByTwo) {\n                resources.sliceByTwo = document.createElement(\"canvas\");\n            }\n            tmpCanvas = resources.sliceByTwo;\n            if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {\n                tmpCanvas.width = oW * 1.5;\n                tmpCanvas.height = oH;\n            }\n            ctx = tmpCanvas.getContext(\"2d\");\n            ctx.clearRect(0, 0, oW * 1.5, oH);\n            ctx.putImageData(imageData, 0, 0);\n            dW = floor(dW);\n            dH = floor(dH);\n            while(!doneW || !doneH){\n                oW = stepW;\n                oH = stepH;\n                if (dW < floor(stepW * mult)) {\n                    stepW = floor(stepW * mult);\n                } else {\n                    stepW = dW;\n                    doneW = true;\n                }\n                if (dH < floor(stepH * mult)) {\n                    stepH = floor(stepH * mult);\n                } else {\n                    stepH = dH;\n                    doneH = true;\n                }\n                ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);\n                sX = dX;\n                sY = dY;\n                dY += stepH;\n            }\n            return ctx.getImageData(sX, sY, dW, dH);\n        },\n        /**\n     * Filter lanczosResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ lanczosResize: function(options, oW, oH, dW, dH) {\n            function process(u) {\n                var v, i, weight, idx, a, red, green, blue, alpha, fX, fY;\n                center.x = (u + 0.5) * ratioX;\n                icenter.x = floor(center.x);\n                for(v = 0; v < dH; v++){\n                    center.y = (v + 0.5) * ratioY;\n                    icenter.y = floor(center.y);\n                    a = 0;\n                    red = 0;\n                    green = 0;\n                    blue = 0;\n                    alpha = 0;\n                    for(i = icenter.x - range2X; i <= icenter.x + range2X; i++){\n                        if (i < 0 || i >= oW) {\n                            continue;\n                        }\n                        fX = floor(1000 * abs(i - center.x));\n                        if (!cacheLanc[fX]) {\n                            cacheLanc[fX] = {};\n                        }\n                        for(var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++){\n                            if (j < 0 || j >= oH) {\n                                continue;\n                            }\n                            fY = floor(1000 * abs(j - center.y));\n                            if (!cacheLanc[fX][fY]) {\n                                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);\n                            }\n                            weight = cacheLanc[fX][fY];\n                            if (weight > 0) {\n                                idx = (j * oW + i) * 4;\n                                a += weight;\n                                red += weight * srcData[idx];\n                                green += weight * srcData[idx + 1];\n                                blue += weight * srcData[idx + 2];\n                                alpha += weight * srcData[idx + 3];\n                            }\n                        }\n                    }\n                    idx = (v * dW + u) * 4;\n                    destData[idx] = red / a;\n                    destData[idx + 1] = green / a;\n                    destData[idx + 2] = blue / a;\n                    destData[idx + 3] = alpha / a;\n                }\n                if (++u < dW) {\n                    return process(u);\n                } else {\n                    return destImg;\n                }\n            }\n            var srcData = options.imageData.data, destImg = options.ctx.createImageData(dW, dH), destData = destImg.data, lanczos = this.lanczosCreate(this.lanczosLobes), ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY, range2X = ceil(ratioX * this.lanczosLobes / 2), range2Y = ceil(ratioY * this.lanczosLobes / 2), cacheLanc = {}, center = {}, icenter = {};\n            return process(0);\n        },\n        /**\n     * bilinearFiltering\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ bilinearFiltering: function(options, oW, oH, dW, dH) {\n            var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl, color, offset = 0, origPix, ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, w4 = 4 * (oW - 1), img = options.imageData, pixels = img.data, destImage = options.ctx.createImageData(dW, dH), destPixels = destImage.data;\n            for(i = 0; i < dH; i++){\n                for(j = 0; j < dW; j++){\n                    x = floor(ratioX * j);\n                    y = floor(ratioY * i);\n                    xDiff = ratioX * j - x;\n                    yDiff = ratioY * i - y;\n                    origPix = 4 * (y * oW + x);\n                    for(chnl = 0; chnl < 4; chnl++){\n                        a = pixels[origPix + chnl];\n                        b = pixels[origPix + 4 + chnl];\n                        c = pixels[origPix + w4 + chnl];\n                        d = pixels[origPix + w4 + 4 + chnl];\n                        color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) + c * yDiff * (1 - xDiff) + d * xDiff * yDiff;\n                        destPixels[offset++] = color;\n                    }\n                }\n            }\n            return destImage;\n        },\n        /**\n     * hermiteFastResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ hermiteFastResize: function(options, oW, oH, dW, dH) {\n            var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY, ratioWHalf = ceil(ratioW / 2), ratioHHalf = ceil(ratioH / 2), img = options.imageData, data = img.data, img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;\n            for(var j = 0; j < dH; j++){\n                for(var i = 0; i < dW; i++){\n                    var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0, gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;\n                    for(var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++){\n                        var dy = abs(centerY - (yy + 0.5)) / ratioHHalf, centerX = (i + 0.5) * ratioW, w0 = dy * dy;\n                        for(var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++){\n                            var dx = abs(centerX - (xx + 0.5)) / ratioWHalf, w = sqrt(w0 + dx * dx);\n                            /* eslint-disable max-depth */ if (w > 1 && w < -1) {\n                                continue;\n                            }\n                            //hermite filter\n                            weight = 2 * w * w * w - 3 * w * w + 1;\n                            if (weight > 0) {\n                                dx = 4 * (xx + yy * oW);\n                                //alpha\n                                gxA += weight * data[dx + 3];\n                                weightsAlpha += weight;\n                                //colors\n                                if (data[dx + 3] < 255) {\n                                    weight = weight * data[dx + 3] / 250;\n                                }\n                                gxR += weight * data[dx];\n                                gxG += weight * data[dx + 1];\n                                gxB += weight * data[dx + 2];\n                                weights += weight;\n                            }\n                        /* eslint-enable max-depth */ }\n                    }\n                    data2[x2] = gxR / weights;\n                    data2[x2 + 1] = gxG / weights;\n                    data2[x2 + 2] = gxB / weights;\n                    data2[x2 + 3] = gxA / weightsAlpha;\n                }\n            }\n            return img2;\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                resizeType: this.resizeType,\n                lanczosLobes: this.lanczosLobes\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize\n   */ fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Contrast filter class\n   * @class fabric.Image.filters.Contrast\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Contrast({\n   *   contrast: 0.25\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Contrast\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uContrast;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\\n\" + \"color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * contrast value, range from -1 to 1.\n     * @param {Number} contrast\n     * @default 0\n     */ contrast: 0,\n        mainParameter: \"contrast\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Contrast.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)\n     */ /**\n      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.\n      *\n      * @param {Object} options\n      * @param {ImageData} options.imageData The Uint8Array to be filtered.\n      */ applyTo2d: function(options) {\n            if (this.contrast === 0) {\n                return;\n            }\n            var imageData = options.imageData, i, len, data = imageData.data, len = data.length, contrast = Math.floor(this.contrast * 255), contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));\n            for(i = 0; i < len; i += 4){\n                data[i] = contrastF * (data[i] - 128) + 128;\n                data[i + 1] = contrastF * (data[i + 1] - 128) + 128;\n                data[i + 2] = contrastF * (data[i + 2] - 128) + 128;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uContrast: gl.getUniformLocation(program, \"uContrast\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uContrast, this.contrast);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast\n   */ fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Saturate filter class\n   * @class fabric.Image.filters.Saturation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Saturation({\n   *   saturation: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Saturation\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uSaturation;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float rgMax = max(color.r, color.g);\\n\" + \"float rgbMax = max(rgMax, color.b);\\n\" + \"color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\\n\" + \"color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\\n\" + \"color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Saturation value, from -1 to 1.\n     * Increases/decreases the color saturation.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} saturation\n     * @default\n     */ saturation: 0,\n        mainParameter: \"saturation\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Saturate.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)\n     */ /**\n     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.saturation === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.saturation, i, max;\n            for(i = 0; i < len; i += 4){\n                max = Math.max(data[i], data[i + 1], data[i + 2]);\n                data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;\n                data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;\n                data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uSaturation: gl.getUniformLocation(program, \"uSaturation\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uSaturation, -this.saturation);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate\n   */ fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Vibrance filter class\n   * @class fabric.Image.filters.Vibrance\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Vibrance#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Vibrance({\n   *   vibrance: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Vibrance = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Vibrance.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Vibrance\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uVibrance;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float max = max(color.r, max(color.g, color.b));\\n\" + \"float avg = (color.r + color.g + color.b) / 3.0;\\n\" + \"float amt = (abs(max - avg) * 2.0) * uVibrance;\\n\" + \"color.r += max != color.r ? (max - color.r) * amt : 0.00;\\n\" + \"color.g += max != color.g ? (max - color.g) * amt : 0.00;\\n\" + \"color.b += max != color.b ? (max - color.b) * amt : 0.00;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Vibrance value, from -1 to 1.\n     * Increases/decreases the saturation of more muted colors with less effect on saturated colors.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} vibrance\n     * @default\n     */ vibrance: 0,\n        mainParameter: \"vibrance\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Vibrance.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.vibrance=0] Vibrance value for the image (between -1 and 1)\n     */ /**\n     * Apply the Vibrance operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.vibrance === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.vibrance, i, max, avg, amt;\n            for(i = 0; i < len; i += 4){\n                max = Math.max(data[i], data[i + 1], data[i + 2]);\n                avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\n                amt = Math.abs(max - avg) * 2 / 255 * adjust;\n                data[i] += max !== data[i] ? (max - data[i]) * amt : 0;\n                data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * amt : 0;\n                data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * amt : 0;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uVibrance: gl.getUniformLocation(program, \"uVibrance\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uVibrance, -this.vibrance);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Vibrance} Instance of fabric.Image.filters.Vibrance\n   */ fabric.Image.filters.Vibrance.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Blur filter class\n   * @class fabric.Image.filters.Blur\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Blur({\n   *   blur: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {\n        type: \"Blur\",\n        /*\n'gl_FragColor = vec4(0.0);',\n'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',\n'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',\n'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',\n*/ /* eslint-disable max-len */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec2 uDelta;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"const float nSamples = 15.0;\\n\" + \"vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\\n\" + \"float random(vec3 scale) {\\n\" + /* use the fragment position for a different seed per-pixel */ \"return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\\n\" + \"}\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0.0);\\n\" + \"float total = 0.0;\\n\" + \"float offset = random(v3offset);\\n\" + \"for (float t = -nSamples; t <= nSamples; t++) {\\n\" + \"float percent = (t + offset - 0.5) / nSamples;\\n\" + \"float weight = 1.0 - abs(percent);\\n\" + \"color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\\n\" + \"total += weight;\\n\" + \"}\\n\" + \"gl_FragColor = color / total;\\n\" + \"}\",\n        /* eslint-enable max-len */ /**\n     * blur value, in percentage of image dimensions.\n     * specific to keep the image blur constant at different resolutions\n     * range between 0 and 1.\n     * @type Number\n     * @default\n     */ blur: 0,\n        mainParameter: \"blur\",\n        applyTo: function(options) {\n            if (options.webgl) {\n                // this aspectRatio is used to give the same blur to vertical and horizontal\n                this.aspectRatio = options.sourceWidth / options.sourceHeight;\n                options.passes++;\n                this._setupFrameBuffer(options);\n                this.horizontal = true;\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                this._setupFrameBuffer(options);\n                this.horizontal = false;\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n            } else {\n                this.applyTo2d(options);\n            }\n        },\n        applyTo2d: function(options) {\n            // paint canvasEl with current image data.\n            //options.ctx.putImageData(options.imageData, 0, 0);\n            options.imageData = this.simpleBlur(options);\n        },\n        simpleBlur: function(options) {\n            var resources = options.filterBackend.resources, canvas1, canvas2, width = options.imageData.width, height = options.imageData.height;\n            if (!resources.blurLayer1) {\n                resources.blurLayer1 = fabric.util.createCanvasElement();\n                resources.blurLayer2 = fabric.util.createCanvasElement();\n            }\n            canvas1 = resources.blurLayer1;\n            canvas2 = resources.blurLayer2;\n            if (canvas1.width !== width || canvas1.height !== height) {\n                canvas2.width = canvas1.width = width;\n                canvas2.height = canvas1.height = height;\n            }\n            var ctx1 = canvas1.getContext(\"2d\"), ctx2 = canvas2.getContext(\"2d\"), nSamples = 15, random, percent, j, i, blur = this.blur * 0.06 * 0.5;\n            // load first canvas\n            ctx1.putImageData(options.imageData, 0, 0);\n            ctx2.clearRect(0, 0, width, height);\n            for(i = -nSamples; i <= nSamples; i++){\n                random = (Math.random() - 0.5) / 4;\n                percent = i / nSamples;\n                j = blur * percent * width + random;\n                ctx2.globalAlpha = 1 - Math.abs(percent);\n                ctx2.drawImage(canvas1, j, random);\n                ctx1.drawImage(canvas2, 0, 0);\n                ctx2.globalAlpha = 1;\n                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);\n            }\n            for(i = -nSamples; i <= nSamples; i++){\n                random = (Math.random() - 0.5) / 4;\n                percent = i / nSamples;\n                j = blur * percent * height + random;\n                ctx2.globalAlpha = 1 - Math.abs(percent);\n                ctx2.drawImage(canvas1, random, j);\n                ctx1.drawImage(canvas2, 0, 0);\n                ctx2.globalAlpha = 1;\n                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);\n            }\n            options.ctx.drawImage(canvas1, 0, 0);\n            var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);\n            ctx1.globalAlpha = 1;\n            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);\n            return newImageData;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                delta: gl.getUniformLocation(program, \"uDelta\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var delta = this.chooseRightDelta();\n            gl.uniform2fv(uniformLocations.delta, delta);\n        },\n        /**\n     * choose right value of image percentage to blur with\n     * @returns {Array} a numeric array with delta values\n     */ chooseRightDelta: function() {\n            var blurScale = 1, delta = [\n                0,\n                0\n            ], blur;\n            if (this.horizontal) {\n                if (this.aspectRatio > 1) {\n                    // image is wide, i want to shrink radius horizontal\n                    blurScale = 1 / this.aspectRatio;\n                }\n            } else {\n                if (this.aspectRatio < 1) {\n                    // image is tall, i want to shrink radius vertical\n                    blurScale = this.aspectRatio;\n                }\n            }\n            blur = blurScale * this.blur * 0.12;\n            if (this.horizontal) {\n                delta[0] = blur;\n            } else {\n                delta[1] = blur;\n            }\n            return delta;\n        }\n    });\n    /**\n   * Deserialize a JSON definition of a BlurFilter into a concrete instance.\n   */ filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Gamma filter class\n   * @class fabric.Image.filters.Gamma\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Gamma({\n   *   gamma: [1, 0.5, 2.1]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Gamma\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec3 uGamma;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec3 correction = (1.0 / uGamma);\\n\" + \"color.r = pow(color.r, correction.r);\\n\" + \"color.g = pow(color.g, correction.g);\\n\" + \"color.b = pow(color.b, correction.b);\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.rgb *= color.a;\\n\" + \"}\",\n        /**\n     * Gamma array value, from 0.01 to 2.2.\n     * @param {Array} gamma\n     * @default\n     */ gamma: [\n            1,\n            1,\n            1\n        ],\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"gamma\",\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.gamma = [\n                1,\n                1,\n                1\n            ];\n            filters.BaseFilter.prototype.initialize.call(this, options);\n        },\n        /**\n     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, gamma = this.gamma, len = data.length, rInv = 1 / gamma[0], gInv = 1 / gamma[1], bInv = 1 / gamma[2], i;\n            if (!this.rVals) {\n                // eslint-disable-next-line\n                this.rVals = new Uint8Array(256);\n                // eslint-disable-next-line\n                this.gVals = new Uint8Array(256);\n                // eslint-disable-next-line\n                this.bVals = new Uint8Array(256);\n            }\n            // This is an optimization - pre-compute a look-up table for each color channel\n            // instead of performing these pow calls for each pixel in the image.\n            for(i = 0, len = 256; i < len; i++){\n                this.rVals[i] = Math.pow(i / 255, rInv) * 255;\n                this.gVals[i] = Math.pow(i / 255, gInv) * 255;\n                this.bVals[i] = Math.pow(i / 255, bInv) * 255;\n            }\n            for(i = 0, len = data.length; i < len; i += 4){\n                data[i] = this.rVals[data[i]];\n                data[i + 1] = this.gVals[data[i + 1]];\n                data[i + 2] = this.bVals[data[i + 2]];\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uGamma: gl.getUniformLocation(program, \"uGamma\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform3fv(uniformLocations.uGamma, this.gamma);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma\n   */ fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * A container class that knows how to apply a sequence of filters to an input image.\n   */ filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {\n        type: \"Composed\",\n        /**\n     * A non sparse array of filters to apply\n     */ subFilters: [],\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            // create a new array instead mutating the prototype with push\n            this.subFilters = this.subFilters.slice(0);\n        },\n        /**\n     * Apply this container's filters to the input image provided.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be applied.\n     */ applyTo: function(options) {\n            options.passes += this.subFilters.length - 1;\n            this.subFilters.forEach(function(filter) {\n                filter.applyTo(options);\n            });\n        },\n        /**\n     * Serialize this filter into JSON.\n     *\n     * @returns {Object} A JSON representation of this filter.\n     */ toObject: function() {\n            return fabric.util.object.extend(this.callSuper(\"toObject\"), {\n                subFilters: this.subFilters.map(function(filter) {\n                    return filter.toObject();\n                })\n            });\n        },\n        isNeutralState: function() {\n            return !this.subFilters.some(function(filter) {\n                return !filter.isNeutralState();\n            });\n        }\n    });\n    /**\n   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.\n   */ fabric.Image.filters.Composed.fromObject = function(object, callback) {\n        var filters = object.subFilters || [], subFilters = filters.map(function(filter) {\n            return new fabric.Image.filters[filter.type](filter);\n        }), instance = new fabric.Image.filters.Composed({\n            subFilters: subFilters\n        });\n        callback && callback(instance);\n        return instance;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * HueRotation filter class\n   * @class fabric.Image.filters.HueRotation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.HueRotation({\n   *   rotation: -0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"HueRotation\",\n        /**\n     * HueRotation value, from -1 to 1.\n     * the unit is radians\n     * @param {Number} myParameter\n     * @default\n     */ rotation: 0,\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"rotation\",\n        calculateMatrix: function() {\n            var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad), aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;\n            this.matrix = [\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0\n            ];\n            this.matrix[0] = cos + OneMinusCos / 3;\n            this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[6] = cos + aThird * OneMinusCos;\n            this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[12] = cos + aThird * OneMinusCos;\n        },\n        /**\n     * HueRotation isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/ isNeutralState: function(options) {\n            this.calculateMatrix();\n            return filters.BaseFilter.prototype.isNeutralState.call(this, options);\n        },\n        /**\n     * Apply this filter to the input image data provided.\n     *\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ applyTo: function(options) {\n            this.calculateMatrix();\n            filters.BaseFilter.prototype.applyTo.call(this, options);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation\n   */ fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), clone = fabric.util.object.clone;\n    if (fabric.Text) {\n        fabric.warn(\"fabric.Text is already defined\");\n        return;\n    }\n    var additionalProps = (\"fontFamily fontWeight fontSize text underline overline linethrough\" + \" textAlign fontStyle lineHeight textBackgroundColor charSpacing styles\" + \" direction path pathStartOffset pathSide pathAlign\").split(\" \");\n    /**\n   * Text class\n   * @class fabric.Text\n   * @extends fabric.Object\n   * @return {fabric.Text} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}\n   * @see {@link fabric.Text#initialize} for constructor definition\n   */ fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {\n        /**\n     * Properties which when set cause object to change dimensions\n     * @type Array\n     * @private\n     */ _dimensionAffectingProps: [\n            \"fontSize\",\n            \"fontWeight\",\n            \"fontFamily\",\n            \"fontStyle\",\n            \"lineHeight\",\n            \"text\",\n            \"charSpacing\",\n            \"textAlign\",\n            \"styles\",\n            \"path\",\n            \"pathStartOffset\",\n            \"pathSide\",\n            \"pathAlign\"\n        ],\n        /**\n     * @private\n     */ _reNewline: /\\r?\\n/,\n        /**\n     * Use this regular expression to filter for whitespaces that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reSpacesAndTabs: /[ \\t\\r]/g,\n        /**\n     * Use this regular expression to filter for whitespace that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reSpaceAndTab: /[ \\t\\r]/,\n        /**\n     * Use this regular expression to filter consecutive groups of non spaces.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reWords: /\\S+/g,\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"text\",\n        /**\n     * Font size (in pixels)\n     * @type Number\n     * @default\n     */ fontSize: 40,\n        /**\n     * Font weight (e.g. bold, normal, 400, 600, 800)\n     * @type {(Number|String)}\n     * @default\n     */ fontWeight: \"normal\",\n        /**\n     * Font family\n     * @type String\n     * @default\n     */ fontFamily: \"Times New Roman\",\n        /**\n     * Text decoration underline.\n     * @type Boolean\n     * @default\n     */ underline: false,\n        /**\n     * Text decoration overline.\n     * @type Boolean\n     * @default\n     */ overline: false,\n        /**\n     * Text decoration linethrough.\n     * @type Boolean\n     * @default\n     */ linethrough: false,\n        /**\n     * Text alignment. Possible values: \"left\", \"center\", \"right\", \"justify\",\n     * \"justify-left\", \"justify-center\" or \"justify-right\".\n     * @type String\n     * @default\n     */ textAlign: \"left\",\n        /**\n     * Font style . Possible values: \"\", \"normal\", \"italic\" or \"oblique\".\n     * @type String\n     * @default\n     */ fontStyle: \"normal\",\n        /**\n     * Line height\n     * @type Number\n     * @default\n     */ lineHeight: 1.16,\n        /**\n     * Superscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */ superscript: {\n            size: 0.60,\n            baseline: -0.35 // baseline-shift factor (upwards)\n        },\n        /**\n     * Subscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */ subscript: {\n            size: 0.60,\n            baseline: 0.11 // baseline-shift factor (downwards)\n        },\n        /**\n     * Background color of text lines\n     * @type String\n     * @default\n     */ textBackgroundColor: \"\",\n        /**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(additionalProps),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * @type Array\n     */ cacheProperties: fabric.Object.prototype.cacheProperties.concat(additionalProps),\n        /**\n     * When defined, an object is rendered via stroke and this property specifies its color.\n     * <b>Backwards incompatibility note:</b> This property was named \"strokeStyle\" until v1.1.6\n     * @type String\n     * @default\n     */ stroke: null,\n        /**\n     * Shadow object representing shadow of this shape.\n     * <b>Backwards incompatibility note:</b> This property was named \"textShadow\" (String) until v1.2.11\n     * @type fabric.Shadow\n     * @default\n     */ shadow: null,\n        /**\n     * fabric.Path that the text should follow.\n     * since 4.6.0 the path will be drawn automatically.\n     * if you want to make the path visible, give it a stroke and strokeWidth or fill value\n     * if you want it to be hidden, assign visible = false to the path.\n     * This feature is in BETA, and SVG import/export is not yet supported.\n     * @type fabric.Path\n     * @example\n     * var textPath = new fabric.Text('Text on a path', {\n     *     top: 150,\n     *     left: 150,\n     *     textAlign: 'center',\n     *     charSpacing: -50,\n     *     path: new fabric.Path('M 0 0 C 50 -100 150 -100 200 0', {\n     *         strokeWidth: 1,\n     *         visible: false\n     *     }),\n     *     pathSide: 'left',\n     *     pathStartOffset: 0\n     * });\n     * @default\n     */ path: null,\n        /**\n     * Offset amount for text path starting position\n     * Only used when text has a path\n     * @type Number\n     * @default\n     */ pathStartOffset: 0,\n        /**\n     * Which side of the path the text should be drawn on.\n     * Only used when text has a path\n     * @type {String} 'left|right'\n     * @default\n     */ pathSide: \"left\",\n        /**\n     * How text is aligned to the path. This property determines\n     * the perpendicular position of each character relative to the path.\n     * (one of \"baseline\", \"center\", \"ascender\", \"descender\")\n     * This feature is in BETA, and its behavior may change\n     * @type String\n     * @default\n     */ pathAlign: \"baseline\",\n        /**\n     * @private\n     */ _fontSizeFraction: 0.222,\n        /**\n     * @private\n     */ offsets: {\n            underline: 0.10,\n            linethrough: -0.315,\n            overline: -0.88\n        },\n        /**\n     * Text Line proportion to font Size (in pixels)\n     * @type Number\n     * @default\n     */ _fontSizeMult: 1.13,\n        /**\n     * additional space between characters\n     * expressed in thousands of em unit\n     * @type Number\n     * @default\n     */ charSpacing: 0,\n        /**\n     * Object containing character styles - top-level properties -> line numbers,\n     * 2nd-level properties - character numbers\n     * @type Object\n     * @default\n     */ styles: null,\n        /**\n     * Reference to a context to measure text char or couple of chars\n     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas\n     * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every\n     * text object created.\n     * @type {CanvasRenderingContext2D}\n     * @default\n     */ _measuringContext: null,\n        /**\n     * Baseline shift, styles only, keep at 0 for the main text object\n     * @type {Number}\n     * @default\n     */ deltaY: 0,\n        /**\n     * WARNING: EXPERIMENTAL. NOT SUPPORTED YET\n     * determine the direction of the text.\n     * This has to be set manually together with textAlign and originX for proper\n     * experience.\n     * some interesting link for the future\n     * https://www.w3.org/International/questions/qa-bidi-unicode-controls\n     * @since 4.5.0\n     * @type {String} 'ltr|rtl'\n     * @default\n     */ direction: \"ltr\",\n        /**\n     * Array of properties that define a style unit (of 'styles').\n     * @type {Array}\n     * @default\n     */ _styleProperties: [\n            \"stroke\",\n            \"strokeWidth\",\n            \"fill\",\n            \"fontFamily\",\n            \"fontSize\",\n            \"fontWeight\",\n            \"fontStyle\",\n            \"underline\",\n            \"overline\",\n            \"linethrough\",\n            \"deltaY\",\n            \"textBackgroundColor\"\n        ],\n        /**\n     * contains characters bounding boxes\n     */ __charBounds: [],\n        /**\n     * use this size when measuring text. To avoid IE11 rounding errors\n     * @type {Number}\n     * @default\n     * @readonly\n     * @private\n     */ CACHE_FONT_SIZE: 400,\n        /**\n     * contains the min text width to avoid getting 0\n     * @type {Number}\n     * @default\n     */ MIN_TEXT_WIDTH: 2,\n        /**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */ initialize: function(text, options) {\n            this.styles = options ? options.styles || {} : {};\n            this.text = text;\n            this.__skipDimension = true;\n            this.callSuper(\"initialize\", options);\n            if (this.path) {\n                this.setPathInfo();\n            }\n            this.__skipDimension = false;\n            this.initDimensions();\n            this.setCoords();\n            this.setupState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * If text has a path, it will add the extra information needed\n     * for path and text calculations\n     * @return {fabric.Text} thisArg\n     */ setPathInfo: function() {\n            var path = this.path;\n            if (path) {\n                path.segmentsInfo = fabric.util.getPathSegmentsInfo(path.path);\n            }\n        },\n        /**\n     * Return a context for measurement of text string.\n     * if created it gets stored for reuse\n     * this is for internal use, please do not use it\n     * @private\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */ getMeasuringContext: function() {\n            // if we did not return we have to measure something.\n            if (!fabric._measuringContext) {\n                fabric._measuringContext = this.canvas && this.canvas.contextCache || fabric.util.createCanvasElement().getContext(\"2d\");\n            }\n            return fabric._measuringContext;\n        },\n        /**\n     * @private\n     * Divides text into lines of text and lines of graphemes.\n     */ _splitText: function() {\n            var newLines = this._splitTextIntoLines(this.text);\n            this.textLines = newLines.lines;\n            this._textLines = newLines.graphemeLines;\n            this._unwrappedTextLines = newLines._unwrappedLines;\n            this._text = newLines.graphemeText;\n            return newLines;\n        },\n        /**\n     * Initialize or update text dimensions.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     */ initDimensions: function() {\n            if (this.__skipDimension) {\n                return;\n            }\n            this._splitText();\n            this._clearCache();\n            if (this.path) {\n                this.width = this.path.width;\n                this.height = this.path.height;\n            } else {\n                this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;\n                this.height = this.calcTextHeight();\n            }\n            if (this.textAlign.indexOf(\"justify\") !== -1) {\n                // once text is measured we need to make space fatter to make justified text.\n                this.enlargeSpaces();\n            }\n            this.saveState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * Enlarge space boxes and shift the others\n     */ enlargeSpaces: function() {\n            var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                if (this.textAlign !== \"justify\" && (i === len - 1 || this.isEndOfWrapping(i))) {\n                    continue;\n                }\n                accumulatedSpace = 0;\n                line = this._textLines[i];\n                currentLineWidth = this.getLineWidth(i);\n                if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {\n                    numberOfSpaces = spaces.length;\n                    diffSpace = (this.width - currentLineWidth) / numberOfSpaces;\n                    for(var j = 0, jlen = line.length; j <= jlen; j++){\n                        charBound = this.__charBounds[i][j];\n                        if (this._reSpaceAndTab.test(line[j])) {\n                            charBound.width += diffSpace;\n                            charBound.kernedWidth += diffSpace;\n                            charBound.left += accumulatedSpace;\n                            accumulatedSpace += diffSpace;\n                        } else {\n                            charBound.left += accumulatedSpace;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @return {Boolean}\n     */ isEndOfWrapping: function(lineIndex) {\n            return lineIndex === this._textLines.length - 1;\n        },\n        /**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * It return always for text and Itext.\n     * @return Number\n     */ missingNewlineOffset: function() {\n            return 1;\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} String representation of text object\n     */ toString: function() {\n            return \"#<fabric.Text (\" + this.complexity() + '): { \"text\": \"' + this.text + '\", \"fontFamily\": \"' + this.fontFamily + '\" }>';\n        },\n        /**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @param {Object} dim.x width of object to be cached\n     * @param {Object} dim.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _getCacheCanvasDimensions: function() {\n            var dims = this.callSuper(\"_getCacheCanvasDimensions\");\n            var fontSize = this.fontSize;\n            dims.width += fontSize * dims.zoomX;\n            dims.height += fontSize * dims.zoomY;\n            return dims;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            var path = this.path;\n            path && !path.isNotVisible() && path._render(ctx);\n            this._setTextStyles(ctx);\n            this._renderTextLinesBackground(ctx);\n            this._renderTextDecoration(ctx, \"underline\");\n            this._renderText(ctx);\n            this._renderTextDecoration(ctx, \"overline\");\n            this._renderTextDecoration(ctx, \"linethrough\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderText: function(ctx) {\n            if (this.paintFirst === \"stroke\") {\n                this._renderTextStroke(ctx);\n                this._renderTextFill(ctx);\n            } else {\n                this._renderTextFill(ctx);\n                this._renderTextStroke(ctx);\n            }\n        },\n        /**\n     * Set the font parameter of the context with the object properties or with charStyle\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [charStyle] object with font style properties\n     * @param {String} [charStyle.fontFamily] Font Family\n     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )\n     * @param {String} [charStyle.fontWeight] Font weight\n     * @param {String} [charStyle.fontStyle] Font style (italic|normal)\n     */ _setTextStyles: function(ctx, charStyle, forMeasuring) {\n            ctx.textBaseline = \"alphabetical\";\n            if (this.path) {\n                switch(this.pathAlign){\n                    case \"center\":\n                        ctx.textBaseline = \"middle\";\n                        break;\n                    case \"ascender\":\n                        ctx.textBaseline = \"top\";\n                        break;\n                    case \"descender\":\n                        ctx.textBaseline = \"bottom\";\n                        break;\n                }\n            }\n            ctx.font = this._getFontDeclaration(charStyle, forMeasuring);\n        },\n        /**\n     * calculate and return the text Width measuring each line.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {Number} Maximum width of fabric.Text object\n     */ calcTextWidth: function() {\n            var maxWidth = this.getLineWidth(0);\n            for(var i = 1, len = this._textLines.length; i < len; i++){\n                var currentLineWidth = this.getLineWidth(i);\n                if (currentLineWidth > maxWidth) {\n                    maxWidth = currentLineWidth;\n                }\n            }\n            return maxWidth;\n        },\n        /**\n     * @private\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} line Text to render\n     * @param {Number} left Left position of text\n     * @param {Number} top Top position of text\n     * @param {Number} lineIndex Index of a line in a text\n     */ _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\n            this._renderChars(method, ctx, line, left, top, lineIndex);\n        },\n        /**\n     * Renders the text background for lines, taking care of style\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextLinesBackground: function(ctx) {\n            if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\")) {\n                return;\n            }\n            var heightOfLine, lineLeftOffset, originalFill = ctx.fillStyle, line, lastColor, leftOffset = this._getLeftOffset(), lineTopOffset = this._getTopOffset(), boxStart = 0, boxWidth = 0, charBox, currentColor, path = this.path, drawStart;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                heightOfLine = this.getHeightOfLine(i);\n                if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\", i)) {\n                    lineTopOffset += heightOfLine;\n                    continue;\n                }\n                line = this._textLines[i];\n                lineLeftOffset = this._getLineLeftOffset(i);\n                boxWidth = 0;\n                boxStart = 0;\n                lastColor = this.getValueOfPropertyAt(i, 0, \"textBackgroundColor\");\n                for(var j = 0, jlen = line.length; j < jlen; j++){\n                    charBox = this.__charBounds[i][j];\n                    currentColor = this.getValueOfPropertyAt(i, j, \"textBackgroundColor\");\n                    if (path) {\n                        ctx.save();\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        ctx.fillStyle = currentColor;\n                        currentColor && ctx.fillRect(-charBox.width / 2, -heightOfLine / this.lineHeight * (1 - this._fontSizeFraction), charBox.width, heightOfLine / this.lineHeight);\n                        ctx.restore();\n                    } else if (currentColor !== lastColor) {\n                        drawStart = leftOffset + lineLeftOffset + boxStart;\n                        if (this.direction === \"rtl\") {\n                            drawStart = this.width - drawStart - boxWidth;\n                        }\n                        ctx.fillStyle = lastColor;\n                        lastColor && ctx.fillRect(drawStart, lineTopOffset, boxWidth, heightOfLine / this.lineHeight);\n                        boxStart = charBox.left;\n                        boxWidth = charBox.width;\n                        lastColor = currentColor;\n                    } else {\n                        boxWidth += charBox.kernedWidth;\n                    }\n                }\n                if (currentColor && !path) {\n                    drawStart = leftOffset + lineLeftOffset + boxStart;\n                    if (this.direction === \"rtl\") {\n                        drawStart = this.width - drawStart - boxWidth;\n                    }\n                    ctx.fillStyle = currentColor;\n                    ctx.fillRect(drawStart, lineTopOffset, boxWidth, heightOfLine / this.lineHeight);\n                }\n                lineTopOffset += heightOfLine;\n            }\n            ctx.fillStyle = originalFill;\n            // if there is text background color no\n            // other shadows should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * @private\n     * @param {Object} decl style declaration for cache\n     * @param {String} decl.fontFamily fontFamily\n     * @param {String} decl.fontStyle fontStyle\n     * @param {String} decl.fontWeight fontWeight\n     * @return {Object} reference to cache\n     */ getFontCache: function(decl) {\n            var fontFamily = decl.fontFamily.toLowerCase();\n            if (!fabric.charWidthsCache[fontFamily]) {\n                fabric.charWidthsCache[fontFamily] = {};\n            }\n            var cache = fabric.charWidthsCache[fontFamily], cacheProp = decl.fontStyle.toLowerCase() + \"_\" + (decl.fontWeight + \"\").toLowerCase();\n            if (!cache[cacheProp]) {\n                cache[cacheProp] = {};\n            }\n            return cache[cacheProp];\n        },\n        /**\n     * measure and return the width of a single character.\n     * possibly overridden to accommodate different measure logic or\n     * to hook some external lib for character measurement\n     * @private\n     * @param {String} _char, char to be measured\n     * @param {Object} charStyle style of char to be measured\n     * @param {String} [previousChar] previous char\n     * @param {Object} [prevCharStyle] style of previous char\n     */ _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {\n            // first i try to return from cache\n            var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle), previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char, stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth, fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;\n            if (previousChar && fontCache[previousChar] !== undefined) {\n                previousWidth = fontCache[previousChar];\n            }\n            if (fontCache[_char] !== undefined) {\n                kernedWidth = width = fontCache[_char];\n            }\n            if (stylesAreEqual && fontCache[couple] !== undefined) {\n                coupleWidth = fontCache[couple];\n                kernedWidth = coupleWidth - previousWidth;\n            }\n            if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {\n                var ctx = this.getMeasuringContext();\n                // send a TRUE to specify measuring font size CACHE_FONT_SIZE\n                this._setTextStyles(ctx, charStyle, true);\n            }\n            if (width === undefined) {\n                kernedWidth = width = ctx.measureText(_char).width;\n                fontCache[_char] = width;\n            }\n            if (previousWidth === undefined && stylesAreEqual && previousChar) {\n                previousWidth = ctx.measureText(previousChar).width;\n                fontCache[previousChar] = previousWidth;\n            }\n            if (stylesAreEqual && coupleWidth === undefined) {\n                // we can measure the kerning couple and subtract the width of the previous character\n                coupleWidth = ctx.measureText(couple).width;\n                fontCache[couple] = coupleWidth;\n                kernedWidth = coupleWidth - previousWidth;\n            }\n            return {\n                width: width * fontMultiplier,\n                kernedWidth: kernedWidth * fontMultiplier\n            };\n        },\n        /**\n     * Computes height of character at given position\n     * @param {Number} line the line index number\n     * @param {Number} _char the character index number\n     * @return {Number} fontSize of the character\n     */ getHeightOfChar: function(line, _char) {\n            return this.getValueOfPropertyAt(line, _char, \"fontSize\");\n        },\n        /**\n     * measure a text line measuring all characters.\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */ measureLine: function(lineIndex) {\n            var lineInfo = this._measureLine(lineIndex);\n            if (this.charSpacing !== 0) {\n                lineInfo.width -= this._getWidthOfCharSpacing();\n            }\n            if (lineInfo.width < 0) {\n                lineInfo.width = 0;\n            }\n            return lineInfo;\n        },\n        /**\n     * measure every grapheme of a line, populating __charBounds\n     * @param {Number} lineIndex\n     * @return {Object} object.width total width of characters\n     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs\n     */ _measureLine: function(lineIndex) {\n            var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme, graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length), positionInPath = 0, startingPoint, totalPathLength, path = this.path, reverse = this.pathSide === \"right\";\n            this.__charBounds[lineIndex] = lineBounds;\n            for(i = 0; i < line.length; i++){\n                grapheme = line[i];\n                graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);\n                lineBounds[i] = graphemeInfo;\n                width += graphemeInfo.kernedWidth;\n                prevGrapheme = grapheme;\n            }\n            // this latest bound box represent the last character of the line\n            // to simplify cursor handling in interactive mode.\n            lineBounds[i] = {\n                left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,\n                width: 0,\n                kernedWidth: 0,\n                height: this.fontSize\n            };\n            if (path) {\n                totalPathLength = path.segmentsInfo[path.segmentsInfo.length - 1].length;\n                startingPoint = fabric.util.getPointOnPath(path.path, 0, path.segmentsInfo);\n                startingPoint.x += path.pathOffset.x;\n                startingPoint.y += path.pathOffset.y;\n                switch(this.textAlign){\n                    case \"left\":\n                        positionInPath = reverse ? totalPathLength - width : 0;\n                        break;\n                    case \"center\":\n                        positionInPath = (totalPathLength - width) / 2;\n                        break;\n                    case \"right\":\n                        positionInPath = reverse ? 0 : totalPathLength - width;\n                        break;\n                }\n                positionInPath += this.pathStartOffset * (reverse ? -1 : 1);\n                for(i = reverse ? line.length - 1 : 0; reverse ? i >= 0 : i < line.length; reverse ? i-- : i++){\n                    graphemeInfo = lineBounds[i];\n                    if (positionInPath > totalPathLength) {\n                        positionInPath %= totalPathLength;\n                    } else if (positionInPath < 0) {\n                        positionInPath += totalPathLength;\n                    }\n                    // it would probably much faster to send all the grapheme position for a line\n                    // and calculate path position/angle at once.\n                    this._setGraphemeOnPath(positionInPath, graphemeInfo, startingPoint);\n                    positionInPath += graphemeInfo.kernedWidth;\n                }\n            }\n            return {\n                width: width,\n                numOfSpaces: numOfSpaces\n            };\n        },\n        /**\n     * Calculate the angle  and the left,top position of the char that follow a path.\n     * It appends it to graphemeInfo to be reused later at rendering\n     * @private\n     * @param {Number} positionInPath to be measured\n     * @param {Object} graphemeInfo current grapheme box information\n     * @param {Object} startingPoint position of the point\n     */ _setGraphemeOnPath: function(positionInPath, graphemeInfo, startingPoint) {\n            var centerPosition = positionInPath + graphemeInfo.kernedWidth / 2, path = this.path;\n            // we are at currentPositionOnPath. we want to know what point on the path is.\n            var info = fabric.util.getPointOnPath(path.path, centerPosition, path.segmentsInfo);\n            graphemeInfo.renderLeft = info.x - startingPoint.x;\n            graphemeInfo.renderTop = info.y - startingPoint.y;\n            graphemeInfo.angle = info.angle + (this.pathSide === \"right\" ? Math.PI : 0);\n        },\n        /**\n     * Measure and return the info of a single grapheme.\n     * needs the the info of previous graphemes already filled\n     * @private\n     * @param {String} grapheme to be measured\n     * @param {Number} lineIndex index of the line where the char is\n     * @param {Number} charIndex position in the line\n     * @param {String} [prevGrapheme] character preceding the one to be measured\n     */ _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {\n            var style = this.getCompleteStyleDeclaration(lineIndex, charIndex), prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : {}, info = this._measureChar(grapheme, style, prevGrapheme, prevStyle), kernedWidth = info.kernedWidth, width = info.width, charSpacing;\n            if (this.charSpacing !== 0) {\n                charSpacing = this._getWidthOfCharSpacing();\n                width += charSpacing;\n                kernedWidth += charSpacing;\n            }\n            var box = {\n                width: width,\n                left: 0,\n                height: style.fontSize,\n                kernedWidth: kernedWidth,\n                deltaY: style.deltaY\n            };\n            if (charIndex > 0 && !skipLeft) {\n                var previousBox = this.__charBounds[lineIndex][charIndex - 1];\n                box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;\n            }\n            return box;\n        },\n        /**\n     * Calculate height of line at 'lineIndex'\n     * @param {Number} lineIndex index of line to calculate\n     * @return {Number}\n     */ getHeightOfLine: function(lineIndex) {\n            if (this.__lineHeights[lineIndex]) {\n                return this.__lineHeights[lineIndex];\n            }\n            var line = this._textLines[lineIndex], // char 0 is measured before the line cycle because it nneds to char\n            // emptylines\n            maxHeight = this.getHeightOfChar(lineIndex, 0);\n            for(var i = 1, len = line.length; i < len; i++){\n                maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);\n            }\n            return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;\n        },\n        /**\n     * Calculate text box height\n     */ calcTextHeight: function() {\n            var lineHeight, height = 0;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                lineHeight = this.getHeightOfLine(i);\n                height += i === len - 1 ? lineHeight / this.lineHeight : lineHeight;\n            }\n            return height;\n        },\n        /**\n     * @private\n     * @return {Number} Left offset\n     */ _getLeftOffset: function() {\n            return this.direction === \"ltr\" ? -this.width / 2 : this.width / 2;\n        },\n        /**\n     * @private\n     * @return {Number} Top offset\n     */ _getTopOffset: function() {\n            return -this.height / 2;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     */ _renderTextCommon: function(ctx, method) {\n            ctx.save();\n            var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                var heightOfLine = this.getHeightOfLine(i), maxHeight = heightOfLine / this.lineHeight, leftOffset = this._getLineLeftOffset(i);\n                this._renderTextLine(method, ctx, this._textLines[i], left + leftOffset, top + lineHeights + maxHeight, i);\n                lineHeights += heightOfLine;\n            }\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextFill: function(ctx) {\n            if (!this.fill && !this.styleHas(\"fill\")) {\n                return;\n            }\n            this._renderTextCommon(ctx, \"fillText\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextStroke: function(ctx) {\n            if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {\n                return;\n            }\n            if (this.shadow && !this.shadow.affectStroke) {\n                this._removeShadow(ctx);\n            }\n            ctx.save();\n            this._setLineDash(ctx, this.strokeDashArray);\n            ctx.beginPath();\n            this._renderTextCommon(ctx, \"strokeText\");\n            ctx.closePath();\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {String} method fillText or strokeText.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} line Content of the line, splitted in an array by grapheme\n     * @param {Number} left\n     * @param {Number} top\n     * @param {Number} lineIndex\n     */ _renderChars: function(method, ctx, line, left, top, lineIndex) {\n            // set proper line offset\n            var lineHeight = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf(\"justify\") !== -1, actualStyle, nextStyle, charsToRender = \"\", charBox, boxWidth = 0, timeToRender, path = this.path, shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex) && !path, isLtr = this.direction === \"ltr\", sign = this.direction === \"ltr\" ? 1 : -1, drawingLeft, currentDirection = ctx.canvas.getAttribute(\"dir\");\n            ctx.save();\n            if (currentDirection !== this.direction) {\n                ctx.canvas.setAttribute(\"dir\", isLtr ? \"ltr\" : \"rtl\");\n                ctx.direction = isLtr ? \"ltr\" : \"rtl\";\n                ctx.textAlign = isLtr ? \"left\" : \"right\";\n            }\n            top -= lineHeight * this._fontSizeFraction / this.lineHeight;\n            if (shortCut) {\n                // render all the line in one pass without checking\n                // drawingLeft = isLtr ? left : left - this.getLineWidth(lineIndex);\n                this._renderChar(method, ctx, lineIndex, 0, line.join(\"\"), left, top, lineHeight);\n                ctx.restore();\n                return;\n            }\n            for(var i = 0, len = line.length - 1; i <= len; i++){\n                timeToRender = i === len || this.charSpacing || path;\n                charsToRender += line[i];\n                charBox = this.__charBounds[lineIndex][i];\n                if (boxWidth === 0) {\n                    left += sign * (charBox.kernedWidth - charBox.width);\n                    boxWidth += charBox.width;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n                if (isJustify && !timeToRender) {\n                    if (this._reSpaceAndTab.test(line[i])) {\n                        timeToRender = true;\n                    }\n                }\n                if (!timeToRender) {\n                    // if we have charSpacing, we render char by char\n                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n                    timeToRender = this._hasStyleChanged(actualStyle, nextStyle);\n                }\n                if (timeToRender) {\n                    if (path) {\n                        ctx.save();\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        this._renderChar(method, ctx, lineIndex, i, charsToRender, -boxWidth / 2, 0, lineHeight);\n                        ctx.restore();\n                    } else {\n                        drawingLeft = left;\n                        this._renderChar(method, ctx, lineIndex, i, charsToRender, drawingLeft, top, lineHeight);\n                    }\n                    charsToRender = \"\";\n                    actualStyle = nextStyle;\n                    left += sign * boxWidth;\n                    boxWidth = 0;\n                }\n            }\n            ctx.restore();\n        },\n        /**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     * @return {CanvasPattern} a pattern to use as fill/stroke style\n     */ _applyPatternGradientTransformText: function(filler) {\n            var pCanvas = fabric.util.createCanvasElement(), pCtx, // TODO: verify compatibility with strokeUniform\n            width = this.width + this.strokeWidth, height = this.height + this.strokeWidth;\n            pCanvas.width = width;\n            pCanvas.height = height;\n            pCtx = pCanvas.getContext(\"2d\");\n            pCtx.beginPath();\n            pCtx.moveTo(0, 0);\n            pCtx.lineTo(width, 0);\n            pCtx.lineTo(width, height);\n            pCtx.lineTo(0, height);\n            pCtx.closePath();\n            pCtx.translate(width / 2, height / 2);\n            pCtx.fillStyle = filler.toLive(pCtx);\n            this._applyPatternGradientTransform(pCtx, filler);\n            pCtx.fill();\n            return pCtx.createPattern(pCanvas, \"no-repeat\");\n        },\n        handleFiller: function(ctx, property, filler) {\n            var offsetX, offsetY;\n            if (filler.toLive) {\n                if (filler.gradientUnits === \"percentage\" || filler.gradientTransform || filler.patternTransform) {\n                    // need to transform gradient in a pattern.\n                    // this is a slow process. If you are hitting this codepath, and the object\n                    // is not using caching, you should consider switching it on.\n                    // we need a canvas as big as the current object caching canvas.\n                    offsetX = -this.width / 2;\n                    offsetY = -this.height / 2;\n                    ctx.translate(offsetX, offsetY);\n                    ctx[property] = this._applyPatternGradientTransformText(filler);\n                    return {\n                        offsetX: offsetX,\n                        offsetY: offsetY\n                    };\n                } else {\n                    // is a simple gradient or pattern\n                    ctx[property] = filler.toLive(ctx, this);\n                    return this._applyPatternGradientTransform(ctx, filler);\n                }\n            } else {\n                // is a color\n                ctx[property] = filler;\n            }\n            return {\n                offsetX: 0,\n                offsetY: 0\n            };\n        },\n        _setStrokeStyles: function(ctx, decl) {\n            ctx.lineWidth = decl.strokeWidth;\n            ctx.lineCap = this.strokeLineCap;\n            ctx.lineDashOffset = this.strokeDashOffset;\n            ctx.lineJoin = this.strokeLineJoin;\n            ctx.miterLimit = this.strokeMiterLimit;\n            return this.handleFiller(ctx, \"strokeStyle\", decl.stroke);\n        },\n        _setFillStyles: function(ctx, decl) {\n            return this.handleFiller(ctx, \"fillStyle\", decl.fill);\n        },\n        /**\n     * @private\n     * @param {String} method\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {String} _char\n     * @param {Number} left Left coordinate\n     * @param {Number} top Top coordinate\n     * @param {Number} lineHeight Height of the line\n     */ _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {\n            var decl = this._getStyleDeclaration(lineIndex, charIndex), fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex), shouldFill = method === \"fillText\" && fullDecl.fill, shouldStroke = method === \"strokeText\" && fullDecl.stroke && fullDecl.strokeWidth, fillOffsets, strokeOffsets;\n            if (!shouldStroke && !shouldFill) {\n                return;\n            }\n            ctx.save();\n            shouldFill && (fillOffsets = this._setFillStyles(ctx, fullDecl));\n            shouldStroke && (strokeOffsets = this._setStrokeStyles(ctx, fullDecl));\n            ctx.font = this._getFontDeclaration(fullDecl);\n            if (decl && decl.textBackgroundColor) {\n                this._removeShadow(ctx);\n            }\n            if (decl && decl.deltaY) {\n                top += decl.deltaY;\n            }\n            shouldFill && ctx.fillText(_char, left - fillOffsets.offsetX, top - fillOffsets.offsetY);\n            shouldStroke && ctx.strokeText(_char, left - strokeOffsets.offsetX, top - strokeOffsets.offsetY);\n            ctx.restore();\n        },\n        /**\n     * Turns the character into a 'superior figure' (i.e. 'superscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ setSuperscript: function(start, end) {\n            return this._setScript(start, end, this.superscript);\n        },\n        /**\n     * Turns the character into an 'inferior figure' (i.e. 'subscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ setSubscript: function(start, end) {\n            return this._setScript(start, end, this.subscript);\n        },\n        /**\n     * Applies 'schema' at given position\n     * @private\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @param {Number} schema\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ _setScript: function(start, end, schema) {\n            var loc = this.get2DCursorLocation(start, true), fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, \"fontSize\"), dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, \"deltaY\"), style = {\n                fontSize: fontSize * schema.size,\n                deltaY: dy + fontSize * schema.baseline\n            };\n            this.setSelectionStyles(style, start, end);\n            return this;\n        },\n        /**\n     * @private\n     * @param {Object} prevStyle\n     * @param {Object} thisStyle\n     */ _hasStyleChanged: function(prevStyle, thisStyle) {\n            return prevStyle.fill !== thisStyle.fill || prevStyle.stroke !== thisStyle.stroke || prevStyle.strokeWidth !== thisStyle.strokeWidth || prevStyle.fontSize !== thisStyle.fontSize || prevStyle.fontFamily !== thisStyle.fontFamily || prevStyle.fontWeight !== thisStyle.fontWeight || prevStyle.fontStyle !== thisStyle.fontStyle || prevStyle.deltaY !== thisStyle.deltaY;\n        },\n        /**\n     * @private\n     * @param {Object} prevStyle\n     * @param {Object} thisStyle\n     */ _hasStyleChangedForSvg: function(prevStyle, thisStyle) {\n            return this._hasStyleChanged(prevStyle, thisStyle) || prevStyle.overline !== thisStyle.overline || prevStyle.underline !== thisStyle.underline || prevStyle.linethrough !== thisStyle.linethrough;\n        },\n        /**\n     * @private\n     * @param {Number} lineIndex index text line\n     * @return {Number} Line left offset\n     */ _getLineLeftOffset: function(lineIndex) {\n            var lineWidth = this.getLineWidth(lineIndex), lineDiff = this.width - lineWidth, textAlign = this.textAlign, direction = this.direction, isEndOfWrapping, leftOffset = 0, isEndOfWrapping = this.isEndOfWrapping(lineIndex);\n            if (textAlign === \"justify\" || textAlign === \"justify-center\" && !isEndOfWrapping || textAlign === \"justify-right\" && !isEndOfWrapping || textAlign === \"justify-left\" && !isEndOfWrapping) {\n                return 0;\n            }\n            if (textAlign === \"center\") {\n                leftOffset = lineDiff / 2;\n            }\n            if (textAlign === \"right\") {\n                leftOffset = lineDiff;\n            }\n            if (textAlign === \"justify-center\") {\n                leftOffset = lineDiff / 2;\n            }\n            if (textAlign === \"justify-right\") {\n                leftOffset = lineDiff;\n            }\n            if (direction === \"rtl\") {\n                leftOffset -= lineDiff;\n            }\n            return leftOffset;\n        },\n        /**\n     * @private\n     */ _clearCache: function() {\n            this.__lineWidths = [];\n            this.__lineHeights = [];\n            this.__charBounds = [];\n        },\n        /**\n     * @private\n     */ _shouldClearDimensionCache: function() {\n            var shouldClear = this._forceClearCache;\n            shouldClear || (shouldClear = this.hasStateChanged(\"_dimensionAffectingProps\"));\n            if (shouldClear) {\n                this.dirty = true;\n                this._forceClearCache = false;\n            }\n            return shouldClear;\n        },\n        /**\n     * Measure a single line given its index. Used to calculate the initial\n     * text bounding box. The values are calculated and stored in __lineWidths cache.\n     * @private\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */ getLineWidth: function(lineIndex) {\n            if (this.__lineWidths[lineIndex] !== undefined) {\n                return this.__lineWidths[lineIndex];\n            }\n            var lineInfo = this.measureLine(lineIndex);\n            var width = lineInfo.width;\n            this.__lineWidths[lineIndex] = width;\n            return width;\n        },\n        _getWidthOfCharSpacing: function() {\n            if (this.charSpacing !== 0) {\n                return this.fontSize * this.charSpacing / 1000;\n            }\n            return 0;\n        },\n        /**\n     * Retrieves the value of property at given character position\n     * @param {Number} lineIndex the line number\n     * @param {Number} charIndex the character number\n     * @param {String} property the property name\n     * @returns the value of 'property'\n     */ getValueOfPropertyAt: function(lineIndex, charIndex, property) {\n            var charStyle = this._getStyleDeclaration(lineIndex, charIndex);\n            if (charStyle && typeof charStyle[property] !== \"undefined\") {\n                return charStyle[property];\n            }\n            return this[property];\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextDecoration: function(ctx, type) {\n            if (!this[type] && !this.styleHas(type)) {\n                return;\n            }\n            var heightOfLine, size, _size, lineLeftOffset, dy, _dy, line, lastDecoration, leftOffset = this._getLeftOffset(), topOffset = this._getTopOffset(), top, boxStart, boxWidth, charBox, currentDecoration, maxHeight, currentFill, lastFill, path = this.path, charSpacing = this._getWidthOfCharSpacing(), offsetY = this.offsets[type];\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                heightOfLine = this.getHeightOfLine(i);\n                if (!this[type] && !this.styleHas(type, i)) {\n                    topOffset += heightOfLine;\n                    continue;\n                }\n                line = this._textLines[i];\n                maxHeight = heightOfLine / this.lineHeight;\n                lineLeftOffset = this._getLineLeftOffset(i);\n                boxStart = 0;\n                boxWidth = 0;\n                lastDecoration = this.getValueOfPropertyAt(i, 0, type);\n                lastFill = this.getValueOfPropertyAt(i, 0, \"fill\");\n                top = topOffset + maxHeight * (1 - this._fontSizeFraction);\n                size = this.getHeightOfChar(i, 0);\n                dy = this.getValueOfPropertyAt(i, 0, \"deltaY\");\n                for(var j = 0, jlen = line.length; j < jlen; j++){\n                    charBox = this.__charBounds[i][j];\n                    currentDecoration = this.getValueOfPropertyAt(i, j, type);\n                    currentFill = this.getValueOfPropertyAt(i, j, \"fill\");\n                    _size = this.getHeightOfChar(i, j);\n                    _dy = this.getValueOfPropertyAt(i, j, \"deltaY\");\n                    if (path && currentDecoration && currentFill) {\n                        ctx.save();\n                        ctx.fillStyle = lastFill;\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        ctx.fillRect(-charBox.kernedWidth / 2, offsetY * _size + _dy, charBox.kernedWidth, this.fontSize / 15);\n                        ctx.restore();\n                    } else if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) && boxWidth > 0) {\n                        var drawStart = leftOffset + lineLeftOffset + boxStart;\n                        if (this.direction === \"rtl\") {\n                            drawStart = this.width - drawStart - boxWidth;\n                        }\n                        if (lastDecoration && lastFill) {\n                            ctx.fillStyle = lastFill;\n                            ctx.fillRect(drawStart, top + offsetY * size + dy, boxWidth, this.fontSize / 15);\n                        }\n                        boxStart = charBox.left;\n                        boxWidth = charBox.width;\n                        lastDecoration = currentDecoration;\n                        lastFill = currentFill;\n                        size = _size;\n                        dy = _dy;\n                    } else {\n                        boxWidth += charBox.kernedWidth;\n                    }\n                }\n                var drawStart = leftOffset + lineLeftOffset + boxStart;\n                if (this.direction === \"rtl\") {\n                    drawStart = this.width - drawStart - boxWidth;\n                }\n                ctx.fillStyle = currentFill;\n                currentDecoration && currentFill && ctx.fillRect(drawStart, top + offsetY * size + dy, boxWidth - charSpacing, this.fontSize / 15);\n                topOffset += heightOfLine;\n            }\n            // if there is text background color no\n            // other shadows should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * return font declaration string for canvas context\n     * @param {Object} [styleObject] object\n     * @returns {String} font declaration formatted for canvas context.\n     */ _getFontDeclaration: function(styleObject, forMeasuring) {\n            var style = styleObject || this, family = this.fontFamily, fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;\n            var fontFamily = family === undefined || family.indexOf(\"'\") > -1 || family.indexOf(\",\") > -1 || family.indexOf('\"') > -1 || fontIsGeneric ? style.fontFamily : '\"' + style.fontFamily + '\"';\n            return [\n                // node-canvas needs \"weight style\", while browsers need \"style weight\"\n                // verify if this can be fixed in JSDOM\n                fabric.isLikelyNode ? style.fontWeight : style.fontStyle,\n                fabric.isLikelyNode ? style.fontStyle : style.fontWeight,\n                forMeasuring ? this.CACHE_FONT_SIZE + \"px\" : style.fontSize + \"px\",\n                fontFamily\n            ].join(\" \");\n        },\n        /**\n     * Renders text instance on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            // do not render if object is not visible\n            if (!this.visible) {\n                return;\n            }\n            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {\n                return;\n            }\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n            }\n            this.callSuper(\"render\", ctx);\n        },\n        /**\n     * Returns the text as an array of lines.\n     * @param {String} text text to split\n     * @returns {Array} Lines in the text\n     */ _splitTextIntoLines: function(text) {\n            var lines = text.split(this._reNewline), newLines = new Array(lines.length), newLine = [\n                \"\\n\"\n            ], newText = [];\n            for(var i = 0; i < lines.length; i++){\n                newLines[i] = fabric.util.string.graphemeSplit(lines[i]);\n                newText = newText.concat(newLines[i], newLine);\n            }\n            newText.pop();\n            return {\n                _unwrappedLines: newLines,\n                lines: lines,\n                graphemeText: newText,\n                graphemeLines: newLines\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var allProperties = additionalProps.concat(propertiesToInclude);\n            var obj = this.callSuper(\"toObject\", allProperties);\n            // styles will be overridden with a properly cloned structure\n            obj.styles = clone(this.styles, true);\n            if (obj.path) {\n                obj.path = this.path.toObject();\n            }\n            return obj;\n        },\n        /**\n     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n     * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ set: function(key, value) {\n            this.callSuper(\"set\", key, value);\n            var needsDims = false;\n            var isAddingPath = false;\n            if (typeof key === \"object\") {\n                for(var _key in key){\n                    if (_key === \"path\") {\n                        this.setPathInfo();\n                    }\n                    needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;\n                    isAddingPath = isAddingPath || _key === \"path\";\n                }\n            } else {\n                needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;\n                isAddingPath = key === \"path\";\n            }\n            if (isAddingPath) {\n                this.setPathInfo();\n            }\n            if (needsDims) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            return this;\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity\n     */ complexity: function() {\n            return 1;\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})\n   * @static\n   * @memberOf fabric.Text\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\n   */ fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor\".split(\" \"));\n    /**\n   * Default SVG font size\n   * @static\n   * @memberOf fabric.Text\n   */ fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;\n    /**\n   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)\n   * @static\n   * @memberOf fabric.Text\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Text.fromElement = function(element, callback, options) {\n        if (!element) {\n            return callback(null);\n        }\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES), parsedAnchor = parsedAttributes.textAnchor || \"left\";\n        options = fabric.util.object.extend(options ? clone(options) : {}, parsedAttributes);\n        options.top = options.top || 0;\n        options.left = options.left || 0;\n        if (parsedAttributes.textDecoration) {\n            var textDecoration = parsedAttributes.textDecoration;\n            if (textDecoration.indexOf(\"underline\") !== -1) {\n                options.underline = true;\n            }\n            if (textDecoration.indexOf(\"overline\") !== -1) {\n                options.overline = true;\n            }\n            if (textDecoration.indexOf(\"line-through\") !== -1) {\n                options.linethrough = true;\n            }\n            delete options.textDecoration;\n        }\n        if (\"dx\" in parsedAttributes) {\n            options.left += parsedAttributes.dx;\n        }\n        if (\"dy\" in parsedAttributes) {\n            options.top += parsedAttributes.dy;\n        }\n        if (!(\"fontSize\" in options)) {\n            options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\n        }\n        var textContent = \"\";\n        // The XML is not properly parsed in IE9 so a workaround to get\n        // textContent is through firstChild.data. Another workaround would be\n        // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)\n        if (!(\"textContent\" in element)) {\n            if (\"firstChild\" in element && element.firstChild !== null) {\n                if (\"data\" in element.firstChild && element.firstChild.data !== null) {\n                    textContent = element.firstChild.data;\n                }\n            }\n        } else {\n            textContent = element.textContent;\n        }\n        textContent = textContent.replace(/^\\s+|\\s+$|\\n+/g, \"\").replace(/\\s+/g, \" \");\n        var originalStrokeWidth = options.strokeWidth;\n        options.strokeWidth = 0;\n        var text = new fabric.Text(textContent, options), textHeightScaleFactor = text.getScaledHeight() / text.height, lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height, scaledDiff = lineHeightDiff * textHeightScaleFactor, textHeight = text.getScaledHeight() + scaledDiff, offX = 0;\n        /*\n      Adjust positioning:\n        x/y attributes in SVG correspond to the bottom-left corner of text bounding box\n        fabric output by default at top, left.\n    */ if (parsedAnchor === \"center\") {\n            offX = text.getScaledWidth() / 2;\n        }\n        if (parsedAnchor === \"right\") {\n            offX = text.getScaledWidth();\n        }\n        text.set({\n            left: text.left - offX,\n            top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,\n            strokeWidth: typeof originalStrokeWidth !== \"undefined\" ? originalStrokeWidth : 1\n        });\n        callback(text);\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Text instance from an object representation\n   * @static\n   * @memberOf fabric.Text\n   * @param {Object} object plain js Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created\n   */ fabric.Text.fromObject = function(object, callback) {\n        var objectCopy = clone(object), path = object.path;\n        delete objectCopy.path;\n        return fabric.Object._fromObject(\"Text\", objectCopy, function(textInstance) {\n            if (path) {\n                fabric.Object._fromObject(\"Path\", path, function(pathInstance) {\n                    textInstance.set(\"path\", pathInstance);\n                    callback(textInstance);\n                }, \"path\");\n            } else {\n                callback(textInstance);\n            }\n        }, \"text\");\n    };\n    fabric.Text.genericFonts = [\n        \"sans-serif\",\n        \"serif\",\n        \"cursive\",\n        \"fantasy\",\n        \"monospace\"\n    ];\n    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);\n})( true ? exports : 0);\n(function() {\n    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {\n        /**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */ isEmptyStyles: function(lineIndex) {\n            if (!this.styles) {\n                return true;\n            }\n            if (typeof lineIndex !== \"undefined\" && !this.styles[lineIndex]) {\n                return true;\n            }\n            var obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                line: this.styles[lineIndex]\n            };\n            for(var p1 in obj){\n                for(var p2 in obj[p1]){\n                    // eslint-disable-next-line no-unused-vars\n                    for(var p3 in obj[p1][p2]){\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n        /**\n     * Returns true if object has a style property or has it ina specified line\n     * This function is used to detect if a text will use a particular property or not.\n     * @param {String} property to check for\n     * @param {Number} lineIndex to check the style on\n     * @return {Boolean}\n     */ styleHas: function(property, lineIndex) {\n            if (!this.styles || !property || property === \"\") {\n                return false;\n            }\n            if (typeof lineIndex !== \"undefined\" && !this.styles[lineIndex]) {\n                return false;\n            }\n            var obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                0: this.styles[lineIndex]\n            };\n            // eslint-disable-next-line\n            for(var p1 in obj){\n                // eslint-disable-next-line\n                for(var p2 in obj[p1]){\n                    if (typeof obj[p1][p2][property] !== \"undefined\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        /**\n     * Check if characters in a text have a value for a property\n     * whose value matches the textbox's value for that property.  If so,\n     * the character-level property is deleted.  If the character\n     * has no other properties, then it is also deleted.  Finally,\n     * if the line containing that character has no other characters\n     * then it also is deleted.\n     *\n     * @param {string} property The property to compare between characters and text.\n     */ cleanStyle: function(property) {\n            if (!this.styles || !property || property === \"\") {\n                return false;\n            }\n            var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue, allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;\n            // eslint-disable-next-line\n            for(var p1 in obj){\n                letterCount = 0;\n                // eslint-disable-next-line\n                for(var p2 in obj[p1]){\n                    var styleObject = obj[p1][p2], stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);\n                    stylesCount++;\n                    if (stylePropertyHasBeenSet) {\n                        if (!stylePropertyValue) {\n                            stylePropertyValue = styleObject[property];\n                        } else if (styleObject[property] !== stylePropertyValue) {\n                            allStyleObjectPropertiesMatch = false;\n                        }\n                        if (styleObject[property] === this[property]) {\n                            delete styleObject[property];\n                        }\n                    } else {\n                        allStyleObjectPropertiesMatch = false;\n                    }\n                    if (Object.keys(styleObject).length !== 0) {\n                        letterCount++;\n                    } else {\n                        delete obj[p1][p2];\n                    }\n                }\n                if (letterCount === 0) {\n                    delete obj[p1];\n                }\n            }\n            // if every grapheme has the same style set then\n            // delete those styles and set it on the parent\n            for(var i = 0; i < this._textLines.length; i++){\n                graphemeCount += this._textLines[i].length;\n            }\n            if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {\n                this[property] = stylePropertyValue;\n                this.removeStyle(property);\n            }\n        },\n        /**\n     * Remove a style property or properties from all individual character styles\n     * in a text object.  Deletes the character style object if it contains no other style\n     * props.  Deletes a line style object if it contains no other character styles.\n     *\n     * @param {String} props The property to remove from character styles.\n     */ removeStyle: function(property) {\n            if (!this.styles || !property || property === \"\") {\n                return;\n            }\n            var obj = this.styles, line, lineNum, charNum;\n            for(lineNum in obj){\n                line = obj[lineNum];\n                for(charNum in line){\n                    delete line[charNum][property];\n                    if (Object.keys(line[charNum]).length === 0) {\n                        delete line[charNum];\n                    }\n                }\n                if (Object.keys(line).length === 0) {\n                    delete obj[lineNum];\n                }\n            }\n        },\n        /**\n     * @private\n     */ _extendStyles: function(index, styles) {\n            var loc = this.get2DCursorLocation(index);\n            if (!this._getLineStyle(loc.lineIndex)) {\n                this._setLineStyle(loc.lineIndex);\n            }\n            if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {\n                this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});\n            }\n            fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);\n        },\n        /**\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\n     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.\n     */ get2DCursorLocation: function(selectionStart, skipWrapping) {\n            if (typeof selectionStart === \"undefined\") {\n                selectionStart = this.selectionStart;\n            }\n            var lines = skipWrapping ? this._unwrappedTextLines : this._textLines, len = lines.length;\n            for(var i = 0; i < len; i++){\n                if (selectionStart <= lines[i].length) {\n                    return {\n                        lineIndex: i,\n                        charIndex: selectionStart\n                    };\n                }\n                selectionStart -= lines[i].length + this.missingNewlineOffset(i);\n            }\n            return {\n                lineIndex: i - 1,\n                charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart\n            };\n        },\n        /**\n     * Gets style of a current selection/cursor (at the start position)\n     * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @param {Boolean} [complete] get full style or not\n     * @return {Array} styles an array with one, zero or more Style objects\n     */ getSelectionStyles: function(startIndex, endIndex, complete) {\n            if (typeof startIndex === \"undefined\") {\n                startIndex = this.selectionStart || 0;\n            }\n            if (typeof endIndex === \"undefined\") {\n                endIndex = this.selectionEnd || startIndex;\n            }\n            var styles = [];\n            for(var i = startIndex; i < endIndex; i++){\n                styles.push(this.getStyleAtPosition(i, complete));\n            }\n            return styles;\n        },\n        /**\n     * Gets style of a current selection/cursor position\n     * @param {Number} position  to get styles at\n     * @param {Boolean} [complete] full style if true\n     * @return {Object} style Style object at a specified index\n     * @private\n     */ getStyleAtPosition: function(position, complete) {\n            var loc = this.get2DCursorLocation(position), style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) : this._getStyleDeclaration(loc.lineIndex, loc.charIndex);\n            return style || {};\n        },\n        /**\n     * Sets style of a current selection, if no selection exist, do not set anything.\n     * @param {Object} [styles] Styles object\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ setSelectionStyles: function(styles, startIndex, endIndex) {\n            if (typeof startIndex === \"undefined\") {\n                startIndex = this.selectionStart || 0;\n            }\n            if (typeof endIndex === \"undefined\") {\n                endIndex = this.selectionEnd || startIndex;\n            }\n            for(var i = startIndex; i < endIndex; i++){\n                this._extendStyles(i, styles);\n            }\n            /* not included in _extendStyles to avoid clearing cache more than once */ this._forceClearCache = true;\n            return this;\n        },\n        /**\n     * get the reference, not a clone, of the style object for a given character\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @return {Object} style object\n     */ _getStyleDeclaration: function(lineIndex, charIndex) {\n            var lineStyle = this.styles && this.styles[lineIndex];\n            if (!lineStyle) {\n                return null;\n            }\n            return lineStyle[charIndex];\n        },\n        /**\n     * return a new object that contains all the style property for a character\n     * the object returned is newly created\n     * @param {Number} lineIndex of the line where the character is\n     * @param {Number} charIndex position of the character on the line\n     * @return {Object} style object\n     */ getCompleteStyleDeclaration: function(lineIndex, charIndex) {\n            var style = this._getStyleDeclaration(lineIndex, charIndex) || {}, styleObject = {}, prop;\n            for(var i = 0; i < this._styleProperties.length; i++){\n                prop = this._styleProperties[i];\n                styleObject[prop] = typeof style[prop] === \"undefined\" ? this[prop] : style[prop];\n            }\n            return styleObject;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */ _setStyleDeclaration: function(lineIndex, charIndex, style) {\n            this.styles[lineIndex][charIndex] = style;\n        },\n        /**\n     *\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _deleteStyleDeclaration: function(lineIndex, charIndex) {\n            delete this.styles[lineIndex][charIndex];\n        },\n        /**\n     * @param {Number} lineIndex\n     * @return {Boolean} if the line exists or not\n     * @private\n     */ _getLineStyle: function(lineIndex) {\n            return !!this.styles[lineIndex];\n        },\n        /**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @private\n     */ _setLineStyle: function(lineIndex) {\n            this.styles[lineIndex] = {};\n        },\n        /**\n     * @param {Number} lineIndex\n     * @private\n     */ _deleteLineStyle: function(lineIndex) {\n            delete this.styles[lineIndex];\n        }\n    });\n})();\n(function() {\n    function parseDecoration(object) {\n        if (object.textDecoration) {\n            object.textDecoration.indexOf(\"underline\") > -1 && (object.underline = true);\n            object.textDecoration.indexOf(\"line-through\") > -1 && (object.linethrough = true);\n            object.textDecoration.indexOf(\"overline\") > -1 && (object.overline = true);\n            delete object.textDecoration;\n        }\n    }\n    /**\n   * IText class (introduced in <b>v1.4</b>) Events are also fired with \"text:\"\n   * prefix when observing canvas.\n   * @class fabric.IText\n   * @extends fabric.Text\n   * @mixes fabric.Observable\n   *\n   * @fires changed\n   * @fires selection:changed\n   * @fires editing:entered\n   * @fires editing:exited\n   *\n   * @return {fabric.IText} thisArg\n   * @see {@link fabric.IText#initialize} for constructor definition\n   *\n   * <p>Supported key combinations:</p>\n   * <pre>\n   *   Move cursor:                    left, right, up, down\n   *   Select character:               shift + left, shift + right\n   *   Select text vertically:         shift + up, shift + down\n   *   Move cursor by word:            alt + left, alt + right\n   *   Select words:                   shift + alt + left, shift + alt + right\n   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end\n   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end\n   *   Jump to start/end of text:      cmd + up, cmd + down\n   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown\n   *   Delete character:               backspace\n   *   Delete word:                    alt + backspace\n   *   Delete line:                    cmd + backspace\n   *   Forward delete:                 delete\n   *   Copy text:                      ctrl/cmd + c\n   *   Paste text:                     ctrl/cmd + v\n   *   Cut text:                       ctrl/cmd + x\n   *   Select entire text:             ctrl/cmd + a\n   *   Quit editing                    tab or esc\n   * </pre>\n   *\n   * <p>Supported mouse/touch combination</p>\n   * <pre>\n   *   Position cursor:                click/touch\n   *   Create selection:               click/touch & drag\n   *   Create selection:               click & shift + click\n   *   Select word:                    double click\n   *   Select line:                    triple click\n   * </pre>\n   */ fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"i-text\",\n        /**\n     * Index where text selection starts (or where cursor is when there is no selection)\n     * @type Number\n     * @default\n     */ selectionStart: 0,\n        /**\n     * Index where text selection ends\n     * @type Number\n     * @default\n     */ selectionEnd: 0,\n        /**\n     * Color of text selection\n     * @type String\n     * @default\n     */ selectionColor: \"rgba(17,119,255,0.3)\",\n        /**\n     * Indicates whether text is in editing mode\n     * @type Boolean\n     * @default\n     */ isEditing: false,\n        /**\n     * Indicates whether a text can be edited\n     * @type Boolean\n     * @default\n     */ editable: true,\n        /**\n     * Border color of text object while it's in editing mode\n     * @type String\n     * @default\n     */ editingBorderColor: \"rgba(102,153,255,0.25)\",\n        /**\n     * Width of cursor (in px)\n     * @type Number\n     * @default\n     */ cursorWidth: 2,\n        /**\n     * Color of text cursor color in editing mode.\n     * if not set (default) will take color from the text.\n     * if set to a color value that fabric can understand, it will\n     * be used instead of the color of the text at the current position.\n     * @type String\n     * @default\n     */ cursorColor: \"\",\n        /**\n     * Delay between cursor blink (in ms)\n     * @type Number\n     * @default\n     */ cursorDelay: 1000,\n        /**\n     * Duration of cursor fadein (in ms)\n     * @type Number\n     * @default\n     */ cursorDuration: 600,\n        /**\n     * Indicates whether internal text char widths can be cached\n     * @type Boolean\n     * @default\n     */ caching: true,\n        /**\n     * DOM container to append the hiddenTextarea.\n     * An alternative to attaching to the document.body.\n     * Useful to reduce laggish redraw of the full document.body tree and\n     * also with modals event capturing that won't let the textarea take focus.\n     * @type HTMLElement\n     * @default\n     */ hiddenTextareaContainer: null,\n        /**\n     * @private\n     */ _reSpace: /\\s|\\n/,\n        /**\n     * @private\n     */ _currentCursorOpacity: 0,\n        /**\n     * @private\n     */ _selectionDirection: null,\n        /**\n     * @private\n     */ _abortCursorAnimation: false,\n        /**\n     * @private\n     */ __widthOfSpace: [],\n        /**\n     * Helps determining when the text is in composition, so that the cursor\n     * rendering is altered.\n     */ inCompositionMode: false,\n        /**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.IText} thisArg\n     */ initialize: function(text, options) {\n            this.callSuper(\"initialize\", text, options);\n            this.initBehavior();\n        },\n        /**\n     * Sets selection start (left boundary of a selection)\n     * @param {Number} index Index to set selection start to\n     */ setSelectionStart: function(index) {\n            index = Math.max(index, 0);\n            this._updateAndFire(\"selectionStart\", index);\n        },\n        /**\n     * Sets selection end (right boundary of a selection)\n     * @param {Number} index Index to set selection end to\n     */ setSelectionEnd: function(index) {\n            index = Math.min(index, this.text.length);\n            this._updateAndFire(\"selectionEnd\", index);\n        },\n        /**\n     * @private\n     * @param {String} property 'selectionStart' or 'selectionEnd'\n     * @param {Number} index new position of property\n     */ _updateAndFire: function(property, index) {\n            if (this[property] !== index) {\n                this._fireSelectionChanged();\n                this[property] = index;\n            }\n            this._updateTextarea();\n        },\n        /**\n     * Fires the even of selection changed\n     * @private\n     */ _fireSelectionChanged: function() {\n            this.fire(\"selection:changed\");\n            this.canvas && this.canvas.fire(\"text:selection:changed\", {\n                target: this\n            });\n        },\n        /**\n     * Initialize text dimensions. Render all text on given context\n     * or on a offscreen canvas to get the text width with measureText.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     * @private\n     */ initDimensions: function() {\n            this.isEditing && this.initDelayedCursor();\n            this.clearContextTop();\n            this.callSuper(\"initDimensions\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            this.clearContextTop();\n            this.callSuper(\"render\", ctx);\n            // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor\n            // the correct position but not at every cursor animation.\n            this.cursorOffsetCache = {};\n            this.renderCursorOrSelection();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            this.callSuper(\"_render\", ctx);\n        },\n        /**\n     * Prepare and clean the contextTop\n     */ clearContextTop: function(skipRestore) {\n            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {\n                return;\n            }\n            var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            this.transform(ctx);\n            this._clearTextArea(ctx);\n            skipRestore || ctx.restore();\n        },\n        /**\n     * Renders cursor or selection (depending on what exists)\n     * it does on the contextTop. If contextTop is not available, do nothing.\n     */ renderCursorOrSelection: function() {\n            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {\n                return;\n            }\n            var boundaries = this._getCursorBoundaries(), ctx = this.canvas.contextTop;\n            this.clearContextTop(true);\n            if (this.selectionStart === this.selectionEnd) {\n                this.renderCursor(boundaries, ctx);\n            } else {\n                this.renderSelection(boundaries, ctx);\n            }\n            ctx.restore();\n        },\n        _clearTextArea: function(ctx) {\n            // we add 4 pixel, to be sure to do not leave any pixel out\n            var width = this.width + 4, height = this.height + 4;\n            ctx.clearRect(-width / 2, -height / 2, width, height);\n        },\n        /**\n     * Returns cursor boundaries (left, top, leftOffset, topOffset)\n     * @private\n     * @param {Array} chars Array of characters\n     * @param {String} typeOfBoundaries\n     */ _getCursorBoundaries: function(position) {\n            // left/top are left/top of entire text box\n            // leftOffset/topOffset are offset from that left/top point of a text box\n            if (typeof position === \"undefined\") {\n                position = this.selectionStart;\n            }\n            var left = this._getLeftOffset(), top = this._getTopOffset(), offsets = this._getCursorBoundariesOffsets(position);\n            return {\n                left: left,\n                top: top,\n                leftOffset: offsets.left,\n                topOffset: offsets.top\n            };\n        },\n        /**\n     * @private\n     */ _getCursorBoundariesOffsets: function(position) {\n            if (this.cursorOffsetCache && \"top\" in this.cursorOffsetCache) {\n                return this.cursorOffsetCache;\n            }\n            var lineLeftOffset, lineIndex, charIndex, topOffset = 0, leftOffset = 0, boundaries, cursorPosition = this.get2DCursorLocation(position);\n            charIndex = cursorPosition.charIndex;\n            lineIndex = cursorPosition.lineIndex;\n            for(var i = 0; i < lineIndex; i++){\n                topOffset += this.getHeightOfLine(i);\n            }\n            lineLeftOffset = this._getLineLeftOffset(lineIndex);\n            var bound = this.__charBounds[lineIndex][charIndex];\n            bound && (leftOffset = bound.left);\n            if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {\n                leftOffset -= this._getWidthOfCharSpacing();\n            }\n            boundaries = {\n                top: topOffset,\n                left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0)\n            };\n            if (this.direction === \"rtl\") {\n                boundaries.left *= -1;\n            }\n            this.cursorOffsetCache = boundaries;\n            return this.cursorOffsetCache;\n        },\n        /**\n     * Renders cursor\n     * @param {Object} boundaries\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */ renderCursor: function(boundaries, ctx) {\n            var cursorLocation = this.get2DCursorLocation(), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, \"fontSize\"), multiplier = this.scaleX * this.canvas.getZoom(), cursorWidth = this.cursorWidth / multiplier, topOffset = boundaries.topOffset, dy = this.getValueOfPropertyAt(lineIndex, charIndex, \"deltaY\");\n            topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight - charHeight * (1 - this._fontSizeFraction);\n            if (this.inCompositionMode) {\n                this.renderSelection(boundaries, ctx);\n            }\n            ctx.fillStyle = this.cursorColor || this.getValueOfPropertyAt(lineIndex, charIndex, \"fill\");\n            ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;\n            ctx.fillRect(boundaries.left + boundaries.leftOffset - cursorWidth / 2, topOffset + boundaries.top + dy, cursorWidth, charHeight);\n        },\n        /**\n     * Renders text selection\n     * @param {Object} boundaries Object with left/top/leftOffset/topOffset\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */ renderSelection: function(boundaries, ctx) {\n            var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, isJustify = this.textAlign.indexOf(\"justify\") !== -1, start = this.get2DCursorLocation(selectionStart), end = this.get2DCursorLocation(selectionEnd), startLine = start.lineIndex, endLine = end.lineIndex, startChar = start.charIndex < 0 ? 0 : start.charIndex, endChar = end.charIndex < 0 ? 0 : end.charIndex;\n            for(var i = startLine; i <= endLine; i++){\n                var lineOffset = this._getLineLeftOffset(i) || 0, lineHeight = this.getHeightOfLine(i), realLineHeight = 0, boxStart = 0, boxEnd = 0;\n                if (i === startLine) {\n                    boxStart = this.__charBounds[startLine][startChar].left;\n                }\n                if (i >= startLine && i < endLine) {\n                    boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?\n                } else if (i === endLine) {\n                    if (endChar === 0) {\n                        boxEnd = this.__charBounds[endLine][endChar].left;\n                    } else {\n                        var charSpacing = this._getWidthOfCharSpacing();\n                        boxEnd = this.__charBounds[endLine][endChar - 1].left + this.__charBounds[endLine][endChar - 1].width - charSpacing;\n                    }\n                }\n                realLineHeight = lineHeight;\n                if (this.lineHeight < 1 || i === endLine && this.lineHeight > 1) {\n                    lineHeight /= this.lineHeight;\n                }\n                var drawStart = boundaries.left + lineOffset + boxStart, drawWidth = boxEnd - boxStart, drawHeight = lineHeight, extraTop = 0;\n                if (this.inCompositionMode) {\n                    ctx.fillStyle = this.compositionColor || \"black\";\n                    drawHeight = 1;\n                    extraTop = lineHeight;\n                } else {\n                    ctx.fillStyle = this.selectionColor;\n                }\n                if (this.direction === \"rtl\") {\n                    drawStart = this.width - drawStart - drawWidth;\n                }\n                ctx.fillRect(drawStart, boundaries.top + boundaries.topOffset + extraTop, drawWidth, drawHeight);\n                boundaries.topOffset += realLineHeight;\n            }\n        },\n        /**\n     * High level function to know the height of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns fontSize of char at the current cursor\n     * Unused from the library, is for the end user\n     * @return {Number} Character font size\n     */ getCurrentCharFontSize: function() {\n            var cp = this._getCurrentCharIndex();\n            return this.getValueOfPropertyAt(cp.l, cp.c, \"fontSize\");\n        },\n        /**\n     * High level function to know the color of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns color (fill) of char at the current cursor\n     * if the text object has a pattern or gradient for filler, it will return that.\n     * Unused by the library, is for the end user\n     * @return {String | fabric.Gradient | fabric.Pattern} Character color (fill)\n     */ getCurrentCharColor: function() {\n            var cp = this._getCurrentCharIndex();\n            return this.getValueOfPropertyAt(cp.l, cp.c, \"fill\");\n        },\n        /**\n     * Returns the cursor position for the getCurrent.. functions\n     * @private\n     */ _getCurrentCharIndex: function() {\n            var cursorPosition = this.get2DCursorLocation(this.selectionStart, true), charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;\n            return {\n                l: cursorPosition.lineIndex,\n                c: charIndex\n            };\n        }\n    });\n    /**\n   * Returns fabric.IText instance from an object representation\n   * @static\n   * @memberOf fabric.IText\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as argument\n   */ fabric.IText.fromObject = function(object, callback) {\n        parseDecoration(object);\n        if (object.styles) {\n            for(var i in object.styles){\n                for(var j in object.styles[i]){\n                    parseDecoration(object.styles[i][j]);\n                }\n            }\n        }\n        fabric.Object._fromObject(\"IText\", object, callback, \"text\");\n    };\n})();\n(function() {\n    var clone = fabric.util.object.clone;\n    fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n        /**\n     * Initializes all the interactive behavior of IText\n     */ initBehavior: function() {\n            this.initAddedHandler();\n            this.initRemovedHandler();\n            this.initCursorSelectionHandlers();\n            this.initDoubleClickSimulation();\n            this.mouseMoveHandler = this.mouseMoveHandler.bind(this);\n        },\n        onDeselect: function() {\n            this.isEditing && this.exitEditing();\n            this.selected = false;\n        },\n        /**\n     * Initializes \"added\" event handler\n     */ initAddedHandler: function() {\n            var _this = this;\n            this.on(\"added\", function() {\n                var canvas = _this.canvas;\n                if (canvas) {\n                    if (!canvas._hasITextHandlers) {\n                        canvas._hasITextHandlers = true;\n                        _this._initCanvasHandlers(canvas);\n                    }\n                    canvas._iTextInstances = canvas._iTextInstances || [];\n                    canvas._iTextInstances.push(_this);\n                }\n            });\n        },\n        initRemovedHandler: function() {\n            var _this = this;\n            this.on(\"removed\", function() {\n                var canvas = _this.canvas;\n                if (canvas) {\n                    canvas._iTextInstances = canvas._iTextInstances || [];\n                    fabric.util.removeFromArray(canvas._iTextInstances, _this);\n                    if (canvas._iTextInstances.length === 0) {\n                        canvas._hasITextHandlers = false;\n                        _this._removeCanvasHandlers(canvas);\n                    }\n                }\n            });\n        },\n        /**\n     * register canvas event to manage exiting on other instances\n     * @private\n     */ _initCanvasHandlers: function(canvas) {\n            canvas._mouseUpITextHandler = function() {\n                if (canvas._iTextInstances) {\n                    canvas._iTextInstances.forEach(function(obj) {\n                        obj.__isMousedown = false;\n                    });\n                }\n            };\n            canvas.on(\"mouse:up\", canvas._mouseUpITextHandler);\n        },\n        /**\n     * remove canvas event to manage exiting on other instances\n     * @private\n     */ _removeCanvasHandlers: function(canvas) {\n            canvas.off(\"mouse:up\", canvas._mouseUpITextHandler);\n        },\n        /**\n     * @private\n     */ _tick: function() {\n            this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, \"_onTickComplete\");\n        },\n        /**\n     * @private\n     */ _animateCursor: function(obj, targetOpacity, duration, completeMethod) {\n            var tickState;\n            tickState = {\n                isAborted: false,\n                abort: function() {\n                    this.isAborted = true;\n                }\n            };\n            obj.animate(\"_currentCursorOpacity\", targetOpacity, {\n                duration: duration,\n                onComplete: function() {\n                    if (!tickState.isAborted) {\n                        obj[completeMethod]();\n                    }\n                },\n                onChange: function() {\n                    // we do not want to animate a selection, only cursor\n                    if (obj.canvas && obj.selectionStart === obj.selectionEnd) {\n                        obj.renderCursorOrSelection();\n                    }\n                },\n                abort: function() {\n                    return tickState.isAborted;\n                }\n            });\n            return tickState;\n        },\n        /**\n     * @private\n     */ _onTickComplete: function() {\n            var _this = this;\n            if (this._cursorTimeout1) {\n                clearTimeout(this._cursorTimeout1);\n            }\n            this._cursorTimeout1 = setTimeout(function() {\n                _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, \"_tick\");\n            }, 100);\n        },\n        /**\n     * Initializes delayed cursor\n     */ initDelayedCursor: function(restart) {\n            var _this = this, delay = restart ? 0 : this.cursorDelay;\n            this.abortCursorAnimation();\n            this._currentCursorOpacity = 1;\n            this._cursorTimeout2 = setTimeout(function() {\n                _this._tick();\n            }, delay);\n        },\n        /**\n     * Aborts cursor animation and clears all timeouts\n     */ abortCursorAnimation: function() {\n            var shouldClear = this._currentTickState || this._currentTickCompleteState, canvas = this.canvas;\n            this._currentTickState && this._currentTickState.abort();\n            this._currentTickCompleteState && this._currentTickCompleteState.abort();\n            clearTimeout(this._cursorTimeout1);\n            clearTimeout(this._cursorTimeout2);\n            this._currentCursorOpacity = 0;\n            // to clear just itext area we need to transform the context\n            // it may not be worth it\n            if (shouldClear && canvas) {\n                canvas.clearContext(canvas.contextTop || canvas.contextContainer);\n            }\n        },\n        /**\n     * Selects entire text\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ selectAll: function() {\n            this.selectionStart = 0;\n            this.selectionEnd = this._text.length;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            return this;\n        },\n        /**\n     * Returns selected text\n     * @return {String}\n     */ getSelectedText: function() {\n            return this._text.slice(this.selectionStart, this.selectionEnd).join(\"\");\n        },\n        /**\n     * Find new selection index representing start of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findWordBoundaryLeft: function(startFrom) {\n            var offset = 0, index = startFrom - 1;\n            // remove space before cursor first\n            if (this._reSpace.test(this._text[index])) {\n                while(this._reSpace.test(this._text[index])){\n                    offset++;\n                    index--;\n                }\n            }\n            while(/\\S/.test(this._text[index]) && index > -1){\n                offset++;\n                index--;\n            }\n            return startFrom - offset;\n        },\n        /**\n     * Find new selection index representing end of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findWordBoundaryRight: function(startFrom) {\n            var offset = 0, index = startFrom;\n            // remove space after cursor first\n            if (this._reSpace.test(this._text[index])) {\n                while(this._reSpace.test(this._text[index])){\n                    offset++;\n                    index++;\n                }\n            }\n            while(/\\S/.test(this._text[index]) && index < this._text.length){\n                offset++;\n                index++;\n            }\n            return startFrom + offset;\n        },\n        /**\n     * Find new selection index representing start of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findLineBoundaryLeft: function(startFrom) {\n            var offset = 0, index = startFrom - 1;\n            while(!/\\n/.test(this._text[index]) && index > -1){\n                offset++;\n                index--;\n            }\n            return startFrom - offset;\n        },\n        /**\n     * Find new selection index representing end of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findLineBoundaryRight: function(startFrom) {\n            var offset = 0, index = startFrom;\n            while(!/\\n/.test(this._text[index]) && index < this._text.length){\n                offset++;\n                index++;\n            }\n            return startFrom + offset;\n        },\n        /**\n     * Finds index corresponding to beginning or end of a word\n     * @param {Number} selectionStart Index of a character\n     * @param {Number} direction 1 or -1\n     * @return {Number} Index of the beginning or end of a word\n     */ searchWordBoundary: function(selectionStart, direction) {\n            var text = this._text, index = this._reSpace.test(text[selectionStart]) ? selectionStart - 1 : selectionStart, _char = text[index], // wrong\n            reNonWord = fabric.reNonWord;\n            while(!reNonWord.test(_char) && index > 0 && index < text.length){\n                index += direction;\n                _char = text[index];\n            }\n            if (reNonWord.test(_char)) {\n                index += direction === 1 ? 0 : 1;\n            }\n            return index;\n        },\n        /**\n     * Selects a word based on the index\n     * @param {Number} selectionStart Index of a character\n     */ selectWord: function(selectionStart) {\n            selectionStart = selectionStart || this.selectionStart;\n            var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */ newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */ \n            this.selectionStart = newSelectionStart;\n            this.selectionEnd = newSelectionEnd;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            this.renderCursorOrSelection();\n        },\n        /**\n     * Selects a line based on the index\n     * @param {Number} selectionStart Index of a character\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ selectLine: function(selectionStart) {\n            selectionStart = selectionStart || this.selectionStart;\n            var newSelectionStart = this.findLineBoundaryLeft(selectionStart), newSelectionEnd = this.findLineBoundaryRight(selectionStart);\n            this.selectionStart = newSelectionStart;\n            this.selectionEnd = newSelectionEnd;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            return this;\n        },\n        /**\n     * Enters editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ enterEditing: function(e) {\n            if (this.isEditing || !this.editable) {\n                return;\n            }\n            if (this.canvas) {\n                this.canvas.calcOffset();\n                this.exitEditingOnOthers(this.canvas);\n            }\n            this.isEditing = true;\n            this.initHiddenTextarea(e);\n            this.hiddenTextarea.focus();\n            this.hiddenTextarea.value = this.text;\n            this._updateTextarea();\n            this._saveEditingProps();\n            this._setEditingProps();\n            this._textBeforeEdit = this.text;\n            this._tick();\n            this.fire(\"editing:entered\");\n            this._fireSelectionChanged();\n            if (!this.canvas) {\n                return this;\n            }\n            this.canvas.fire(\"text:editing:entered\", {\n                target: this\n            });\n            this.initMouseMoveHandler();\n            this.canvas.requestRenderAll();\n            return this;\n        },\n        exitEditingOnOthers: function(canvas) {\n            if (canvas._iTextInstances) {\n                canvas._iTextInstances.forEach(function(obj) {\n                    obj.selected = false;\n                    if (obj.isEditing) {\n                        obj.exitEditing();\n                    }\n                });\n            }\n        },\n        /**\n     * Initializes \"mousemove\" event handler\n     */ initMouseMoveHandler: function() {\n            this.canvas.on(\"mouse:move\", this.mouseMoveHandler);\n        },\n        /**\n     * @private\n     */ mouseMoveHandler: function(options) {\n            if (!this.__isMousedown || !this.isEditing) {\n                return;\n            }\n            var newSelectionStart = this.getSelectionStartFromPointer(options.e), currentStart = this.selectionStart, currentEnd = this.selectionEnd;\n            if ((newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd) && (currentStart === newSelectionStart || currentEnd === newSelectionStart)) {\n                return;\n            }\n            if (newSelectionStart > this.__selectionStartOnMouseDown) {\n                this.selectionStart = this.__selectionStartOnMouseDown;\n                this.selectionEnd = newSelectionStart;\n            } else {\n                this.selectionStart = newSelectionStart;\n                this.selectionEnd = this.__selectionStartOnMouseDown;\n            }\n            if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {\n                this.restartCursorIfNeeded();\n                this._fireSelectionChanged();\n                this._updateTextarea();\n                this.renderCursorOrSelection();\n            }\n        },\n        /**\n     * @private\n     */ _setEditingProps: function() {\n            this.hoverCursor = \"text\";\n            if (this.canvas) {\n                this.canvas.defaultCursor = this.canvas.moveCursor = \"text\";\n            }\n            this.borderColor = this.editingBorderColor;\n            this.hasControls = this.selectable = false;\n            this.lockMovementX = this.lockMovementY = true;\n        },\n        /**\n     * convert from textarea to grapheme indexes\n     */ fromStringToGraphemeSelection: function(start, end, text) {\n            var smallerTextStart = text.slice(0, start), graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;\n            if (start === end) {\n                return {\n                    selectionStart: graphemeStart,\n                    selectionEnd: graphemeStart\n                };\n            }\n            var smallerTextEnd = text.slice(start, end), graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;\n            return {\n                selectionStart: graphemeStart,\n                selectionEnd: graphemeStart + graphemeEnd\n            };\n        },\n        /**\n     * convert from fabric to textarea values\n     */ fromGraphemeToStringSelection: function(start, end, _text) {\n            var smallerTextStart = _text.slice(0, start), graphemeStart = smallerTextStart.join(\"\").length;\n            if (start === end) {\n                return {\n                    selectionStart: graphemeStart,\n                    selectionEnd: graphemeStart\n                };\n            }\n            var smallerTextEnd = _text.slice(start, end), graphemeEnd = smallerTextEnd.join(\"\").length;\n            return {\n                selectionStart: graphemeStart,\n                selectionEnd: graphemeStart + graphemeEnd\n            };\n        },\n        /**\n     * @private\n     */ _updateTextarea: function() {\n            this.cursorOffsetCache = {};\n            if (!this.hiddenTextarea) {\n                return;\n            }\n            if (!this.inCompositionMode) {\n                var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);\n                this.hiddenTextarea.selectionStart = newSelection.selectionStart;\n                this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;\n            }\n            this.updateTextareaPosition();\n        },\n        /**\n     * @private\n     */ updateFromTextArea: function() {\n            if (!this.hiddenTextarea) {\n                return;\n            }\n            this.cursorOffsetCache = {};\n            this.text = this.hiddenTextarea.value;\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            var newSelection = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n            this.selectionEnd = this.selectionStart = newSelection.selectionEnd;\n            if (!this.inCompositionMode) {\n                this.selectionStart = newSelection.selectionStart;\n            }\n            this.updateTextareaPosition();\n        },\n        /**\n     * @private\n     */ updateTextareaPosition: function() {\n            if (this.selectionStart === this.selectionEnd) {\n                var style = this._calcTextareaPosition();\n                this.hiddenTextarea.style.left = style.left;\n                this.hiddenTextarea.style.top = style.top;\n            }\n        },\n        /**\n     * @private\n     * @return {Object} style contains style for hiddenTextarea\n     */ _calcTextareaPosition: function() {\n            if (!this.canvas) {\n                return {\n                    x: 1,\n                    y: 1\n                };\n            }\n            var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart, boundaries = this._getCursorBoundaries(desiredPosition), cursorLocation = this.get2DCursorLocation(desiredPosition), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, \"fontSize\") * this.lineHeight, leftOffset = boundaries.leftOffset, m = this.calcTransformMatrix(), p = {\n                x: boundaries.left + leftOffset,\n                y: boundaries.top + boundaries.topOffset + charHeight\n            }, retinaScaling = this.canvas.getRetinaScaling(), upperCanvas = this.canvas.upperCanvasEl, upperCanvasWidth = upperCanvas.width / retinaScaling, upperCanvasHeight = upperCanvas.height / retinaScaling, maxWidth = upperCanvasWidth - charHeight, maxHeight = upperCanvasHeight - charHeight, scaleX = upperCanvas.clientWidth / upperCanvasWidth, scaleY = upperCanvas.clientHeight / upperCanvasHeight;\n            p = fabric.util.transformPoint(p, m);\n            p = fabric.util.transformPoint(p, this.canvas.viewportTransform);\n            p.x *= scaleX;\n            p.y *= scaleY;\n            if (p.x < 0) {\n                p.x = 0;\n            }\n            if (p.x > maxWidth) {\n                p.x = maxWidth;\n            }\n            if (p.y < 0) {\n                p.y = 0;\n            }\n            if (p.y > maxHeight) {\n                p.y = maxHeight;\n            }\n            // add canvas offset on document\n            p.x += this.canvas._offset.left;\n            p.y += this.canvas._offset.top;\n            return {\n                left: p.x + \"px\",\n                top: p.y + \"px\",\n                fontSize: charHeight + \"px\",\n                charHeight: charHeight\n            };\n        },\n        /**\n     * @private\n     */ _saveEditingProps: function() {\n            this._savedProps = {\n                hasControls: this.hasControls,\n                borderColor: this.borderColor,\n                lockMovementX: this.lockMovementX,\n                lockMovementY: this.lockMovementY,\n                hoverCursor: this.hoverCursor,\n                selectable: this.selectable,\n                defaultCursor: this.canvas && this.canvas.defaultCursor,\n                moveCursor: this.canvas && this.canvas.moveCursor\n            };\n        },\n        /**\n     * @private\n     */ _restoreEditingProps: function() {\n            if (!this._savedProps) {\n                return;\n            }\n            this.hoverCursor = this._savedProps.hoverCursor;\n            this.hasControls = this._savedProps.hasControls;\n            this.borderColor = this._savedProps.borderColor;\n            this.selectable = this._savedProps.selectable;\n            this.lockMovementX = this._savedProps.lockMovementX;\n            this.lockMovementY = this._savedProps.lockMovementY;\n            if (this.canvas) {\n                this.canvas.defaultCursor = this._savedProps.defaultCursor;\n                this.canvas.moveCursor = this._savedProps.moveCursor;\n            }\n        },\n        /**\n     * Exits from editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ exitEditing: function() {\n            var isTextChanged = this._textBeforeEdit !== this.text;\n            var hiddenTextarea = this.hiddenTextarea;\n            this.selected = false;\n            this.isEditing = false;\n            this.selectionEnd = this.selectionStart;\n            if (hiddenTextarea) {\n                hiddenTextarea.blur && hiddenTextarea.blur();\n                hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);\n            }\n            this.hiddenTextarea = null;\n            this.abortCursorAnimation();\n            this._restoreEditingProps();\n            this._currentCursorOpacity = 0;\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            this.fire(\"editing:exited\");\n            isTextChanged && this.fire(\"modified\");\n            if (this.canvas) {\n                this.canvas.off(\"mouse:move\", this.mouseMoveHandler);\n                this.canvas.fire(\"text:editing:exited\", {\n                    target: this\n                });\n                isTextChanged && this.canvas.fire(\"object:modified\", {\n                    target: this\n                });\n            }\n            return this;\n        },\n        /**\n     * @private\n     */ _removeExtraneousStyles: function() {\n            for(var prop in this.styles){\n                if (!this._textLines[prop]) {\n                    delete this.styles[prop];\n                }\n            }\n        },\n        /**\n     * remove and reflow a style block from start to end.\n     * @param {Number} start linear start position for removal (included in removal)\n     * @param {Number} end linear end position for removal ( excluded from removal )\n     */ removeStyleFromTo: function(start, end) {\n            var cursorStart = this.get2DCursorLocation(start, true), cursorEnd = this.get2DCursorLocation(end, true), lineStart = cursorStart.lineIndex, charStart = cursorStart.charIndex, lineEnd = cursorEnd.lineIndex, charEnd = cursorEnd.charIndex, i, styleObj;\n            if (lineStart !== lineEnd) {\n                // step1 remove the trailing of lineStart\n                if (this.styles[lineStart]) {\n                    for(i = charStart; i < this._unwrappedTextLines[lineStart].length; i++){\n                        delete this.styles[lineStart][i];\n                    }\n                }\n                // step2 move the trailing of lineEnd to lineStart if needed\n                if (this.styles[lineEnd]) {\n                    for(i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++){\n                        styleObj = this.styles[lineEnd][i];\n                        if (styleObj) {\n                            this.styles[lineStart] || (this.styles[lineStart] = {});\n                            this.styles[lineStart][charStart + i - charEnd] = styleObj;\n                        }\n                    }\n                }\n                // step3 detects lines will be completely removed.\n                for(i = lineStart + 1; i <= lineEnd; i++){\n                    delete this.styles[i];\n                }\n                // step4 shift remaining lines.\n                this.shiftLineStyles(lineEnd, lineStart - lineEnd);\n            } else {\n                // remove and shift left on the same line\n                if (this.styles[lineStart]) {\n                    styleObj = this.styles[lineStart];\n                    var diff = charEnd - charStart, numericChar, _char;\n                    for(i = charStart; i < charEnd; i++){\n                        delete styleObj[i];\n                    }\n                    for(_char in this.styles[lineStart]){\n                        numericChar = parseInt(_char, 10);\n                        if (numericChar >= charEnd) {\n                            styleObj[numericChar - diff] = styleObj[_char];\n                            delete styleObj[_char];\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Shifts line styles up or down\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} offset Can any number?\n     */ shiftLineStyles: function(lineIndex, offset) {\n            // shift all line styles by offset upward or downward\n            // do not clone deep. we need new array, not new style objects\n            var clonedStyles = clone(this.styles);\n            for(var line in this.styles){\n                var numericLine = parseInt(line, 10);\n                if (numericLine > lineIndex) {\n                    this.styles[numericLine + offset] = clonedStyles[numericLine];\n                    if (!clonedStyles[numericLine - offset]) {\n                        delete this.styles[numericLine];\n                    }\n                }\n            }\n        },\n        restartCursorIfNeeded: function() {\n            if (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) {\n                this.initDelayedCursor();\n            }\n        },\n        /**\n     * Handle insertion of more consecutive style lines for when one or more\n     * newlines gets added to the text. Since current style needs to be shifted\n     * first we shift the current style of the number lines needed, then we add\n     * new lines from the last to the first.\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} qty number of lines to add\n     * @param {Array} copiedStyle Array of objects styles\n     */ insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {\n            var currentCharStyle, newLineStyles = {}, somethingAdded = false, isEndOfLine = this._unwrappedTextLines[lineIndex].length === charIndex;\n            qty || (qty = 1);\n            this.shiftLineStyles(lineIndex, qty);\n            if (this.styles[lineIndex]) {\n                currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];\n            }\n            // we clone styles of all chars\n            // after cursor onto the current line\n            for(var index in this.styles[lineIndex]){\n                var numIndex = parseInt(index, 10);\n                if (numIndex >= charIndex) {\n                    somethingAdded = true;\n                    newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];\n                    // remove lines from the previous line since they're on a new line now\n                    if (!(isEndOfLine && charIndex === 0)) {\n                        delete this.styles[lineIndex][index];\n                    }\n                }\n            }\n            var styleCarriedOver = false;\n            if (somethingAdded && !isEndOfLine) {\n                // if is end of line, the extra style we copied\n                // is probably not something we want\n                this.styles[lineIndex + qty] = newLineStyles;\n                styleCarriedOver = true;\n            }\n            if (styleCarriedOver) {\n                // skip the last line of since we already prepared it.\n                qty--;\n            }\n            // for the all the lines or all the other lines\n            // we clone current char style onto the next (otherwise empty) line\n            while(qty > 0){\n                if (copiedStyle && copiedStyle[qty - 1]) {\n                    this.styles[lineIndex + qty] = {\n                        0: clone(copiedStyle[qty - 1])\n                    };\n                } else if (currentCharStyle) {\n                    this.styles[lineIndex + qty] = {\n                        0: clone(currentCharStyle)\n                    };\n                } else {\n                    delete this.styles[lineIndex + qty];\n                }\n                qty--;\n            }\n            this._forceClearCache = true;\n        },\n        /**\n     * Inserts style object for a given line/char index\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} quantity number Style object to insert, if given\n     * @param {Array} copiedStyle array of style objects\n     */ insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {\n            if (!this.styles) {\n                this.styles = {};\n            }\n            var currentLineStyles = this.styles[lineIndex], currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};\n            quantity || (quantity = 1);\n            // shift all char styles by quantity forward\n            // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4\n            for(var index in currentLineStylesCloned){\n                var numericIndex = parseInt(index, 10);\n                if (numericIndex >= charIndex) {\n                    currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];\n                    // only delete the style if there was nothing moved there\n                    if (!currentLineStylesCloned[numericIndex - quantity]) {\n                        delete currentLineStyles[numericIndex];\n                    }\n                }\n            }\n            this._forceClearCache = true;\n            if (copiedStyle) {\n                while(quantity--){\n                    if (!Object.keys(copiedStyle[quantity]).length) {\n                        continue;\n                    }\n                    if (!this.styles[lineIndex]) {\n                        this.styles[lineIndex] = {};\n                    }\n                    this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);\n                }\n                return;\n            }\n            if (!currentLineStyles) {\n                return;\n            }\n            var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];\n            while(newStyle && quantity--){\n                this.styles[lineIndex][charIndex + quantity] = clone(newStyle);\n            }\n        },\n        /**\n     * Inserts style object(s)\n     * @param {Array} insertedText Characters at the location where style is inserted\n     * @param {Number} start cursor index for inserting style\n     * @param {Array} [copiedStyle] array of style objects to insert.\n     */ insertNewStyleBlock: function(insertedText, start, copiedStyle) {\n            var cursorLoc = this.get2DCursorLocation(start, true), addedLines = [\n                0\n            ], linesLength = 0;\n            // get an array of how many char per lines are being added.\n            for(var i = 0; i < insertedText.length; i++){\n                if (insertedText[i] === \"\\n\") {\n                    linesLength++;\n                    addedLines[linesLength] = 0;\n                } else {\n                    addedLines[linesLength]++;\n                }\n            }\n            // for the first line copy the style from the current char position.\n            if (addedLines[0] > 0) {\n                this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);\n                copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);\n            }\n            linesLength && this.insertNewlineStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLength);\n            for(var i = 1; i < linesLength; i++){\n                if (addedLines[i] > 0) {\n                    this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);\n                } else if (copiedStyle) {\n                    // this test is required in order to close #6841\n                    // when a pasted buffer begins with a newline then\n                    // this.styles[cursorLoc.lineIndex + i] and copiedStyle[0]\n                    // may be undefined for some reason\n                    if (this.styles[cursorLoc.lineIndex + i] && copiedStyle[0]) {\n                        this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];\n                    }\n                }\n                copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);\n            }\n            // we use i outside the loop to get it like linesLength\n            if (addedLines[i] > 0) {\n                this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);\n            }\n        },\n        /**\n     * Set the selectionStart and selectionEnd according to the new position of cursor\n     * mimic the key - mouse navigation when shift is pressed.\n     */ setSelectionStartEndWithShift: function(start, end, newSelection) {\n            if (newSelection <= start) {\n                if (end === start) {\n                    this._selectionDirection = \"left\";\n                } else if (this._selectionDirection === \"right\") {\n                    this._selectionDirection = \"left\";\n                    this.selectionEnd = start;\n                }\n                this.selectionStart = newSelection;\n            } else if (newSelection > start && newSelection < end) {\n                if (this._selectionDirection === \"right\") {\n                    this.selectionEnd = newSelection;\n                } else {\n                    this.selectionStart = newSelection;\n                }\n            } else {\n                // newSelection is > selection start and end\n                if (end === start) {\n                    this._selectionDirection = \"right\";\n                } else if (this._selectionDirection === \"left\") {\n                    this._selectionDirection = \"right\";\n                    this.selectionStart = end;\n                }\n                this.selectionEnd = newSelection;\n            }\n        },\n        setSelectionInBoundaries: function() {\n            var length = this.text.length;\n            if (this.selectionStart > length) {\n                this.selectionStart = length;\n            } else if (this.selectionStart < 0) {\n                this.selectionStart = 0;\n            }\n            if (this.selectionEnd > length) {\n                this.selectionEnd = length;\n            } else if (this.selectionEnd < 0) {\n                this.selectionEnd = 0;\n            }\n        }\n    });\n})();\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n    /**\n   * Initializes \"dbclick\" event handler\n   */ initDoubleClickSimulation: function() {\n        // for double click\n        this.__lastClickTime = +new Date();\n        // for triple click\n        this.__lastLastClickTime = +new Date();\n        this.__lastPointer = {};\n        this.on(\"mousedown\", this.onMouseDown);\n    },\n    /**\n   * Default event handler to simulate triple click\n   * @private\n   */ onMouseDown: function(options) {\n        if (!this.canvas) {\n            return;\n        }\n        this.__newClickTime = +new Date();\n        var newPointer = options.pointer;\n        if (this.isTripleClick(newPointer)) {\n            this.fire(\"tripleclick\", options);\n            this._stopEvent(options.e);\n        }\n        this.__lastLastClickTime = this.__lastClickTime;\n        this.__lastClickTime = this.__newClickTime;\n        this.__lastPointer = newPointer;\n        this.__lastIsEditing = this.isEditing;\n        this.__lastSelected = this.selected;\n    },\n    isTripleClick: function(newPointer) {\n        return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === newPointer.x && this.__lastPointer.y === newPointer.y;\n    },\n    /**\n   * @private\n   */ _stopEvent: function(e) {\n        e.preventDefault && e.preventDefault();\n        e.stopPropagation && e.stopPropagation();\n    },\n    /**\n   * Initializes event handlers related to cursor or selection\n   */ initCursorSelectionHandlers: function() {\n        this.initMousedownHandler();\n        this.initMouseupHandler();\n        this.initClicks();\n    },\n    /**\n   * Default handler for double click, select a word\n   */ doubleClickHandler: function(options) {\n        if (!this.isEditing) {\n            return;\n        }\n        this.selectWord(this.getSelectionStartFromPointer(options.e));\n    },\n    /**\n   * Default handler for triple click, select a line\n   */ tripleClickHandler: function(options) {\n        if (!this.isEditing) {\n            return;\n        }\n        this.selectLine(this.getSelectionStartFromPointer(options.e));\n    },\n    /**\n   * Initializes double and triple click event handlers\n   */ initClicks: function() {\n        this.on(\"mousedblclick\", this.doubleClickHandler);\n        this.on(\"tripleclick\", this.tripleClickHandler);\n    },\n    /**\n   * Default event handler for the basic functionalities needed on _mouseDown\n   * can be overridden to do something different.\n   * Scope of this implementation is: find the click position, set selectionStart\n   * find selectionEnd, initialize the drawing of either cursor or selection area\n   * initializing a mousedDown on a text area will cancel fabricjs knowledge of\n   * current compositionMode. It will be set to false.\n   */ _mouseDownHandler: function(options) {\n        if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        this.__isMousedown = true;\n        if (this.selected) {\n            this.inCompositionMode = false;\n            this.setCursorByClick(options.e);\n        }\n        if (this.isEditing) {\n            this.__selectionStartOnMouseDown = this.selectionStart;\n            if (this.selectionStart === this.selectionEnd) {\n                this.abortCursorAnimation();\n            }\n            this.renderCursorOrSelection();\n        }\n    },\n    /**\n   * Default event handler for the basic functionalities needed on mousedown:before\n   * can be overridden to do something different.\n   * Scope of this implementation is: verify the object is already selected when mousing down\n   */ _mouseDownHandlerBefore: function(options) {\n        if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        // we want to avoid that an object that was selected and then becomes unselectable,\n        // may trigger editing mode in some way.\n        this.selected = this === this.canvas._activeObject;\n    },\n    /**\n   * Initializes \"mousedown\" event handler\n   */ initMousedownHandler: function() {\n        this.on(\"mousedown\", this._mouseDownHandler);\n        this.on(\"mousedown:before\", this._mouseDownHandlerBefore);\n    },\n    /**\n   * Initializes \"mouseup\" event handler\n   */ initMouseupHandler: function() {\n        this.on(\"mouseup\", this.mouseUpHandler);\n    },\n    /**\n   * standard handler for mouse up, overridable\n   * @private\n   */ mouseUpHandler: function(options) {\n        this.__isMousedown = false;\n        if (!this.editable || this.group || options.transform && options.transform.actionPerformed || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        if (this.canvas) {\n            var currentActive = this.canvas._activeObject;\n            if (currentActive && currentActive !== this) {\n                // avoid running this logic when there is an active object\n                // this because is possible with shift click and fast clicks,\n                // to rapidly deselect and reselect this object and trigger an enterEdit\n                return;\n            }\n        }\n        if (this.__lastSelected && !this.__corner) {\n            this.selected = false;\n            this.__lastSelected = false;\n            this.enterEditing(options.e);\n            if (this.selectionStart === this.selectionEnd) {\n                this.initDelayedCursor(true);\n            } else {\n                this.renderCursorOrSelection();\n            }\n        } else {\n            this.selected = true;\n        }\n    },\n    /**\n   * Changes cursor location in a text depending on passed pointer (x/y) object\n   * @param {Event} e Event object\n   */ setCursorByClick: function(e) {\n        var newSelection = this.getSelectionStartFromPointer(e), start = this.selectionStart, end = this.selectionEnd;\n        if (e.shiftKey) {\n            this.setSelectionStartEndWithShift(start, end, newSelection);\n        } else {\n            this.selectionStart = newSelection;\n            this.selectionEnd = newSelection;\n        }\n        if (this.isEditing) {\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Returns index of a character corresponding to where an object was clicked\n   * @param {Event} e Event object\n   * @return {Number} Index of a character\n   */ getSelectionStartFromPointer: function(e) {\n        var mouseOffset = this.getLocalPointer(e), prevWidth = 0, width = 0, height = 0, charIndex = 0, lineIndex = 0, lineLeftOffset, line;\n        for(var i = 0, len = this._textLines.length; i < len; i++){\n            if (height <= mouseOffset.y) {\n                height += this.getHeightOfLine(i) * this.scaleY;\n                lineIndex = i;\n                if (i > 0) {\n                    charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);\n                }\n            } else {\n                break;\n            }\n        }\n        lineLeftOffset = this._getLineLeftOffset(lineIndex);\n        width = lineLeftOffset * this.scaleX;\n        line = this._textLines[lineIndex];\n        // handling of RTL: in order to get things work correctly,\n        // we assume RTL writing is mirrored compared to LTR writing.\n        // so in position detection we mirror the X offset, and when is time\n        // of rendering it, we mirror it again.\n        if (this.direction === \"rtl\") {\n            mouseOffset.x = this.width * this.scaleX - mouseOffset.x + width;\n        }\n        for(var j = 0, jlen = line.length; j < jlen; j++){\n            prevWidth = width;\n            // i removed something about flipX here, check.\n            width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;\n            if (width <= mouseOffset.x) {\n                charIndex++;\n            } else {\n                break;\n            }\n        }\n        return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);\n    },\n    /**\n   * @private\n   */ _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {\n        // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0\n        var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth, distanceBtwNextCharAndCursor = width - mouseOffset.x, offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor || distanceBtwNextCharAndCursor < 0 ? 0 : 1, newSelectionStart = index + offset;\n        // if object is horizontally flipped, mirror cursor location from the end\n        if (this.flipX) {\n            newSelectionStart = jlen - newSelectionStart;\n        }\n        if (newSelectionStart > this._text.length) {\n            newSelectionStart = this._text.length;\n        }\n        return newSelectionStart;\n    }\n});\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n    /**\n   * Initializes hidden textarea (needed to bring up keyboard in iOS)\n   */ initHiddenTextarea: function() {\n        this.hiddenTextarea = fabric.document.createElement(\"textarea\");\n        this.hiddenTextarea.setAttribute(\"autocapitalize\", \"off\");\n        this.hiddenTextarea.setAttribute(\"autocorrect\", \"off\");\n        this.hiddenTextarea.setAttribute(\"autocomplete\", \"off\");\n        this.hiddenTextarea.setAttribute(\"spellcheck\", \"false\");\n        this.hiddenTextarea.setAttribute(\"data-fabric-hiddentextarea\", \"\");\n        this.hiddenTextarea.setAttribute(\"wrap\", \"off\");\n        var style = this._calcTextareaPosition();\n        // line-height: 1px; was removed from the style to fix this:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=870966\n        this.hiddenTextarea.style.cssText = \"position: absolute; top: \" + style.top + \"; left: \" + style.left + \"; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;\" + \" paddingｰtop: \" + style.fontSize + \";\";\n        if (this.hiddenTextareaContainer) {\n            this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);\n        } else {\n            fabric.document.body.appendChild(this.hiddenTextarea);\n        }\n        fabric.util.addListener(this.hiddenTextarea, \"keydown\", this.onKeyDown.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"keyup\", this.onKeyUp.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"input\", this.onInput.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"copy\", this.copy.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"cut\", this.copy.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"paste\", this.paste.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionstart\", this.onCompositionStart.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionupdate\", this.onCompositionUpdate.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionend\", this.onCompositionEnd.bind(this));\n        if (!this._clickHandlerInitialized && this.canvas) {\n            fabric.util.addListener(this.canvas.upperCanvasEl, \"click\", this.onClick.bind(this));\n            this._clickHandlerInitialized = true;\n        }\n    },\n    /**\n   * For functionalities on keyDown\n   * Map a special key to a function of the instance/prototype\n   * If you need different behaviour for ESC or TAB or arrows, you have to change\n   * this map setting the name of a function that you build on the fabric.Itext or\n   * your prototype.\n   * the map change will affect all Instances unless you need for only some text Instances\n   * in that case you have to clone this object and assign your Instance.\n   * this.keysMap = fabric.util.object.clone(this.keysMap);\n   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]\n   */ keysMap: {\n        9: \"exitEditing\",\n        27: \"exitEditing\",\n        33: \"moveCursorUp\",\n        34: \"moveCursorDown\",\n        35: \"moveCursorRight\",\n        36: \"moveCursorLeft\",\n        37: \"moveCursorLeft\",\n        38: \"moveCursorUp\",\n        39: \"moveCursorRight\",\n        40: \"moveCursorDown\"\n    },\n    keysMapRtl: {\n        9: \"exitEditing\",\n        27: \"exitEditing\",\n        33: \"moveCursorUp\",\n        34: \"moveCursorDown\",\n        35: \"moveCursorLeft\",\n        36: \"moveCursorRight\",\n        37: \"moveCursorRight\",\n        38: \"moveCursorUp\",\n        39: \"moveCursorLeft\",\n        40: \"moveCursorDown\"\n    },\n    /**\n   * For functionalities on keyUp + ctrl || cmd\n   */ ctrlKeysMapUp: {\n        67: \"copy\",\n        88: \"cut\"\n    },\n    /**\n   * For functionalities on keyDown + ctrl || cmd\n   */ ctrlKeysMapDown: {\n        65: \"selectAll\"\n    },\n    onClick: function() {\n        // No need to trigger click event here, focus is enough to have the keyboard appear on Android\n        this.hiddenTextarea && this.hiddenTextarea.focus();\n    },\n    /**\n   * Handles keydown event\n   * only used for arrows and combination of modifier keys.\n   * @param {Event} e Event object\n   */ onKeyDown: function(e) {\n        if (!this.isEditing) {\n            return;\n        }\n        var keyMap = this.direction === \"rtl\" ? this.keysMapRtl : this.keysMap;\n        if (e.keyCode in keyMap) {\n            this[keyMap[e.keyCode]](e);\n        } else if (e.keyCode in this.ctrlKeysMapDown && (e.ctrlKey || e.metaKey)) {\n            this[this.ctrlKeysMapDown[e.keyCode]](e);\n        } else {\n            return;\n        }\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        if (e.keyCode >= 33 && e.keyCode <= 40) {\n            // if i press an arrow key just update selection\n            this.inCompositionMode = false;\n            this.clearContextTop();\n            this.renderCursorOrSelection();\n        } else {\n            this.canvas && this.canvas.requestRenderAll();\n        }\n    },\n    /**\n   * Handles keyup event\n   * We handle KeyUp because ie11 and edge have difficulties copy/pasting\n   * if a copy/cut event fired, keyup is dismissed\n   * @param {Event} e Event object\n   */ onKeyUp: function(e) {\n        if (!this.isEditing || this._copyDone || this.inCompositionMode) {\n            this._copyDone = false;\n            return;\n        }\n        if (e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey)) {\n            this[this.ctrlKeysMapUp[e.keyCode]](e);\n        } else {\n            return;\n        }\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        this.canvas && this.canvas.requestRenderAll();\n    },\n    /**\n   * Handles onInput event\n   * @param {Event} e Event object\n   */ onInput: function(e) {\n        var fromPaste = this.fromPaste;\n        this.fromPaste = false;\n        e && e.stopPropagation();\n        if (!this.isEditing) {\n            return;\n        }\n        // decisions about style changes.\n        var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, charCount = this._text.length, nextCharCount = nextText.length, removedText, insertedText, charDiff = nextCharCount - charCount, selectionStart = this.selectionStart, selectionEnd = this.selectionEnd, selection = selectionStart !== selectionEnd, copiedStyle, removeFrom, removeTo;\n        if (this.hiddenTextarea.value === \"\") {\n            this.styles = {};\n            this.updateFromTextArea();\n            this.fire(\"changed\");\n            if (this.canvas) {\n                this.canvas.fire(\"text:changed\", {\n                    target: this\n                });\n                this.canvas.requestRenderAll();\n            }\n            return;\n        }\n        var textareaSelection = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n        var backDelete = selectionStart > textareaSelection.selectionStart;\n        if (selection) {\n            removedText = this._text.slice(selectionStart, selectionEnd);\n            charDiff += selectionEnd - selectionStart;\n        } else if (nextCharCount < charCount) {\n            if (backDelete) {\n                removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);\n            } else {\n                removedText = this._text.slice(selectionStart, selectionStart - charDiff);\n            }\n        }\n        insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);\n        if (removedText && removedText.length) {\n            if (insertedText.length) {\n                // let's copy some style before deleting.\n                // we want to copy the style before the cursor OR the style at the cursor if selection\n                // is bigger than 0.\n                copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);\n                // now duplicate the style one for each inserted text.\n                copiedStyle = insertedText.map(function() {\n                    // this return an array of references, but that is fine since we are\n                    // copying the style later.\n                    return copiedStyle[0];\n                });\n            }\n            if (selection) {\n                removeFrom = selectionStart;\n                removeTo = selectionEnd;\n            } else if (backDelete) {\n                // detect differences between forwardDelete and backDelete\n                removeFrom = selectionEnd - removedText.length;\n                removeTo = selectionEnd;\n            } else {\n                removeFrom = selectionEnd;\n                removeTo = selectionEnd + removedText.length;\n            }\n            this.removeStyleFromTo(removeFrom, removeTo);\n        }\n        if (insertedText.length) {\n            if (fromPaste && insertedText.join(\"\") === fabric.copiedText && !fabric.disableStyleCopyPaste) {\n                copiedStyle = fabric.copiedTextStyle;\n            }\n            this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);\n        }\n        this.updateFromTextArea();\n        this.fire(\"changed\");\n        if (this.canvas) {\n            this.canvas.fire(\"text:changed\", {\n                target: this\n            });\n            this.canvas.requestRenderAll();\n        }\n    },\n    /**\n   * Composition start\n   */ onCompositionStart: function() {\n        this.inCompositionMode = true;\n    },\n    /**\n   * Composition end\n   */ onCompositionEnd: function() {\n        this.inCompositionMode = false;\n    },\n    // /**\n    //  * Composition update\n    //  */\n    onCompositionUpdate: function(e) {\n        this.compositionStart = e.target.selectionStart;\n        this.compositionEnd = e.target.selectionEnd;\n        this.updateTextareaPosition();\n    },\n    /**\n   * Copies selected text\n   * @param {Event} e Event object\n   */ copy: function() {\n        if (this.selectionStart === this.selectionEnd) {\n            //do not cut-copy if no selection\n            return;\n        }\n        fabric.copiedText = this.getSelectedText();\n        if (!fabric.disableStyleCopyPaste) {\n            fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);\n        } else {\n            fabric.copiedTextStyle = null;\n        }\n        this._copyDone = true;\n    },\n    /**\n   * Pastes text\n   * @param {Event} e Event object\n   */ paste: function() {\n        this.fromPaste = true;\n    },\n    /**\n   * @private\n   * @param {Event} e Event object\n   * @return {Object} Clipboard data object\n   */ _getClipboardData: function(e) {\n        return e && e.clipboardData || fabric.window.clipboardData;\n    },\n    /**\n   * Finds the width in pixels before the cursor on the same line\n   * @private\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @return {Number} widthBeforeCursor width before cursor\n   */ _getWidthBeforeCursor: function(lineIndex, charIndex) {\n        var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;\n        if (charIndex > 0) {\n            bound = this.__charBounds[lineIndex][charIndex - 1];\n            widthBeforeCursor += bound.left + bound.width;\n        }\n        return widthBeforeCursor;\n    },\n    /**\n   * Gets start offset of a selection\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ getDownCursorOffset: function(e, isRight) {\n        var selectionProp = this._getSelectionForOffset(e, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;\n        // if on last line, down cursor goes to end of line\n        if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {\n            // move to the end of a text\n            return this._text.length - selectionProp;\n        }\n        var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor), textAfterCursor = this._textLines[lineIndex].slice(charIndex);\n        return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);\n    },\n    /**\n   * private\n   * Helps finding if the offset should be counted from Start or End\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ _getSelectionForOffset: function(e, isRight) {\n        if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {\n            return this.selectionEnd;\n        } else {\n            return this.selectionStart;\n        }\n    },\n    /**\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ getUpCursorOffset: function(e, isRight) {\n        var selectionProp = this._getSelectionForOffset(e, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;\n        if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {\n            // if on first line, up cursor goes to start of line\n            return -selectionProp;\n        }\n        var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor), textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex), missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);\n        // return a negative offset\n        return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);\n    },\n    /**\n   * for a given width it founds the matching character.\n   * @private\n   */ _getIndexOnLine: function(lineIndex, width) {\n        var line = this._textLines[lineIndex], lineLeftOffset = this._getLineLeftOffset(lineIndex), widthOfCharsOnLine = lineLeftOffset, indexOnLine = 0, charWidth, foundMatch;\n        for(var j = 0, jlen = line.length; j < jlen; j++){\n            charWidth = this.__charBounds[lineIndex][j].width;\n            widthOfCharsOnLine += charWidth;\n            if (widthOfCharsOnLine > width) {\n                foundMatch = true;\n                var leftEdge = widthOfCharsOnLine - charWidth, rightEdge = widthOfCharsOnLine, offsetFromLeftEdge = Math.abs(leftEdge - width), offsetFromRightEdge = Math.abs(rightEdge - width);\n                indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : j - 1;\n                break;\n            }\n        }\n        // reached end\n        if (!foundMatch) {\n            indexOnLine = line.length - 1;\n        }\n        return indexOnLine;\n    },\n    /**\n   * Moves cursor down\n   * @param {Event} e Event object\n   */ moveCursorDown: function(e) {\n        if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {\n            return;\n        }\n        this._moveCursorUpOrDown(\"Down\", e);\n    },\n    /**\n   * Moves cursor up\n   * @param {Event} e Event object\n   */ moveCursorUp: function(e) {\n        if (this.selectionStart === 0 && this.selectionEnd === 0) {\n            return;\n        }\n        this._moveCursorUpOrDown(\"Up\", e);\n    },\n    /**\n   * Moves cursor up or down, fires the events\n   * @param {String} direction 'Up' or 'Down'\n   * @param {Event} e Event object\n   */ _moveCursorUpOrDown: function(direction, e) {\n        // getUpCursorOffset\n        // getDownCursorOffset\n        var action = \"get\" + direction + \"CursorOffset\", offset = this[action](e, this._selectionDirection === \"right\");\n        if (e.shiftKey) {\n            this.moveCursorWithShift(offset);\n        } else {\n            this.moveCursorWithoutShift(offset);\n        }\n        if (offset !== 0) {\n            this.setSelectionInBoundaries();\n            this.abortCursorAnimation();\n            this._currentCursorOpacity = 1;\n            this.initDelayedCursor();\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Moves cursor with shift\n   * @param {Number} offset\n   */ moveCursorWithShift: function(offset) {\n        var newSelection = this._selectionDirection === \"left\" ? this.selectionStart + offset : this.selectionEnd + offset;\n        this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);\n        return offset !== 0;\n    },\n    /**\n   * Moves cursor up without shift\n   * @param {Number} offset\n   */ moveCursorWithoutShift: function(offset) {\n        if (offset < 0) {\n            this.selectionStart += offset;\n            this.selectionEnd = this.selectionStart;\n        } else {\n            this.selectionEnd += offset;\n            this.selectionStart = this.selectionEnd;\n        }\n        return offset !== 0;\n    },\n    /**\n   * Moves cursor left\n   * @param {Event} e Event object\n   */ moveCursorLeft: function(e) {\n        if (this.selectionStart === 0 && this.selectionEnd === 0) {\n            return;\n        }\n        this._moveCursorLeftOrRight(\"Left\", e);\n    },\n    /**\n   * @private\n   * @return {Boolean} true if a change happened\n   */ _move: function(e, prop, direction) {\n        var newValue;\n        if (e.altKey) {\n            newValue = this[\"findWordBoundary\" + direction](this[prop]);\n        } else if (e.metaKey || e.keyCode === 35 || e.keyCode === 36) {\n            newValue = this[\"findLineBoundary\" + direction](this[prop]);\n        } else {\n            this[prop] += direction === \"Left\" ? -1 : 1;\n            return true;\n        }\n        if (typeof newValue !== undefined && this[prop] !== newValue) {\n            this[prop] = newValue;\n            return true;\n        }\n    },\n    /**\n   * @private\n   */ _moveLeft: function(e, prop) {\n        return this._move(e, prop, \"Left\");\n    },\n    /**\n   * @private\n   */ _moveRight: function(e, prop) {\n        return this._move(e, prop, \"Right\");\n    },\n    /**\n   * Moves cursor left without keeping selection\n   * @param {Event} e\n   */ moveCursorLeftWithoutShift: function(e) {\n        var change = true;\n        this._selectionDirection = \"left\";\n        // only move cursor when there is no selection,\n        // otherwise we discard it, and leave cursor on same place\n        if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {\n            change = this._moveLeft(e, \"selectionStart\");\n        }\n        this.selectionEnd = this.selectionStart;\n        return change;\n    },\n    /**\n   * Moves cursor left while keeping selection\n   * @param {Event} e\n   */ moveCursorLeftWithShift: function(e) {\n        if (this._selectionDirection === \"right\" && this.selectionStart !== this.selectionEnd) {\n            return this._moveLeft(e, \"selectionEnd\");\n        } else if (this.selectionStart !== 0) {\n            this._selectionDirection = \"left\";\n            return this._moveLeft(e, \"selectionStart\");\n        }\n    },\n    /**\n   * Moves cursor right\n   * @param {Event} e Event object\n   */ moveCursorRight: function(e) {\n        if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {\n            return;\n        }\n        this._moveCursorLeftOrRight(\"Right\", e);\n    },\n    /**\n   * Moves cursor right or Left, fires event\n   * @param {String} direction 'Left', 'Right'\n   * @param {Event} e Event object\n   */ _moveCursorLeftOrRight: function(direction, e) {\n        var actionName = \"moveCursor\" + direction + \"With\";\n        this._currentCursorOpacity = 1;\n        if (e.shiftKey) {\n            actionName += \"Shift\";\n        } else {\n            actionName += \"outShift\";\n        }\n        if (this[actionName](e)) {\n            this.abortCursorAnimation();\n            this.initDelayedCursor();\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Moves cursor right while keeping selection\n   * @param {Event} e\n   */ moveCursorRightWithShift: function(e) {\n        if (this._selectionDirection === \"left\" && this.selectionStart !== this.selectionEnd) {\n            return this._moveRight(e, \"selectionStart\");\n        } else if (this.selectionEnd !== this._text.length) {\n            this._selectionDirection = \"right\";\n            return this._moveRight(e, \"selectionEnd\");\n        }\n    },\n    /**\n   * Moves cursor right without keeping selection\n   * @param {Event} e Event object\n   */ moveCursorRightWithoutShift: function(e) {\n        var changed = true;\n        this._selectionDirection = \"right\";\n        if (this.selectionStart === this.selectionEnd) {\n            changed = this._moveRight(e, \"selectionStart\");\n            this.selectionEnd = this.selectionStart;\n        } else {\n            this.selectionStart = this.selectionEnd;\n        }\n        return changed;\n    },\n    /**\n   * Removes characters from start/end\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */ removeChars: function(start, end) {\n        if (typeof end === \"undefined\") {\n            end = start + 1;\n        }\n        this.removeStyleFromTo(start, end);\n        this._text.splice(start, end - start);\n        this.text = this._text.join(\"\");\n        this.set(\"dirty\", true);\n        if (this._shouldClearDimensionCache()) {\n            this.initDimensions();\n            this.setCoords();\n        }\n        this._removeExtraneousStyles();\n    },\n    /**\n   * insert characters at start position, before start position.\n   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1\n   * if style array is provided, it must be as the same length of text in graphemes\n   * if end is provided and is bigger than start, old text is replaced.\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {String} text text to insert\n   * @param {Array} style array of style objects\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */ insertChars: function(text, style, start, end) {\n        if (typeof end === \"undefined\") {\n            end = start;\n        }\n        if (end > start) {\n            this.removeStyleFromTo(start, end);\n        }\n        var graphemes = fabric.util.string.graphemeSplit(text);\n        this.insertNewStyleBlock(graphemes, start, style);\n        this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));\n        this.text = this._text.join(\"\");\n        this.set(\"dirty\", true);\n        if (this._shouldClearDimensionCache()) {\n            this.initDimensions();\n            this.setCoords();\n        }\n        this._removeExtraneousStyles();\n    }\n});\n/* _TO_SVG_START_ */ (function() {\n    var toFixed = fabric.util.toFixed, multipleSpacesRegex = /  +/g;\n    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {\n        /**\n     * Returns SVG representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ _toSVG: function() {\n            var offsets = this._getSVGLeftTopOffsets(), textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);\n            return this._wrapSVGTextAndBg(textAndBg);\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            return this._createBaseSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                noStyle: true,\n                withShadow: true\n            });\n        },\n        /**\n     * @private\n     */ _getSVGLeftTopOffsets: function() {\n            return {\n                textLeft: -this.width / 2,\n                textTop: -this.height / 2,\n                lineTop: this.getHeightOfLine(0)\n            };\n        },\n        /**\n     * @private\n     */ _wrapSVGTextAndBg: function(textAndBg) {\n            var noShadow = true, textDecoration = this.getSvgTextDecoration(this);\n            return [\n                textAndBg.textBgRects.join(\"\"),\n                '\t\t<text xml:space=\"preserve\" ',\n                this.fontFamily ? 'font-family=\"' + this.fontFamily.replace(/\"/g, \"'\") + '\" ' : \"\",\n                this.fontSize ? 'font-size=\"' + this.fontSize + '\" ' : \"\",\n                this.fontStyle ? 'font-style=\"' + this.fontStyle + '\" ' : \"\",\n                this.fontWeight ? 'font-weight=\"' + this.fontWeight + '\" ' : \"\",\n                textDecoration ? 'text-decoration=\"' + textDecoration + '\" ' : \"\",\n                'style=\"',\n                this.getSvgStyles(noShadow),\n                '\"',\n                this.addPaintOrder(),\n                \" >\",\n                textAndBg.textSpans.join(\"\"),\n                \"</text>\\n\"\n            ];\n        },\n        /**\n     * @private\n     * @param {Number} textTopOffset Text top offset\n     * @param {Number} textLeftOffset Text left offset\n     * @return {Object}\n     */ _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {\n            var textSpans = [], textBgRects = [], height = textTopOffset, lineOffset;\n            // bounding-box background\n            this._setSVGBg(textBgRects);\n            // text and text-background\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                lineOffset = this._getLineLeftOffset(i);\n                if (this.textBackgroundColor || this.styleHas(\"textBackgroundColor\", i)) {\n                    this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);\n                }\n                this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);\n                height += this.getHeightOfLine(i);\n            }\n            return {\n                textSpans: textSpans,\n                textBgRects: textBgRects\n            };\n        },\n        /**\n     * @private\n     */ _createTextCharSpan: function(_char, styleDecl, left, top) {\n            var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex), styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace), fillStyles = styleProps ? 'style=\"' + styleProps + '\"' : \"\", dy = styleDecl.deltaY, dySpan = \"\", NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            if (dy) {\n                dySpan = ' dy=\"' + toFixed(dy, NUM_FRACTION_DIGITS) + '\" ';\n            }\n            return [\n                '<tspan x=\"',\n                toFixed(left, NUM_FRACTION_DIGITS),\n                '\" y=\"',\n                toFixed(top, NUM_FRACTION_DIGITS),\n                '\" ',\n                dySpan,\n                fillStyles,\n                \">\",\n                fabric.util.string.escapeXml(_char),\n                \"</tspan>\"\n            ].join(\"\");\n        },\n        _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {\n            // set proper line offset\n            var lineHeight = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf(\"justify\") !== -1, actualStyle, nextStyle, charsToRender = \"\", charBox, style, boxWidth = 0, line = this._textLines[lineIndex], timeToRender;\n            textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;\n            for(var i = 0, len = line.length - 1; i <= len; i++){\n                timeToRender = i === len || this.charSpacing;\n                charsToRender += line[i];\n                charBox = this.__charBounds[lineIndex][i];\n                if (boxWidth === 0) {\n                    textLeftOffset += charBox.kernedWidth - charBox.width;\n                    boxWidth += charBox.width;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n                if (isJustify && !timeToRender) {\n                    if (this._reSpaceAndTab.test(line[i])) {\n                        timeToRender = true;\n                    }\n                }\n                if (!timeToRender) {\n                    // if we have charSpacing, we render char by char\n                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n                    timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);\n                }\n                if (timeToRender) {\n                    style = this._getStyleDeclaration(lineIndex, i) || {};\n                    textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));\n                    charsToRender = \"\";\n                    actualStyle = nextStyle;\n                    textLeftOffset += boxWidth;\n                    boxWidth = 0;\n                }\n            }\n        },\n        _pushTextBgRect: function(textBgRects, color, left, top, width, height) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            textBgRects.push(\"\t\t<rect \", this._getFillAttributes(color), ' x=\"', toFixed(left, NUM_FRACTION_DIGITS), '\" y=\"', toFixed(top, NUM_FRACTION_DIGITS), '\" width=\"', toFixed(width, NUM_FRACTION_DIGITS), '\" height=\"', toFixed(height, NUM_FRACTION_DIGITS), '\"></rect>\\n');\n        },\n        _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {\n            var line = this._textLines[i], heightOfLine = this.getHeightOfLine(i) / this.lineHeight, boxWidth = 0, boxStart = 0, charBox, currentColor, lastColor = this.getValueOfPropertyAt(i, 0, \"textBackgroundColor\");\n            for(var j = 0, jlen = line.length; j < jlen; j++){\n                charBox = this.__charBounds[i][j];\n                currentColor = this.getValueOfPropertyAt(i, j, \"textBackgroundColor\");\n                if (currentColor !== lastColor) {\n                    lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart, textTopOffset, boxWidth, heightOfLine);\n                    boxStart = charBox.left;\n                    boxWidth = charBox.width;\n                    lastColor = currentColor;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n            }\n            currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart, textTopOffset, boxWidth, heightOfLine);\n        },\n        /**\n     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values\n     * we work around it by \"moving\" alpha channel into opacity attribute and setting fill's alpha to 1\n     *\n     * @private\n     * @param {*} value\n     * @return {String}\n     */ _getFillAttributes: function(value) {\n            var fillColor = value && typeof value === \"string\" ? new fabric.Color(value) : \"\";\n            if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {\n                return 'fill=\"' + value + '\"';\n            }\n            return 'opacity=\"' + fillColor.getAlpha() + '\" fill=\"' + fillColor.setAlpha(1).toRgb() + '\"';\n        },\n        /**\n     * @private\n     */ _getSVGLineTopOffset: function(lineIndex) {\n            var lineTopOffset = 0, lastHeight = 0;\n            for(var j = 0; j < lineIndex; j++){\n                lineTopOffset += this.getHeightOfLine(j);\n            }\n            lastHeight = this.getHeightOfLine(j);\n            return {\n                lineTop: lineTopOffset,\n                offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)\n            };\n        },\n        /**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */ getSvgStyles: function(skipShadow) {\n            var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);\n            return svgStyle + \" white-space: pre;\";\n        }\n    });\n})();\n/* _TO_SVG_END_ */ (function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    /**\n   * Textbox class, based on IText, allows the user to resize the text rectangle\n   * and wraps lines automatically. Textboxes have their Y scaling locked, the\n   * user can only change width. Height is adjusted automatically based on the\n   * wrapping of lines.\n   * @class fabric.Textbox\n   * @extends fabric.IText\n   * @mixes fabric.Observable\n   * @return {fabric.Textbox} thisArg\n   * @see {@link fabric.Textbox#initialize} for constructor definition\n   */ fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"textbox\",\n        /**\n     * Minimum width of textbox, in pixels.\n     * @type Number\n     * @default\n     */ minWidth: 20,\n        /**\n     * Minimum calculated width of a textbox, in pixels.\n     * fixed to 2 so that an empty textbox cannot go to 0\n     * and is still selectable without text.\n     * @type Number\n     * @default\n     */ dynamicMinWidth: 2,\n        /**\n     * Cached array of text wrapping.\n     * @type Array\n     */ __cachedLines: null,\n        /**\n     * Override standard Object class values\n     */ lockScalingFlip: true,\n        /**\n     * Override standard Object class values\n     * Textbox needs this on false\n     */ noScaleCache: false,\n        /**\n     * Properties which when set cause object to change dimensions\n     * @type Object\n     * @private\n     */ _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat(\"width\"),\n        /**\n     * Use this regular expression to split strings in breakable lines\n     * @private\n     */ _wordJoiners: /[ \\t\\r]/,\n        /**\n     * Use this boolean property in order to split strings that have no white space concept.\n     * this is a cheap way to help with chinese/japanese\n     * @type Boolean\n     * @since 2.6.0\n     */ splitByGrapheme: false,\n        /**\n     * Unlike superclass's version of this function, Textbox does not update\n     * its width.\n     * @private\n     * @override\n     */ initDimensions: function() {\n            if (this.__skipDimension) {\n                return;\n            }\n            this.isEditing && this.initDelayedCursor();\n            this.clearContextTop();\n            this._clearCache();\n            // clear dynamicMinWidth as it will be different after we re-wrap line\n            this.dynamicMinWidth = 0;\n            // wrap lines\n            this._styleMap = this._generateStyleMap(this._splitText());\n            // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\n            if (this.dynamicMinWidth > this.width) {\n                this._set(\"width\", this.dynamicMinWidth);\n            }\n            if (this.textAlign.indexOf(\"justify\") !== -1) {\n                // once text is measured we need to make space fatter to make justified text.\n                this.enlargeSpaces();\n            }\n            // clear cache and re-calculate height\n            this.height = this.calcTextHeight();\n            this.saveState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * Generate an object that translates the style object so that it is\n     * broken up by visual lines (new lines and automatic wrapping).\n     * The original text styles object is broken up by actual lines (new lines only),\n     * which is only sufficient for Text / IText\n     * @private\n     */ _generateStyleMap: function(textInfo) {\n            var realLineCount = 0, realLineCharCount = 0, charCount = 0, map = {};\n            for(var i = 0; i < textInfo.graphemeLines.length; i++){\n                if (textInfo.graphemeText[charCount] === \"\\n\" && i > 0) {\n                    realLineCharCount = 0;\n                    charCount++;\n                    realLineCount++;\n                } else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {\n                    // this case deals with space's that are removed from end of lines when wrapping\n                    realLineCharCount++;\n                    charCount++;\n                }\n                map[i] = {\n                    line: realLineCount,\n                    offset: realLineCharCount\n                };\n                charCount += textInfo.graphemeLines[i].length;\n                realLineCharCount += textInfo.graphemeLines[i].length;\n            }\n            return map;\n        },\n        /**\n     * Returns true if object has a style property or has it on a specified line\n     * @param {Number} lineIndex\n     * @return {Boolean}\n     */ styleHas: function(property, lineIndex) {\n            if (this._styleMap && !this.isWrapping) {\n                var map = this._styleMap[lineIndex];\n                if (map) {\n                    lineIndex = map.line;\n                }\n            }\n            return fabric.Text.prototype.styleHas.call(this, property, lineIndex);\n        },\n        /**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */ isEmptyStyles: function(lineIndex) {\n            if (!this.styles) {\n                return true;\n            }\n            var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false, map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];\n            if (map) {\n                lineIndex = map.line;\n                offset = map.offset;\n            }\n            if (mapNextLine) {\n                nextLineIndex = mapNextLine.line;\n                shouldLimit = nextLineIndex === lineIndex;\n                nextOffset = mapNextLine.offset;\n            }\n            obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                line: this.styles[lineIndex]\n            };\n            for(var p1 in obj){\n                for(var p2 in obj[p1]){\n                    if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {\n                        // eslint-disable-next-line no-unused-vars\n                        for(var p3 in obj[p1][p2]){\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _getStyleDeclaration: function(lineIndex, charIndex) {\n            if (this._styleMap && !this.isWrapping) {\n                var map = this._styleMap[lineIndex];\n                if (!map) {\n                    return null;\n                }\n                lineIndex = map.line;\n                charIndex = map.offset + charIndex;\n            }\n            return this.callSuper(\"_getStyleDeclaration\", lineIndex, charIndex);\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */ _setStyleDeclaration: function(lineIndex, charIndex, style) {\n            var map = this._styleMap[lineIndex];\n            lineIndex = map.line;\n            charIndex = map.offset + charIndex;\n            this.styles[lineIndex][charIndex] = style;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _deleteStyleDeclaration: function(lineIndex, charIndex) {\n            var map = this._styleMap[lineIndex];\n            lineIndex = map.line;\n            charIndex = map.offset + charIndex;\n            delete this.styles[lineIndex][charIndex];\n        },\n        /**\n     * probably broken need a fix\n     * Returns the real style line that correspond to the wrapped lineIndex line\n     * Used just to verify if the line does exist or not.\n     * @param {Number} lineIndex\n     * @returns {Boolean} if the line exists or not\n     * @private\n     */ _getLineStyle: function(lineIndex) {\n            var map = this._styleMap[lineIndex];\n            return !!this.styles[map.line];\n        },\n        /**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @param {Object} style\n     * @private\n     */ _setLineStyle: function(lineIndex) {\n            var map = this._styleMap[lineIndex];\n            this.styles[map.line] = {};\n        },\n        /**\n     * Wraps text using the 'width' property of Textbox. First this function\n     * splits text on newlines, so we preserve newlines entered by the user.\n     * Then it wraps each line using the width of the Textbox by calling\n     * _wrapLine().\n     * @param {Array} lines The string array of text that is split into lines\n     * @param {Number} desiredWidth width you want to wrap to\n     * @returns {Array} Array of lines\n     */ _wrapText: function(lines, desiredWidth) {\n            var wrapped = [], i;\n            this.isWrapping = true;\n            for(i = 0; i < lines.length; i++){\n                wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));\n            }\n            this.isWrapping = false;\n            return wrapped;\n        },\n        /**\n     * Helper function to measure a string of text, given its lineIndex and charIndex offset\n     * it gets called when charBounds are not available yet.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {String} text\n     * @param {number} lineIndex\n     * @param {number} charOffset\n     * @returns {number}\n     * @private\n     */ _measureWord: function(word, lineIndex, charOffset) {\n            var width = 0, prevGrapheme, skipLeft = true;\n            charOffset = charOffset || 0;\n            for(var i = 0, len = word.length; i < len; i++){\n                var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);\n                width += box.kernedWidth;\n                prevGrapheme = word[i];\n            }\n            return width;\n        },\n        /**\n     * Wraps a line of text using the width of the Textbox and a context.\n     * @param {Array} line The grapheme array that represent the line\n     * @param {Number} lineIndex\n     * @param {Number} desiredWidth width you want to wrap the line to\n     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities\n     * @returns {Array} Array of line(s) into which the given text is wrapped\n     * to.\n     */ _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {\n            var lineWidth = 0, splitByGrapheme = this.splitByGrapheme, graphemeLines = [], line = [], // spaces in different languages?\n            words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners), word = \"\", offset = 0, infix = splitByGrapheme ? \"\" : \" \", wordWidth = 0, infixWidth = 0, largestWordWidth = 0, lineJustStarted = true, additionalSpace = this._getWidthOfCharSpacing(), reservedSpace = reservedSpace || 0;\n            // fix a difference between split and graphemeSplit\n            if (words.length === 0) {\n                words.push([]);\n            }\n            desiredWidth -= reservedSpace;\n            for(var i = 0; i < words.length; i++){\n                // if using splitByGrapheme words are already in graphemes.\n                word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);\n                wordWidth = this._measureWord(word, lineIndex, offset);\n                offset += word.length;\n                lineWidth += infixWidth + wordWidth - additionalSpace;\n                if (lineWidth > desiredWidth && !lineJustStarted) {\n                    graphemeLines.push(line);\n                    line = [];\n                    lineWidth = wordWidth;\n                    lineJustStarted = true;\n                } else {\n                    lineWidth += additionalSpace;\n                }\n                if (!lineJustStarted && !splitByGrapheme) {\n                    line.push(infix);\n                }\n                line = line.concat(word);\n                infixWidth = splitByGrapheme ? 0 : this._measureWord([\n                    infix\n                ], lineIndex, offset);\n                offset++;\n                lineJustStarted = false;\n                // keep track of largest word\n                if (wordWidth > largestWordWidth) {\n                    largestWordWidth = wordWidth;\n                }\n            }\n            i && graphemeLines.push(line);\n            if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {\n                this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;\n            }\n            return graphemeLines;\n        },\n        /**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @param {Number} lineIndex text to split\n     * @return {Boolean}\n     */ isEndOfWrapping: function(lineIndex) {\n            if (!this._styleMap[lineIndex + 1]) {\n                // is last line, return true;\n                return true;\n            }\n            if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {\n                // this is last line before a line break, return true;\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * @return Number\n     */ missingNewlineOffset: function(lineIndex) {\n            if (this.splitByGrapheme) {\n                return this.isEndOfWrapping(lineIndex) ? 1 : 0;\n            }\n            return 1;\n        },\n        /**\n    * Gets lines of text to render in the Textbox. This function calculates\n    * text wrapping on the fly every time it is called.\n    * @param {String} text text to split\n    * @returns {Array} Array of lines in the Textbox.\n    * @override\n    */ _splitTextIntoLines: function(text) {\n            var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text), graphemeLines = this._wrapText(newText.lines, this.width), lines = new Array(graphemeLines.length);\n            for(var i = 0; i < graphemeLines.length; i++){\n                lines[i] = graphemeLines[i].join(\"\");\n            }\n            newText.lines = lines;\n            newText.graphemeLines = graphemeLines;\n            return newText;\n        },\n        getMinWidth: function() {\n            return Math.max(this.minWidth, this.dynamicMinWidth);\n        },\n        _removeExtraneousStyles: function() {\n            var linesToKeep = {};\n            for(var prop in this._styleMap){\n                if (this._textLines[prop]) {\n                    linesToKeep[this._styleMap[prop].line] = 1;\n                }\n            }\n            for(var prop in this.styles){\n                if (!linesToKeep[prop]) {\n                    delete this.styles[prop];\n                }\n            }\n        },\n        /**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"minWidth\",\n                \"splitByGrapheme\"\n            ].concat(propertiesToInclude));\n        }\n    });\n    /**\n   * Returns fabric.Textbox instance from an object representation\n   * @static\n   * @memberOf fabric.Textbox\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created\n   */ fabric.Textbox.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Textbox\", object, callback, \"text\");\n    };\n})( true ? exports : 0);\n(function() {\n    var controlsUtils = fabric.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric.Object.prototype.controls;\n    objectControls.ml = new fabric.Control({\n        x: -0.5,\n        y: 0,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingXOrSkewingY,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mr = new fabric.Control({\n        x: 0.5,\n        y: 0,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingXOrSkewingY,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mb = new fabric.Control({\n        x: 0,\n        y: 0.5,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingYOrSkewingX,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mt = new fabric.Control({\n        x: 0,\n        y: -0.5,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingYOrSkewingX,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.tl = new fabric.Control({\n        x: -0.5,\n        y: -0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.tr = new fabric.Control({\n        x: 0.5,\n        y: -0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.bl = new fabric.Control({\n        x: -0.5,\n        y: 0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.br = new fabric.Control({\n        x: 0.5,\n        y: 0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.mtr = new fabric.Control({\n        x: 0,\n        y: -0.5,\n        actionHandler: controlsUtils.rotationWithSnapping,\n        cursorStyleHandler: controlsUtils.rotationStyleHandler,\n        offsetY: -40,\n        withConnection: true,\n        actionName: \"rotate\"\n    });\n    if (fabric.Textbox) {\n        // this is breaking the prototype inheritance, no time / ideas to fix it.\n        // is important to document that if you want to have all objects to have a\n        // specific custom control, you have to add it to Object prototype and to Textbox\n        // prototype. The controls are shared as references. So changes to control `tr`\n        // can still apply to all objects if needed.\n        var textBoxControls = fabric.Textbox.prototype.controls = {};\n        textBoxControls.mtr = objectControls.mtr;\n        textBoxControls.tr = objectControls.tr;\n        textBoxControls.br = objectControls.br;\n        textBoxControls.tl = objectControls.tl;\n        textBoxControls.bl = objectControls.bl;\n        textBoxControls.mt = objectControls.mt;\n        textBoxControls.mb = objectControls.mb;\n        textBoxControls.mr = new fabric.Control({\n            x: 0.5,\n            y: 0,\n            actionHandler: controlsUtils.changeWidth,\n            cursorStyleHandler: scaleSkewStyleHandler,\n            actionName: \"resizing\"\n        });\n        textBoxControls.ml = new fabric.Control({\n            x: -0.5,\n            y: 0,\n            actionHandler: controlsUtils.changeWidth,\n            cursorStyleHandler: scaleSkewStyleHandler,\n            actionName: \"resizing\"\n        });\n    }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFicmljLXB1cmUtYnJvd3Nlci9kaXN0L2ZhYnJpYy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxR0FBcUcsR0FDckcsMkVBQTJFLEdBRTNFLElBQUlBLFNBQVNBLFVBQVU7SUFBRUMsU0FBUztBQUFRO0FBQzFDLElBQUksSUFBbUIsRUFBYTtJQUNsQ0MsY0FBYyxHQUFHRjtBQUNuQixPQUVLLEVBRUo7QUFDRCxhQUFhLEdBQ2IsSUFBSSxPQUFPSyxhQUFhLGVBQWUsZ0JBQWtCLGFBQWEsRUFRckUsTUFDSTtJQUNILDBFQUEwRTtJQUMxRSxJQUFJTSxRQUFRQyxtQkFBT0EsQ0FBQztJQUNwQixJQUFJQyxnQkFBZ0IsSUFBSUYsTUFBTUcsS0FBSyxDQUNqQ0MsbUJBQW1CLCtGQUNuQjtRQUNFQyxVQUFVO1lBQ1JDLHdCQUF3QjtnQkFBQzthQUFNO1FBQ2pDO1FBQ0FDLFdBQVc7SUFDYixHQUFHUixNQUFNO0lBQ1hWLE9BQU9LLFFBQVEsR0FBR1EsY0FBY1IsUUFBUTtJQUN4Q0wsT0FBT21CLG1CQUFtQixHQUFHUCxvSkFBZ0U7SUFDN0ZaLE9BQU9xQixVQUFVLEdBQUdULDBHQUF1QztJQUMzRFosT0FBT1UsTUFBTSxHQUFHRztJQUNoQlUsWUFBWXZCLE9BQU9VLE1BQU0sQ0FBQ2EsU0FBUztBQUNyQztBQUVBOzs7Q0FHQyxHQUNEdkIsT0FBT3dCLGdCQUFnQixHQUFHLGtCQUFrQnhCLE9BQU9VLE1BQU0sSUFBSSxrQkFBa0JWLE9BQU9LLFFBQVEsSUFDM0ZMLE9BQU9VLE1BQU0sSUFBSVYsT0FBT1UsTUFBTSxDQUFDZSxTQUFTLElBQUl6QixPQUFPVSxNQUFNLENBQUNlLFNBQVMsQ0FBQ0MsY0FBYyxHQUFHO0FBRXhGOzs7Q0FHQyxHQUNEMUIsT0FBTzJCLFlBQVksR0FBRyxPQUFPQyxXQUFXLGVBQ2xCLGdCQUFrQjtBQUV4QyxvQkFBb0IsR0FDcEI7OztDQUdDLEdBQ0Q1QixPQUFPNkIsaUJBQWlCLEdBQUc7SUFDekI7SUFDQTtJ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LElBQUloMUcsT0FBTzAzQyxPQUFPLENBQUM7WUFDdENsdEMsR0FBRyxDQUFDO1lBQ0pDLEdBQUc7WUFDSDhtQyxlQUFlMkUsY0FBY1gsV0FBVztZQUN4QzZDLG9CQUFvQnk4RDtZQUNwQmw5RCxZQUFZO1FBQ2Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGljdGlvbmFyeS1nYW1lLy4vbm9kZV9tb2R1bGVzL2ZhYnJpYy1wdXJlLWJyb3dzZXIvZGlzdC9mYWJyaWMuanM/ODU0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBidWlsZDogYG5vZGUgYnVpbGQuanMgbW9kdWxlcz1BTEwgZXhjbHVkZT1nZXN0dXJlcyxhY2Nlc3NvcnMsZXJhc2luZyByZXF1aXJlanMgbWluaWZpZXI9dWdsaWZ5anNgICovXG4vKiEgRmFicmljLmpzIENvcHlyaWdodCAyMDA4LTIwMTUsIFByaW50aW8gKEp1cml5IFpheXRzZXYsIE1heGltIENoZXJueWFrKSAqL1xuXG52YXIgZmFicmljID0gZmFicmljIHx8IHsgdmVyc2lvbjogJzUuMS4wJyB9O1xuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLmZhYnJpYyA9IGZhYnJpYztcbn1cbi8qIF9BTURfU1RBUlRfICovXG5lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhYnJpYzsgfSk7XG59XG4vKiBfQU1EX0VORF8gKi9cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mICh0eXBlb2YgSFRNTERvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IEhUTUxEb2N1bWVudCA6IERvY3VtZW50KSkge1xuICAgIGZhYnJpYy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICB9XG4gIGVsc2Uge1xuICAgIGZhYnJpYy5kb2N1bWVudCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnJyk7XG4gIH1cbiAgZmFicmljLndpbmRvdyA9IHdpbmRvdztcbn1cbmVsc2Uge1xuICAvLyBhc3N1bWUgd2UncmUgcnVubmluZyB1bmRlciBub2RlLmpzIHdoZW4gZG9jdW1lbnQvd2luZG93IGFyZSBub3QgcHJlc2VudFxuICB2YXIganNkb20gPSByZXF1aXJlKCdqc2RvbScpO1xuICB2YXIgdmlydHVhbFdpbmRvdyA9IG5ldyBqc2RvbS5KU0RPTShcbiAgICBkZWNvZGVVUklDb21wb25lbnQoJyUzQyFET0NUWVBFJTIwaHRtbCUzRSUzQ2h0bWwlM0UlM0NoZWFkJTNFJTNDJTJGaGVhZCUzRSUzQ2JvZHklM0UlM0MlMkZib2R5JTNFJTNDJTJGaHRtbCUzRScpLFxuICAgIHtcbiAgICAgIGZlYXR1cmVzOiB7XG4gICAgICAgIEZldGNoRXh0ZXJuYWxSZXNvdXJjZXM6IFsnaW1nJ11cbiAgICAgIH0sXG4gICAgICByZXNvdXJjZXM6ICd1c2FibGUnXG4gICAgfSkud2luZG93O1xuICBmYWJyaWMuZG9jdW1lbnQgPSB2aXJ0dWFsV2luZG93LmRvY3VtZW50O1xuICBmYWJyaWMuanNkb21JbXBsRm9yV3JhcHBlciA9IHJlcXVpcmUoJ2pzZG9tL2xpYi9qc2RvbS9saXZpbmcvZ2VuZXJhdGVkL3V0aWxzJykuaW1wbEZvcldyYXBwZXI7XG4gIGZhYnJpYy5ub2RlQ2FudmFzID0gcmVxdWlyZSgnanNkb20vbGliL2pzZG9tL3V0aWxzJykuQ2FudmFzO1xuICBmYWJyaWMud2luZG93ID0gdmlydHVhbFdpbmRvdztcbiAgRE9NUGFyc2VyID0gZmFicmljLndpbmRvdy5ET01QYXJzZXI7XG59XG5cbi8qKlxuICogVHJ1ZSB3aGVuIGluIGVudmlyb25tZW50IHRoYXQgc3VwcG9ydHMgdG91Y2ggZXZlbnRzXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbmZhYnJpYy5pc1RvdWNoU3VwcG9ydGVkID0gJ29udG91Y2hzdGFydCcgaW4gZmFicmljLndpbmRvdyB8fCAnb250b3VjaHN0YXJ0JyBpbiBmYWJyaWMuZG9jdW1lbnQgfHxcbiAgKGZhYnJpYy53aW5kb3cgJiYgZmFicmljLndpbmRvdy5uYXZpZ2F0b3IgJiYgZmFicmljLndpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwKTtcblxuLyoqXG4gKiBUcnVlIHdoZW4gaW4gZW52aXJvbm1lbnQgdGhhdCdzIHByb2JhYmx5IE5vZGUuanNcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xuZmFicmljLmlzTGlrZWx5Tm9kZSA9IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cbi8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbi8qKlxuICogQXR0cmlidXRlcyBwYXJzZWQgZnJvbSBhbGwgU1ZHIGVsZW1lbnRzXG4gKiBAdHlwZSBhcnJheVxuICovXG5mYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMgPSBbXG4gICdkaXNwbGF5JyxcbiAgJ3RyYW5zZm9ybScsXG4gICdmaWxsJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLFxuICAnb3BhY2l0eScsXG4gICdzdHJva2UnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJyxcbiAgJ2lkJywgJ3BhaW50LW9yZGVyJywgJ3ZlY3Rvci1lZmZlY3QnLFxuICAnaW5zdGFudGlhdGVkX2J5X3VzZScsICdjbGlwLXBhdGgnLFxuXTtcbi8qIF9GUk9NX1NWR19FTkRfICovXG5cbi8qKlxuICogUGl4ZWwgcGVyIEluY2ggYXMgYSBkZWZhdWx0IHZhbHVlIHNldCB0byA5Ni4gQ2FuIGJlIGNoYW5nZWQgZm9yIG1vcmUgcmVhbGlzdGljIGNvbnZlcnNpb24uXG4gKi9cbmZhYnJpYy5EUEkgPSA5NjtcbmZhYnJpYy5yZU51bSA9ICcoPzpbLStdPyg/OlxcXFxkK3xcXFxcZCpcXFxcLlxcXFxkKykoPzpbZUVdWy0rXT9cXFxcZCspPyknO1xuZmFicmljLmNvbW1hV3NwID0gJyg/OlxcXFxzKyw/XFxcXHMqfCxcXFxccyopJztcbmZhYnJpYy5yZVBhdGhDb21tYW5kID0gLyhbLStdPygoXFxkK1xcLlxcZCspfCgoXFxkKyl8KFxcLlxcZCspKSkoPzpbZUVdWy0rXT9cXGQrKT8pL2lnO1xuZmFicmljLnJlTm9uV29yZCA9IC9bIFxcblxcLiw7IVxcP1xcLV0vO1xuZmFicmljLmZvbnRQYXRocyA9IHsgfTtcbmZhYnJpYy5pTWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuZmFicmljLnN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuLyoqXG4gKiBQaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMuIDFNcHggLCA0TXB4IHNob3VsZCBiZSBmaW5lLlxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMucGVyZkxpbWl0U2l6ZVRvdGFsID0gMjA5NzE1MjtcblxuLyoqXG4gKiBQaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMgd2lkdGggb3IgaGVpZ2h0LiBJRSBmaXhlcyB0aGUgbWF4aW11bSBhdCA1MDAwXG4gKiBAc2luY2UgMS43LjE0XG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5tYXhDYWNoZVNpZGVMaW1pdCA9IDQwOTY7XG5cbi8qKlxuICogTG93ZXN0IHBpeGVsIGxpbWl0IGZvciBjYWNoZSBjYW52YXNlcywgc2V0IGF0IDI1NlBYXG4gKiBAc2luY2UgMS43LjE0XG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdCA9IDI1NjtcblxuLyoqXG4gKiBDYWNoZSBPYmplY3QgZm9yIHdpZHRocyBvZiBjaGFycyBpbiB0ZXh0IHJlbmRlcmluZy5cbiAqL1xuZmFicmljLmNoYXJXaWR0aHNDYWNoZSA9IHsgfTtcblxuLyoqXG4gKiBpZiB3ZWJnbCBpcyBlbmFibGVkIGFuZCBhdmFpbGFibGUsIHRleHR1cmVTaXplIHdpbGwgZGV0ZXJtaW5lIHRoZSBzaXplXG4gKiBvZiB0aGUgY2FudmFzIGJhY2tlbmRcbiAqIEBzaW5jZSAyLjAuMFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMudGV4dHVyZVNpemUgPSAyMDQ4O1xuXG4vKipcbiAqIFdoZW4gJ3RydWUnLCBzdHlsZSBpbmZvcm1hdGlvbiBpcyBub3QgcmV0YWluZWQgd2hlbiBjb3B5L3Bhc3RpbmcgdGV4dCwgbWFraW5nXG4gKiBwYXN0ZWQgdGV4dCB1c2UgZGVzdGluYXRpb24gc3R5bGUuXG4gKiBEZWZhdWx0cyB0byAnZmFsc2UnLlxuICogQHR5cGUgQm9vbGVhblxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLmRpc2FibGVTdHlsZUNvcHlQYXN0ZSA9IGZhbHNlO1xuXG4vKipcbiAqIEVuYWJsZSB3ZWJnbCBmb3IgZmlsdGVyaW5nIHBpY3R1cmUgaXMgYXZhaWxhYmxlXG4gKiBBIGZpbHRlcmluZyBiYWNrZW5kIHdpbGwgYmUgaW5pdGlhbGl6ZWQsIHRoaXMgd2lsbCBib3RoIHRha2UgbWVtb3J5IGFuZFxuICogdGltZSBzaW5jZSBhIGRlZmF1bHQgMjA0OHgyMDQ4IGNhbnZhcyB3aWxsIGJlIGNyZWF0ZWQgZm9yIHRoZSBnbCBjb250ZXh0XG4gKiBAc2luY2UgMi4wLjBcbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5lbmFibGVHTEZpbHRlcmluZyA9IHRydWU7XG5cbi8qKlxuICogRGV2aWNlIFBpeGVsIFJhdGlvXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L3NhZmFyaS9kb2N1bWVudGF0aW9uL0F1ZGlvVmlkZW8vQ29uY2VwdHVhbC9IVE1MLWNhbnZhcy1ndWlkZS9TZXR0aW5nVXB0aGVDYW52YXMvU2V0dGluZ1VwdGhlQ2FudmFzLmh0bWxcbiAqL1xuZmFicmljLmRldmljZVBpeGVsUmF0aW8gPSBmYWJyaWMud2luZG93LmRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy53ZWJraXREZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cubW96RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAxO1xuLyoqXG4gKiBCcm93c2VyLXNwZWNpZmljIGNvbnN0YW50IHRvIGFkanVzdCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuc2hhZG93Qmx1ciB2YWx1ZSxcbiAqIHdoaWNoIGlzIHVuaXRsZXNzIGFuZCBub3QgcmVuZGVyZWQgZXF1YWxseSBhY3Jvc3MgYnJvd3NlcnMuXG4gKlxuICogVmFsdWVzIHRoYXQgd29yayBxdWl0ZSB3ZWxsIChhcyBvZiBPY3RvYmVyIDIwMTcpIGFyZTpcbiAqIC0gQ2hyb21lOiAxLjVcbiAqIC0gRWRnZTogMS43NVxuICogLSBGaXJlZm94OiAwLjlcbiAqIC0gU2FmYXJpOiAwLjk1XG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0IDFcbiAqL1xuZmFicmljLmJyb3dzZXJTaGFkb3dCbHVyQ29uc3RhbnQgPSAxO1xuXG4vKipcbiAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgYXJjIHRvIGJlemllciBjb252ZXJzaW9uIGZvciBmYXN0ZXIgcmV0cmlldmluZyBpZiB0aGUgc2FtZSBhcmMgbmVlZHMgdG8gYmUgY29udmVydGVkIGFnYWluLlxuICogSXQgd2FzIGFuIGludGVybmFsIHZhcmlhYmxlLCBpcyBhY2Nlc3NpYmxlIHNpbmNlIHZlcnNpb24gMi4zLjRcbiAqL1xuZmFicmljLmFyY1RvU2VnbWVudHNDYWNoZSA9IHsgfTtcblxuLyoqXG4gKiBUaGlzIG9iamVjdCBrZWVwcyB0aGUgcmVzdWx0cyBvZiB0aGUgYm91bmRzT2ZDdXJ2ZSBjYWxjdWxhdGlvbiBtYXBwZWQgYnkgdGhlIGpvaW5lZCBhcmd1bWVudHMgbmVjZXNzYXJ5IHRvIGNhbGN1bGF0ZSBpdC5cbiAqIEl0IGRvZXMgc3BlZWQgdXAgY2FsY3VsYXRpb24sIGlmIHlvdSBwYXJzZSBhbmQgYWRkIGFsd2F5cyB0aGUgc2FtZSBwYXRocywgYnV0IGluIGNhc2Ugb2YgaGVhdnkgdXNhZ2Ugb2YgZnJlZWRyYXdpbmdcbiAqIHlvdSBkbyBub3QgZ2V0IGFueSBzcGVlZCBiZW5lZml0IGFuZCB5b3UgZ2V0IGEgYmlnIG9iamVjdCBpbiBtZW1vcnkuXG4gKiBUaGUgb2JqZWN0IHdhcyBhIHByaXZhdGUgdmFyaWFibGUgYmVmb3JlLCB3aGlsZSBub3cgaXMgYXBwZW5kZWQgdG8gdGhlIGxpYiBzbyB0aGF0IHlvdSBoYXZlIGFjY2VzcyB0byBpdCBhbmQgeW91XG4gKiBjYW4gZXZlbnR1YWxseSBjbGVhciBpdC5cbiAqIEl0IHdhcyBhbiBpbnRlcm5hbCB2YXJpYWJsZSwgaXMgYWNjZXNzaWJsZSBzaW5jZSB2ZXJzaW9uIDIuMy40XG4gKi9cbmZhYnJpYy5ib3VuZHNPZkN1cnZlQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogSWYgZGlzYWJsZWQgYm91bmRzT2ZDdXJ2ZUNhY2hlIGlzIG5vdCB1c2VkLiBGb3IgYXBwcyB0aGF0IG1ha2UgaGVhdnkgdXNhZ2Ugb2YgcGVuY2lsIGRyYXdpbmcgcHJvYmFibHkgZGlzYWJsaW5nIGl0IGlzIGJldHRlclxuICogQGRlZmF1bHQgdHJ1ZVxuICovXG5mYWJyaWMuY2FjaGVzQm91bmRzT2ZDdXJ2ZSA9IHRydWU7XG5cbi8qKlxuICogU2tpcCBwZXJmb3JtYW5jZSB0ZXN0aW5nIG9mIHNldHVwR0xDb250ZXh0IGFuZCBmb3JjZSB0aGUgdXNlIG9mIHB1dEltYWdlRGF0YSB0aGF0IHNlZW1zIHRvIGJlIHRoZSBvbmUgdGhhdCB3b3JrcyBiZXN0IG9uXG4gKiBDaHJvbWUgKyBvbGQgaGFyZHdhcmUuIGlmIHlvdXIgdXNlcnMgYXJlIGV4cGVyaWVuY2luZyBlbXB0eSBpbWFnZXMgYWZ0ZXIgZmlsdGVyaW5nIHlvdSBtYXkgdHJ5IHRvIGZvcmNlIHRoaXMgdG8gdHJ1ZVxuICogdGhpcyBoYXMgdG8gYmUgc2V0IGJlZm9yZSBpbnN0YW50aWF0aW5nIHRoZSBmaWx0ZXJpbmcgYmFja2VuZCAoIGJlZm9yZSBmaWx0ZXJpbmcgdGhlIGZpcnN0IGltYWdlIClcbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbmZhYnJpYy5mb3JjZUdMUHV0SW1hZ2VEYXRhID0gZmFsc2U7XG5cbmZhYnJpYy5pbml0RmlsdGVyQmFja2VuZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoZmFicmljLmVuYWJsZUdMRmlsdGVyaW5nICYmIGZhYnJpYy5pc1dlYmdsU3VwcG9ydGVkICYmIGZhYnJpYy5pc1dlYmdsU3VwcG9ydGVkKGZhYnJpYy50ZXh0dXJlU2l6ZSkpIHtcbiAgICBjb25zb2xlLmxvZygnbWF4IHRleHR1cmUgc2l6ZTogJyArIGZhYnJpYy5tYXhUZXh0dXJlU2l6ZSk7XG4gICAgcmV0dXJuIChuZXcgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZCh7IHRpbGVTaXplOiBmYWJyaWMudGV4dHVyZVNpemUgfSkpO1xuICB9XG4gIGVsc2UgaWYgKGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQpIHtcbiAgICByZXR1cm4gKG5ldyBmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKCkpO1xuICB9XG59O1xuXG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIGVuc3VyZSBnbG9iYWxpdHkgZXZlbiBpZiBlbnRpcmUgbGlicmFyeSB3ZXJlIGZ1bmN0aW9uIHdyYXBwZWQgKGFzIGluIE1ldGVvci5qcyBwYWNrYWdpbmcgc3lzdGVtKVxuICB3aW5kb3cuZmFicmljID0gZmFicmljO1xufVxuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBldmVudExpc3RlbmVyID0gdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGV2ZW50TGlzdGVuZXJbZXZlbnRMaXN0ZW5lci5pbmRleE9mKGhhbmRsZXIpXSA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy51dGlsLmFycmF5LmZpbGwoZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlcyBzcGVjaWZpZWQgZXZlbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyBvblxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50TmFtZSBFdmVudCBuYW1lIChlZy4gJ2FmdGVyOnJlbmRlcicpIG9yIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyAoZWcuIHsnYWZ0ZXI6cmVuZGVyJzogaGFuZGxlciwgJ3NlbGVjdGlvbjpjbGVhcmVkJzogaGFuZGxlcn0pXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzID0geyB9O1xuICAgIH1cbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vbihwcm9wLCBldmVudE5hbWVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gX29uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgdmFyIF9oYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBfaGFuZGxlcik7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub24oZXZlbnROYW1lLCBfaGFuZGxlcik7XG4gIH1cblxuICBmdW5jdGlvbiBvbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIC8vIG9uZSBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgd2FzIHBhc3NlZFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV2ZW50TmFtZSkge1xuICAgICAgICBfb25jZS5jYWxsKHRoaXMsIHByb3AsIGV2ZW50TmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX29uY2UuY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBldmVudCBvYnNlcnZpbmcgZm9yIGEgcGFydGljdWxhciBldmVudCBoYW5kbGVyLiBDYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqIHdpdGhvdXQgYXJndW1lbnRzIHJlbW92ZXMgYWxsIGhhbmRsZXJzIGZvciBhbGwgZXZlbnRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgb2ZmXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnROYW1lIEV2ZW50IG5hbWUgKGVnLiAnYWZ0ZXI6cmVuZGVyJykgb3Igb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIChlZy4geydhZnRlcjpyZW5kZXInOiBoYW5kbGVyLCAnc2VsZWN0aW9uOmNsZWFyZWQnOiBoYW5kbGVyfSlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBGdW5jdGlvbiB0byBiZSBkZWxldGVkIGZyb20gRXZlbnRMaXN0ZW5lcnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvZmYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbGwga2V5L3ZhbHVlIHBhaXJzIChldmVudCBuYW1lIC0+IGV2ZW50IGhhbmRsZXIpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAoZXZlbnROYW1lIGluIHRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9uZSBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgd2FzIHBhc3NlZFxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgcHJvcCwgZXZlbnROYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGV2ZW50IHdpdGggYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZSB0byBmaXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBmaXJlKGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzRm9yRXZlbnQgPSB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICBpZiAoIWxpc3RlbmVyc0ZvckV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc0ZvckV2ZW50W2ldICYmIGxpc3RlbmVyc0ZvckV2ZW50W2ldLmNhbGwodGhpcywgb3B0aW9ucyB8fCB7IH0pO1xuICAgIH1cbiAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSA9IGxpc3RlbmVyc0ZvckV2ZW50LmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2V2ZW50c31cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9ldmVudHN8RXZlbnRzIGRlbW99XG4gICAqL1xuICBmYWJyaWMuT2JzZXJ2YWJsZSA9IHtcbiAgICBmaXJlOiBmaXJlLFxuICAgIG9uOiBvbixcbiAgICBvbmNlOiBvbmNlLFxuICAgIG9mZjogb2ZmLFxuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZmFicmljLkNvbGxlY3Rpb25cbiAqL1xuZmFicmljLkNvbGxlY3Rpb24gPSB7XG5cbiAgX29iamVjdHM6IFtdLFxuXG4gIC8qKlxuICAgKiBBZGRzIG9iamVjdHMgdG8gY29sbGVjdGlvbiwgQ2FudmFzIG9yIEdyb3VwLCB0aGVuIHJlbmRlcnMgY2FudmFzXG4gICAqIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKS5cbiAgICogaW4gY2FzZSBvZiBHcm91cCBubyBjaGFuZ2VzIHRvIGJvdW5kaW5nIGJveCBhcmUgbWFkZS5cbiAgICogT2JqZWN0cyBzaG91bGQgYmUgaW5zdGFuY2VzIG9mIChvciBpbmhlcml0IGZyb20pIGZhYnJpYy5PYmplY3RcbiAgICogVXNlIG9mIHRoaXMgZnVuY3Rpb24gaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGZvciBncm91cHMuXG4gICAqIHlvdSBjYW4gYWRkIGEgYnVuY2ggb2Ygb2JqZWN0cyB3aXRoIHRoZSBhZGQgbWV0aG9kIGJ1dCB0aGVuIHlvdSBORUVEXG4gICAqIHRvIHJ1biBhIGFkZFdpdGhVcGRhdGUgY2FsbCBmb3IgdGhlIEdyb3VwIGNsYXNzIG9yIHBvc2l0aW9uL2Jib3ggd2lsbCBiZSB3cm9uZy5cbiAgICogQHBhcmFtIHsuLi5mYWJyaWMuT2JqZWN0fSBvYmplY3QgWmVybyBvciBtb3JlIGZhYnJpYyBpbnN0YW5jZXNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9vYmplY3RzLnB1c2guYXBwbHkodGhpcy5fb2JqZWN0cywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fb25PYmplY3RBZGRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9vbk9iamVjdEFkZGVkKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluc2VydHMgYW4gb2JqZWN0IGludG8gY29sbGVjdGlvbiBhdCBzcGVjaWZpZWQgaW5kZXgsIHRoZW4gcmVuZGVycyBjYW52YXMgKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApXG4gICAqIEFuIG9iamVjdCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgKG9yIGluaGVyaXQgZnJvbSkgZmFicmljLk9iamVjdFxuICAgKiBVc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyBoaWdobHkgZGlzY291cmFnZWQgZm9yIGdyb3Vwcy5cbiAgICogeW91IGNhbiBhZGQgYSBidW5jaCBvZiBvYmplY3RzIHdpdGggdGhlIGluc2VydEF0IG1ldGhvZCBidXQgdGhlbiB5b3UgTkVFRFxuICAgKiB0byBydW4gYSBhZGRXaXRoVXBkYXRlIGNhbGwgZm9yIHRoZSBHcm91cCBjbGFzcyBvciBwb3NpdGlvbi9iYm94IHdpbGwgYmUgd3JvbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGluc2VydFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gaW5zZXJ0IG9iamVjdCBhdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vblNwbGljaW5nIFdoZW4gYHRydWVgLCBubyBzcGxpY2luZyAoc2hpZnRpbmcpIG9mIG9iamVjdHMgb2NjdXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgaW5zZXJ0QXQ6IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCBub25TcGxpY2luZykge1xuICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cztcbiAgICBpZiAobm9uU3BsaWNpbmcpIHtcbiAgICAgIG9iamVjdHNbaW5kZXhdID0gb2JqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAwLCBvYmplY3QpO1xuICAgIH1cbiAgICB0aGlzLl9vbk9iamVjdEFkZGVkICYmIHRoaXMuX29uT2JqZWN0QWRkZWQob2JqZWN0KTtcbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG9iamVjdHMgZnJvbSBhIGNvbGxlY3Rpb24sIHRoZW4gcmVuZGVycyBjYW52YXMgKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApXG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG4gICAgICAgIGluZGV4LCBzb21ldGhpbmdSZW1vdmVkID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihhcmd1bWVudHNbaV0pO1xuXG4gICAgICAvLyBvbmx5IGNhbGwgb25PYmplY3RSZW1vdmVkIGlmIGFuIG9iamVjdCB3YXMgYWN0dWFsbHkgcmVtb3ZlZFxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBzb21ldGhpbmdSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgb2JqZWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLl9vbk9iamVjdFJlbW92ZWQgJiYgdGhpcy5fb25PYmplY3RSZW1vdmVkKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiBzb21ldGhpbmdSZW1vdmVkICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBvYmplY3QgaW4gdGhpcyBncm91cFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBpbnZva2VkIHdpdGggY3VycmVudCBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnQsXG4gICAqICAgICAgICAgICAgICAgICAgIGluZGV4IC0gYXMgc2Vjb25kIGFuZCBhbiBhcnJheSBvZiBhbGwgb2JqZWN0cyAtIGFzIHRoaXJkLlxuICAgKiAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBpcyBpbnZva2VkIGluIGEgY29udGV4dCBvZiBHbG9iYWwgT2JqZWN0IChlLmcuIGB3aW5kb3dgKVxuICAgKiAgICAgICAgICAgICAgICAgICB3aGVuIG5vIGBjb250ZXh0YCBhcmd1bWVudCBpcyBnaXZlblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBDb250ZXh0IChha2EgdGhpc09iamVjdClcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmb3JFYWNoT2JqZWN0OiBmdW5jdGlvbihjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRPYmplY3RzKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgb2JqZWN0c1tpXSwgaSwgb2JqZWN0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNoaWxkcmVuIG9iamVjdHMgb2YgdGhpcyBpbnN0YW5jZVxuICAgKiBUeXBlIHBhcmFtZXRlciBpbnRyb2R1Y2VkIGluIDEuMy4xMFxuICAgKiBzaW5jZSAyLjMuNSB0aGlzIG1ldGhvZCByZXR1cm4gYWx3YXlzIGEgQ09QWSBvZiB0aGUgYXJyYXk7XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gV2hlbiBzcGVjaWZpZWQsIG9ubHkgb2JqZWN0cyBvZiB0aGlzIHR5cGUgYXJlIHJldHVybmVkXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZ2V0T2JqZWN0czogZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmNvbmNhdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIG8udHlwZSA9PT0gdHlwZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBvYmplY3QgYXQgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqL1xuICBpdGVtOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0c1tpbmRleF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIG5vIG9iamVjdHNcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBjb2xsZWN0aW9uIGlzIGVtcHR5XG4gICAqL1xuICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMubGVuZ3RoID09PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2l6ZSBvZiBhIGNvbGxlY3Rpb24gKGkuZTogbGVuZ3RoIG9mIGFuIGFycmF5IGNvbnRhaW5pbmcgaXRzIG9iamVjdHMpXG4gICAqIEByZXR1cm4ge051bWJlcn0gQ29sbGVjdGlvbiBzaXplXG4gICAqL1xuICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjaGVjayBhZ2FpbnN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlZXA9ZmFsc2VdIGB0cnVlYCB0byBjaGVjayBhbGwgZGVzY2VuZGFudHMsIGBmYWxzZWAgdG8gY2hlY2sgb25seSBgX29iamVjdHNgXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIGFuIG9iamVjdFxuICAgKi9cbiAgY29udGFpbnM6IGZ1bmN0aW9uIChvYmplY3QsIGRlZXApIHtcbiAgICBpZiAodGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPiAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZXApIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3RzLnNvbWUoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iai5jb250YWlucyA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29udGFpbnMob2JqZWN0LCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sbGVjdGlvbiBjb21wbGV4aXR5XG4gICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eVxuICAgKi9cbiAgY29tcGxleGl0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgY3VycmVudCkge1xuICAgICAgbWVtbyArPSBjdXJyZW50LmNvbXBsZXhpdHkgPyBjdXJyZW50LmNvbXBsZXhpdHkoKSA6IDA7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZmFicmljLkNvbW1vbk1ldGhvZHNcbiAqL1xuZmFicmljLkNvbW1vbk1ldGhvZHMgPSB7XG5cbiAgLyoqXG4gICAqIFNldHMgb2JqZWN0J3MgcHJvcGVydGllcyBmcm9tIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgX3NldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2V0KHByb3AsIG9wdGlvbnNbcHJvcF0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtmaWxsZXJdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIHByb3BlcnR5IHRvIHNldCB0aGUgR3JhZGllbnQgdG9cbiAgICovXG4gIF9pbml0R3JhZGllbnQ6IGZ1bmN0aW9uKGZpbGxlciwgcHJvcGVydHkpIHtcbiAgICBpZiAoZmlsbGVyICYmIGZpbGxlci5jb2xvclN0b3BzICYmICEoZmlsbGVyIGluc3RhbmNlb2YgZmFicmljLkdyYWRpZW50KSkge1xuICAgICAgdGhpcy5zZXQocHJvcGVydHksIG5ldyBmYWJyaWMuR3JhZGllbnQoZmlsbGVyKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2ZpbGxlcl0gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gcHJvcGVydHkgdG8gc2V0IHRoZSBQYXR0ZXJuIHRvXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIHBhdHRlcm4gbG9hZFxuICAgKi9cbiAgX2luaXRQYXR0ZXJuOiBmdW5jdGlvbihmaWxsZXIsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgIGlmIChmaWxsZXIgJiYgZmlsbGVyLnNvdXJjZSAmJiAhKGZpbGxlciBpbnN0YW5jZW9mIGZhYnJpYy5QYXR0ZXJuKSkge1xuICAgICAgdGhpcy5zZXQocHJvcGVydHksIG5ldyBmYWJyaWMuUGF0dGVybihmaWxsZXIsIGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0T2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgdGhpcy5fc2V0KHByb3AsIG9ialtwcm9wXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHByb3BlcnR5IHRvIGEgZ2l2ZW4gdmFsdWUuIFdoZW4gY2hhbmdpbmcgcG9zaXRpb24vZGltZW5zaW9uIC1yZWxhdGVkIHByb3BlcnRpZXMgKGxlZnQsIHRvcCwgc2NhbGUsIGFuZ2xlLCBldGMuKSBgc2V0YCBkb2VzIG5vdCB1cGRhdGUgcG9zaXRpb24gb2Ygb2JqZWN0J3MgYm9yZGVycy9jb250cm9scy4gSWYgeW91IG5lZWQgdG8gdXBkYXRlIHRob3NlLCBjYWxsIGBzZXRDb29yZHMoKWAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IChpZiBvYmplY3QsIGl0ZXJhdGUgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSAoaWYgZnVuY3Rpb24sIHRoZSB2YWx1ZSBpcyBwYXNzZWQgaW50byBpdCBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGFzIGEgbmV3IG9uZSlcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuX3NldE9iamVjdChrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGB0cnVlYCB0byBgZmFsc2VgIG9yIGZyb20gYGZhbHNlYCB0byBgdHJ1ZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHRvZ2dsZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHRvZ2dsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChwcm9wZXJ0eSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgIXZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2ljIGdldHRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcmV0dXJuIHsqfSB2YWx1ZSBvZiBhIHByb3BlcnR5XG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICB9XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICB2YXIgc3FydCA9IE1hdGguc3FydCxcbiAgICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgUGlCeTE4MCA9IE1hdGguUEkgLyAxODAsXG4gICAgICBQaUJ5MiA9IE1hdGguUEkgLyAyO1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsXG4gICAqL1xuICBmYWJyaWMudXRpbCA9IHtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29zIG9mIGFuIGFuZ2xlLCBhdm9pZGluZyByZXR1cm5pbmcgZmxvYXRzIGZvciBrbm93biByZXN1bHRzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSB0aGUgYW5nbGUgaW4gcmFkaWFucyBvciBpbiBkZWdyZWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgY29zOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7IHJldHVybiAxOyB9XG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIC8vIGNvcyhhKSA9IGNvcygtYSlcbiAgICAgICAgYW5nbGUgPSAtYW5nbGU7XG4gICAgICB9XG4gICAgICB2YXIgYW5nbGVTbGljZSA9IGFuZ2xlIC8gUGlCeTI7XG4gICAgICBzd2l0Y2ggKGFuZ2xlU2xpY2UpIHtcbiAgICAgICAgY2FzZSAxOiBjYXNlIDM6IHJldHVybiAwO1xuICAgICAgICBjYXNlIDI6IHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc2luIG9mIGFuIGFuZ2xlLCBhdm9pZGluZyByZXR1cm5pbmcgZmxvYXRzIGZvciBrbm93biByZXN1bHRzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSB0aGUgYW5nbGUgaW4gcmFkaWFucyBvciBpbiBkZWdyZWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgc2luOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7IHJldHVybiAwOyB9XG4gICAgICB2YXIgYW5nbGVTbGljZSA9IGFuZ2xlIC8gUGlCeTIsIHNpZ24gPSAxO1xuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAvLyBzaW4oLWEpID0gLXNpbihhKVxuICAgICAgICBzaWduID0gLTE7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFuZ2xlU2xpY2UpIHtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gc2lnbjtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gLXNpZ247XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5zaW4oYW5nbGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAgICogUHJlc2VuY2Ugb2YgdmFsdWUgKGFuZCBpdHMgcG9zaXRpb24gaW4gYW4gYXJyYXkpIGlzIGRldGVybWluZWQgdmlhIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IG9yaWdpbmFsIGFycmF5XG4gICAgICovXG4gICAgcmVtb3ZlRnJvbUFycmF5OiBmdW5jdGlvbihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBpZHggPSBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIGFycmF5LnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAyIHNwZWNpZmllZCBvbmVzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluIGxvd2VyIGxpbWl0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heCB1cHBlciBsaW1pdFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcmFuZG9tIHZhbHVlIChiZXR3ZWVuIG1pbiBhbmQgbWF4KVxuICAgICAqL1xuICAgIGdldFJhbmRvbUludDogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlZ3JlZXMgdmFsdWUgaW4gZGVncmVlc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgaW4gcmFkaWFuc1xuICAgICAqL1xuICAgIGRlZ3JlZXNUb1JhZGlhbnM6IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcbiAgICAgIHJldHVybiBkZWdyZWVzICogUGlCeTE4MDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zIHZhbHVlIGluIHJhZGlhbnNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlIGluIGRlZ3JlZXNcbiAgICAgKi9cbiAgICByYWRpYW5zVG9EZWdyZWVzOiBmdW5jdGlvbihyYWRpYW5zKSB7XG4gICAgICByZXR1cm4gcmFkaWFucyAvIFBpQnkxODA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYHBvaW50YCBhcm91bmQgYG9yaWdpbmAgd2l0aCBgcmFkaWFuc2BcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgVGhlIHJhZGlhbnMgb2YgdGhlIGFuZ2xlIGZvciB0aGUgcm90YXRpb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IFRoZSBuZXcgcm90YXRlZCBwb2ludFxuICAgICAqL1xuICAgIHJvdGF0ZVBvaW50OiBmdW5jdGlvbihwb2ludCwgb3JpZ2luLCByYWRpYW5zKSB7XG4gICAgICB2YXIgbmV3UG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50LnggLSBvcmlnaW4ueCwgcG9pbnQueSAtIG9yaWdpbi55KSxcbiAgICAgICAgICB2ID0gZmFicmljLnV0aWwucm90YXRlVmVjdG9yKG5ld1BvaW50LCByYWRpYW5zKTtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHYueCwgdi55KS5hZGRFcXVhbHMob3JpZ2luKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBgdmVjdG9yYCB3aXRoIGByYWRpYW5zYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmVjdG9yIFRoZSB2ZWN0b3IgdG8gcm90YXRlICh4IGFuZCB5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zIFRoZSByYWRpYW5zIG9mIHRoZSBhbmdsZSBmb3IgdGhlIHJvdGF0aW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IHJvdGF0ZWQgcG9pbnRcbiAgICAgKi9cbiAgICByb3RhdGVWZWN0b3I6IGZ1bmN0aW9uKHZlY3RvciwgcmFkaWFucykge1xuICAgICAgdmFyIHNpbiA9IGZhYnJpYy51dGlsLnNpbihyYWRpYW5zKSxcbiAgICAgICAgICBjb3MgPSBmYWJyaWMudXRpbC5jb3MocmFkaWFucyksXG4gICAgICAgICAgcnggPSB2ZWN0b3IueCAqIGNvcyAtIHZlY3Rvci55ICogc2luLFxuICAgICAgICAgIHJ5ID0gdmVjdG9yLnggKiBzaW4gKyB2ZWN0b3IueSAqIGNvcztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJ4LFxuICAgICAgICB5OiByeVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHZldG9yIGZyb20gcG9pbnRzIHJlcHJlc2VudGVkIGFzIGEgcG9pbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGZyb21cbiAgICAgKiBAcGFyYW0ge1BvaW50fSB0b1xuICAgICAqIEByZXR1cm5zIHtQb2ludH0gdmVjdG9yXG4gICAgICovXG4gICAgY3JlYXRlVmVjdG9yOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHRvLnggLSBmcm9tLngsIHRvLnkgLSBmcm9tLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuZ2xlIGJldHdlZW4gMiB2ZWN0b3JzIHVzaW5nIGRvdCBwcm9kdWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGFcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBiXG4gICAgICogQHJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbiBiZXR3ZWVuIHRoZSB2ZWN0b3JzXG4gICAgICovXG4gICAgY2FsY0FuZ2xlQmV0d2VlblZlY3RvcnM6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gTWF0aC5hY29zKChhLnggKiBiLnggKyBhLnkgKiBiLnkpIC8gKE1hdGguaHlwb3QoYS54LCBhLnkpICogTWF0aC5oeXBvdChiLngsIGIueSkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHZcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHVuaXQgdmVjdG9yIG9mIHBvaW50aW5nIHRvIHRoZSBkaXJlY3Rpb24gb2YgYHZgXG4gICAgICovXG4gICAgZ2V0SGF0VmVjdG9yOiBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQodi54LCB2LnkpLm11bHRpcGx5KDEgLyBNYXRoLmh5cG90KHYueCwgdi55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBBXG4gICAgICogQHBhcmFtIHtQb2ludH0gQlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IENcbiAgICAgKiBAcmV0dXJucyB7eyB2ZWN0b3I6IFBvaW50LCBhbmdsZTogbnVtYmVyIH19IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGJpc2VjdG9yIG9mIEEgYW5kIEEncyBhbmdsZVxuICAgICAqL1xuICAgIGdldEJpc2VjdG9yOiBmdW5jdGlvbiAoQSwgQiwgQykge1xuICAgICAgdmFyIEFCID0gZmFicmljLnV0aWwuY3JlYXRlVmVjdG9yKEEsIEIpLCBBQyA9IGZhYnJpYy51dGlsLmNyZWF0ZVZlY3RvcihBLCBDKTtcbiAgICAgIHZhciBhbHBoYSA9IGZhYnJpYy51dGlsLmNhbGNBbmdsZUJldHdlZW5WZWN0b3JzKEFCLCBBQyk7XG4gICAgICAvLyAgY2hlY2sgaWYgYWxwaGEgaXMgcmVsYXRpdmUgdG8gQUItPkJDXG4gICAgICB2YXIgcm8gPSBmYWJyaWMudXRpbC5jYWxjQW5nbGVCZXR3ZWVuVmVjdG9ycyhmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoQUIsIGFscGhhKSwgQUMpO1xuICAgICAgdmFyIHBoaSA9IGFscGhhICogKHJvID09PSAwID8gMSA6IC0xKSAvIDI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZWN0b3I6IGZhYnJpYy51dGlsLmdldEhhdFZlY3RvcihmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoQUIsIHBoaSkpLFxuICAgICAgICBhbmdsZTogYWxwaGFcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2plY3Qgc3Ryb2tlIHdpZHRoIG9uIHBvaW50cyByZXR1cm5pbmcgMiBwcm9qZWN0aW9ucyBmb3IgZWFjaCBwb2ludCBhcyBmb2xsb3dzOlxuICAgICAqIC0gYG1pdGVyYDogMiBwb2ludHMgY29ycmVzcG9uZGluZyB0byB0aGUgb3V0ZXIgYm91bmRhcnkgYW5kIHRoZSBpbm5lciBib3VuZGFyeSBvZiBzdHJva2UuXG4gICAgICogLSBgYmV2ZWxgOiAyIHBvaW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBiZXZlbCBib3VuZGFyaWVzLCB0YW5nZW50IHRvIHRoZSBiaXNlY3Rvci5cbiAgICAgKiAtIGByb3VuZGA6IHNhbWUgYXMgYGJldmVsYFxuICAgICAqIFVzZWQgdG8gY2FsY3VsYXRlIG9iamVjdCdzIGJvdW5kaW5nIGJveFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1BvaW50W119IHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc3Ryb2tlV2lkdGhcbiAgICAgKiBAcGFyYW0geydtaXRlcid8J2JldmVsJ3wncm91bmQnfSBvcHRpb25zLnN0cm9rZUxpbmVKb2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc3Ryb2tlTWl0ZXJMaW1pdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1taXRlcmxpbWl0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnN0cm9rZVVuaWZvcm1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zY2FsZVhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zY2FsZVlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcGVuUGF0aF0gd2hldGhlciB0aGUgc2hhcGUgaXMgb3BlbiBvciBub3QsIGFmZmVjdHMgdGhlIGNhbGN1bGF0aW9ucyBvZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzXG4gICAgICogQHJldHVybnMge2ZhYnJpYy5Qb2ludFtdfSBhcnJheSBvZiBzaXplIDJuLzRuIG9mIGFsbCBzdXNwZWN0ZWQgcG9pbnRzXG4gICAgICovXG4gICAgcHJvamVjdFN0cm9rZU9uUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzLCBvcHRpb25zLCBvcGVuUGF0aCkge1xuICAgICAgdmFyIGNvb3JkcyA9IFtdLCBzID0gb3B0aW9ucy5zdHJva2VXaWR0aCAvIDIsXG4gICAgICAgICAgc3Ryb2tlVW5pZm9ybVNjYWxhciA9IG9wdGlvbnMuc3Ryb2tlVW5pZm9ybSA/XG4gICAgICAgICAgICBuZXcgZmFicmljLlBvaW50KDEgLyBvcHRpb25zLnNjYWxlWCwgMSAvIG9wdGlvbnMuc2NhbGVZKSA6IG5ldyBmYWJyaWMuUG9pbnQoMSwgMSksXG4gICAgICAgICAgZ2V0U3Ryb2tlSGF0VmVjdG9yID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBzY2FsYXIgPSBzIC8gKE1hdGguaHlwb3Qodi54LCB2LnkpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHYueCAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueCwgdi55ICogc2NhbGFyICogc3Ryb2tlVW5pZm9ybVNjYWxhci55KTtcbiAgICAgICAgICB9O1xuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPD0gMSkge3JldHVybiBjb29yZHM7fVxuICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgIHZhciBBID0gbmV3IGZhYnJpYy5Qb2ludChwLngsIHAueSksIEIsIEM7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIEMgPSBwb2ludHNbaW5kZXggKyAxXTtcbiAgICAgICAgICBCID0gb3BlblBhdGggPyBnZXRTdHJva2VIYXRWZWN0b3IoZmFicmljLnV0aWwuY3JlYXRlVmVjdG9yKEMsIEEpKS5hZGRFcXVhbHMoQSkgOiBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIEIgPSBwb2ludHNbaW5kZXggLSAxXTtcbiAgICAgICAgICBDID0gb3BlblBhdGggPyBnZXRTdHJva2VIYXRWZWN0b3IoZmFicmljLnV0aWwuY3JlYXRlVmVjdG9yKEIsIEEpKS5hZGRFcXVhbHMoQSkgOiBwb2ludHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgQiA9IHBvaW50c1tpbmRleCAtIDFdO1xuICAgICAgICAgIEMgPSBwb2ludHNbaW5kZXggKyAxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmlzZWN0b3IgPSBmYWJyaWMudXRpbC5nZXRCaXNlY3RvcihBLCBCLCBDKSxcbiAgICAgICAgICAgIGJpc2VjdG9yVmVjdG9yID0gYmlzZWN0b3IudmVjdG9yLFxuICAgICAgICAgICAgYWxwaGEgPSBiaXNlY3Rvci5hbmdsZSxcbiAgICAgICAgICAgIHNjYWxhcixcbiAgICAgICAgICAgIG1pdGVyVmVjdG9yO1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJva2VMaW5lSm9pbiA9PT0gJ21pdGVyJykge1xuICAgICAgICAgIHNjYWxhciA9IC1zIC8gTWF0aC5zaW4oYWxwaGEgLyAyKTtcbiAgICAgICAgICBtaXRlclZlY3RvciA9IG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgICAgICBiaXNlY3RvclZlY3Rvci54ICogc2NhbGFyICogc3Ryb2tlVW5pZm9ybVNjYWxhci54LFxuICAgICAgICAgICAgYmlzZWN0b3JWZWN0b3IueSAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKE1hdGguaHlwb3QobWl0ZXJWZWN0b3IueCwgbWl0ZXJWZWN0b3IueSkgLyBzIDw9IG9wdGlvbnMuc3Ryb2tlTWl0ZXJMaW1pdCkge1xuICAgICAgICAgICAgY29vcmRzLnB1c2goQS5hZGQobWl0ZXJWZWN0b3IpKTtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKEEuc3VidHJhY3QobWl0ZXJWZWN0b3IpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGFyID0gLXMgKiBNYXRoLlNRUlQyO1xuICAgICAgICBtaXRlclZlY3RvciA9IG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgICAgYmlzZWN0b3JWZWN0b3IueCAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueCxcbiAgICAgICAgICBiaXNlY3RvclZlY3Rvci55ICogc2NhbGFyICogc3Ryb2tlVW5pZm9ybVNjYWxhci55XG4gICAgICAgICk7XG4gICAgICAgIGNvb3Jkcy5wdXNoKEEuYWRkKG1pdGVyVmVjdG9yKSk7XG4gICAgICAgIGNvb3Jkcy5wdXNoKEEuc3VidHJhY3QobWl0ZXJWZWN0b3IpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdHJhbnNmb3JtIHQgdG8gcG9pbnQgcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtmYWJyaWMuUG9pbnR9IHAgVGhlIHBvaW50IHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSAge0FycmF5fSB0IFRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbaWdub3JlT2Zmc2V0XSBJbmRpY2F0ZXMgdGhhdCB0aGUgb2Zmc2V0IHNob3VsZCBub3QgYmUgYXBwbGllZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gVGhlIHRyYW5zZm9ybWVkIHBvaW50XG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHAsIHQsIGlnbm9yZU9mZnNldCkge1xuICAgICAgaWYgKGlnbm9yZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgICB0WzBdICogcC54ICsgdFsyXSAqIHAueSxcbiAgICAgICAgICB0WzFdICogcC54ICsgdFszXSAqIHAueVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgIHRbMF0gKiBwLnggKyB0WzJdICogcC55ICsgdFs0XSxcbiAgICAgICAgdFsxXSAqIHAueCArIHRbM10gKiBwLnkgKyB0WzVdXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIHBvaW50cydzIGJvdW5kaW5nIHJlY3RhbmdsZSAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyA0IHBvaW50cyBhcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2Zvcm1dIGFuIGFycmF5IG9mIDYgbnVtYmVycyByZXByZXNlbnRpbmcgYSAyeDMgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBtYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzOiBmdW5jdGlvbihwb2ludHMsIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBvaW50c1tpXSA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHBvaW50c1tpXSwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHhQb2ludHMgPSBbcG9pbnRzWzBdLngsIHBvaW50c1sxXS54LCBwb2ludHNbMl0ueCwgcG9pbnRzWzNdLnhdLFxuICAgICAgICAgIG1pblggPSBmYWJyaWMudXRpbC5hcnJheS5taW4oeFBvaW50cyksXG4gICAgICAgICAgbWF4WCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCh4UG9pbnRzKSxcbiAgICAgICAgICB3aWR0aCA9IG1heFggLSBtaW5YLFxuICAgICAgICAgIHlQb2ludHMgPSBbcG9pbnRzWzBdLnksIHBvaW50c1sxXS55LCBwb2ludHNbMl0ueSwgcG9pbnRzWzNdLnldLFxuICAgICAgICAgIG1pblkgPSBmYWJyaWMudXRpbC5hcnJheS5taW4oeVBvaW50cyksXG4gICAgICAgICAgbWF4WSA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCh5UG9pbnRzKSxcbiAgICAgICAgICBoZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgdHJhbnNmb3JtYXRpb24gdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0IFRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGludmVydGVkIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGludmVydFRyYW5zZm9ybTogZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGEgPSAxIC8gKHRbMF0gKiB0WzNdIC0gdFsxXSAqIHRbMl0pLFxuICAgICAgICAgIHIgPSBbYSAqIHRbM10sIC1hICogdFsxXSwgLWEgKiB0WzJdLCBhICogdFswXV0sXG4gICAgICAgICAgbyA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHsgeDogdFs0XSwgeTogdFs1XSB9LCByLCB0cnVlKTtcbiAgICAgIHJbNF0gPSAtby54O1xuICAgICAgcls1XSA9IC1vLnk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGFyb3VuZCBOdW1iZXIjdG9GaXhlZCwgd2hpY2ggY29udHJhcnkgdG8gbmF0aXZlIG1ldGhvZCByZXR1cm5zIG51bWJlciwgbm90IHN0cmluZy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBudW1iZXIgbnVtYmVyIHRvIG9wZXJhdGUgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJhY3Rpb25EaWdpdHMgbnVtYmVyIG9mIGZyYWN0aW9uIGRpZ2l0cyB0byBcImxlYXZlXCJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdG9GaXhlZDogZnVuY3Rpb24obnVtYmVyLCBmcmFjdGlvbkRpZ2l0cykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoTnVtYmVyKG51bWJlcikudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBmcm9tIGF0dHJpYnV0ZSB2YWx1ZSB0byBwaXhlbCB2YWx1ZSBpZiBhcHBsaWNhYmxlLlxuICAgICAqIFJldHVybnMgY29udmVydGVkIHBpeGVscyBvciBvcmlnaW5hbCB2YWx1ZSBub3QgY29udmVydGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgbnVtYmVyIHRvIG9wZXJhdGUgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZm9udFNpemVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICAgICAqL1xuICAgIHBhcnNlVW5pdDogZnVuY3Rpb24odmFsdWUsIGZvbnRTaXplKSB7XG4gICAgICB2YXIgdW5pdCA9IC9cXER7MCwyfSQvLmV4ZWModmFsdWUpLFxuICAgICAgICAgIG51bWJlciA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgaWYgKCFmb250U2l6ZSkge1xuICAgICAgICBmb250U2l6ZSA9IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodW5pdFswXSkge1xuICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyAyNS40O1xuXG4gICAgICAgIGNhc2UgJ2NtJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDIuNTQ7XG5cbiAgICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJO1xuXG4gICAgICAgIGNhc2UgJ3B0JzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDcyOyAvLyBvciAqIDQgLyAzXG5cbiAgICAgICAgY2FzZSAncGMnOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gNzIgKiAxMjsgLy8gb3IgKiAxNlxuXG4gICAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZm9udFNpemU7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZhbHNlRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGtsYXNzIFwiQ2xhc3NcIiBvYmplY3Qgb2YgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBvYmplY3QgKGVnLiAnY2lyY2xlJylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIE5hbWVzcGFjZSB0byBnZXQga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBmcm9tXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBrbGFzcyBcIkNsYXNzXCJcbiAgICAgKi9cbiAgICBnZXRLbGFzczogZnVuY3Rpb24odHlwZSwgbmFtZXNwYWNlKSB7XG4gICAgICAvLyBjYXBpdGFsaXplIGZpcnN0IGxldHRlciBvbmx5XG4gICAgICB0eXBlID0gZmFicmljLnV0aWwuc3RyaW5nLmNhbWVsaXplKHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnNsaWNlKDEpKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSlbdHlwZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXJyYXkgb2YgYXR0cmlidXRlcyBmb3IgZ2l2ZW4gc3ZnIHRoYXQgZmFicmljIHBhcnNlc1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2Ygc3ZnIGVsZW1lbnQgKGVnLiAnY2lyY2xlJylcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gc3RyaW5nIG5hbWVzIG9mIHN1cHBvcnRlZCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgZ2V0U3ZnQXR0cmlidXRlczogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdpbnN0YW50aWF0ZWRfYnlfdXNlJyxcbiAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ2NsYXNzJ1xuICAgICAgXTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdsaW5lYXJHcmFkaWVudCc6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KFsneDEnLCAneTEnLCAneDInLCAneTInLCAnZ3JhZGllbnRVbml0cycsICdncmFkaWVudFRyYW5zZm9ybSddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmFkaWFsR3JhZGllbnQnOlxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChbJ2dyYWRpZW50VW5pdHMnLCAnZ3JhZGllbnRUcmFuc2Zvcm0nLCAnY3gnLCAnY3knLCAncicsICdmeCcsICdmeScsICdmciddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RvcCc6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KFsnb2Zmc2V0JywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5J10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IG9mIGdpdmVuIG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHN0cmluZyBlLmcuICdmYWJyaWMuSW1hZ2UuZmlsdGVyJyBvciAnZmFicmljJ1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGZvciBnaXZlbiBuYW1lc3BhY2UgKGRlZmF1bHQgZmFicmljKVxuICAgICAqL1xuICAgIHJlc29sdmVOYW1lc3BhY2U6IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xuICAgICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnRzID0gbmFtZXNwYWNlLnNwbGl0KCcuJyksXG4gICAgICAgICAgbGVuID0gcGFydHMubGVuZ3RoLCBpLFxuICAgICAgICAgIG9iaiA9IGdsb2JhbCB8fCBmYWJyaWMud2luZG93O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgb2JqID0gb2JqW3BhcnRzW2ldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgaW1hZ2UgZWxlbWVudCBmcm9tIGdpdmVuIHVybCBhbmQgcGFzc2VzIGl0IHRvIGEgY2FsbGJhY2tcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCByZXByZXNlbnRpbmcgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjazsgaW52b2tlZCB3aXRoIGxvYWRlZCBpbWFnZVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIENvbnRleHQgdG8gaW52b2tlIGNhbGxiYWNrIGluXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gdmFsdWUgdG8gc2V0IGltYWdlIGVsZW1lbnQgdG9cbiAgICAgKi9cbiAgICBsb2FkSW1hZ2U6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGNvbnRleHQsIGNyb3NzT3JpZ2luKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHVybCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGltZyA9IGZhYnJpYy51dGlsLmNyZWF0ZUltYWdlKCk7XG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICB2YXIgb25Mb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgaW1nLCBmYWxzZSk7XG4gICAgICAgIGltZyA9IGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBpbWcub25sb2FkID0gb25Mb2FkQ2FsbGJhY2s7XG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmFicmljLmxvZygnRXJyb3IgbG9hZGluZyAnICsgaW1nLnNyYyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIGltZyA9IGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvLyBkYXRhLXVybHMgYXBwZWFyIHRvIGJlIGJ1Z2d5IHdpdGggY3Jvc3NPcmlnaW5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvZmFicmljLmpzL2NvbW1pdC9kMGFiYjkwZjFjZDVjNWVmOWQyYTk0ZDNmYjIxYTIyMzMwZGEzZTBhI2NvbW1pdGNvbW1lbnQtNDUxMzc2N1xuICAgICAgLy8gc2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zMTUxNTJcbiAgICAgIC8vICAgICBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MzUwNjlcbiAgICAgIC8vIGNyb3NzT3JpZ2luIG51bGwgaXMgdGhlIHNhbWUgYXMgbm90IHNldC5cbiAgICAgIGlmICh1cmwuaW5kZXhPZignZGF0YScpICE9PSAwICYmXG4gICAgICAgIGNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgY3Jvc3NPcmlnaW4gIT09IG51bGwpIHtcbiAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICB9XG5cbiAgICAgIC8vIElFMTAgLyBJRTExLUZpeDogU1ZHIGNvbnRlbnRzIGZyb20gZGF0YTogVVJJXG4gICAgICAvLyB3aWxsIG9ubHkgYmUgYXZhaWxhYmxlIGlmIHRoZSBJTUcgaXMgcHJlc2VudFxuICAgICAgLy8gaW4gdGhlIERPTSAoYW5kIHZpc2libGUpXG4gICAgICBpZiAodXJsLnN1YnN0cmluZygwLDE0KSA9PT0gJ2RhdGE6aW1hZ2Uvc3ZnJykge1xuICAgICAgICBpbWcub25sb2FkID0gbnVsbDtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlSW5Eb20oaW1nLCBvbkxvYWRDYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIFNWRyBpbWFnZSB3aXRoIGRhdGE6IFVSTCB0byB0aGUgZG9tXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltZyBJbWFnZSBvYmplY3Qgd2l0aCBkYXRhOmltYWdlL3N2ZyBzcmNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjazsgaW52b2tlZCB3aXRoIGxvYWRlZCBpbWFnZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gRE9NIGVsZW1lbnQgKGRpdiBjb250YWluaW5nIHRoZSBTVkcgaW1hZ2UpXG4gICAgICovXG4gICAgbG9hZEltYWdlSW5Eb206IGZ1bmN0aW9uKGltZywgb25Mb2FkQ2FsbGJhY2spIHtcbiAgICAgIHZhciBkaXYgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XG4gICAgICBkaXYuc3R5bGUubGVmdCA9IGRpdi5zdHlsZS50b3AgPSAnLTEwMCUnO1xuICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgZmFicmljLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwIGluIGZ1bmN0aW9uIHRvOlxuICAgICAgICogICAxLiBDYWxsIGV4aXN0aW5nIGNhbGxiYWNrXG4gICAgICAgKiAgIDIuIENsZWFudXAgRE9NXG4gICAgICAgKi9cbiAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uTG9hZENhbGxiYWNrKCk7XG4gICAgICAgIGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIGRpdiA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNvcnJlc3BvbmRpbmcgZmFicmljIGluc3RhbmNlcyBmcm9tIHRoZWlyIG9iamVjdCByZXByZXNlbnRhdGlvbnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyBPYmplY3RzIHRvIGVubGl2ZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2JqZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHRvIGdldCBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IGZyb21cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXZpdmVyIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIG9iamVjdCBlbGVtZW50cyxcbiAgICAgKiBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgZW5saXZlbk9iamVjdHM6IGZ1bmN0aW9uKG9iamVjdHMsIGNhbGxiYWNrLCBuYW1lc3BhY2UsIHJldml2ZXIpIHtcbiAgICAgIG9iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuXG4gICAgICB2YXIgZW5saXZlbmVkT2JqZWN0cyA9IFtdLFxuICAgICAgICAgIG51bUxvYWRlZE9iamVjdHMgPSAwLFxuICAgICAgICAgIG51bVRvdGFsT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBvbkxvYWRlZCgpIHtcbiAgICAgICAgaWYgKCsrbnVtTG9hZGVkT2JqZWN0cyA9PT0gbnVtVG90YWxPYmplY3RzKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkT2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHVuZGVmaW5lZCBvYmplY3RzIChvYmplY3RzIHRoYXQgZ2F2ZSBlcnJvcilcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbnVtVG90YWxPYmplY3RzKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAobywgaW5kZXgpIHtcbiAgICAgICAgLy8gaWYgc3BhcnNlIGFycmF5XG4gICAgICAgIGlmICghbyB8fCAhby50eXBlKSB7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtsYXNzID0gZmFicmljLnV0aWwuZ2V0S2xhc3Moby50eXBlLCBuYW1lc3BhY2UpO1xuICAgICAgICBrbGFzcy5mcm9tT2JqZWN0KG8sIGZ1bmN0aW9uIChvYmosIGVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgfHwgKGVubGl2ZW5lZE9iamVjdHNbaW5kZXhdID0gb2JqKTtcbiAgICAgICAgICByZXZpdmVyICYmIHJldml2ZXIobywgb2JqLCBlcnJvcik7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjb3JyZXNwb25kaW5nIGZhYnJpYyBpbnN0YW5jZXMgcmVzaWRpbmcgaW4gYW4gb2JqZWN0LCBlLmcuIGBjbGlwUGF0aGBcbiAgICAgKiBAc2VlIHtAbGluayBmYWJyaWMuT2JqZWN0LkVOTElWRU5fUFJPUFN9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gYXNzaWduIGVubGl2ZWQgcHJvcHMgdG8gdGhpcyBvYmplY3QgKHBhc3MgbnVsbCB0byBza2lwIHRoaXMpXG4gICAgICogQHBhcmFtIHsob2JqZWN0czpmYWJyaWMuT2JqZWN0W10pID0+IHZvaWR9IGNhbGxiYWNrXG4gICAgICovXG4gICAgZW5saXZlbk9iamVjdEVubGl2YWJsZXM6IGZ1bmN0aW9uIChvYmplY3QsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZW5saXZlblByb3BzID0gZmFicmljLk9iamVjdC5FTkxJVkVOX1BST1BTLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhIW9iamVjdFtrZXldOyB9KTtcbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKGVubGl2ZW5Qcm9wcy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gb2JqZWN0W2tleV07IH0pLCBmdW5jdGlvbiAoZW5saXZlZFByb3BzKSB7XG4gICAgICAgIHZhciBvYmplY3RzID0ge307XG4gICAgICAgIGVubGl2ZW5Qcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICAgICAgb2JqZWN0c1trZXldID0gZW5saXZlZFByb3BzW2luZGV4XTtcbiAgICAgICAgICBjb250ZXh0ICYmIChjb250ZXh0W2tleV0gPSBlbmxpdmVkUHJvcHNbaW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG9iamVjdHMpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgd2FpdCBmb3IgbG9hZGluZyBvZiBwYXR0ZXJuc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXR0ZXJucyBPYmplY3RzIHRvIGVubGl2ZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2JqZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuUGF0dGVybnM6IGZ1bmN0aW9uKHBhdHRlcm5zLCBjYWxsYmFjaykge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucyB8fCBbXTtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkZWQoKSB7XG4gICAgICAgIGlmICgrK251bUxvYWRlZFBhdHRlcm5zID09PSBudW1QYXR0ZXJucykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZFBhdHRlcm5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkUGF0dGVybnMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRQYXR0ZXJucyA9IDAsXG4gICAgICAgICAgbnVtUGF0dGVybnMgPSBwYXR0ZXJucy5sZW5ndGg7XG5cbiAgICAgIGlmICghbnVtUGF0dGVybnMpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkUGF0dGVybnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhdHRlcm5zLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgIGlmIChwICYmIHAuc291cmNlKSB7XG4gICAgICAgICAgbmV3IGZhYnJpYy5QYXR0ZXJuKHAsIGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHBhdHRlcm47XG4gICAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHA7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBTVkcgZWxlbWVudHMgKHVzdWFsbHkgdGhvc2UgcmV0cmlldmVkIGZyb20gU1ZHIGRvY3VtZW50KVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBTVkcgZWxlbWVudHMgdG8gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVmFsdWUgdG8gc2V0IHNvdXJjZVBhdGggdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fGZhYnJpYy5Hcm91cH1cbiAgICAgKi9cbiAgICBncm91cFNWR0VsZW1lbnRzOiBmdW5jdGlvbihlbGVtZW50cywgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdDtcbiAgICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzWzBdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgICBvcHRpb25zLmNlbnRlclBvaW50ID0ge1xuICAgICAgICAgICAgeDogb3B0aW9ucy53aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiBvcHRpb25zLmhlaWdodCAvIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLndpZHRoO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqZWN0ID0gbmV3IGZhYnJpYy5Hcm91cChlbGVtZW50cywgb3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIHBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5zb3VyY2VQYXRoID0gcGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIG5hbWVzIHRvIGluY2x1ZGVcbiAgICAgKi9cbiAgICBwb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uLCBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAocHJvcGVydGllcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvcGVydGllcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1tpXSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnRpZXNbaV1dID0gc291cmNlW3Byb3BlcnRpZXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0NhbnZhc0VsZW1lbnR9IGluaXRpYWxpemVkIGNhbnZhcyBlbGVtZW50XG4gICAgICovXG4gICAgY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FudmFzIGVsZW1lbnQgdGhhdCBpcyBhIGNvcHkgb2YgYW5vdGhlciBhbmQgaXMgYWxzbyBwYWludGVkXG4gICAgICogQHBhcmFtIHtDYW52YXNFbGVtZW50fSBjYW52YXMgdG8gY29weSBzaXplIGFuZCBjb250ZW50IG9mXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0NhbnZhc0VsZW1lbnR9IGluaXRpYWxpemVkIGNhbnZhcyBlbGVtZW50XG4gICAgICovXG4gICAgY29weUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgdmFyIG5ld0NhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIG5ld0NhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgIG5ld0NhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgbmV3Q2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgICByZXR1cm4gbmV3Q2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzaW5jZSAyLjYuMCBtb3ZlZCBmcm9tIGNhbnZhcyBpbnN0YW5jZSB0byB1dGlsaXR5LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzRWxlbWVudH0gY2FudmFzRWwgdG8gY29weSBzaXplIGFuZCBjb250ZW50IG9mXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCAnanBlZycgb3IgJ3BuZycsIGluIHNvbWUgYnJvd3NlcnMgJ3dlYnAnIGlzIG9rIHRvb1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFsaXR5IDw9IDEgYW5kID4gMFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRhdGEgdXJsXG4gICAgICovXG4gICAgdG9EYXRhVVJMOiBmdW5jdGlvbihjYW52YXNFbCwgZm9ybWF0LCBxdWFsaXR5KSB7XG4gICAgICByZXR1cm4gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS8nICsgZm9ybWF0LCBxdWFsaXR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBpbWFnZSBlbGVtZW50ICh3b3JrcyBvbiBjbGllbnQgYW5kIG5vZGUpXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEhUTUwgaW1hZ2UgZWxlbWVudFxuICAgICAqL1xuICAgIGNyZWF0ZUltYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IG1hdHJpeCBBIGJ5IG1hdHJpeCBCIHRvIG5lc3QgdHJhbnNmb3JtYXRpb25zXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhIEZpcnN0IHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBiIFNlY29uZCB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpczJ4MiBmbGFnIHRvIG11bHRpcGx5IG1hdHJpY2VzIGFzIDJ4MiBtYXRyaWNlc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgcHJvZHVjdCBvZiB0aGUgdHdvIHRyYW5zZm9ybSBtYXRyaWNlc1xuICAgICAqL1xuICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXM6IGZ1bmN0aW9uKGEsIGIsIGlzMngyKSB7XG4gICAgICAvLyBNYXRyaXggbXVsdGlwbHkgYSAqIGJcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGFbMF0gKiBiWzBdICsgYVsyXSAqIGJbMV0sXG4gICAgICAgIGFbMV0gKiBiWzBdICsgYVszXSAqIGJbMV0sXG4gICAgICAgIGFbMF0gKiBiWzJdICsgYVsyXSAqIGJbM10sXG4gICAgICAgIGFbMV0gKiBiWzJdICsgYVszXSAqIGJbM10sXG4gICAgICAgIGlzMngyID8gMCA6IGFbMF0gKiBiWzRdICsgYVsyXSAqIGJbNV0gKyBhWzRdLFxuICAgICAgICBpczJ4MiA/IDAgOiBhWzFdICogYls0XSArIGFbM10gKiBiWzVdICsgYVs1XVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjb21wb3NlcyBzdGFuZGFyZCAyeDMgbWF0cml4IGludG8gdHJhbnNmb3JtIGNvbXBvbmVudHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGEgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb21wb25lbnRzIG9mIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHFyRGVjb21wb3NlOiBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYW5nbGUgPSBhdGFuMihhWzFdLCBhWzBdKSxcbiAgICAgICAgICBkZW5vbSA9IHBvdyhhWzBdLCAyKSArIHBvdyhhWzFdLCAyKSxcbiAgICAgICAgICBzY2FsZVggPSBzcXJ0KGRlbm9tKSxcbiAgICAgICAgICBzY2FsZVkgPSAoYVswXSAqIGFbM10gLSBhWzJdICogYVsxXSkgLyBzY2FsZVgsXG4gICAgICAgICAgc2tld1ggPSBhdGFuMihhWzBdICogYVsyXSArIGFbMV0gKiBhIFszXSwgZGVub20pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW5nbGU6IGFuZ2xlIC8gUGlCeTE4MCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBza2V3WDogc2tld1ggLyBQaUJ5MTgwLFxuICAgICAgICBza2V3WTogMCxcbiAgICAgICAgdHJhbnNsYXRlWDogYVs0XSxcbiAgICAgICAgdHJhbnNsYXRlWTogYVs1XVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyYW5zZm9ybSBtYXRyaXggc3RhcnRpbmcgZnJvbSBhbiBvYmplY3Qgb2YgdGhlIHNhbWUga2luZCBvZlxuICAgICAqIHRoZSBvbmUgcmV0dXJuZWQgZnJvbSBxckRlY29tcG9zZSwgdXNlZnVsIGFsc28gaWYgeW91IHdhbnQgdG8gY2FsY3VsYXRlIHNvbWVcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgZnJvbSBhbiBvYmplY3QgdGhhdCBpcyBub3QgZW5saXZlZCB5ZXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZV0gYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEByZXR1cm4ge051bWJlcltdfSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgY2FsY1JvdGF0ZU1hdHJpeDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMuaU1hdHJpeC5jb25jYXQoKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aGV0YSA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5hbmdsZSksXG4gICAgICAgICAgY29zID0gZmFicmljLnV0aWwuY29zKHRoZXRhKSxcbiAgICAgICAgICBzaW4gPSBmYWJyaWMudXRpbC5zaW4odGhldGEpO1xuICAgICAgcmV0dXJuIFtjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyYW5zZm9ybSBtYXRyaXggc3RhcnRpbmcgZnJvbSBhbiBvYmplY3Qgb2YgdGhlIHNhbWUga2luZCBvZlxuICAgICAqIHRoZSBvbmUgcmV0dXJuZWQgZnJvbSBxckRlY29tcG9zZSwgdXNlZnVsIGFsc28gaWYgeW91IHdhbnQgdG8gY2FsY3VsYXRlIHNvbWVcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgZnJvbSBhbiBvYmplY3QgdGhhdCBpcyBub3QgZW5saXZlZCB5ZXQuXG4gICAgICogaXMgY2FsbGVkIERpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXggYmVjYXVzZSB0aG9zZSBwcm9wZXJ0aWVzIGFyZSB0aGUgb25lIHRoYXQgaW5mbHVlbmNlXG4gICAgICogdGhlIHNpemUgb2YgdGhlIHJlc3VsdGluZyBib3ggb2YgdGhlIG9iamVjdC5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZVhdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZVldXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZmxpcFhdXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZmxpcFldXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5za2V3WF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNrZXdZXVxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgY2FsY0RpbWVuc2lvbnNNYXRyaXg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzY2FsZVggPSB0eXBlb2Ygb3B0aW9ucy5zY2FsZVggPT09ICd1bmRlZmluZWQnID8gMSA6IG9wdGlvbnMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSA9IHR5cGVvZiBvcHRpb25zLnNjYWxlWSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogb3B0aW9ucy5zY2FsZVksXG4gICAgICAgICAgc2NhbGVNYXRyaXggPSBbXG4gICAgICAgICAgICBvcHRpb25zLmZsaXBYID8gLXNjYWxlWCA6IHNjYWxlWCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3B0aW9ucy5mbGlwWSA/IC1zY2FsZVkgOiBzY2FsZVksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMF0sXG4gICAgICAgICAgbXVsdGlwbHkgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuICAgICAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zO1xuICAgICAgaWYgKG9wdGlvbnMuc2tld1gpIHtcbiAgICAgICAgc2NhbGVNYXRyaXggPSBtdWx0aXBseShcbiAgICAgICAgICBzY2FsZU1hdHJpeCxcbiAgICAgICAgICBbMSwgMCwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyhvcHRpb25zLnNrZXdYKSksIDFdLFxuICAgICAgICAgIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2tld1kpIHtcbiAgICAgICAgc2NhbGVNYXRyaXggPSBtdWx0aXBseShcbiAgICAgICAgICBzY2FsZU1hdHJpeCxcbiAgICAgICAgICBbMSwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyhvcHRpb25zLnNrZXdZKSksIDAsIDFdLFxuICAgICAgICAgIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjYWxlTWF0cml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHJhbnNmb3JtIG1hdHJpeCBzdGFydGluZyBmcm9tIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBraW5kIG9mXG4gICAgICogdGhlIG9uZSByZXR1cm5lZCBmcm9tIHFyRGVjb21wb3NlLCB1c2VmdWwgYWxzbyBpZiB5b3Ugd2FudCB0byBjYWxjdWxhdGUgc29tZVxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBmcm9tIGFuIG9iamVjdCB0aGF0IGlzIG5vdCBlbmxpdmVkIHlldFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2NhbGVYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2NhbGVZXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZsaXBYXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZsaXBZXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2tld1hdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5za2V3WF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnRyYW5zbGF0ZVhdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy50cmFuc2xhdGVZXVxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgY29tcG9zZU1hdHJpeDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1hdHJpeCA9IFsxLCAwLCAwLCAxLCBvcHRpb25zLnRyYW5zbGF0ZVggfHwgMCwgb3B0aW9ucy50cmFuc2xhdGVZIHx8IDBdLFxuICAgICAgICAgIG11bHRpcGx5ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcztcbiAgICAgIGlmIChvcHRpb25zLmFuZ2xlKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5KG1hdHJpeCwgZmFicmljLnV0aWwuY2FsY1JvdGF0ZU1hdHJpeChvcHRpb25zKSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY2FsZVggIT09IDEgfHwgb3B0aW9ucy5zY2FsZVkgIT09IDEgfHxcbiAgICAgICAgICBvcHRpb25zLnNrZXdYIHx8IG9wdGlvbnMuc2tld1kgfHwgb3B0aW9ucy5mbGlwWCB8fCBvcHRpb25zLmZsaXBZKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5KG1hdHJpeCwgZmFicmljLnV0aWwuY2FsY0RpbWVuc2lvbnNNYXRyaXgob3B0aW9ucykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVzZXQgYW4gb2JqZWN0IHRyYW5zZm9ybSBzdGF0ZSB0byBuZXV0cmFsLiBUb3AgYW5kIGxlZnQgYXJlIG5vdCBhY2NvdW50ZWQgZm9yXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBvYmplY3QgdG8gdHJhbnNmb3JtXG4gICAgICovXG4gICAgcmVzZXRPYmplY3RUcmFuc2Zvcm06IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5zY2FsZVggPSAxO1xuICAgICAgdGFyZ2V0LnNjYWxlWSA9IDE7XG4gICAgICB0YXJnZXQuc2tld1ggPSAwO1xuICAgICAgdGFyZ2V0LnNrZXdZID0gMDtcbiAgICAgIHRhcmdldC5mbGlwWCA9IGZhbHNlO1xuICAgICAgdGFyZ2V0LmZsaXBZID0gZmFsc2U7XG4gICAgICB0YXJnZXQucm90YXRlKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IE9iamVjdCB0cmFuc2Zvcm0gdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBvYmplY3QgdG8gcmVhZCBmcm9tXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb21wb25lbnRzIG9mIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHNhdmVPYmplY3RUcmFuc2Zvcm06IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxlWDogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICBza2V3WDogdGFyZ2V0LnNrZXdYLFxuICAgICAgICBza2V3WTogdGFyZ2V0LnNrZXdZLFxuICAgICAgICBhbmdsZTogdGFyZ2V0LmFuZ2xlLFxuICAgICAgICBsZWZ0OiB0YXJnZXQubGVmdCxcbiAgICAgICAgZmxpcFg6IHRhcmdldC5mbGlwWCxcbiAgICAgICAgZmxpcFk6IHRhcmdldC5mbGlwWSxcbiAgICAgICAgdG9wOiB0YXJnZXQudG9wXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgY29udGV4dCBoYXMgdHJhbnNwYXJlbnQgcGl4ZWxcbiAgICAgKiBhdCBzcGVjaWZpZWQgbG9jYXRpb24gKHRha2luZyB0b2xlcmFuY2UgaW50byBhY2NvdW50KVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlXG4gICAgICovXG4gICAgaXNUcmFuc3BhcmVudDogZnVuY3Rpb24oY3R4LCB4LCB5LCB0b2xlcmFuY2UpIHtcblxuICAgICAgLy8gSWYgdG9sZXJhbmNlIGlzID4gMCBhZGp1c3Qgc3RhcnQgY29vcmRzIHRvIHRha2UgaW50byBhY2NvdW50LlxuICAgICAgLy8gSWYgbW92ZXMgb2ZmIENhbnZhcyBmaXggdG8gMFxuICAgICAgaWYgKHRvbGVyYW5jZSA+IDApIHtcbiAgICAgICAgaWYgKHggPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICB4IC09IHRvbGVyYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHkgLT0gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXNUcmFuc3BhcmVudCA9IHRydWUsIGksIHRlbXAsXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCAodG9sZXJhbmNlICogMikgfHwgMSwgKHRvbGVyYW5jZSAqIDIpIHx8IDEpLFxuICAgICAgICAgIGwgPSBpbWFnZURhdGEuZGF0YS5sZW5ndGg7XG5cbiAgICAgIC8vIFNwbGl0IGltYWdlIGRhdGEgLSBmb3IgdG9sZXJhbmNlID4gMSwgcGl4ZWxEYXRhU2l6ZSA9IDQ7XG4gICAgICBmb3IgKGkgPSAzOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICAgIHRlbXAgPSBpbWFnZURhdGEuZGF0YVtpXTtcbiAgICAgICAgX2lzVHJhbnNwYXJlbnQgPSB0ZW1wIDw9IDA7XG4gICAgICAgIGlmIChfaXNUcmFuc3BhcmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhazsgLy8gU3RvcCBpZiBjb2xvdXIgZm91bmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbWFnZURhdGEgPSBudWxsO1xuXG4gICAgICByZXR1cm4gX2lzVHJhbnNwYXJlbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHByZXNlcnZlQXNwZWN0UmF0aW8gYXR0cmlidXRlIGZyb20gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgdG8gYmUgcGFyc2VkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBhbGlnbiBhbmQgbWVldE9yU2xpY2UgYXR0cmlidXRlXG4gICAgICovXG4gICAgcGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlOiBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBtZWV0T3JTbGljZSA9ICdtZWV0JywgYWxpZ25YID0gJ01pZCcsIGFsaWduWSA9ICdNaWQnLFxuICAgICAgICAgIGFzcGVjdFJhdGlvQXR0cnMgPSBhdHRyaWJ1dGUuc3BsaXQoJyAnKSwgYWxpZ247XG5cbiAgICAgIGlmIChhc3BlY3RSYXRpb0F0dHJzICYmIGFzcGVjdFJhdGlvQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW9BdHRycy5wb3AoKTtcbiAgICAgICAgaWYgKG1lZXRPclNsaWNlICE9PSAnbWVldCcgJiYgbWVldE9yU2xpY2UgIT09ICdzbGljZScpIHtcbiAgICAgICAgICBhbGlnbiA9IG1lZXRPclNsaWNlO1xuICAgICAgICAgIG1lZXRPclNsaWNlID0gJ21lZXQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzcGVjdFJhdGlvQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgYWxpZ24gPSBhc3BlY3RSYXRpb0F0dHJzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2RpdmlkZSBhbGlnbiBpbiBhbGlnblggYW5kIGFsaWduWVxuICAgICAgYWxpZ25YID0gYWxpZ24gIT09ICdub25lJyA/IGFsaWduLnNsaWNlKDEsIDQpIDogJ25vbmUnO1xuICAgICAgYWxpZ25ZID0gYWxpZ24gIT09ICdub25lJyA/IGFsaWduLnNsaWNlKDUsIDgpIDogJ25vbmUnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVldE9yU2xpY2U6IG1lZXRPclNsaWNlLFxuICAgICAgICBhbGlnblg6IGFsaWduWCxcbiAgICAgICAgYWxpZ25ZOiBhbGlnbllcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGNoYXIgd2lkdGhzIGNhY2hlIGZvciB0aGUgZ2l2ZW4gZm9udCBmYW1pbHkgb3IgYWxsIHRoZSBjYWNoZSBpZiBub1xuICAgICAqIGZvbnRGYW1pbHkgaXMgc3BlY2lmaWVkLlxuICAgICAqIFVzZSBpdCBpZiB5b3Uga25vdyB5b3UgYXJlIGxvYWRpbmcgZm9udHMgaW4gYSBsYXp5IHdheSBhbmQgeW91IGFyZSBub3Qgd2FpdGluZ1xuICAgICAqIGZvciBjdXN0b20gZm9udHMgdG8gbG9hZCBwcm9wZXJseSB3aGVuIGFkZGluZyB0ZXh0IG9iamVjdHMgdG8gdGhlIGNhbnZhcy5cbiAgICAgKiBJZiBhIHRleHQgb2JqZWN0IGlzIGFkZGVkIHdoZW4gaXRzIG93biBmb250IGlzIG5vdCBsb2FkZWQgeWV0LCB5b3Ugd2lsbCBnZXQgd3JvbmdcbiAgICAgKiBtZWFzdXJlbWVudCBhbmQgc28gd3JvbmcgYm91bmRpbmcgYm94ZXMuXG4gICAgICogQWZ0ZXIgdGhlIGZvbnQgY2FjaGUgaXMgY2xlYXJlZCwgZWl0aGVyIGNoYW5nZSB0aGUgdGV4dE9iamVjdCB0ZXh0IGNvbnRlbnQgb3IgY2FsbFxuICAgICAqIGluaXREaW1lbnNpb25zKCkgdG8gdHJpZ2dlciBhIHJlY2FsY3VsYXRpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZvbnRGYW1pbHldIGZvbnQgZmFtaWx5IHRvIGNsZWFyXG4gICAgICovXG4gICAgY2xlYXJGYWJyaWNGb250Q2FjaGU6IGZ1bmN0aW9uKGZvbnRGYW1pbHkpIHtcbiAgICAgIGZvbnRGYW1pbHkgPSAoZm9udEZhbWlseSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghZm9udEZhbWlseSkge1xuICAgICAgICBmYWJyaWMuY2hhcldpZHRoc0NhY2hlID0geyB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSkge1xuICAgICAgICBkZWxldGUgZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gY3VycmVudCBhc3BlY3QgcmF0aW8sIGRldGVybWluZXMgdGhlIG1heCB3aWR0aCBhbmQgaGVpZ2h0IHRoYXQgY2FuXG4gICAgICogcmVzcGVjdCB0aGUgdG90YWwgYWxsb3dlZCBhcmVhIGZvciB0aGUgY2FjaGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyIGFzcGVjdCByYXRpb1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhpbXVtQXJlYSBNYXhpbXVtIGFyZWEgeW91IHdhbnQgdG8gYWNoaWV2ZVxuICAgICAqIEByZXR1cm4ge09iamVjdC54fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWFxuICAgICAqIEByZXR1cm4ge09iamVjdC55fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWVxuICAgICAqL1xuICAgIGxpbWl0RGltc0J5QXJlYTogZnVuY3Rpb24oYXIsIG1heGltdW1BcmVhKSB7XG4gICAgICB2YXIgcm91Z2hXaWR0aCA9IE1hdGguc3FydChtYXhpbXVtQXJlYSAqIGFyKSxcbiAgICAgICAgICBwZXJmTGltaXRTaXplWSA9IE1hdGguZmxvb3IobWF4aW11bUFyZWEgLyByb3VnaFdpZHRoKTtcbiAgICAgIHJldHVybiB7IHg6IE1hdGguZmxvb3Iocm91Z2hXaWR0aCksIHk6IHBlcmZMaW1pdFNpemVZIH07XG4gICAgfSxcblxuICAgIGNhcFZhbHVlOiBmdW5jdGlvbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHNjYWxlIGZvciB0aGUgb2JqZWN0IHNvdXJjZSB0byBmaXQgaW5zaWRlIHRoZSBvYmplY3QgZGVzdGluYXRpb24sXG4gICAgICoga2VlcGluZyBhc3BlY3QgcmF0aW8gaW50YWN0LlxuICAgICAqIHJlc3BlY3QgdGhlIHRvdGFsIGFsbG93ZWQgYXJlYSBmb3IgdGhlIGNhY2hlLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgZmFicmljLk9iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZS5oZWlnaHQgbmF0dXJhbCB1bnNjYWxlZCBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2Uud2lkdGggbmF0dXJhbCB1bnNjYWxlZCB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3QgfCBmYWJyaWMuT2JqZWN0fSBkZXN0aW5hdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbi5oZWlnaHQgbmF0dXJhbCB1bnNjYWxlZCBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbi53aWR0aCBuYXR1cmFsIHVuc2NhbGVkIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlIGZhY3RvciB0byBhcHBseSB0byBzb3VyY2UgdG8gZml0IGludG8gZGVzdGluYXRpb25cbiAgICAgKi9cbiAgICBmaW5kU2NhbGVUb0ZpdDogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGRlc3RpbmF0aW9uLndpZHRoIC8gc291cmNlLndpZHRoLCBkZXN0aW5hdGlvbi5oZWlnaHQgLyBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHNjYWxlIGZvciB0aGUgb2JqZWN0IHNvdXJjZSB0byBjb3ZlciBlbnRpcmVseSB0aGUgb2JqZWN0IGRlc3RpbmF0aW9uLFxuICAgICAqIGtlZXBpbmcgYXNwZWN0IHJhdGlvIGludGFjdC5cbiAgICAgKiByZXNwZWN0IHRoZSB0b3RhbCBhbGxvd2VkIGFyZWEgZm9yIHRoZSBjYWNoZS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdCB8IGZhYnJpYy5PYmplY3R9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2UuaGVpZ2h0IG5hdHVyYWwgdW5zY2FsZWQgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlLndpZHRoIG5hdHVyYWwgdW5zY2FsZWQgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgZmFicmljLk9iamVjdH0gZGVzdGluYXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzdGluYXRpb24uaGVpZ2h0IG5hdHVyYWwgdW5zY2FsZWQgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzdGluYXRpb24ud2lkdGggbmF0dXJhbCB1bnNjYWxlZCB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZSBmYWN0b3IgdG8gYXBwbHkgdG8gc291cmNlIHRvIGNvdmVyIGRlc3RpbmF0aW9uXG4gICAgICovXG4gICAgZmluZFNjYWxlVG9Db3ZlcjogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGRlc3RpbmF0aW9uLndpZHRoIC8gc291cmNlLndpZHRoLCBkZXN0aW5hdGlvbi5oZWlnaHQgLyBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYW4gYXJyYXkgb2YgNiBudW1iZXIgcmV0dXJucyBzb21ldGhpbmcgbGlrZSBgXCJtYXRyaXgoLi4ubnVtYmVycylcImBcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gYW4gYXJyYXkgd2l0aCA2IG51bWJlcnNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRyYW5zZm9ybSBtYXRyaXggZm9yIHN2Z1xuICAgICAqIEByZXR1cm4ge09iamVjdC55fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWVxuICAgICAqL1xuICAgIG1hdHJpeFRvU1ZHOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiAnbWF0cml4KCcgKyB0cmFuc2Zvcm0ubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC50b0ZpeGVkKHZhbHVlLCBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMpO1xuICAgICAgfSkuam9pbignICcpICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhbiBvYmplY3QgYW5kIGEgdHJhbnNmb3JtLCBhcHBseSB0aGUgaW52ZXJzZSB0cmFuc2Zvcm0gdG8gdGhlIG9iamVjdCxcbiAgICAgKiB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gcmVtb3ZlIGZyb20gdGhhdCBvYmplY3QgdGhhdCB0cmFuc2Zvcm1hdGlvbiwgc28gdGhhdFxuICAgICAqIGFkZGVkIGluIGEgc3BhY2Ugd2l0aCB0aGUgcmVtb3ZlZCB0cmFuc2Zvcm0sIHRoZSBvYmplY3Qgd2lsbCBiZSB0aGUgc2FtZSBhcyBiZWZvcmUuXG4gICAgICogUmVtb3ZpbmcgZnJvbSBhbiBvYmplY3QgYSB0cmFuc2Zvcm0gdGhhdCBzY2FsZSBieSAyIGlzIGxpa2Ugc2NhbGluZyBpdCBieSAxLzIuXG4gICAgICogUmVtb3ZpbmcgZnJvbSBhbiBvYmplY3QgYSB0cmFuc2Zyb20gdGhhdCByb3RhdGUgYnkgMzBkZWcgaXMgbGlrZSByb3RhdGluZyBieSAzMGRlZ1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgICogVGhpcyB1dGlsIGlzIHVzZWQgdG8gYWRkIG9iamVjdHMgaW5zaWRlIHRyYW5zZm9ybWVkIGdyb3VwcyBvciBuZXN0ZWQgZ3JvdXBzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IHRoZSBvYmplY3QgeW91IHdhbnQgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIHRoZSBkZXN0aW5hdGlvbiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICByZW1vdmVUcmFuc2Zvcm1Gcm9tT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIGludmVydGVkID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKHRyYW5zZm9ybSksXG4gICAgICAgICAgZmluYWxUcmFuc2Zvcm0gPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKGludmVydGVkLCBvYmplY3QuY2FsY093bk1hdHJpeCgpKTtcbiAgICAgIGZhYnJpYy51dGlsLmFwcGx5VHJhbnNmb3JtVG9PYmplY3Qob2JqZWN0LCBmaW5hbFRyYW5zZm9ybSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdpdmVuIGFuIG9iamVjdCBhbmQgYSB0cmFuc2Zvcm0sIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8gdGhlIG9iamVjdC5cbiAgICAgKiB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gY2hhbmdlIHRoZSBzcGFjZSB3aGVyZSB0aGUgb2JqZWN0IGlzIGRyYXduLlxuICAgICAqIEFkZGluZyB0byBhbiBvYmplY3QgYSB0cmFuc2Zvcm0gdGhhdCBzY2FsZSBieSAyIGlzIGxpa2Ugc2NhbGluZyBpdCBieSAyLlxuICAgICAqIFRoaXMgaXMgdXNlZCB3aGVuIHJlbW92aW5nIGFuIG9iamVjdCBmcm9tIGFuIGFjdGl2ZSBzZWxlY3Rpb24gZm9yIGV4YW1wbGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB5b3Ugd2FudCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gdGhlIGRlc3RpbmF0aW9uIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGFkZFRyYW5zZm9ybVRvT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIHRyYW5zZm9ybSkge1xuICAgICAgZmFicmljLnV0aWwuYXBwbHlUcmFuc2Zvcm1Ub09iamVjdChcbiAgICAgICAgb2JqZWN0LFxuICAgICAgICBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKHRyYW5zZm9ybSwgb2JqZWN0LmNhbGNPd25NYXRyaXgoKSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRpc2NhcmQgYW4gb2JqZWN0IHRyYW5zZm9ybSBzdGF0ZSBhbmQgYXBwbHkgdGhlIG9uZSBmcm9tIHRoZSBtYXRyaXguXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB5b3Ugd2FudCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gdGhlIGRlc3RpbmF0aW9uIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGFwcGx5VHJhbnNmb3JtVG9PYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKHRyYW5zZm9ybSksXG4gICAgICAgICAgY2VudGVyID0gbmV3IGZhYnJpYy5Qb2ludChvcHRpb25zLnRyYW5zbGF0ZVgsIG9wdGlvbnMudHJhbnNsYXRlWSk7XG4gICAgICBvYmplY3QuZmxpcFggPSBmYWxzZTtcbiAgICAgIG9iamVjdC5mbGlwWSA9IGZhbHNlO1xuICAgICAgb2JqZWN0LnNldCgnc2NhbGVYJywgb3B0aW9ucy5zY2FsZVgpO1xuICAgICAgb2JqZWN0LnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgb2JqZWN0LnNrZXdYID0gb3B0aW9ucy5za2V3WDtcbiAgICAgIG9iamVjdC5za2V3WSA9IG9wdGlvbnMuc2tld1k7XG4gICAgICBvYmplY3QuYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgb2JqZWN0LnNldFBvc2l0aW9uQnlPcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhIHdpZHRoIGFuZCBoZWlnaHQsIHJldHVybiB0aGUgc2l6ZSBvZiB0aGUgYm91bmRpbmcgYm94XG4gICAgICogdGhhdCBjYW4gY29udGFpbnMgdGhlIGJveCB3aXRoIHdpZHRoL2hlaWdodCB3aXRoIGFwcGxpZWQgdHJhbnNmb3JtXG4gICAgICogZGVzY3JpYmVkIGluIG9wdGlvbnMuXG4gICAgICogVXNlIHRvIGNhbGN1bGF0ZSB0aGUgYm94ZXMgYXJvdW5kIG9iamVjdHMgZm9yIGNvbnRyb2xzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNjYWxlWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNjYWxlWVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNrZXdYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2tld1lcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueH0gd2lkdGggb2YgY29udGFpbmluZ1xuICAgICAqIEByZXR1cm4ge09iamVjdC55fSBoZWlnaHQgb2YgY29udGFpbmluZ1xuICAgICAqL1xuICAgIHNpemVBZnRlclRyYW5zZm9ybTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgdmFyIGRpbVggPSB3aWR0aCAvIDIsIGRpbVkgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogLWRpbVgsXG4gICAgICAgICAgICAgIHk6IC1kaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBkaW1YLFxuICAgICAgICAgICAgICB5OiAtZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogLWRpbVgsXG4gICAgICAgICAgICAgIHk6IGRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IGRpbVgsXG4gICAgICAgICAgICAgIHk6IGRpbVlcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IGZhYnJpYy51dGlsLmNhbGNEaW1lbnNpb25zTWF0cml4KG9wdGlvbnMpLFxuICAgICAgICAgIGJib3ggPSBmYWJyaWMudXRpbC5tYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzKHBvaW50cywgdHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJib3gud2lkdGgsXG4gICAgICAgIHk6IGJib3guaGVpZ2h0LFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIDIgY2xpcCBwYXRocyBpbnRvIG9uZSB2aXN1YWxseSBlcXVhbCBjbGlwIHBhdGhcbiAgICAgKlxuICAgICAqICoqSU1QT1JUQU5UKio6XFxcbiAgICAgKiBEb2VzICoqTk9UKiogY2xvbmUgdGhlIGFyZ3VtZW50cywgY2xvbmUgdGhlbSBwcm9pciBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGEgd3JhcHBlciAoZ3JvdXApIHRoYXQgY29udGFpbnMgb25lIGNsaXAgcGF0aCBhbmQgaXMgY2xpcHBlZCBieSB0aGUgb3RoZXIgc28gY29udGVudCBpcyBrZXB0IHdoZXJlIGJvdGggb3ZlcmxhcC5cbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgaWYgYm90aCB0aGUgY2xpcCBwYXRocyBtYXkgaGF2ZSBuZXN0ZWQgY2xpcCBwYXRocyBvZiB0aGVpciBvd24sIHNvIGFzc2lnbmluZyBvbmUgdG8gdGhlIG90aGVyJ3MgY2xpcCBwYXRoIHByb3BlcnR5IGlzIG5vdCBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIGhhbmRsZSB0aGUgYGludmVydGVkYCBwcm9wZXJ0eSB3ZSBmb2xsb3cgbG9naWMgZGVzY3JpYmVkIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XFxcbiAgICAgKiAqKigxKSoqIGJvdGggY2xpcCBwYXRocyBhcmUgaW52ZXJ0ZWQgLSB0aGUgY2xpcCBwYXRocyBwYXNzIHRoZSBpbnZlcnRlZCBwcm9wIHRvIHRoZSB3cmFwcGVyIGFuZCBsb29zZSBpdCB0aGVtc2VsdmVzLlxcXG4gICAgICogKiooMikqKiBvbmUgaXMgaW52ZXJ0ZWQgYW5kIHRoZSBvdGhlciBpc24ndCAtIHRoZSB3cmFwcGVyIHNob3VsZG4ndCBiZWNvbWUgaW52ZXJ0ZWQgYW5kIHRoZSBpbnZlcnRlZCBjbGlwIHBhdGggbXVzdCBjbGlwIHRoZSBub24gaW52ZXJ0ZWQgb25lIHRvIHByb2R1Y2UgYW4gaWRlbnRpY2FsIHZpc3VhbCBlZmZlY3QuXFxcbiAgICAgKiAqKigzKSoqIGJvdGggY2xpcCBwYXRocyBhcmUgbm90IGludmVydGVkIC0gd3JhcHBlciBhbmQgY2xpcCBwYXRocyByZW1haW4gdW5jaGFuZ2VkLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBjMVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gYzJcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLk9iamVjdH0gbWVyZ2VkIGNsaXAgcGF0aFxuICAgICAqL1xuICAgIG1lcmdlQ2xpcFBhdGhzOiBmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgICB2YXIgYSA9IGMxLCBiID0gYzI7XG4gICAgICBpZiAoYS5pbnZlcnRlZCAmJiAhYi5pbnZlcnRlZCkge1xuICAgICAgICAvLyAgY2FzZSAoMilcbiAgICAgICAgYSA9IGMyO1xuICAgICAgICBiID0gYzE7XG4gICAgICB9XG4gICAgICAvLyAgYGJgIGJlY29tZXMgYGFgJ3MgY2xpcCBwYXRoIHNvIHdlIHRyYW5zZm9ybSBgYmAgdG8gYGFgIGNvb3JkaW5hdGUgcGxhbmVcbiAgICAgIGZhYnJpYy51dGlsLmFwcGx5VHJhbnNmb3JtVG9PYmplY3QoXG4gICAgICAgIGIsXG4gICAgICAgIGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgICAgZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKGEuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKSxcbiAgICAgICAgICBiLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgLy8gIGFzc2lnbiB0aGUgYGludmVydGVkYCBwcm9wIHRvIHRoZSB3cmFwcGluZyBncm91cFxuICAgICAgdmFyIGludmVydGVkID0gYS5pbnZlcnRlZCAmJiBiLmludmVydGVkO1xuICAgICAgaWYgKGludmVydGVkKSB7XG4gICAgICAgIC8vICBjYXNlICgxKVxuICAgICAgICBhLmludmVydGVkID0gYi5pbnZlcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuR3JvdXAoW2FdLCB7IGNsaXBQYXRoOiBiLCBpbnZlcnRlZDogaW52ZXJ0ZWQgfSk7XG4gICAgfSxcbiAgfTtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luLFxuICAgICAgY29tbWFuZExlbmd0aHMgPSB7XG4gICAgICAgIG06IDIsXG4gICAgICAgIGw6IDIsXG4gICAgICAgIGg6IDEsXG4gICAgICAgIHY6IDEsXG4gICAgICAgIGM6IDYsXG4gICAgICAgIHM6IDQsXG4gICAgICAgIHE6IDQsXG4gICAgICAgIHQ6IDIsXG4gICAgICAgIGE6IDdcbiAgICAgIH0sXG4gICAgICByZXBlYXRlZENvbW1hbmRzID0ge1xuICAgICAgICBtOiAnbCcsXG4gICAgICAgIE06ICdMJ1xuICAgICAgfTtcbiAgZnVuY3Rpb24gc2VnbWVudFRvQmV6aWVyKHRoMiwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpIHtcbiAgICB2YXIgY29zdGgyID0gZmFicmljLnV0aWwuY29zKHRoMiksXG4gICAgICAgIHNpbnRoMiA9IGZhYnJpYy51dGlsLnNpbih0aDIpLFxuICAgICAgICBjb3N0aDMgPSBmYWJyaWMudXRpbC5jb3ModGgzKSxcbiAgICAgICAgc2ludGgzID0gZmFicmljLnV0aWwuc2luKHRoMyksXG4gICAgICAgIHRvWCA9IGNvc1RoICogcnggKiBjb3N0aDMgLSBzaW5UaCAqIHJ5ICogc2ludGgzICsgY3gxLFxuICAgICAgICB0b1kgPSBzaW5UaCAqIHJ4ICogY29zdGgzICsgY29zVGggKiByeSAqIHNpbnRoMyArIGN5MSxcbiAgICAgICAgY3AxWCA9IGZyb21YICsgbVQgKiAoIC1jb3NUaCAqIHJ4ICogc2ludGgyIC0gc2luVGggKiByeSAqIGNvc3RoMiksXG4gICAgICAgIGNwMVkgPSBmcm9tWSArIG1UICogKCAtc2luVGggKiByeCAqIHNpbnRoMiArIGNvc1RoICogcnkgKiBjb3N0aDIpLFxuICAgICAgICBjcDJYID0gdG9YICsgbVQgKiAoIGNvc1RoICogcnggKiBzaW50aDMgKyBzaW5UaCAqIHJ5ICogY29zdGgzKSxcbiAgICAgICAgY3AyWSA9IHRvWSArIG1UICogKCBzaW5UaCAqIHJ4ICogc2ludGgzIC0gY29zVGggKiByeSAqIGNvc3RoMyk7XG5cbiAgICByZXR1cm4gWydDJyxcbiAgICAgIGNwMVgsIGNwMVksXG4gICAgICBjcDJYLCBjcDJZLFxuICAgICAgdG9YLCB0b1lcbiAgICBdO1xuICB9XG5cbiAgLyogQWRhcHRlZCBmcm9tIGh0dHA6Ly9keHIubW96aWxsYS5vcmcvbW96aWxsYS1jZW50cmFsL3NvdXJjZS9jb250ZW50L3N2Zy9jb250ZW50L3NyYy9uc1NWR1BhdGhEYXRhUGFyc2VyLmNwcFxuICAgKiBieSBBbmRyZWEgQm9nYXp6aSBjb2RlIGlzIHVuZGVyIE1QTC4gaWYgeW91IGRvbid0IGhhdmUgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIHlvdSBjYW4gdGFrZSBpdCBoZXJlXG4gICAqIGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wL1xuICAgKi9cbiAgZnVuY3Rpb24gYXJjVG9TZWdtZW50cyh0b1gsIHRvWSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgpIHtcbiAgICB2YXIgUEkgPSBNYXRoLlBJLCB0aCA9IHJvdGF0ZVggKiBQSSAvIDE4MCxcbiAgICAgICAgc2luVGggPSBmYWJyaWMudXRpbC5zaW4odGgpLFxuICAgICAgICBjb3NUaCA9IGZhYnJpYy51dGlsLmNvcyh0aCksXG4gICAgICAgIGZyb21YID0gMCwgZnJvbVkgPSAwO1xuXG4gICAgcnggPSBNYXRoLmFicyhyeCk7XG4gICAgcnkgPSBNYXRoLmFicyhyeSk7XG5cbiAgICB2YXIgcHggPSAtY29zVGggKiB0b1ggKiAwLjUgLSBzaW5UaCAqIHRvWSAqIDAuNSxcbiAgICAgICAgcHkgPSAtY29zVGggKiB0b1kgKiAwLjUgKyBzaW5UaCAqIHRvWCAqIDAuNSxcbiAgICAgICAgcngyID0gcnggKiByeCwgcnkyID0gcnkgKiByeSwgcHkyID0gcHkgKiBweSwgcHgyID0gcHggKiBweCxcbiAgICAgICAgcGwgPSByeDIgKiByeTIgLSByeDIgKiBweTIgLSByeTIgKiBweDIsXG4gICAgICAgIHJvb3QgPSAwO1xuXG4gICAgaWYgKHBsIDwgMCkge1xuICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMSAtIHBsIC8gKHJ4MiAqIHJ5MikpO1xuICAgICAgcnggKj0gcztcbiAgICAgIHJ5ICo9IHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcm9vdCA9IChsYXJnZSA9PT0gc3dlZXAgPyAtMS4wIDogMS4wKSAqXG4gICAgICAgICAgICAgIE1hdGguc3FydCggcGwgLyAocngyICogcHkyICsgcnkyICogcHgyKSk7XG4gICAgfVxuXG4gICAgdmFyIGN4ID0gcm9vdCAqIHJ4ICogcHkgLyByeSxcbiAgICAgICAgY3kgPSAtcm9vdCAqIHJ5ICogcHggLyByeCxcbiAgICAgICAgY3gxID0gY29zVGggKiBjeCAtIHNpblRoICogY3kgKyB0b1ggKiAwLjUsXG4gICAgICAgIGN5MSA9IHNpblRoICogY3ggKyBjb3NUaCAqIGN5ICsgdG9ZICogMC41LFxuICAgICAgICBtVGhldGEgPSBjYWxjVmVjdG9yQW5nbGUoMSwgMCwgKHB4IC0gY3gpIC8gcngsIChweSAtIGN5KSAvIHJ5KSxcbiAgICAgICAgZHRoZXRhID0gY2FsY1ZlY3RvckFuZ2xlKChweCAtIGN4KSAvIHJ4LCAocHkgLSBjeSkgLyByeSwgKC1weCAtIGN4KSAvIHJ4LCAoLXB5IC0gY3kpIC8gcnkpO1xuXG4gICAgaWYgKHN3ZWVwID09PSAwICYmIGR0aGV0YSA+IDApIHtcbiAgICAgIGR0aGV0YSAtPSAyICogUEk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN3ZWVwID09PSAxICYmIGR0aGV0YSA8IDApIHtcbiAgICAgIGR0aGV0YSArPSAyICogUEk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBpbnRvIGN1YmljIGJlemllciBzZWdtZW50cyA8PSA5MGRlZ1xuICAgIHZhciBzZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyhkdGhldGEgLyBQSSAqIDIpKSxcbiAgICAgICAgcmVzdWx0ID0gW10sIG1EZWx0YSA9IGR0aGV0YSAvIHNlZ21lbnRzLFxuICAgICAgICBtVCA9IDggLyAzICogTWF0aC5zaW4obURlbHRhIC8gNCkgKiBNYXRoLnNpbihtRGVsdGEgLyA0KSAvIE1hdGguc2luKG1EZWx0YSAvIDIpLFxuICAgICAgICB0aDMgPSBtVGhldGEgKyBtRGVsdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IHNlZ21lbnRUb0JlemllcihtVGhldGEsIHRoMywgY29zVGgsIHNpblRoLCByeCwgcnksIGN4MSwgY3kxLCBtVCwgZnJvbVgsIGZyb21ZKTtcbiAgICAgIGZyb21YID0gcmVzdWx0W2ldWzVdO1xuICAgICAgZnJvbVkgPSByZXN1bHRbaV1bNl07XG4gICAgICBtVGhldGEgPSB0aDM7XG4gICAgICB0aDMgKz0gbURlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLypcbiAgICogUHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY1ZlY3RvckFuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XG4gICAgdmFyIHRhID0gTWF0aC5hdGFuMih1eSwgdXgpLFxuICAgICAgICB0YiA9IE1hdGguYXRhbjIodnksIHZ4KTtcbiAgICBpZiAodGIgPj0gdGEpIHtcbiAgICAgIHJldHVybiB0YiAtIHRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAyICogTWF0aC5QSSAtICh0YSAtIHRiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGJvdW5kaW5nIGJveCBvZiBhIGJlemllcmN1cnZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MCBzdGFydGluZyBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgxIGZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBzZWNvbmRvIGNvbnRyb2wgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MyBlbmQgb2YgYmV6aWVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5M1xuICAgKi9cbiAgLy8gdGFrZW4gZnJvbSBodHRwOi8vanNiaW4uY29tL2l2b21pcS81Ni9lZGl0ICBubyBjcmVkaXRzIGF2YWlsYWJsZSBmb3IgdGhhdC5cbiAgLy8gVE9ETzogY2FuIHdlIG5vcm1hbGl6ZSB0aGlzIHdpdGggdGhlIHN0YXJ0aW5nIHBvaW50cyBzZXQgYXQgMCBhbmQgdGhlbiB0cmFuc2xhdGVkIHRoZSBiYm94P1xuICBmdW5jdGlvbiBnZXRCb3VuZHNPZkN1cnZlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBhcmdzU3RyaW5nO1xuICAgIGlmIChmYWJyaWMuY2FjaGVzQm91bmRzT2ZDdXJ2ZSkge1xuICAgICAgYXJnc1N0cmluZyA9IF9qb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGlmIChmYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgICBtaW4gPSBNYXRoLm1pbiwgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIGFicyA9IE1hdGguYWJzLCB0dmFsdWVzID0gW10sXG4gICAgICAgIGJvdW5kcyA9IFtbXSwgW11dLFxuICAgICAgICBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuXG4gICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgaWYgKGFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IC1jIC8gYjtcbiAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3FydGIyYWMgPSBzcXJ0KGIyYWMpO1xuICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQxKTtcbiAgICAgIH1cbiAgICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHgsIHksIGogPSB0dmFsdWVzLmxlbmd0aCwgamxlbiA9IGosIG10O1xuICAgIHdoaWxlIChqLS0pIHtcbiAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgbXQgPSAxIC0gdDtcbiAgICAgIHggPSAobXQgKiBtdCAqIG10ICogeDApICsgKDMgKiBtdCAqIG10ICogdCAqIHgxKSArICgzICogbXQgKiB0ICogdCAqIHgyKSArICh0ICogdCAqIHQgKiB4Myk7XG4gICAgICBib3VuZHNbMF1bal0gPSB4O1xuXG4gICAgICB5ID0gKG10ICogbXQgKiBtdCAqIHkwKSArICgzICogbXQgKiBtdCAqIHQgKiB5MSkgKyAoMyAqIG10ICogdCAqIHQgKiB5MikgKyAodCAqIHQgKiB0ICogeTMpO1xuICAgICAgYm91bmRzWzFdW2pdID0geTtcbiAgICB9XG5cbiAgICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICAgIHZhciByZXN1bHQgPSBbXG4gICAgICB7XG4gICAgICAgIHg6IG1pbi5hcHBseShudWxsLCBib3VuZHNbMF0pLFxuICAgICAgICB5OiBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzFdKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgeDogbWF4LmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICAgIHk6IG1heC5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgICB9XG4gICAgXTtcbiAgICBpZiAoZmFicmljLmNhY2hlc0JvdW5kc09mQ3VydmUpIHtcbiAgICAgIGZhYnJpYy5ib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10gPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYXJjIHRvIGEgYnVuY2ggb2YgYmV6aWVyIGN1cnZlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZnggc3RhcnRpbmcgcG9pbnQgeFxuICAgKiBAcGFyYW0ge051bWJlcn0gZnkgc3RhcnRpbmcgcG9pbnQgeVxuICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgQXJjIGNvbW1hbmRcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21BcmNUb0JlemllcnMoZngsIGZ5LCBjb29yZHMpIHtcbiAgICB2YXIgcnggPSBjb29yZHNbMV0sXG4gICAgICAgIHJ5ID0gY29vcmRzWzJdLFxuICAgICAgICByb3QgPSBjb29yZHNbM10sXG4gICAgICAgIGxhcmdlID0gY29vcmRzWzRdLFxuICAgICAgICBzd2VlcCA9IGNvb3Jkc1s1XSxcbiAgICAgICAgdHggPSBjb29yZHNbNl0sXG4gICAgICAgIHR5ID0gY29vcmRzWzddLFxuICAgICAgICBzZWdzTm9ybSA9IGFyY1RvU2VnbWVudHModHggLSBmeCwgdHkgLSBmeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2Vnc05vcm0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNlZ3NOb3JtW2ldWzFdICs9IGZ4O1xuICAgICAgc2Vnc05vcm1baV1bMl0gKz0gZnk7XG4gICAgICBzZWdzTm9ybVtpXVszXSArPSBmeDtcbiAgICAgIHNlZ3NOb3JtW2ldWzRdICs9IGZ5O1xuICAgICAgc2Vnc05vcm1baV1bNV0gKz0gZng7XG4gICAgICBzZWdzTm9ybVtpXVs2XSArPSBmeTtcbiAgICB9XG4gICAgcmV0dXJuIHNlZ3NOb3JtO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2UgYSBwYXJzZWQgU1ZHIHBhdGggYW5kIG1ha2UgaXQgc2ltcGxlciBmb3IgZmFicmljSlMgbG9naWMuXG4gICAqIHNpbXBsaWZpY2F0aW9uIGNvbnNpc3Qgb2Y6IG9ubHkgVVBQRVJDQVNFIGFic29sdXRlIGNvbW1hbmRzICggcmVsYXRpdmUgY29udmVydGVkIHRvIGFic29sdXRlIClcbiAgICogUyBjb252ZXJ0ZWQgaW4gQywgVCBjb252ZXJ0ZWQgaW4gUSwgQSBjb252ZXJ0ZWQgaW4gQy5cbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aCB0aGUgYXJyYXkgb2YgY29tbWFuZHMgb2YgYSBwYXJzZWQgc3ZnIHBhdGggZm9yIGZhYnJpYy5QYXRoXG4gICAqIEByZXR1cm4ge0FycmF5fSB0aGUgc2ltcGxpZmllZCBhcnJheSBvZiBjb21tYW5kcyBvZiBhIHBhcnNlZCBzdmcgcGF0aCBmb3IgZmFicmljLlBhdGhcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VQYXRoU2ltcGxlcihwYXRoKSB7XG4gICAgLy8geCBhbmQgeSByZXByZXNlbnQgdGhlIGxhc3QgcG9pbnQgb2YgdGhlIHBhdGguIHRoZSBwcmV2aW91cyBjb21tYW5kIHBvaW50LlxuICAgIC8vIHdlIGFkZCB0aGVtIHRvIGVhY2ggcmVsYXRpdmUgY29tbWFuZCB0byBtYWtlIGl0IGFuIGFic29sdXRlIGNvbW1lbnQuXG4gICAgLy8gd2UgYWxzbyBzd2FwIHRoZSB2IFYgaCBIIHdpdGggTCwgYmVjYXVzZSBhcmUgZWFzaWVyIHRvIHRyYW5zZm9ybS5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBsZW4gPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgLy8geDEgYW5kIHkxIHJlcHJlc2VudCB0aGUgbGFzdCBwb2ludCBvZiB0aGUgc3VicGF0aC4gdGhlIHN1YnBhdGggaXMgc3RhcnRlZCB3aXRoXG4gICAgICAgIC8vIG0gb3IgTSBjb21tYW5kLiBXaGVuIGEgeiBvciBaIGNvbW1hbmQgaXMgZHJhd24sIHggYW5kIHkgbmVlZCB0byBiZSByZXNldHRlZCB0b1xuICAgICAgICAvLyB0aGUgbGFzdCB4MSBhbmQgeTEuXG4gICAgICAgIHgxID0gMCwgeTEgPSAwLCBjdXJyZW50LCBpLCBjb252ZXJ0ZWQsXG4gICAgICAgIC8vIHByZXZpb3VzIHdpbGwgaG9zdCB0aGUgbGV0dGVyIG9mIHRoZSBwcmV2aW91cyBjb21tYW5kLCB0byBoYW5kbGUgUyBhbmQgVC5cbiAgICAgICAgLy8gY29udHJvbFggYW5kIGNvbnRyb2xZIHdpbGwgaG9zdCB0aGUgcHJldmlvdXMgcmVmbGVjdGVkIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgZGVzdGluYXRpb25QYXRoID0gW10sIHByZXZpb3VzLCBjb250cm9sWCwgY29udHJvbFk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb252ZXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGN1cnJlbnQgPSBwYXRoW2ldLnNsaWNlKDApO1xuICAgICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuICAgICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnTCc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgY3VycmVudFswXSA9ICdMJztcbiAgICAgICAgICBjdXJyZW50WzJdID0geTtcbiAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndic6IC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0wnO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGN1cnJlbnRbMV0gPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gPSB5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtJzogLy8gbW92ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnTSc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIHgxID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5MSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2MnOiAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnQyc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICBjdXJyZW50WzNdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSArPSB5O1xuICAgICAgICAgIGN1cnJlbnRbNV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzZdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdTJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIGN1cnJlbnRbM10gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzRdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAvLyB3b3VsZCBiZSBzU2NDIGJ1dCBzaW5jZSB3ZSBhcmUgc3dhcHBpbmcgc1NjIGZvciBDLCB3ZSBjaGVjayBqdXN0IHRoYXQuXG4gICAgICAgICAgaWYgKHByZXZpb3VzID09PSAnQycpIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB4ID0gY3VycmVudFszXTtcbiAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0MnO1xuICAgICAgICAgIGN1cnJlbnRbNV0gPSBjdXJyZW50WzNdO1xuICAgICAgICAgIGN1cnJlbnRbNl0gPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGN1cnJlbnRbM10gPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGN1cnJlbnRbNF0gPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGN1cnJlbnRbMV0gPSBjb250cm9sWDtcbiAgICAgICAgICBjdXJyZW50WzJdID0gY29udHJvbFk7XG4gICAgICAgICAgLy8gY3VycmVudFszXSBhbmQgY3VycmVudFs0XSBhcmUgTk9XIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAgICAgICAvLyB3ZSBrZWVwIGl0IGZvciB0aGUgbmV4dCByZWZsZWN0aW9uLlxuICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnUSc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICBjdXJyZW50WzNdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgICB4ID0gY3VycmVudFszXTtcbiAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnVCc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50WzBdID0gJ1EnO1xuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGN1cnJlbnRbMV0gPSBjb250cm9sWDtcbiAgICAgICAgICBjdXJyZW50WzJdID0gY29udHJvbFk7XG4gICAgICAgICAgY3VycmVudFszXSA9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSA9IHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnQSc7XG4gICAgICAgICAgY3VycmVudFs2XSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbN10gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIGNvbnZlcnRlZCA9IHRydWU7XG4gICAgICAgICAgZGVzdGluYXRpb25QYXRoID0gZGVzdGluYXRpb25QYXRoLmNvbmNhdChmcm9tQXJjVG9CZXppZXJzKHgsIHksIGN1cnJlbnQpKTtcbiAgICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneic6XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgIHggPSB4MTtcbiAgICAgICAgICB5ID0geTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgICBpZiAoIWNvbnZlcnRlZCkge1xuICAgICAgICBkZXN0aW5hdGlvblBhdGgucHVzaChjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzID0gY3VycmVudFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uUGF0aDtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsYyBsZW5ndGggZnJvbSBwb2ludCB4MSx5MSB0byB4Mix5MlxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgc3RhcnRpbmcgcG9pbnQgeFxuICAgKiBAcGFyYW0ge051bWJlcn0geTEgc3RhcnRpbmcgcG9pbnQgeVxuICAgKiBAcGFyYW0ge051bWJlcn0geDIgc3RhcnRpbmcgcG9pbnQgeFxuICAgKiBAcGFyYW0ge051bWJlcn0geTIgc3RhcnRpbmcgcG9pbnQgeVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiBzZWdtZW50XG4gICAqL1xuICBmdW5jdGlvbiBjYWxjTGluZUxlbmd0aCh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgfVxuXG4gIC8vIGZ1bmN0aW9ucyBmb3IgdGhlIEN1YmljIGJlaXplclxuICAvLyB0YWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20va29udmFqcy9rb252YS9ibG9iLzcuMC41L3NyYy9zaGFwZXMvUGF0aC50cyNMMzUwXG4gIGZ1bmN0aW9uIENCMSh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBmdW5jdGlvbiBDQjIodCkge1xuICAgIHJldHVybiAzICogdCAqIHQgKiAoMSAtIHQpO1xuICB9XG4gIGZ1bmN0aW9uIENCMyh0KSB7XG4gICAgcmV0dXJuIDMgKiB0ICogKDEgLSB0KSAqICgxIC0gdCk7XG4gIH1cbiAgZnVuY3Rpb24gQ0I0KHQpIHtcbiAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UG9pbnRPbkN1YmljQmV6aWVySXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgcDR4LCBwNHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocGN0KSB7XG4gICAgICB2YXIgYzEgPSBDQjEocGN0KSwgYzIgPSBDQjIocGN0KSwgYzMgPSBDQjMocGN0KSwgYzQgPSBDQjQocGN0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHA0eCAqIGMxICsgcDN4ICogYzIgKyBwMnggKiBjMyArIHAxeCAqIGM0LFxuICAgICAgICB5OiBwNHkgKiBjMSArIHAzeSAqIGMyICsgcDJ5ICogYzMgKyBwMXkgKiBjNFxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFuZ2VudEN1YmljSXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgcDR4LCBwNHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBjdCkge1xuICAgICAgdmFyIGludlQgPSAxIC0gcGN0LFxuICAgICAgICAgIHRhbmdlbnRYID0gKDMgKiBpbnZUICogaW52VCAqIChwMnggLSBwMXgpKSArICg2ICogaW52VCAqIHBjdCAqIChwM3ggLSBwMngpKSArXG4gICAgICAgICAgKDMgKiBwY3QgKiBwY3QgKiAocDR4IC0gcDN4KSksXG4gICAgICAgICAgdGFuZ2VudFkgPSAoMyAqIGludlQgKiBpbnZUICogKHAyeSAtIHAxeSkpICsgKDYgKiBpbnZUICogcGN0ICogKHAzeSAtIHAyeSkpICtcbiAgICAgICAgICAoMyAqIHBjdCAqIHBjdCAqIChwNHkgLSBwM3kpKTtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRhbmdlbnRZLCB0YW5nZW50WCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFFCMSh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9XG5cbiAgZnVuY3Rpb24gUUIyKHQpIHtcbiAgICByZXR1cm4gMiAqIHQgKiAoMSAtIHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gUUIzKHQpIHtcbiAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVySXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgIHJldHVybiBmdW5jdGlvbihwY3QpIHtcbiAgICAgIHZhciBjMSA9IFFCMShwY3QpLCBjMiA9IFFCMihwY3QpLCBjMyA9IFFCMyhwY3QpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcDN4ICogYzEgKyBwMnggKiBjMiArIHAxeCAqIGMzLFxuICAgICAgICB5OiBwM3kgKiBjMSArIHAyeSAqIGMyICsgcDF5ICogYzNcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhbmdlbnRRdWFkcmF0aWNJdGVyYXRvcihwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwY3QpIHtcbiAgICAgIHZhciBpbnZUID0gMSAtIHBjdCxcbiAgICAgICAgICB0YW5nZW50WCA9ICgyICogaW52VCAqIChwMnggLSBwMXgpKSArICgyICogcGN0ICogKHAzeCAtIHAyeCkpLFxuICAgICAgICAgIHRhbmdlbnRZID0gKDIgKiBpbnZUICogKHAyeSAtIHAxeSkpICsgKDIgKiBwY3QgKiAocDN5IC0gcDJ5KSk7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih0YW5nZW50WSwgdGFuZ2VudFgpO1xuICAgIH07XG4gIH1cblxuXG4gIC8vIHRoaXMgd2lsbCBydW4gb3ZlciBhIHBhdGggc2VnbWVudCAoIGEgY3ViaWMgb3IgcXVhZHJhdGljIHNlZ21lbnQpIGFuZCBhcHByb3hpbWF0ZSBpdFxuICAvLyB3aXRoIDEwMCBzZWdlbW50cy4gVGhpcyB3aWxsIGdvb2QgZW5vdWdoIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBjdXJ2ZVxuICBmdW5jdGlvbiBwYXRoSXRlcmF0b3IoaXRlcmF0b3IsIHgxLCB5MSkge1xuICAgIHZhciB0ZW1wUCA9IHsgeDogeDEsIHk6IHkxIH0sIHAsIHRtcExlbiA9IDAsIHBlcmM7XG4gICAgZm9yIChwZXJjID0gMTsgcGVyYyA8PSAxMDA7IHBlcmMgKz0gMSkge1xuICAgICAgcCA9IGl0ZXJhdG9yKHBlcmMgLyAxMDApO1xuICAgICAgdG1wTGVuICs9IGNhbGNMaW5lTGVuZ3RoKHRlbXBQLngsIHRlbXBQLnksIHAueCwgcC55KTtcbiAgICAgIHRlbXBQID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHRtcExlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHBhdGhJbmZvLCBhbmQgYSBkaXN0YW5jZSBpbiBwaXhlbHMsIGZpbmQgdGhlIHBlcmNlbnRhZ2UgZnJvbSAwIHRvIDFcbiAgICogdGhhdCBjb3JyZXNwb25kIHRvIHRoYXQgcGl4ZWxzIHJ1biBvdmVyIHRoZSBwYXRoLlxuICAgKiBUaGUgcGVyY2VudGFnZSB3aWxsIGJlIHRoZW4gdXNlZCB0byBmaW5kIHRoZSBjb3JyZWN0IHBvaW50IG9uIHRoZSBjYW52YXMgZm9yIHRoZSBwYXRoLlxuICAgKiBAcGFyYW0ge0FycmF5fSBzZWdJbmZvIGZhYnJpY0pTIGNvbGxlY3Rpb24gb2YgaW5mb3JtYXRpb24gb24gYSBwYXJzZWQgcGF0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2UgZnJvbSBzdGFydGluZyBwb2ludCwgaW4gcGl4ZWxzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluZm8gb2JqZWN0IHdpdGggeCBhbmQgeSAoIHRoZSBwb2ludCBvbiBjYW52YXMgKSBhbmQgYW5nbGUsIHRoZSB0YW5nZW50IG9uIHRoYXQgcG9pbnQ7XG4gICAqL1xuICBmdW5jdGlvbiBmaW5kUGVyY2VudGFnZUZvckRpc3RhbmNlKHNlZ0luZm8sIGRpc3RhbmNlKSB7XG4gICAgdmFyIHBlcmMgPSAwLCB0bXBMZW4gPSAwLCBpdGVyYXRvciA9IHNlZ0luZm8uaXRlcmF0b3IsIHRlbXBQID0geyB4OiBzZWdJbmZvLngsIHk6IHNlZ0luZm8ueSB9LFxuICAgICAgICBwLCBuZXh0TGVuLCBuZXh0U3RlcCA9IDAuMDEsIGFuZ2xlRmluZGVyID0gc2VnSW5mby5hbmdsZUZpbmRlciwgbGFzdFBlcmM7XG4gICAgLy8gbmV4dFN0ZXAgPiAwLjAwMDEgY292ZXJzIDAuMDAwMTU2MjUgdGhhdCAxLzY0dGggb2YgMS8xMDBcbiAgICAvLyB0aGUgcGF0aFxuICAgIHdoaWxlICh0bXBMZW4gPCBkaXN0YW5jZSAmJiBuZXh0U3RlcCA+IDAuMDAwMSkge1xuICAgICAgcCA9IGl0ZXJhdG9yKHBlcmMpO1xuICAgICAgbGFzdFBlcmMgPSBwZXJjO1xuICAgICAgbmV4dExlbiA9IGNhbGNMaW5lTGVuZ3RoKHRlbXBQLngsIHRlbXBQLnksIHAueCwgcC55KTtcbiAgICAgIC8vIGNvbXBhcmUgdG1wTGVuIGVhY2ggY3ljbGUgd2l0aCBkaXN0YW5jZSwgZGVjaWRlIG5leHQgcGVyYyB0byB0ZXN0LlxuICAgICAgaWYgKChuZXh0TGVuICsgdG1wTGVuKSA+IGRpc3RhbmNlKSB7XG4gICAgICAgIC8vIHdlIGRpc2NhcmQgdGhpcyBzdGVwIGFuZCB3ZSBtYWtlIHNtYWxsZXIgc3RlcHMuXG4gICAgICAgIHBlcmMgLT0gbmV4dFN0ZXA7XG4gICAgICAgIG5leHRTdGVwIC89IDI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGVtcFAgPSBwO1xuICAgICAgICBwZXJjICs9IG5leHRTdGVwO1xuICAgICAgICB0bXBMZW4gKz0gbmV4dExlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcC5hbmdsZSA9IGFuZ2xlRmluZGVyKGxhc3RQZXJjKTtcbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gb3ZlciBhIHBhcnNlZCBhbmQgc2ltcGxpZmVkIHBhdGggYW5kIGV4dHJhYyBzb21lIGluZm9ybWF0aW9ucy5cbiAgICogaW5mb3JtYXRpb25zIGFyZSBsZW5ndGggb2YgZWFjaCBjb21tYW5kIGFuZCBzdGFydGluZyBwb2ludFxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIGZhYnJpY0pTIHBhcnNlZCBwYXRoIGNvbW1hbmRzXG4gICAqIEByZXR1cm4ge0FycmF5fSBwYXRoIGNvbW1hbmRzIGluZm9ybWF0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UGF0aFNlZ21lbnRzSW5mbyhwYXRoKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gMCwgbGVuID0gcGF0aC5sZW5ndGgsIGN1cnJlbnQsXG4gICAgICAgIC8veDIgYW5kIHkyIGFyZSB0aGUgY29vcmRzIG9mIHNlZ21lbnQgc3RhcnRcbiAgICAgICAgLy94MSBhbmQgeTEgYXJlIHRoZSBjb29yZHMgb2YgdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgeDEgPSAwLCB5MSA9IDAsIHgyID0gMCwgeTIgPSAwLCBpbmZvID0gW10sIGl0ZXJhdG9yLCB0ZW1wSW5mbywgYW5nbGVGaW5kZXI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY3VycmVudCA9IHBhdGhbaV07XG4gICAgICB0ZW1wSW5mbyA9IHtcbiAgICAgICAgeDogeDEsXG4gICAgICAgIHk6IHkxLFxuICAgICAgICBjb21tYW5kOiBjdXJyZW50WzBdLFxuICAgICAgfTtcbiAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvL2ZpcnN0IGxldHRlclxuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSAwO1xuICAgICAgICAgIHgyID0geDEgPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkyID0geTEgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSBjYWxjTGluZUxlbmd0aCh4MSwgeTEsIGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0pO1xuICAgICAgICAgIHgxID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5MSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgIGl0ZXJhdG9yID0gZ2V0UG9pbnRPbkN1YmljQmV6aWVySXRlcmF0b3IoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICBjdXJyZW50WzZdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhbmdsZUZpbmRlciA9IGdldFRhbmdlbnRDdWJpY0l0ZXJhdG9yKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgY3VycmVudFs2XVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGVtcEluZm8uaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICAgICAgICB0ZW1wSW5mby5hbmdsZUZpbmRlciA9IGFuZ2xlRmluZGVyO1xuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IHBhdGhJdGVyYXRvcihpdGVyYXRvciwgeDEsIHkxKTtcbiAgICAgICAgICB4MSA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgeTEgPSBjdXJyZW50WzZdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICBpdGVyYXRvciA9IGdldFBvaW50T25RdWFkcmF0aWNCZXppZXJJdGVyYXRvcihcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICBjdXJyZW50WzRdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhbmdsZUZpbmRlciA9IGdldFRhbmdlbnRRdWFkcmF0aWNJdGVyYXRvcihcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICBjdXJyZW50WzRdXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0ZW1wSW5mby5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgICAgIHRlbXBJbmZvLmFuZ2xlRmluZGVyID0gYW5nbGVGaW5kZXI7XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gcGF0aEl0ZXJhdG9yKGl0ZXJhdG9yLCB4MSwgeTEpO1xuICAgICAgICAgIHgxID0gY3VycmVudFszXTtcbiAgICAgICAgICB5MSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAvLyB3ZSBhZGQgdGhvc2UgaW4gb3JkZXIgdG8gZWFzZSBjYWxjdWxhdGlvbnMgbGF0ZXJcbiAgICAgICAgICB0ZW1wSW5mby5kZXN0WCA9IHgyO1xuICAgICAgICAgIHRlbXBJbmZvLmRlc3RZID0geTI7XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gY2FsY0xpbmVMZW5ndGgoeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgIHgxID0geDI7XG4gICAgICAgICAgeTEgPSB5MjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRvdGFsTGVuZ3RoICs9IHRlbXBJbmZvLmxlbmd0aDtcbiAgICAgIGluZm8ucHVzaCh0ZW1wSW5mbyk7XG4gICAgfVxuICAgIGluZm8ucHVzaCh7IGxlbmd0aDogdG90YWxMZW5ndGgsIHg6IHgxLCB5OiB5MSB9KTtcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBvaW50T25QYXRoKHBhdGgsIGRpc3RhbmNlLCBpbmZvcykge1xuICAgIGlmICghaW5mb3MpIHtcbiAgICAgIGluZm9zID0gZ2V0UGF0aFNlZ21lbnRzSW5mbyhwYXRoKTtcbiAgICB9XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICgoZGlzdGFuY2UgLSBpbmZvc1tpXS5sZW5ndGggPiAwKSAmJiBpIDwgKGluZm9zLmxlbmd0aCAtIDIpKSB7XG4gICAgICBkaXN0YW5jZSAtPSBpbmZvc1tpXS5sZW5ndGg7XG4gICAgICBpKys7XG4gICAgfVxuICAgIC8vIHZhciBkaXN0YW5jZSA9IGluZm9zW2luZm9zLmxlbmd0aCAtIDFdICogcGVyYztcbiAgICB2YXIgc2VnSW5mbyA9IGluZm9zW2ldLCBzZWdQZXJjZW50ID0gZGlzdGFuY2UgLyBzZWdJbmZvLmxlbmd0aCxcbiAgICAgICAgY29tbWFuZCA9IHNlZ0luZm8uY29tbWFuZCwgc2VnbWVudCA9IHBhdGhbaV0sIGluZm87XG5cbiAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICByZXR1cm4geyB4OiBzZWdJbmZvLngsIHk6IHNlZ0luZm8ueSwgYW5nbGU6IDAgfTtcbiAgICAgIGNhc2UgJ1onOlxuICAgICAgY2FzZSAneic6XG4gICAgICAgIGluZm8gPSBuZXcgZmFicmljLlBvaW50KHNlZ0luZm8ueCwgc2VnSW5mby55KS5sZXJwKFxuICAgICAgICAgIG5ldyBmYWJyaWMuUG9pbnQoc2VnSW5mby5kZXN0WCwgc2VnSW5mby5kZXN0WSksXG4gICAgICAgICAgc2VnUGVyY2VudFxuICAgICAgICApO1xuICAgICAgICBpbmZvLmFuZ2xlID0gTWF0aC5hdGFuMihzZWdJbmZvLmRlc3RZIC0gc2VnSW5mby55LCBzZWdJbmZvLmRlc3RYIC0gc2VnSW5mby54KTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgaW5mbyA9IG5ldyBmYWJyaWMuUG9pbnQoc2VnSW5mby54LCBzZWdJbmZvLnkpLmxlcnAoXG4gICAgICAgICAgbmV3IGZhYnJpYy5Qb2ludChzZWdtZW50WzFdLCBzZWdtZW50WzJdKSxcbiAgICAgICAgICBzZWdQZXJjZW50XG4gICAgICAgICk7XG4gICAgICAgIGluZm8uYW5nbGUgPSBNYXRoLmF0YW4yKHNlZ21lbnRbMl0gLSBzZWdJbmZvLnksIHNlZ21lbnRbMV0gLSBzZWdJbmZvLngpO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICByZXR1cm4gZmluZFBlcmNlbnRhZ2VGb3JEaXN0YW5jZShzZWdJbmZvLCBkaXN0YW5jZSk7XG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgcmV0dXJuIGZpbmRQZXJjZW50YWdlRm9yRGlzdGFuY2Uoc2VnSW5mbywgZGlzdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICAgKiBAcmV0dXJuIHsoc3RyaW5nfG51bWJlcilbXVtdfSBBbiBhcnJheSBvZiBTVkcgcGF0aCBjb21tYW5kc1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2FnZTwvY2FwdGlvbj5cbiAgICogcGFyc2VQYXRoKCdNIDMgNCBRIDMgNSAyIDEgNCAwIFEgOSAxMiAyIDEgNCAwJykgPT09IFtcbiAgICogICBbJ00nLCAzLCA0XSxcbiAgICogICBbJ1EnLCAzLCA1LCAyLCAxLCA0LCAwXSxcbiAgICogICBbJ1EnLCA5LCAxMiwgMiwgMSwgNCwgMF0sXG4gICAqIF07XG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aFN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgY29vcmRzID0gW10sXG4gICAgICAgIGN1cnJlbnRQYXRoLFxuICAgICAgICBwYXJzZWQsXG4gICAgICAgIHJlID0gZmFicmljLnJlUGF0aENvbW1hbmQsXG4gICAgICAgIHJOdW1iZXIgPSAnWy0rXT8oPzpcXFxcZCpcXFxcLlxcXFxkK3xcXFxcZCtcXFxcLj8pKD86W2VFXVstK10/XFxcXGQrKT9cXFxccyonLFxuICAgICAgICByTnVtYmVyQ29tbWFXc3AgPSAnKCcgKyByTnVtYmVyICsgJyknICsgZmFicmljLmNvbW1hV3NwLFxuICAgICAgICByRmxhZ0NvbW1hV3NwID0gJyhbMDFdKScgKyBmYWJyaWMuY29tbWFXc3AgKyAnPycsXG4gICAgICAgIHJBcmNTZXEgPSByTnVtYmVyQ29tbWFXc3AgKyAnPycgKyByTnVtYmVyQ29tbWFXc3AgKyAnPycgKyByTnVtYmVyQ29tbWFXc3AgKyByRmxhZ0NvbW1hV3NwICsgckZsYWdDb21tYVdzcCArXG4gICAgICAgICAgck51bWJlckNvbW1hV3NwICsgJz8oJyArIHJOdW1iZXIgKyAnKScsXG4gICAgICAgIHJlZ0FyY0FyZ3VtZW50U2VxdWVuY2UgPSBuZXcgUmVnRXhwKHJBcmNTZXEsICdnJyksXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBjb29yZHNTdHIsXG4gICAgICAgIC8vIG9uZSBvZiBjb21tYW5kcyAobSxNLGwsTCxxLFEsYyxDLGV0Yy4pIGZvbGxvd2VkIGJ5IG5vbi1jb21tYW5kIGNoYXJhY3RlcnMgKGkuZS4gY29tbWFuZCB2YWx1ZXMpXG4gICAgICAgIHBhdGg7XG4gICAgaWYgKCFwYXRoU3RyaW5nIHx8ICFwYXRoU3RyaW5nLm1hdGNoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXRoID0gcGF0aFN0cmluZy5tYXRjaCgvW216bGh2Y3NxdGFdW15temxodmNzcXRhXSovZ2kpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGNvb3Jkc1BhcnNlZCwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY3VycmVudFBhdGggPSBwYXRoW2ldO1xuXG4gICAgICBjb29yZHNTdHIgPSBjdXJyZW50UGF0aC5zbGljZSgxKS50cmltKCk7XG4gICAgICBjb29yZHMubGVuZ3RoID0gMDtcblxuICAgICAgdmFyIGNvbW1hbmQgPSBjdXJyZW50UGF0aC5jaGFyQXQoMCk7XG4gICAgICBjb29yZHNQYXJzZWQgPSBbY29tbWFuZF07XG5cbiAgICAgIGlmIChjb21tYW5kLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuICAgICAgICAvLyBhcmNzIGhhdmUgc3BlY2lhbCBmbGFncyB0aGF0IGFwcGFyZW50bHkgZG9uJ3QgcmVxdWlyZSBzcGFjZXMgc28gaGFuZGxlIHNwZWNpYWxcbiAgICAgICAgZm9yICh2YXIgYXJnczsgKGFyZ3MgPSByZWdBcmNBcmd1bWVudFNlcXVlbmNlLmV4ZWMoY29vcmRzU3RyKSk7KSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb29yZHMucHVzaChhcmdzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhjb29yZHNTdHIpKSkge1xuICAgICAgICAgIGNvb3Jkcy5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgcGFyc2VkID0gcGFyc2VGbG9hdChjb29yZHNbal0pO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICBjb29yZHNQYXJzZWQucHVzaChwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21tYW5kTGVuZ3RoID0gY29tbWFuZExlbmd0aHNbY29tbWFuZC50b0xvd2VyQ2FzZSgpXSxcbiAgICAgICAgICByZXBlYXRlZENvbW1hbmQgPSByZXBlYXRlZENvbW1hbmRzW2NvbW1hbmRdIHx8IGNvbW1hbmQ7XG5cbiAgICAgIGlmIChjb29yZHNQYXJzZWQubGVuZ3RoIC0gMSA+IGNvbW1hbmRMZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IDEsIGtsZW4gPSBjb29yZHNQYXJzZWQubGVuZ3RoOyBrIDwga2xlbjsgayArPSBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goW2NvbW1hbmRdLmNvbmNhdChjb29yZHNQYXJzZWQuc2xpY2UoaywgayArIGNvbW1hbmRMZW5ndGgpKSk7XG4gICAgICAgICAgY29tbWFuZCA9IHJlcGVhdGVkQ29tbWFuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvb3Jkc1BhcnNlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogQ29udmVydHMgcG9pbnRzIHRvIGEgc21vb3RoIFNWRyBwYXRoXG4gICAqIEBwYXJhbSB7eyB4OiBudW1iZXIseTogbnVtYmVyIH1bXX0gcG9pbnRzIEFycmF5IG9mIHBvaW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvcnJlY3Rpb25dIEFwcGx5IGEgY29ycmVjdGlvbiB0byB0aGUgcGF0aCAodXN1YWxseSB3ZSB1c2UgYHdpZHRoIC8gMTAwMGApLiBJZiB2YWx1ZSBpcyB1bmRlZmluZWQgMCBpcyB1c2VkIGFzIHRoZSBjb3JyZWN0aW9uIHZhbHVlLlxuICAgKiBAcmV0dXJuIHsoc3RyaW5nfG51bWJlcilbXVtdfSBBbiBhcnJheSBvZiBTVkcgcGF0aCBjb21tYW5kc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U21vb3RoUGF0aEZyb21Qb2ludHMocG9pbnRzLCBjb3JyZWN0aW9uKSB7XG4gICAgdmFyIHBhdGggPSBbXSwgaSxcbiAgICAgICAgcDEgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1swXS54LCBwb2ludHNbMF0ueSksXG4gICAgICAgIHAyID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpLFxuICAgICAgICBsZW4gPSBwb2ludHMubGVuZ3RoLCBtdWx0U2lnblggPSAxLCBtdWx0U2lnblkgPSAwLCBtYW55UG9pbnRzID0gbGVuID4gMjtcbiAgICBjb3JyZWN0aW9uID0gY29ycmVjdGlvbiB8fCAwO1xuXG4gICAgaWYgKG1hbnlQb2ludHMpIHtcbiAgICAgIG11bHRTaWduWCA9IHBvaW50c1syXS54IDwgcDIueCA/IC0xIDogcG9pbnRzWzJdLnggPT09IHAyLnggPyAwIDogMTtcbiAgICAgIG11bHRTaWduWSA9IHBvaW50c1syXS55IDwgcDIueSA/IC0xIDogcG9pbnRzWzJdLnkgPT09IHAyLnkgPyAwIDogMTtcbiAgICB9XG4gICAgcGF0aC5wdXNoKFsnTScsIHAxLnggLSBtdWx0U2lnblggKiBjb3JyZWN0aW9uLCBwMS55IC0gbXVsdFNpZ25ZICogY29ycmVjdGlvbl0pO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFwMS5lcShwMikpIHtcbiAgICAgICAgdmFyIG1pZFBvaW50ID0gcDEubWlkUG9pbnRGcm9tKHAyKTtcbiAgICAgICAgLy8gcDEgaXMgb3VyIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICAgIC8vIG1pZHBvaW50IGlzIG91ciBlbmRwb2ludFxuICAgICAgICAvLyBzdGFydCBwb2ludCBpcyBwKGktMSkgdmFsdWUuXG4gICAgICAgIHBhdGgucHVzaChbJ1EnLCBwMS54LCBwMS55LCBtaWRQb2ludC54LCBtaWRQb2ludC55XSk7XG4gICAgICB9XG4gICAgICBwMSA9IHBvaW50c1tpXTtcbiAgICAgIGlmICgoaSArIDEpIDwgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICBwMiA9IHBvaW50c1tpICsgMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYW55UG9pbnRzKSB7XG4gICAgICBtdWx0U2lnblggPSBwMS54ID4gcG9pbnRzW2kgLSAyXS54ID8gMSA6IHAxLnggPT09IHBvaW50c1tpIC0gMl0ueCA/IDAgOiAtMTtcbiAgICAgIG11bHRTaWduWSA9IHAxLnkgPiBwb2ludHNbaSAtIDJdLnkgPyAxIDogcDEueSA9PT0gcG9pbnRzW2kgLSAyXS55ID8gMCA6IC0xO1xuICAgIH1cbiAgICBwYXRoLnB1c2goWydMJywgcDEueCArIG11bHRTaWduWCAqIGNvcnJlY3Rpb24sIHAxLnkgKyBtdWx0U2lnblkgKiBjb3JyZWN0aW9uXSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBhIHBhdGggYnkgdHJhbnNmb3JtaW5nIGVhY2ggc2VnbWVudC5cbiAgICogaXQgaGFzIHRvIGJlIGEgc2ltcGxpZmllZCBwYXRoIG9yIGl0IHdvbid0IHdvcmsuXG4gICAqIFdBUk5JTkc6IHRoaXMgZGVwZW5kcyBmcm9tIHBhdGhPZmZzZXQgZm9yIGNvcnJlY3Qgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggZmFicmljSlMgcGFyc2VkIGFuZCBzaW1wbGlmaWVkIHBhdGggY29tbWFuZHNcbiAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIG1hdHJpeCB0aGF0IHJlcHJlc2VudCB0aGUgdHJhbnNmb3JtYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXRoT2Zmc2V0XSB0aGUgZmFicmljLlBhdGggcGF0aE9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gcGF0aE9mZnNldC54XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXRoT2Zmc2V0LnlcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgdHJhbnNmb3JtZWQgcGF0aFxuICAgKi9cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUGF0aChwYXRoLCB0cmFuc2Zvcm0sIHBhdGhPZmZzZXQpIHtcbiAgICBpZiAocGF0aE9mZnNldCkge1xuICAgICAgdHJhbnNmb3JtID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBbMSwgMCwgMCwgMSwgLXBhdGhPZmZzZXQueCwgLXBhdGhPZmZzZXQueV1cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLm1hcChmdW5jdGlvbihwYXRoU2VnbWVudCkge1xuICAgICAgdmFyIG5ld1NlZ21lbnQgPSBwYXRoU2VnbWVudC5zbGljZSgwKSwgcG9pbnQgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcGF0aFNlZ21lbnQubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50LnggPSBwYXRoU2VnbWVudFtpXTtcbiAgICAgICAgcG9pbnQueSA9IHBhdGhTZWdtZW50W2kgKyAxXTtcbiAgICAgICAgcG9pbnQgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludCwgdHJhbnNmb3JtKTtcbiAgICAgICAgbmV3U2VnbWVudFtpXSA9IHBvaW50Lng7XG4gICAgICAgIG5ld1NlZ21lbnRbaSArIDFdID0gcG9pbnQueTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTZWdtZW50O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gcGF0aCBjb21tYW5kcyB0byBnbyBiYWNrIHRvIHN2ZyBmb3JtYXRcbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aERhdGEgZmFicmljSlMgcGFyc2VkIHBhdGggY29tbWFuZHNcbiAgICogQHJldHVybiB7U3RyaW5nfSBqb2luZWQgcGF0aCAnTSAwIDAgTCAyMCAzMCdcbiAgICovXG4gIGZhYnJpYy51dGlsLmpvaW5QYXRoID0gZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICByZXR1cm4gcGF0aERhdGEubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7IHJldHVybiBzZWdtZW50LmpvaW4oJyAnKTsgfSkuam9pbignICcpO1xuICB9O1xuICBmYWJyaWMudXRpbC5wYXJzZVBhdGggPSBwYXJzZVBhdGg7XG4gIGZhYnJpYy51dGlsLm1ha2VQYXRoU2ltcGxlciA9IG1ha2VQYXRoU2ltcGxlcjtcbiAgZmFicmljLnV0aWwuZ2V0U21vb3RoUGF0aEZyb21Qb2ludHMgPSBnZXRTbW9vdGhQYXRoRnJvbVBvaW50cztcbiAgZmFicmljLnV0aWwuZ2V0UGF0aFNlZ21lbnRzSW5mbyA9IGdldFBhdGhTZWdtZW50c0luZm87XG4gIGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUgPSBnZXRCb3VuZHNPZkN1cnZlO1xuICBmYWJyaWMudXRpbC5nZXRQb2ludE9uUGF0aCA9IGdldFBvaW50T25QYXRoO1xuICBmYWJyaWMudXRpbC50cmFuc2Zvcm1QYXRoID0gdHJhbnNmb3JtUGF0aDtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogSW52b2tlcyBtZXRob2Qgb24gYWxsIGl0ZW1zIGluIGEgZ2l2ZW4gYXJyYXlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgYSBtZXRob2QgdG8gaW52b2tlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gaW52b2tlKGFycmF5LCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhcmdzLmxlbmd0aCA/IGFycmF5W2ldW21ldGhvZF0uYXBwbHkoYXJyYXlbaV0sIGFyZ3MpIDogYXJyYXlbaV1bbWV0aG9kXS5jYWxsKGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtYXhpbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWF4KGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID49IHZhbHVlMjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtaW5pbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWluKGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxIDwgdmFsdWUyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBrID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChrLS0pIHtcbiAgICAgIGFycmF5W2tdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDEsXG4gICAgICAgIHJlc3VsdCA9IGJ5UHJvcGVydHkgPyBhcnJheVtpXVtieVByb3BlcnR5XSA6IGFycmF5W2ldO1xuICAgIGlmIChieVByb3BlcnR5KSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyYXlbaV1bYnlQcm9wZXJ0eV0sIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnJheVtpXVtieVByb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJheVtpXSwgcmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5hcnJheVxuICAgKi9cbiAgZmFicmljLnV0aWwuYXJyYXkgPSB7XG4gICAgZmlsbDogZmlsbCxcbiAgICBpbnZva2U6IGludm9rZSxcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIENvcGllcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIG9uZSBqcyBvYmplY3QgdG8gYW5vdGhlclxuICAgKiB0aGlzIGRvZXMgbm90IGFuZCBjYW5ub3QgY29tcGV0ZSB3aXRoIGdlbmVyaWMgdXRpbHMuXG4gICAqIERvZXMgbm90IGNsb25lIG9yIGV4dGVuZCBmYWJyaWMuT2JqZWN0IHN1YmNsYXNzZXMuXG4gICAqIFRoaXMgaXMgbW9zdGx5IGZvciBpbnRlcm5hbCB1c2UgYW5kIGhhcyBleHRyYSBoYW5kbGluZyBmb3IgZmFicmljSlMgb2JqZWN0c1xuICAgKiBpdCBza2lwcyB0aGUgY2FudmFzIGFuZCBncm91cCBwcm9wZXJ0aWVzIGluIGRlZXAgY2xvbmluZy5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLm9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gV2hlcmUgdG8gY29weSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFdoZXJlIHRvIGNvcHkgZnJvbVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWVwXSBXaGV0aGVyIHRvIGV4dGVuZCBuZXN0ZWQgb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGV4dGVuZChkZXN0aW5hdGlvbiwgc291cmNlLCBkZWVwKSB7XG4gICAgLy8gSlNjcmlwdCBEb250RW51bSBidWcgaXMgbm90IHRha2VuIGNhcmUgb2ZcbiAgICAvLyB0aGUgZGVlcCBjbG9uZSBpcyBmb3IgaW50ZXJuYWwgdXNlLCBpcyBub3QgbWVhbnQgdG8gYXZvaWRcbiAgICAvLyBqYXZhc2NyaXB0IHRyYXBzIG9yIGNsb25pbmcgaHRtbCBlbGVtZW50IG9yIHNlbGYgcmVmZXJlbmNlZCBvYmplY3RzLlxuICAgIGlmIChkZWVwKSB7XG4gICAgICBpZiAoIWZhYnJpYy5pc0xpa2VseU5vZGUgJiYgc291cmNlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAvLyBhdm9pZCBjbG9uaW5nIGRlZXAgaW1hZ2VzLCBjYW52YXNlcyxcbiAgICAgICAgZGVzdGluYXRpb24gPSBzb3VyY2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBkZXN0aW5hdGlvbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25baV0gPSBleHRlbmQoeyB9LCBzb3VyY2VbaV0sIGRlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnY2FudmFzJyB8fCBwcm9wZXJ0eSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gY2xvbmUgdGhpcyBwcm9wcyBhdCBhbGwuXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGtlZXAgdGhlIGtleXMgaW4gdGhlIGNvcHlcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IGV4dGVuZCh7IH0sIHNvdXJjZVtwcm9wZXJ0eV0sIGRlZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgc291bmRzIG9kZCBmb3IgYW4gZXh0ZW5kIGJ1dCBpcyBvayBmb3IgcmVjdXJzaXZlIHVzZVxuICAgICAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZW1wdHkgb2JqZWN0IGFuZCBjb3BpZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbm90aGVyIG9iamVjdCB0byBpdFxuICAgKiBUaGlzIG1ldGhvZCBpcyBtb3N0bHkgZm9yIGludGVybmFsIHVzZSwgYW5kIG5vdCBpbnRlbmRlZCBmb3IgZHVwbGljYXRpbmcgc2hhcGVzIGluIGNhbnZhcy4gXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5vYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2xvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZGVlcF0gV2hldGhlciB0byBjbG9uZSBuZXN0ZWQgb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIC8vVE9ETzogdGhpcyBmdW5jdGlvbiByZXR1cm4gYW4gZW1wdHkgb2JqZWN0IGlmIHlvdSB0cnkgdG8gY2xvbmUgbnVsbFxuICBmdW5jdGlvbiBjbG9uZShvYmplY3QsIGRlZXApIHtcbiAgICByZXR1cm4gZXh0ZW5kKHsgfSwgb2JqZWN0LCBkZWVwKTtcbiAgfVxuXG4gIC8qKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLm9iamVjdCAqL1xuICBmYWJyaWMudXRpbC5vYmplY3QgPSB7XG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY2xvbmU6IGNsb25lXG4gIH07XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLnV0aWwsIGZhYnJpYy5PYnNlcnZhYmxlKTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBDYW1lbGl6ZXMgYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBjYW1lbGl6ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhbWVsaXplZCB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLy0rKC4pPy9nLCBmdW5jdGlvbihtYXRjaCwgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyID8gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBpdGFsaXplcyBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGNhcGl0YWxpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZmlyc3RMZXR0ZXJPbmx5XSBJZiB0cnVlIG9ubHkgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAqIGFuZCBvdGhlciBsZXR0ZXJzIHN0YXkgdW50b3VjaGVkLCBpZiBmYWxzZSBmaXJzdCBsZXR0ZXIgaXMgY2FwaXRhbGl6ZWRcbiAgICogYW5kIG90aGVyIGxldHRlcnMgYXJlIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQ2FwaXRhbGl6ZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcsIGZpcnN0TGV0dGVyT25seSkge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgKGZpcnN0TGV0dGVyT25seSA/IHN0cmluZy5zbGljZSgxKSA6IHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIFhNTCBpbiBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEVzY2FwZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlWG1sKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgLnJlcGxhY2UoLycvZywgJyZhcG9zOycpXG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpdmlkZSBhIHN0cmluZyBpbiB0aGUgdXNlciBwZXJjZWl2ZWQgc2luZ2xlIHVuaXRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRzdHJpbmcgU3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgY29udGFpbmluZyB0aGUgZ3JhcGhlbWVzXG4gICAqL1xuICBmdW5jdGlvbiBncmFwaGVtZVNwbGl0KHRleHRzdHJpbmcpIHtcbiAgICB2YXIgaSA9IDAsIGNociwgZ3JhcGhlbWVzID0gW107XG4gICAgZm9yIChpID0gMCwgY2hyOyBpIDwgdGV4dHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChjaHIgPSBnZXRXaG9sZUNoYXIodGV4dHN0cmluZywgaSkpID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGdyYXBoZW1lcy5wdXNoKGNocik7XG4gICAgfVxuICAgIHJldHVybiBncmFwaGVtZXM7XG4gIH1cblxuICAvLyB0YWtlbiBmcm9tIG1kbiBpbiB0aGUgY2hhckF0IGRvYyBwYWdlLlxuICBmdW5jdGlvbiBnZXRXaG9sZUNoYXIoc3RyLCBpKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChpc05hTihjb2RlKSkge1xuICAgICAgcmV0dXJuICcnOyAvLyBQb3NpdGlvbiBub3QgZm91bmRcbiAgICB9XG4gICAgaWYgKGNvZGUgPCAweEQ4MDAgfHwgY29kZSA+IDB4REZGRikge1xuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoaSk7XG4gICAgfVxuXG4gICAgLy8gSGlnaCBzdXJyb2dhdGUgKGNvdWxkIGNoYW5nZSBsYXN0IGhleCB0byAweERCN0YgdG8gdHJlYXQgaGlnaCBwcml2YXRlXG4gICAgLy8gc3Vycm9nYXRlcyBhcyBzaW5nbGUgY2hhcmFjdGVycylcbiAgICBpZiAoMHhEODAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERCRkYpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoIDw9IChpICsgMSkpIHtcbiAgICAgICAgdGhyb3cgJ0hpZ2ggc3Vycm9nYXRlIHdpdGhvdXQgZm9sbG93aW5nIGxvdyBzdXJyb2dhdGUnO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBzdHIuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICBpZiAoMHhEQzAwID4gbmV4dCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgICAgIHRocm93ICdIaWdoIHN1cnJvZ2F0ZSB3aXRob3V0IGZvbGxvd2luZyBsb3cgc3Vycm9nYXRlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIuY2hhckF0KGkpICsgc3RyLmNoYXJBdChpICsgMSk7XG4gICAgfVxuICAgIC8vIExvdyBzdXJyb2dhdGUgKDB4REMwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhERkZGKVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICB0aHJvdyAnTG93IHN1cnJvZ2F0ZSB3aXRob3V0IHByZWNlZGluZyBoaWdoIHN1cnJvZ2F0ZSc7XG4gICAgfVxuICAgIHZhciBwcmV2ID0gc3RyLmNoYXJDb2RlQXQoaSAtIDEpO1xuXG4gICAgLy8gKGNvdWxkIGNoYW5nZSBsYXN0IGhleCB0byAweERCN0YgdG8gdHJlYXQgaGlnaCBwcml2YXRlXG4gICAgLy8gc3Vycm9nYXRlcyBhcyBzaW5nbGUgY2hhcmFjdGVycylcbiAgICBpZiAoMHhEODAwID4gcHJldiB8fCBwcmV2ID4gMHhEQkZGKSB7XG4gICAgICB0aHJvdyAnTG93IHN1cnJvZ2F0ZSB3aXRob3V0IHByZWNlZGluZyBoaWdoIHN1cnJvZ2F0ZSc7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBwYXNzIG92ZXIgbG93IHN1cnJvZ2F0ZXMgbm93IGFzIHRoZSBzZWNvbmQgY29tcG9uZW50XG4gICAgLy8gaW4gYSBwYWlyIHdoaWNoIHdlIGhhdmUgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTdHJpbmcgdXRpbGl0aWVzXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqL1xuICBmYWJyaWMudXRpbC5zdHJpbmcgPSB7XG4gICAgY2FtZWxpemU6IGNhbWVsaXplLFxuICAgIGNhcGl0YWxpemU6IGNhcGl0YWxpemUsXG4gICAgZXNjYXBlWG1sOiBlc2NhcGVYbWwsXG4gICAgZ3JhcGhlbWVTcGxpdDogZ3JhcGhlbWVTcGxpdFxuICB9O1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLCBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAgIElTX0RPTlRFTlVNX0JVR0dZID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBwIGluIHsgdG9TdHJpbmc6IDEgfSkge1xuICAgICAgICAgIGlmIChwID09PSAndG9TdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkoKSxcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGFkZE1ldGhvZHMgPSBmdW5jdGlvbihrbGFzcywgc291cmNlLCBwYXJlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG5cbiAgICAgICAgICBpZiAocHJvcGVydHkgaW4ga2xhc3MucHJvdG90eXBlICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIChzb3VyY2VbcHJvcGVydHldICsgJycpLmluZGV4T2YoJ2NhbGxTdXBlcicpID4gLTEpIHtcblxuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9IChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3VwZXJjbGFzcyA9IHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gc291cmNlW3Byb3BlcnR5XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3M7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgIT09ICdpbml0aWFsaXplJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSVNfRE9OVEVOVU1fQlVHR1kpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLnRvU3RyaW5nID0gc291cmNlLnRvU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHtcbiAgICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLnZhbHVlT2YgPSBzb3VyY2UudmFsdWVPZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gU3ViY2xhc3MoKSB7IH1cblxuICBmdW5jdGlvbiBjYWxsU3VwZXIobWV0aG9kTmFtZSkge1xuICAgIHZhciBwYXJlbnRNZXRob2QgPSBudWxsLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBjbGltYiBwcm90b3R5cGUgY2hhaW4gdG8gZmluZCBtZXRob2Qgbm90IGVxdWFsIHRvIGNhbGxlZSdzIG1ldGhvZFxuICAgIHdoaWxlIChfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzKSB7XG4gICAgICB2YXIgc3VwZXJDbGFzc01ldGhvZCA9IF90aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKF90aGlzW21ldGhvZE5hbWVdICE9PSBzdXBlckNsYXNzTWV0aG9kKSB7XG4gICAgICAgIHBhcmVudE1ldGhvZCA9IHN1cGVyQ2xhc3NNZXRob2Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBfdGhpcyA9IF90aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MucHJvdG90eXBlO1xuICAgIH1cblxuICAgIGlmICghcGFyZW50TWV0aG9kKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5sb2coJ3RyaWVkIHRvIGNhbGxTdXBlciAnICsgbWV0aG9kTmFtZSArICcsIG1ldGhvZCBub3QgZm91bmQgaW4gcHJvdG90eXBlIGNoYWluJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgID8gcGFyZW50TWV0aG9kLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSlcbiAgICAgIDogcGFyZW50TWV0aG9kLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZvciBjcmVhdGlvbiBvZiBcImNsYXNzZXNcIi5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJlbnRdIG9wdGlvbmFsIFwiQ2xhc3NcIiB0byBpbmhlcml0IGZyb21cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHNoYXJlZCBieSBhbGwgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3NcbiAgICogICAgICAgICAgICAgICAgICAoYmUgY2FyZWZ1bCBtb2RpZnlpbmcgb2JqZWN0cyBkZWZpbmVkIGhlcmUgYXMgdGhpcyB3b3VsZCBhZmZlY3QgYWxsIGluc3RhbmNlcylcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKCkge1xuICAgIHZhciBwYXJlbnQgPSBudWxsLFxuICAgICAgICBwcm9wZXJ0aWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJlbnQgPSBwcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtsYXNzKCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAga2xhc3Muc3VwZXJjbGFzcyA9IHBhcmVudDtcbiAgICBrbGFzcy5zdWJjbGFzc2VzID0gW107XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBTdWJjbGFzcy5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAga2xhc3MucHJvdG90eXBlID0gbmV3IFN1YmNsYXNzKCk7XG4gICAgICBwYXJlbnQuc3ViY2xhc3Nlcy5wdXNoKGtsYXNzKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZE1ldGhvZHMoa2xhc3MsIHByb3BlcnRpZXNbaV0sIHBhcmVudCk7XG4gICAgfVxuICAgIGlmICgha2xhc3MucHJvdG90eXBlLmluaXRpYWxpemUpIHtcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZW1wdHlGdW5jdGlvbjtcbiAgICB9XG4gICAga2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0ga2xhc3M7XG4gICAga2xhc3MucHJvdG90eXBlLmNhbGxTdXBlciA9IGNhbGxTdXBlcjtcbiAgICByZXR1cm4ga2xhc3M7XG4gIH1cblxuICBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyA9IGNyZWF0ZUNsYXNzO1xufSkoKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuICAvLyBzaW5jZSBpZTExIGNhbiB1c2UgYWRkRXZlbnRMaXN0ZW5lciBidXQgdGhleSBkbyBub3Qgc3VwcG9ydCBvcHRpb25zLCBpIG5lZWQgdG8gY2hlY2tcbiAgdmFyIGNvdWxkVXNlQXR0YWNoRXZlbnQgPSAhIWZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5hdHRhY2hFdmVudCxcbiAgICAgIHRvdWNoRXZlbnRzID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCddO1xuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBlbGVtZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgZWxlbWVudCAmJiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBjb3VsZFVzZUF0dGFjaEV2ZW50ID8gZmFsc2UgOiBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZmFicmljLnV0aWwucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGNvdWxkVXNlQXR0YWNoRXZlbnQgPyBmYWxzZSA6IG9wdGlvbnMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFRvdWNoSW5mbyhldmVudCkge1xuICAgIHZhciB0b3VjaFByb3AgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICBpZiAodG91Y2hQcm9wICYmIHRvdWNoUHJvcFswXSkge1xuICAgICAgcmV0dXJuIHRvdWNoUHJvcFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgZmFicmljLnV0aWwuZ2V0UG9pbnRlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50YXJnZXQsXG4gICAgICAgIHNjcm9sbCA9IGZhYnJpYy51dGlsLmdldFNjcm9sbExlZnRUb3AoZWxlbWVudCksXG4gICAgICAgIF9ldnQgPSBnZXRUb3VjaEluZm8oZXZlbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBfZXZ0LmNsaWVudFggKyBzY3JvbGwubGVmdCxcbiAgICAgIHk6IF9ldnQuY2xpZW50WSArIHNjcm9sbC50b3BcbiAgICB9O1xuICB9O1xuXG4gIGZhYnJpYy51dGlsLmlzVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRvdWNoRXZlbnRzLmluZGV4T2YoZXZlbnQudHlwZSkgPiAtMSB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbiAgfTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciB3cmFwcGVyIGZvciBzZXR0aW5nIGVsZW1lbnQncyBzdHlsZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgICB2YXIgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBpZiAoIWVsZW1lbnRTdHlsZSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ICs9ICc7JyArIHN0eWxlcztcbiAgICAgIHJldHVybiBzdHlsZXMuaW5kZXhPZignb3BhY2l0eScpID4gLTFcbiAgICAgICAgPyBzZXRPcGFjaXR5KGVsZW1lbnQsIHN0eWxlcy5tYXRjaCgvb3BhY2l0eTpcXHMqKFxcZD9cXC4/XFxkKikvKVsxXSlcbiAgICAgICAgOiBlbGVtZW50O1xuICAgIH1cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgIHNldE9wYWNpdHkoZWxlbWVudCwgc3R5bGVzW3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRQcm9wZXJ0eSA9IChwcm9wZXJ0eSA9PT0gJ2Zsb2F0JyB8fCBwcm9wZXJ0eSA9PT0gJ2Nzc0Zsb2F0JylcbiAgICAgICAgICA/ICh0eXBlb2YgZWxlbWVudFN0eWxlLnN0eWxlRmxvYXQgPT09ICd1bmRlZmluZWQnID8gJ2Nzc0Zsb2F0JyA6ICdzdHlsZUZsb2F0JylcbiAgICAgICAgICA6IHByb3BlcnR5O1xuICAgICAgICBlbGVtZW50U3R5bGVbbm9ybWFsaXplZFByb3BlcnR5XSA9IHN0eWxlc1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIHBhcnNlRWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICBzdXBwb3J0c09wYWNpdHkgPSB0eXBlb2YgcGFyc2VFbC5zdHlsZS5vcGFjaXR5ID09PSAnc3RyaW5nJyxcbiAgICAgIHN1cHBvcnRzRmlsdGVycyA9IHR5cGVvZiBwYXJzZUVsLnN0eWxlLmZpbHRlciA9PT0gJ3N0cmluZycsXG4gICAgICByZU9wYWNpdHkgPSAvYWxwaGFcXHMqXFwoXFxzKm9wYWNpdHlcXHMqPVxccyooW15cXCldKylcXCkvLFxuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50OyB9O1xuXG4gIGlmIChzdXBwb3J0c09wYWNpdHkpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICB9XG4gIGVsc2UgaWYgKHN1cHBvcnRzRmlsdGVycykge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICB2YXIgZXMgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgaWYgKGVsZW1lbnQuY3VycmVudFN0eWxlICYmICFlbGVtZW50LmN1cnJlbnRTdHlsZS5oYXNMYXlvdXQpIHtcbiAgICAgICAgZXMuem9vbSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAocmVPcGFjaXR5LnRlc3QoZXMuZmlsdGVyKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID49IDAuOTk5OSA/ICcnIDogKCdhbHBoYShvcGFjaXR5PScgKyAodmFsdWUgKiAxMDApICsgJyknKTtcbiAgICAgICAgZXMuZmlsdGVyID0gZXMuZmlsdGVyLnJlcGxhY2UocmVPcGFjaXR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXMuZmlsdGVyICs9ICcgYWxwaGEob3BhY2l0eT0nICsgKHZhbHVlICogMTAwKSArICcpJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gIH1cblxuICBmYWJyaWMudXRpbC5zZXRTdHlsZSA9IHNldFN0eWxlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgX3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBUYWtlcyBpZCBhbmQgcmV0dXJucyBhbiBlbGVtZW50IHdpdGggdGhhdCBpZCAoaWYgb25lIGV4aXN0cyBpbiBhIGRvY3VtZW50KVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGlkXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBmYWJyaWMuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XG4gIH1cblxuICB2YXIgc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzLFxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhbiBhcnJheS1saWtlIG9iamVjdCAoZS5nLiBhcmd1bWVudHMgb3IgTm9kZUxpc3QpIHRvIGFuIGFycmF5XG4gICAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICovXG4gICAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICAgIHJldHVybiBfc2xpY2UuY2FsbChhcnJheUxpa2UsIDApO1xuICAgICAgfTtcblxuICB0cnkge1xuICAgIHNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyA9IHRvQXJyYXkoZmFicmljLmRvY3VtZW50LmNoaWxkTm9kZXMpIGluc3RhbmNlb2YgQXJyYXk7XG4gIH1cbiAgY2F0Y2ggKGVycikgeyB9XG5cbiAgaWYgKCFzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMpIHtcbiAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGFycmF5TGlrZS5sZW5ndGgpLCBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyYXlMaWtlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBzcGVjaWZpZWQgYXR0cmlidXRlc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVHlwZSBvZiBhbiBlbGVtZW50IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEF0dHJpYnV0ZXMgdG8gc2V0IG9uIGFuIGVsZW1lbnRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUVsZW1lbnQodGFnTmFtZSwgYXR0cmlidXRlcykge1xuICAgIHZhciBlbCA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGZvciAodmFyIHByb3AgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKHByb3AgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHByb3AgPT09ICdmb3InKSB7XG4gICAgICAgIGVsLmh0bWxGb3IgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY2xhc3MgdG8gYW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGFkZCBjbGFzcyB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIENsYXNzIHRvIGFkZCB0byBhbiBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudCAmJiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA9PT0gLTEpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IChlbGVtZW50LmNsYXNzTmFtZSA/ICcgJyA6ICcnKSArIGNsYXNzTmFtZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgZWxlbWVudCB3aXRoIGFub3RoZXIgZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHdyYXBcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IHdyYXBwZXIgRWxlbWVudCB0byB3cmFwIHdpdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiBhIHdyYXBwZXJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IHdyYXBwZXJcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBFbGVtZW50KGVsZW1lbnQsIHdyYXBwZXIsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodHlwZW9mIHdyYXBwZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB3cmFwcGVyID0gbWFrZUVsZW1lbnQod3JhcHBlciwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlciwgZWxlbWVudCk7XG4gICAgfVxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBlbGVtZW50IHNjcm9sbCBvZmZzZXRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gb3BlcmF0ZSBvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQvdG9wIHZhbHVlc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KSB7XG5cbiAgICB2YXIgbGVmdCA9IDAsXG4gICAgICAgIHRvcCA9IDAsXG4gICAgICAgIGRvY0VsZW1lbnQgPSBmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBib2R5ID0gZmFicmljLmRvY3VtZW50LmJvZHkgfHwge1xuICAgICAgICAgIHNjcm9sbExlZnQ6IDAsIHNjcm9sbFRvcDogMFxuICAgICAgICB9O1xuXG4gICAgLy8gV2hpbGUgbG9vcCBjaGVja3MgKGFuZCB0aGVuIHNldHMgZWxlbWVudCB0bykgLnBhcmVudE5vZGUgT1IgLmhvc3RcbiAgICAvLyAgdG8gYWNjb3VudCBmb3IgU2hhZG93RE9NLiBXZSBzdGlsbCB3YW50IHRvIHRyYXZlcnNlIHVwIG91dCBvZiBTaGFkb3dET00sXG4gICAgLy8gIGJ1dCB0aGUgLnBhcmVudE5vZGUgb2YgYSByb290IFNoYWRvd0RPTSBub2RlIHdpbGwgYWx3YXlzIGJlIG51bGwsIGluc3RlYWRcbiAgICAvLyAgaXQgc2hvdWxkIGJlIGFjY2Vzc2VkIHRocm91Z2ggLmhvc3QuIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNDc2NTUyOC80MzgzOTM4XG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgKGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3QpKSB7XG5cbiAgICAgIC8vIFNldCBlbGVtZW50IHRvIGVsZW1lbnQgcGFyZW50LCBvciAnaG9zdCcgaW4gY2FzZSBvZiBTaGFkb3dET01cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xuXG4gICAgICBpZiAoZWxlbWVudCA9PT0gZmFicmljLmRvY3VtZW50KSB7XG4gICAgICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8ICBkb2NFbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxlZnQgKz0gZWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCArPSBlbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBvZmZzZXQgZm9yIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBnZXQgb2Zmc2V0IGZvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIFwibGVmdFwiIGFuZCBcInRvcFwiIHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkge1xuICAgIHZhciBkb2NFbGVtLFxuICAgICAgICBkb2MgPSBlbGVtZW50ICYmIGVsZW1lbnQub3duZXJEb2N1bWVudCxcbiAgICAgICAgYm94ID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcbiAgICAgICAgb2Zmc2V0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcbiAgICAgICAgc2Nyb2xsTGVmdFRvcCxcbiAgICAgICAgb2Zmc2V0QXR0cmlidXRlcyA9IHtcbiAgICAgICAgICBib3JkZXJMZWZ0V2lkdGg6ICdsZWZ0JyxcbiAgICAgICAgICBib3JkZXJUb3BXaWR0aDogICd0b3AnLFxuICAgICAgICAgIHBhZGRpbmdMZWZ0OiAgICAgJ2xlZnQnLFxuICAgICAgICAgIHBhZGRpbmdUb3A6ICAgICAgJ3RvcCdcbiAgICAgICAgfTtcblxuICAgIGlmICghZG9jKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGF0dHIgaW4gb2Zmc2V0QXR0cmlidXRlcykge1xuICAgICAgb2Zmc2V0W29mZnNldEF0dHJpYnV0ZXNbYXR0cl1dICs9IHBhcnNlSW50KGdldEVsZW1lbnRTdHlsZShlbGVtZW50LCBhdHRyKSwgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaWYgKCB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG5cbiAgICBzY3JvbGxMZWZ0VG9wID0gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBib3gubGVmdCArIHNjcm9sbExlZnRUb3AubGVmdCAtIChkb2NFbGVtLmNsaWVudExlZnQgfHwgMCkgKyBvZmZzZXQubGVmdCxcbiAgICAgIHRvcDogYm94LnRvcCArIHNjcm9sbExlZnRUb3AudG9wIC0gKGRvY0VsZW0uY2xpZW50VG9wIHx8IDApICArIG9mZnNldC50b3BcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3R5bGUgYXR0cmlidXRlIHZhbHVlIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGdldCBzdHlsZSBhdHRyaWJ1dGUgZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFN0eWxlIGF0dHJpYnV0ZSB0byBnZXQgZm9yIGVsZW1lbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSBTdHlsZSBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqL1xuICB2YXIgZ2V0RWxlbWVudFN0eWxlO1xuICBpZiAoZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgZ2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xuICAgICAgdmFyIHN0eWxlID0gZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICByZXR1cm4gc3R5bGUgPyBzdHlsZVthdHRyXSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIGdldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQuc3R5bGVbYXR0cl07XG4gICAgICBpZiAoIXZhbHVlICYmIGVsZW1lbnQuY3VycmVudFN0eWxlKSB7XG4gICAgICAgIHZhbHVlID0gZWxlbWVudC5jdXJyZW50U3R5bGVbYXR0cl07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgICAgICAgc2VsZWN0UHJvcCA9ICd1c2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgID8gJ3VzZXJTZWxlY3QnXG4gICAgICAgICAgOiAnTW96VXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgID8gJ01velVzZXJTZWxlY3QnXG4gICAgICAgICAgICA6ICdXZWJraXRVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgICA/ICdXZWJraXRVc2VyU2VsZWN0J1xuICAgICAgICAgICAgICA6ICdLaHRtbFVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICAgICAgPyAnS2h0bWxVc2VyU2VsZWN0J1xuICAgICAgICAgICAgICAgIDogJyc7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBlbGVtZW50IHVuc2VsZWN0YWJsZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBtYWtlIHVuc2VsZWN0YWJsZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWJyaWMudXRpbC5mYWxzZUZ1bmN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzZWxlY3RQcm9wXSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnVuc2VsZWN0YWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudC51bnNlbGVjdGFibGUgPSAnb24nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgZWxlbWVudCBzZWxlY3RhYmxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG1ha2Ugc2VsZWN0YWJsZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VFbGVtZW50U2VsZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQub25zZWxlY3RzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc2VsZWN0UHJvcF0gPSAnJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnVuc2VsZWN0YWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudC51bnNlbGVjdGFibGUgPSAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlID0gbWFrZUVsZW1lbnRVbnNlbGVjdGFibGU7XG4gICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRTZWxlY3RhYmxlID0gbWFrZUVsZW1lbnRTZWxlY3RhYmxlO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGdldE5vZGVDYW52YXMoZWxlbWVudCkge1xuICAgIHZhciBpbXBsID0gZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIoZWxlbWVudCk7XG4gICAgcmV0dXJuIGltcGwuX2NhbnZhcyB8fCBpbXBsLl9pbWFnZTtcbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhblVwSnNkb21Ob2RlKGVsZW1lbnQpIHtcbiAgICBpZiAoIWZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGltcGwgPSBmYWJyaWMuanNkb21JbXBsRm9yV3JhcHBlcihlbGVtZW50KTtcbiAgICBpZiAoaW1wbCkge1xuICAgICAgaW1wbC5faW1hZ2UgPSBudWxsO1xuICAgICAgaW1wbC5fY2FudmFzID0gbnVsbDtcbiAgICAgIC8vIHVuc3VyZSBpZiBuZWNlc3NhcnlcbiAgICAgIGltcGwuX2N1cnJlbnRTcmMgPSBudWxsO1xuICAgICAgaW1wbC5fYXR0cmlidXRlcyA9IG51bGw7XG4gICAgICBpbXBsLl9jbGFzc0xpc3QgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEltYWdlU21vb3RoaW5nKGN0eCwgdmFsdWUpIHtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkXG4gICAgICB8fCBjdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgub0ltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogc2V0SW1hZ2VTbW9vdGhpbmcgc2V0cyB0aGUgY29udGV4dCBpbWFnZVNtb290aGluZ0VuYWJsZWQgcHJvcGVydHkuXG4gICAqIFVzZWQgYnkgY2FudmFzIGFuZCBieSBJbWFnZU9iamVjdC5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAcGFyYW0ge0hUTUxSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0byBzZXQgb25cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSB0cnVlIG9yIGZhbHNlXG4gICAqL1xuICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyA9IHNldEltYWdlU21vb3RoaW5nO1xuICBmYWJyaWMudXRpbC5nZXRCeUlkID0gZ2V0QnlJZDtcbiAgZmFicmljLnV0aWwudG9BcnJheSA9IHRvQXJyYXk7XG4gIGZhYnJpYy51dGlsLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50ID0gbWFrZUVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLndyYXBFbGVtZW50ID0gd3JhcEVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmdldFNjcm9sbExlZnRUb3AgPSBnZXRTY3JvbGxMZWZ0VG9wO1xuICBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0ID0gZ2V0RWxlbWVudE9mZnNldDtcbiAgZmFicmljLnV0aWwuZ2V0Tm9kZUNhbnZhcyA9IGdldE5vZGVDYW52YXM7XG4gIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUgPSBjbGVhblVwSnNkb21Ob2RlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBhZGRQYXJhbVRvVXJsKHVybCwgcGFyYW0pIHtcbiAgICByZXR1cm4gdXJsICsgKC9cXD8vLnRlc3QodXJsKSA/ICcmJyA6ICc/JykgKyBwYXJhbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Rm4oKSB7IH1cblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciBhYnN0cmFjdGlvbiBmb3Igc2VuZGluZyBYTUxIdHRwUmVxdWVzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gc2VuZCBYTUxIdHRwUmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2Q9XCJHRVRcIl1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhcmFtZXRlcnNdIHBhcmFtZXRlcnMgdG8gYXBwZW5kIHRvIHVybCBpbiBHRVQgb3IgaW4gYm9keVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYm9keV0gYm9keSB0byBzZW5kIHdpdGggUE9TVCBvciBQVVQgcmVxdWVzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uQ29tcGxldGUgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gcmVxdWVzdCBpcyBjb21wbGV0ZWRcbiAgICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R9IHJlcXVlc3RcbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgPyBvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpIDogJ0dFVCcsXG4gICAgICAgIG9uQ29tcGxldGUgPSBvcHRpb25zLm9uQ29tcGxldGUgfHwgZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIHhociA9IG5ldyBmYWJyaWMud2luZG93LlhNTEh0dHBSZXF1ZXN0KCksXG4gICAgICAgIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5wYXJhbWV0ZXJzO1xuXG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgb25Db21wbGV0ZSh4aHIpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHlGbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIGJvZHkgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBhcmFtZXRlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHVybCA9IGFkZFBhcmFtVG9VcmwodXJsLCBvcHRpb25zLnBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgIGlmIChtZXRob2QgPT09ICdQT1NUJyB8fCBtZXRob2QgPT09ICdQVVQnKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIH1cblxuICAgIHhoci5zZW5kKGJvZHkpO1xuICAgIHJldHVybiB4aHI7XG4gIH1cblxuICBmYWJyaWMudXRpbC5yZXF1ZXN0ID0gcmVxdWVzdDtcbn0pKCk7XG5cblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBgY29uc29sZS5sb2dgICh3aGVuIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlc10gVmFsdWVzIHRvIGxvZ1xuICovXG5mYWJyaWMubG9nID0gY29uc29sZS5sb2c7XG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYGNvbnNvbGUud2FybmAgKHdoZW4gYXZhaWxhYmxlKVxuICogQHBhcmFtIHsqfSBbdmFsdWVzXSBWYWx1ZXMgdG8gbG9nIGFzIGEgd2FybmluZ1xuICovXG5mYWJyaWMud2FybiA9IGNvbnNvbGUud2FybjtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gIHZhciBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAgICogQW5pbWF0aW9uIG9mIGEgdmFsdWUgb3IgbGlzdCBvZiB2YWx1ZXMuXG4gICAqIFdoZW4gdXNpbmcgbGlzdHMsIHRoaW5rIG9mIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gICAqIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgKiAgIHN0YXJ0VmFsdWU6IFsxLCAyLCAzXSxcbiAgICogICBlbmRWYWx1ZTogWzIsIDQsIDZdLFxuICAgKiAgIG9uQ2hhbmdlOiBmdW5jdGlvbihbYSwgYiwgY10pIHtcbiAgICogICAgIGNhbnZhcy56b29tVG9Qb2ludCh7eDogYiwgeTogY30sIGEpXG4gICAqICAgICBjYW52YXMucmVuZGVyQWxsKClcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBAZXhhbXBsZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb25DaGFuZ2VdIENhbGxiYWNrOyBpbnZva2VkIG9uIGV2ZXJ5IHZhbHVlIGNoYW5nZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb25Db21wbGV0ZV0gQ2FsbGJhY2s7IGludm9rZWQgd2hlbiB2YWx1ZSBjaGFuZ2UgaXMgY29tcGxldGVkXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIE5vdGU6IHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBhbmQgYnlWYWx1ZSBtdXN0IG1hdGNoIHRoZSB0eXBlXG4gICAqIHZhciBhbmltYXRpb25PcHRpb25zID0geyBzdGFydFZhbHVlOiAwLCBlbmRWYWx1ZTogMSwgYnlWYWx1ZTogMC4yNSB9XG4gICAqIHZhciBhbmltYXRpb25PcHRpb25zID0geyBzdGFydFZhbHVlOiBbMCwgMV0sIGVuZFZhbHVlOiBbMSwgMl0sIGJ5VmFsdWU6IFswLjI1LCAwLjI1XSB9XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVtYmVyW119IFtzdGFydFZhbHVlPTBdIFN0YXJ0aW5nIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVtYmVyW119IFtlbmRWYWx1ZT0xMDBdIEVuZGluZyB2YWx1ZVxuICAgKiBAcHJvcGVydHkge251bWJlciB8IG51bWJlcltdfSBbYnlWYWx1ZT0xMDBdIFZhbHVlIHRvIG1vZGlmeSB0aGUgcHJvcGVydHkgYnlcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2Vhc2luZ10gRWFzaW5nIGZ1bmN0aW9uXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZHVyYXRpb249NTAwXSBEdXJhdGlvbiBvZiBjaGFuZ2UgKGluIG1zKVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbYWJvcnRdIEFkZGl0aW9uYWwgZnVuY3Rpb24gd2l0aCBsb2dpYy4gSWYgcmV0dXJucyB0cnVlLCBhbmltYXRpb24gYWJvcnRzLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7KCkgPT4gdm9pZH0gQ2FuY2VsRnVuY3Rpb25cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uQ3VycmVudFN0YXRlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVtYmVyW119IGN1cnJlbnRWYWx1ZSB2YWx1ZSBpbiByYW5nZSBbYHN0YXJ0VmFsdWVgLCBgZW5kVmFsdWVgXVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gY29tcGxldGlvblJhdGUgdmFsdWUgaW4gcmFuZ2UgWzAsIDFdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvblJhdGUgdmFsdWUgaW4gcmFuZ2UgWzAsIDFdXG4gICAqXG4gICAqIEB0eXBlZGVmIHsoQW5pbWF0aW9uT3B0aW9ucyAmIEFuaW1hdGlvbkN1cnJlbnRTdGF0ZSAmIHsgY2FuY2VsOiBDYW5jZWxGdW5jdGlvbiB9fSBBbmltYXRpb25Db250ZXh0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBBcnJheSBob2xkaW5nIGFsbCBydW5uaW5nIGFuaW1hdGlvbnNcbiAgICogQG1lbWJlcm9mIGZhYnJpY1xuICAgKiBAdHlwZSB7QW5pbWF0aW9uQ29udGV4dFtdfVxuICAgKi9cbiAgdmFyIFJVTk5JTkdfQU5JTUFUSU9OUyA9IFtdO1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKFJVTk5JTkdfQU5JTUFUSU9OUywge1xuXG4gICAgLyoqXG4gICAgICogY2FuY2VsIGFsbCBydW5uaW5nIGFuaW1hdGlvbnMgYXQgdGhlIG5leHQgcmVxdWVzdEFuaW1GcmFtZVxuICAgICAqIEByZXR1cm5zIHtBbmltYXRpb25Db250ZXh0W119XG4gICAgICovXG4gICAgY2FuY2VsQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYW5pbWF0aW9ucyA9IHRoaXMuc3BsaWNlKDApO1xuICAgICAgYW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuY2VsIGFsbCBydW5uaW5nIGFuaW1hdGlvbnMgYXR0YWNoZWQgdG8gY2FudmFzIGF0IHRoZSBuZXh0IHJlcXVlc3RBbmltRnJhbWVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgICAqIEByZXR1cm5zIHtBbmltYXRpb25Db250ZXh0W119XG4gICAgICovXG4gICAgY2FuY2VsQnlDYW52YXM6IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW5jZWxsZWQgPSB0aGlzLmZpbHRlcihmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYW5pbWF0aW9uLnRhcmdldCA9PT0gJ29iamVjdCcgJiYgYW5pbWF0aW9uLnRhcmdldC5jYW52YXMgPT09IGNhbnZhcztcbiAgICAgIH0pO1xuICAgICAgY2FuY2VsbGVkLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYW5jZWxsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbmNlbCBhbGwgcnVubmluZyBhbmltYXRpb25zIGZvciB0YXJnZXQgYXQgdGhlIG5leHQgcmVxdWVzdEFuaW1GcmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHJldHVybnMge0FuaW1hdGlvbkNvbnRleHRbXX1cbiAgICAgKi9cbiAgICBjYW5jZWxCeVRhcmdldDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdmFyIGNhbmNlbGxlZCA9IHRoaXMuZmluZEFuaW1hdGlvbnNCeVRhcmdldCh0YXJnZXQpO1xuICAgICAgY2FuY2VsbGVkLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYW5jZWxsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW5jZWxGdW5jdGlvbn0gY2FuY2VsRnVuYyB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgYW5pbWF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZmluZEFuaW1hdGlvbkluZGV4OiBmdW5jdGlvbiAoY2FuY2VsRnVuYykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZih0aGlzLmZpbmRBbmltYXRpb24oY2FuY2VsRnVuYykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FuY2VsRnVuY3Rpb259IGNhbmNlbEZ1bmMgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGFuaW1hdGVcbiAgICAgKiBAcmV0dXJucyB7QW5pbWF0aW9uQ29udGV4dCB8IHVuZGVmaW5lZH0gYW5pbWF0aW9uJ3Mgb3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBmaW5kQW5pbWF0aW9uOiBmdW5jdGlvbiAoY2FuY2VsRnVuYykge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb24uY2FuY2VsID09PSBjYW5jZWxGdW5jO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgdGhlIG9iamVjdCB0aGF0IGlzIGFzc2lnbmVkIHRvIHRoZSB0YXJnZXQgcHJvcGVydHkgb2YgdGhlIGFuaW1hdGlvbiBjb250ZXh0XG4gICAgICogQHJldHVybnMge0FuaW1hdGlvbkNvbnRleHRbXX0gYXJyYXkgb2YgYW5pbWF0aW9uIG9wdGlvbnMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0YXJnZXRcbiAgICAgKi9cbiAgICBmaW5kQW5pbWF0aW9uc0J5VGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnRhcmdldCA9PT0gdGFyZ2V0O1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBub29wKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRFYXNpbmcodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHZhbHVlIGZyb20gb25lIHRvIGFub3RoZXIgd2l0aGluIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUsIGludm9raW5nIGNhbGxiYWNrcyBhcyB2YWx1ZSBpcyBiZWluZyBjaGFuZ2VkLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc10gQW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQGV4YW1wbGVcbiAgICogLy8gTm90ZTogc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGFuZCBieVZhbHVlIG11c3QgbWF0Y2ggdGhlIHR5cGVcbiAgICogZmFicmljLnV0aWwuYW5pbWF0ZSh7IHN0YXJ0VmFsdWU6IDAsIGVuZFZhbHVlOiAxLCBieVZhbHVlOiAwLjI1IH0pXG4gICAqIGZhYnJpYy51dGlsLmFuaW1hdGUoeyBzdGFydFZhbHVlOiBbMCwgMV0sIGVuZFZhbHVlOiBbMSwgMl0sIGJ5VmFsdWU6IFswLjI1LCAwLjI1XSB9KVxuICAgKiBAcmV0dXJucyB7Q2FuY2VsRnVuY3Rpb259IGNhbmNlbCBmdW5jdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gYW5pbWF0ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB2YXIgY2FuY2VsID0gZmFsc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHJlbW92ZUZyb21SZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMuaW5kZXhPZihjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMSAmJiBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgICAgICAgfTtcblxuICAgIGNvbnRleHQgPSBleHRlbmQoY2xvbmUob3B0aW9ucyksIHtcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnJvbVJlZ2lzdHJ5KCk7XG4gICAgICB9LFxuICAgICAgY3VycmVudFZhbHVlOiAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZSA6IDAsXG4gICAgICBjb21wbGV0aW9uUmF0ZTogMCxcbiAgICAgIGR1cmF0aW9uUmF0ZTogMFxuICAgIH0pO1xuICAgIGZhYnJpYy5ydW5uaW5nQW5pbWF0aW9ucy5wdXNoKGNvbnRleHQpO1xuXG4gICAgcmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAgIHZhciBzdGFydCA9IHRpbWVzdGFtcCB8fCArbmV3IERhdGUoKSxcbiAgICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgNTAwLFxuICAgICAgICAgIGZpbmlzaCA9IHN0YXJ0ICsgZHVyYXRpb24sIHRpbWUsXG4gICAgICAgICAgb25DaGFuZ2UgPSBvcHRpb25zLm9uQ2hhbmdlIHx8IG5vb3AsXG4gICAgICAgICAgYWJvcnQgPSBvcHRpb25zLmFib3J0IHx8IG5vb3AsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSB8fCBub29wLFxuICAgICAgICAgIGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nIHx8IGRlZmF1bHRFYXNpbmcsXG4gICAgICAgICAgaXNNYW55ID0gJ3N0YXJ0VmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXJ0VmFsdWUubGVuZ3RoID4gMCA6IGZhbHNlLFxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZSA6IDAsXG4gICAgICAgICAgZW5kVmFsdWUgPSAnZW5kVmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVuZFZhbHVlIDogMTAwLFxuICAgICAgICAgIGJ5VmFsdWUgPSBvcHRpb25zLmJ5VmFsdWUgfHwgKGlzTWFueSA/IHN0YXJ0VmFsdWUubWFwKGZ1bmN0aW9uKHZhbHVlLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWVbaV0gLSBzdGFydFZhbHVlW2ldO1xuICAgICAgICAgIH0pIDogZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcblxuICAgICAgb3B0aW9ucy5vblN0YXJ0ICYmIG9wdGlvbnMub25TdGFydCgpO1xuXG4gICAgICAoZnVuY3Rpb24gdGljayh0aWNrdGltZSkge1xuICAgICAgICB0aW1lID0gdGlja3RpbWUgfHwgK25ldyBEYXRlKCk7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IHRpbWUgPiBmaW5pc2ggPyBkdXJhdGlvbiA6ICh0aW1lIC0gc3RhcnQpLFxuICAgICAgICAgICAgdGltZVBlcmMgPSBjdXJyZW50VGltZSAvIGR1cmF0aW9uLFxuICAgICAgICAgICAgY3VycmVudCA9IGlzTWFueSA/IHN0YXJ0VmFsdWUubWFwKGZ1bmN0aW9uKF92YWx1ZSwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWFzaW5nKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlW2ldLCBieVZhbHVlW2ldLCBkdXJhdGlvbik7XG4gICAgICAgICAgICB9KSA6IGVhc2luZyhjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgYnlWYWx1ZSwgZHVyYXRpb24pLFxuICAgICAgICAgICAgdmFsdWVQZXJjID0gaXNNYW55ID8gTWF0aC5hYnMoKGN1cnJlbnRbMF0gLSBzdGFydFZhbHVlWzBdKSAvIGJ5VmFsdWVbMF0pXG4gICAgICAgICAgICAgIDogTWF0aC5hYnMoKGN1cnJlbnQgLSBzdGFydFZhbHVlKSAvIGJ5VmFsdWUpO1xuICAgICAgICAvLyAgdXBkYXRlIGNvbnRleHRcbiAgICAgICAgY29udGV4dC5jdXJyZW50VmFsdWUgPSBpc01hbnkgPyBjdXJyZW50LnNsaWNlKCkgOiBjdXJyZW50O1xuICAgICAgICBjb250ZXh0LmNvbXBsZXRpb25SYXRlID0gdmFsdWVQZXJjO1xuICAgICAgICBjb250ZXh0LmR1cmF0aW9uUmF0ZSA9IHRpbWVQZXJjO1xuICAgICAgICBpZiAoY2FuY2VsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhYm9ydChjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSkge1xuICAgICAgICAgIHJlbW92ZUZyb21SZWdpc3RyeSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZSA+IGZpbmlzaCkge1xuICAgICAgICAgIC8vICB1cGRhdGUgY29udGV4dFxuICAgICAgICAgIGNvbnRleHQuY3VycmVudFZhbHVlID0gaXNNYW55ID8gZW5kVmFsdWUuc2xpY2UoKSA6IGVuZFZhbHVlO1xuICAgICAgICAgIGNvbnRleHQuY29tcGxldGlvblJhdGUgPSAxO1xuICAgICAgICAgIGNvbnRleHQuZHVyYXRpb25SYXRlID0gMTtcbiAgICAgICAgICAvLyAgZXhlY3V0ZSBjYWxsYmFja3NcbiAgICAgICAgICBvbkNoYW5nZShpc01hbnkgPyBlbmRWYWx1ZS5zbGljZSgpIDogZW5kVmFsdWUsIDEsIDEpO1xuICAgICAgICAgIG9uQ29tcGxldGUoZW5kVmFsdWUsIDEsIDEpO1xuICAgICAgICAgIHJlbW92ZUZyb21SZWdpc3RyeSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvbkNoYW5nZShjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKTtcbiAgICAgICAgICByZXF1ZXN0QW5pbUZyYW1lKHRpY2spO1xuICAgICAgICB9XG4gICAgICB9KShzdGFydCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGV4dC5jYW5jZWw7XG4gIH1cblxuICB2YXIgX3JlcXVlc3RBbmltRnJhbWUgPSBmYWJyaWMud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWJyaWMud2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgdmFyIF9jYW5jZWxBbmltRnJhbWUgPSBmYWJyaWMud2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGZhYnJpYy53aW5kb3cuY2xlYXJUaW1lb3V0O1xuXG4gIC8qKlxuICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYmFzZWQgb24gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbiAgICogSW4gb3JkZXIgdG8gZ2V0IGEgcHJlY2lzZSBzdGFydCB0aW1lLCBgcmVxdWVzdEFuaW1GcmFtZWAgc2hvdWxkIGJlIGNhbGxlZCBhcyBhbiBlbnRyeSBpbnRvIHRoZSBtZXRob2RcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgb3B0aW9uYWwgRWxlbWVudCB0byBhc3NvY2lhdGUgd2l0aCBhbmltYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0QW5pbUZyYW1lLmFwcGx5KGZhYnJpYy53aW5kb3csIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoKSB7XG4gICAgcmV0dXJuIF9jYW5jZWxBbmltRnJhbWUuYXBwbHkoZmFicmljLndpbmRvdywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGUgPSBhbmltYXRlO1xuICBmYWJyaWMudXRpbC5yZXF1ZXN0QW5pbUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZTtcbiAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lID0gY2FuY2VsQW5pbUZyYW1lO1xuICBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMgPSBSVU5OSU5HX0FOSU1BVElPTlM7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLy8gQ2FsY3VsYXRlIGFuIGluLWJldHdlZW4gY29sb3IuIFJldHVybnMgYSBcInJnYmEoKVwiIHN0cmluZy5cbiAgLy8gQ3JlZGl0OiBFZHdpbiBNYXJ0aW4gPGVkd2luQGJpdHN0b3JtLm9yZz5cbiAgLy8gICAgICAgICBodHRwOi8vd3d3LmJpdHN0b3JtLm9yZy9qcXVlcnkvY29sb3ItYW5pbWF0aW9uL2pxdWVyeS5hbmltYXRlLWNvbG9ycy5qc1xuICBmdW5jdGlvbiBjYWxjdWxhdGVDb2xvcihiZWdpbiwgZW5kLCBwb3MpIHtcbiAgICB2YXIgY29sb3IgPSAncmdiYSgnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzBdICsgcG9zICogKGVuZFswXSAtIGJlZ2luWzBdKSksIDEwKSArICcsJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblsxXSArIHBvcyAqIChlbmRbMV0gLSBiZWdpblsxXSkpLCAxMCkgKyAnLCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMl0gKyBwb3MgKiAoZW5kWzJdIC0gYmVnaW5bMl0pKSwgMTApO1xuXG4gICAgY29sb3IgKz0gJywnICsgKGJlZ2luICYmIGVuZCA/IHBhcnNlRmxvYXQoYmVnaW5bM10gKyBwb3MgKiAoZW5kWzNdIC0gYmVnaW5bM10pKSA6IDEpO1xuICAgIGNvbG9yICs9ICcpJztcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgY29sb3IgZnJvbSBvbmUgdG8gYW5vdGhlciB3aXRoaW4gY2VydGFpbiBwZXJpb2Qgb2YgdGltZSwgaW52b2tpbmcgY2FsbGJhY2tzIGFzIHZhbHVlIGlzIGJlaW5nIGNoYW5nZWQuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbUNvbG9yIFRoZSBzdGFydGluZyBjb2xvciBpbiBoZXggb3IgcmdiKGEpIGZvcm1hdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRvQ29sb3IgVGhlIHN0YXJ0aW5nIGNvbG9yIGluIGhleCBvciByZ2IoYSkgZm9ybWF0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uXSBEdXJhdGlvbiBvZiBjaGFuZ2UgKGluIG1zKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNoYW5nZV0gQ2FsbGJhY2s7IGludm9rZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ29tcGxldGVdIENhbGxiYWNrOyBpbnZva2VkIHdoZW4gdmFsdWUgY2hhbmdlIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jb2xvckVhc2luZ10gRWFzaW5nIGZ1bmN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBvbmx5IHRha2UgdHdvIGFyZ3VtZW50cyAoY3VycmVudFRpbWUsIGR1cmF0aW9uKS4gVGh1cyB0aGUgcmVndWxhciBhbmltYXRpb24gZWFzaW5nIGZ1bmN0aW9ucyBjYW5ub3QgYmUgdXNlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuYWJvcnRdIEFkZGl0aW9uYWwgZnVuY3Rpb24gd2l0aCBsb2dpYy4gSWYgcmV0dXJucyB0cnVlLCBvbkNvbXBsZXRlIGlzIGNhbGxlZC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBhYm9ydCBmdW5jdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gYW5pbWF0ZUNvbG9yKGZyb21Db2xvciwgdG9Db2xvciwgZHVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgc3RhcnRDb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoZnJvbUNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgZW5kQ29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRvQ29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICBvcmlnaW5hbE9uQ29tcGxldGUgPSBvcHRpb25zLm9uQ29tcGxldGUsXG4gICAgICAgIG9yaWdpbmFsT25DaGFuZ2UgPSBvcHRpb25zLm9uQ2hhbmdlO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChvcHRpb25zLCB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24gfHwgNTAwLFxuICAgICAgc3RhcnRWYWx1ZTogc3RhcnRDb2xvcixcbiAgICAgIGVuZFZhbHVlOiBlbmRDb2xvcixcbiAgICAgIGJ5VmFsdWU6IGVuZENvbG9yLFxuICAgICAgZWFzaW5nOiBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBwb3NWYWx1ZSA9IG9wdGlvbnMuY29sb3JFYXNpbmdcbiAgICAgICAgICA/IG9wdGlvbnMuY29sb3JFYXNpbmcoY3VycmVudFRpbWUsIGR1cmF0aW9uKVxuICAgICAgICAgIDogMSAtIE1hdGguY29zKGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gKiAoTWF0aC5QSSAvIDIpKTtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUNvbG9yKHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIHBvc1ZhbHVlKTtcbiAgICAgIH0sXG4gICAgICAvLyBoYXMgdG8gdGFrZSBpbiBhY2NvdW50IGZvciBjb2xvciByZXN0b3Jpbmc7XG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbihjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbE9uQ29tcGxldGUpIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxPbkNvbXBsZXRlKFxuICAgICAgICAgICAgY2FsY3VsYXRlQ29sb3IoZW5kQ29sb3IsIGVuZENvbG9yLCAwKSxcbiAgICAgICAgICAgIHZhbHVlUGVyYyxcbiAgICAgICAgICAgIHRpbWVQZXJjXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbE9uQ2hhbmdlKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE9uQ2hhbmdlKFxuICAgICAgICAgICAgICBjYWxjdWxhdGVDb2xvcihjdXJyZW50LCBjdXJyZW50LCAwKSxcbiAgICAgICAgICAgICAgdmFsdWVQZXJjLFxuICAgICAgICAgICAgICB0aW1lUGVyY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZ2luYWxPbkNoYW5nZShjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGVDb2xvciA9IGFuaW1hdGVDb2xvcjtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGEsIGMsIHAsIHMpIHtcbiAgICBpZiAoYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICBhID0gYztcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2hhbmRsZSB0aGUgMC8wIGNhc2U6XG4gICAgICBpZiAoYyA9PT0gMCAmJiBhID09PSAwKSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhOiBhLCBjOiBjLCBwOiBwLCBzOiBzIH07XG4gIH1cblxuICBmdW5jdGlvbiBlbGFzdGljKG9wdHMsIHQsIGQpIHtcbiAgICByZXR1cm4gb3B0cy5hICpcbiAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICpcbiAgICAgIE1hdGguc2luKCAodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1YmljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ3ViaWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVhcnRpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gLWMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5RdWludCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5TaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiBNYXRoLmNvcyh0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0U2luZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiBNYXRoLnNpbih0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRTaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgLyAyICogKE1hdGguY29zKE1hdGguUEkgKiB0IC8gZCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FeHBvKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gKHQgPT09IDApID8gYiA6IGMgKiBNYXRoLnBvdygyLCAxMCAqICh0IC8gZCAtIDEpKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEV4cG8odCwgYiwgYywgZCkge1xuICAgIHJldHVybiAodCA9PT0gZCkgPyBiICsgYyA6IGMgKiAoLU1hdGgucG93KDIsIC0xMCAqIHQgLyBkKSArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0RXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBpZiAodCA9PT0gZCkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkNpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIChNYXRoLnNxcnQoMSAtICh0IC89IGQpICogdCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dENpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogTWF0aC5zcXJ0KDEgLSAodCA9IHQgLyBkIC0gMSkgKiB0KSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dENpcmModCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gLWMgLyAyICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FbGFzdGljKHQsIGIsIGMsIGQpIHtcbiAgICB2YXIgcyA9IDEuNzAxNTgsIHAgPSAwLCBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHQgLz0gZDtcbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogMC4zO1xuICAgIH1cbiAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZShhLCBjLCBwLCBzKTtcbiAgICByZXR1cm4gLWVsYXN0aWMob3B0cywgdCwgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkO1xuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAwLjM7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIHJldHVybiBvcHRzLmEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICkgKyBvcHRzLmMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA9PT0gMikge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogKDAuMyAqIDEuNSk7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiBlbGFzdGljKG9wdHMsIHQsIGQpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHMuYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqXG4gICAgICBNYXRoLnNpbigodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApICogMC41ICsgb3B0cy5jICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5CYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0QmFjayh0LCBiLCBjLCBkLCBzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb3VuY2luZyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgLSBlYXNlT3V0Qm91bmNlIChkIC0gdCwgMCwgYywgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICgodCAvPSBkKSA8ICgxIC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqIHQgKiB0KSArIGI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHQgPCAoMiAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIDAuNzUpICsgYjtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1KSArIGI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuNjI1IC8gMi43NSkpICogdCArIDAuOTg0Mzc1KSArIGI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICh0IDwgZCAvIDIpIHtcbiAgICAgIHJldHVybiBlYXNlSW5Cb3VuY2UgKHQgKiAyLCAwLCBjLCBkKSAqIDAuNSArIGI7XG4gICAgfVxuICAgIHJldHVybiBlYXNlT3V0Qm91bmNlKHQgKiAyIC0gZCwgMCwgYywgZCkgKiAwLjUgKyBjICogMC41ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFYXNpbmcgZnVuY3Rpb25zXG4gICAqIFNlZSA8YSBocmVmPVwiaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXCI+RWFzaW5nIEVxdWF0aW9ucyBieSBSb2JlcnQgUGVubmVyPC9hPlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZhYnJpYy51dGlsLmVhc2UgPSB7XG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIGluXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB0IC89IChkIC8gMik7XG4gICAgICBpZiAodCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKyBiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC1jIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEN1YmljIGVhc2luZyBpblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCArIGI7XG4gICAgfSxcblxuICAgIGVhc2VPdXRDdWJpYzogZWFzZU91dEN1YmljLFxuICAgIGVhc2VJbk91dEN1YmljOiBlYXNlSW5PdXRDdWJpYyxcbiAgICBlYXNlSW5RdWFydDogZWFzZUluUXVhcnQsXG4gICAgZWFzZU91dFF1YXJ0OiBlYXNlT3V0UXVhcnQsXG4gICAgZWFzZUluT3V0UXVhcnQ6IGVhc2VJbk91dFF1YXJ0LFxuICAgIGVhc2VJblF1aW50OiBlYXNlSW5RdWludCxcbiAgICBlYXNlT3V0UXVpbnQ6IGVhc2VPdXRRdWludCxcbiAgICBlYXNlSW5PdXRRdWludDogZWFzZUluT3V0UXVpbnQsXG4gICAgZWFzZUluU2luZTogZWFzZUluU2luZSxcbiAgICBlYXNlT3V0U2luZTogZWFzZU91dFNpbmUsXG4gICAgZWFzZUluT3V0U2luZTogZWFzZUluT3V0U2luZSxcbiAgICBlYXNlSW5FeHBvOiBlYXNlSW5FeHBvLFxuICAgIGVhc2VPdXRFeHBvOiBlYXNlT3V0RXhwbyxcbiAgICBlYXNlSW5PdXRFeHBvOiBlYXNlSW5PdXRFeHBvLFxuICAgIGVhc2VJbkNpcmM6IGVhc2VJbkNpcmMsXG4gICAgZWFzZU91dENpcmM6IGVhc2VPdXRDaXJjLFxuICAgIGVhc2VJbk91dENpcmM6IGVhc2VJbk91dENpcmMsXG4gICAgZWFzZUluRWxhc3RpYzogZWFzZUluRWxhc3RpYyxcbiAgICBlYXNlT3V0RWxhc3RpYzogZWFzZU91dEVsYXN0aWMsXG4gICAgZWFzZUluT3V0RWxhc3RpYzogZWFzZUluT3V0RWxhc3RpYyxcbiAgICBlYXNlSW5CYWNrOiBlYXNlSW5CYWNrLFxuICAgIGVhc2VPdXRCYWNrOiBlYXNlT3V0QmFjayxcbiAgICBlYXNlSW5PdXRCYWNrOiBlYXNlSW5PdXRCYWNrLFxuICAgIGVhc2VJbkJvdW5jZTogZWFzZUluQm91bmNlLFxuICAgIGVhc2VPdXRCb3VuY2U6IGVhc2VPdXRCb3VuY2UsXG4gICAgZWFzZUluT3V0Qm91bmNlOiBlYXNlSW5PdXRCb3VuY2VcbiAgfTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBmYWJyaWNcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIHBhcnNlVW5pdCA9IGZhYnJpYy51dGlsLnBhcnNlVW5pdCxcbiAgICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuXG4gICAgICBzdmdWYWxpZFRhZ05hbWVzID0gWydwYXRoJywgJ2NpcmNsZScsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ2VsbGlwc2UnLCAncmVjdCcsICdsaW5lJyxcbiAgICAgICAgJ2ltYWdlJywgJ3RleHQnXSxcbiAgICAgIHN2Z1ZpZXdCb3hFbGVtZW50cyA9IFsnc3ltYm9sJywgJ2ltYWdlJywgJ21hcmtlcicsICdwYXR0ZXJuJywgJ3ZpZXcnLCAnc3ZnJ10sXG4gICAgICBzdmdJbnZhbGlkQW5jZXN0b3JzID0gWydwYXR0ZXJuJywgJ2RlZnMnLCAnc3ltYm9sJywgJ21ldGFkYXRhJywgJ2NsaXBQYXRoJywgJ21hc2snLCAnZGVzYyddLFxuICAgICAgc3ZnVmFsaWRQYXJlbnRzID0gWydzeW1ib2wnLCAnZycsICdhJywgJ3N2ZycsICdjbGlwUGF0aCcsICdkZWZzJ10sXG5cbiAgICAgIGF0dHJpYnV0ZXNNYXAgPSB7XG4gICAgICAgIGN4OiAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgIHg6ICAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgIHI6ICAgICAgICAgICAgICAgICAgICAncmFkaXVzJyxcbiAgICAgICAgY3k6ICAgICAgICAgICAgICAgICAgICd0b3AnLFxuICAgICAgICB5OiAgICAgICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgIGRpc3BsYXk6ICAgICAgICAgICAgICAndmlzaWJsZScsXG4gICAgICAgIHZpc2liaWxpdHk6ICAgICAgICAgICAndmlzaWJsZScsXG4gICAgICAgIHRyYW5zZm9ybTogICAgICAgICAgICAndHJhbnNmb3JtTWF0cml4JyxcbiAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6ICAgICAgICdmaWxsT3BhY2l0eScsXG4gICAgICAgICdmaWxsLXJ1bGUnOiAgICAgICAgICAnZmlsbFJ1bGUnLFxuICAgICAgICAnZm9udC1mYW1pbHknOiAgICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgICAnZm9udC1zaXplJzogICAgICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICAgJ2ZvbnQtc3R5bGUnOiAgICAgICAgICdmb250U3R5bGUnLFxuICAgICAgICAnZm9udC13ZWlnaHQnOiAgICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgICAnbGV0dGVyLXNwYWNpbmcnOiAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICAgJ3BhaW50LW9yZGVyJzogICAgICAgICdwYWludEZpcnN0JyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAgICdzdHJva2VEYXNoQXJyYXknLFxuICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAgJ3N0cm9rZURhc2hPZmZzZXQnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAgICAgJ3N0cm9rZUxpbmVDYXAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVqb2luJzogICAgJ3N0cm9rZUxpbmVKb2luJyxcbiAgICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogICdzdHJva2VNaXRlckxpbWl0JyxcbiAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICAgICAgICdzdHJva2VXaWR0aCcsXG4gICAgICAgICd0ZXh0LWRlY29yYXRpb24nOiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICAgICAndGV4dC1hbmNob3InOiAgICAgICAgJ3RleHRBbmNob3InLFxuICAgICAgICBvcGFjaXR5OiAgICAgICAgICAgICAgJ29wYWNpdHknLFxuICAgICAgICAnY2xpcC1wYXRoJzogICAgICAgICAgJ2NsaXBQYXRoJyxcbiAgICAgICAgJ2NsaXAtcnVsZSc6ICAgICAgICAgICdjbGlwUnVsZScsXG4gICAgICAgICd2ZWN0b3ItZWZmZWN0JzogICAgICAnc3Ryb2tlVW5pZm9ybScsXG4gICAgICAgICdpbWFnZS1yZW5kZXJpbmcnOiAgICAnaW1hZ2VTbW9vdGhpbmcnLFxuICAgICAgfSxcblxuICAgICAgY29sb3JBdHRyaWJ1dGVzID0ge1xuICAgICAgICBzdHJva2U6ICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgZmlsbDogICAnZmlsbE9wYWNpdHknXG4gICAgICB9LFxuXG4gICAgICBmU2l6ZSA9ICdmb250LXNpemUnLCBjUGF0aCA9ICdjbGlwLXBhdGgnO1xuXG4gIGZhYnJpYy5zdmdWYWxpZFRhZ05hbWVzUmVnRXggPSBnZXRTdmdSZWdleChzdmdWYWxpZFRhZ05hbWVzKTtcbiAgZmFicmljLnN2Z1ZpZXdCb3hFbGVtZW50c1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmlld0JveEVsZW1lbnRzKTtcbiAgZmFicmljLnN2Z0ludmFsaWRBbmNlc3RvcnNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z0ludmFsaWRBbmNlc3RvcnMpO1xuICBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXggPSBnZXRTdmdSZWdleChzdmdWYWxpZFBhcmVudHMpO1xuXG4gIGZhYnJpYy5jc3NSdWxlcyA9IHsgfTtcbiAgZmFicmljLmdyYWRpZW50RGVmcyA9IHsgfTtcbiAgZmFicmljLmNsaXBQYXRocyA9IHsgfTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVBdHRyKGF0dHIpIHtcbiAgICAvLyB0cmFuc2Zvcm0gYXR0cmlidXRlIG5hbWVzXG4gICAgaWYgKGF0dHIgaW4gYXR0cmlidXRlc01hcCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNNYXBbYXR0cl07XG4gICAgfVxuICAgIHJldHVybiBhdHRyO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUoYXR0ciwgdmFsdWUsIHBhcmVudEF0dHJpYnV0ZXMsIGZvbnRTaXplKSB7XG4gICAgdmFyIGlzQXJyYXkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgICBwYXJzZWQ7XG5cbiAgICBpZiAoKGF0dHIgPT09ICdmaWxsJyB8fCBhdHRyID09PSAnc3Ryb2tlJykgJiYgdmFsdWUgPT09ICdub25lJykge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3N0cm9rZVVuaWZvcm0nKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09PSAnbm9uLXNjYWxpbmctc3Ryb2tlJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdzdHJva2VEYXNoQXJyYXknKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICdub25lJykge1xuICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8sL2csICcgJykuc3BsaXQoL1xccysvKS5tYXAocGFyc2VGbG9hdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd0cmFuc2Zvcm1NYXRyaXgnKSB7XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiBwYXJlbnRBdHRyaWJ1dGVzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICB2YWx1ZSA9IG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgICAgcGFyZW50QXR0cmlidXRlcy50cmFuc2Zvcm1NYXRyaXgsIGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSAnbm9uZScgJiYgdmFsdWUgIT09ICdoaWRkZW4nO1xuICAgICAgLy8gZGlzcGxheT1ub25lIG9uIHBhcmVudCBlbGVtZW50IGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY2hpbGQgZWxlbWVudFxuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgcGFyZW50QXR0cmlidXRlcy52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnb3BhY2l0eScpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiB0eXBlb2YgcGFyZW50QXR0cmlidXRlcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWx1ZSAqPSBwYXJlbnRBdHRyaWJ1dGVzLm9wYWNpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd0ZXh0QW5jaG9yJyAvKiB0ZXh0LWFuY2hvciAqLykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IHZhbHVlID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ2NoYXJTcGFjaW5nJykge1xuICAgICAgLy8gcGFyc2VVbml0IHJldHVybnMgcHggYW5kIHdlIGNvbnZlcnQgaXQgdG8gZW1cbiAgICAgIHBhcnNlZCA9IHBhcnNlVW5pdCh2YWx1ZSwgZm9udFNpemUpIC8gZm9udFNpemUgKiAxMDAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAncGFpbnRGaXJzdCcpIHtcbiAgICAgIHZhciBmaWxsSW5kZXggPSB2YWx1ZS5pbmRleE9mKCdmaWxsJyk7XG4gICAgICB2YXIgc3Ryb2tlSW5kZXggPSB2YWx1ZS5pbmRleE9mKCdzdHJva2UnKTtcbiAgICAgIHZhciB2YWx1ZSA9ICdmaWxsJztcbiAgICAgIGlmIChmaWxsSW5kZXggPiAtMSAmJiBzdHJva2VJbmRleCA+IC0xICYmIHN0cm9rZUluZGV4IDwgZmlsbEluZGV4KSB7XG4gICAgICAgIHZhbHVlID0gJ3N0cm9rZSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmaWxsSW5kZXggPT09IC0xICYmIHN0cm9rZUluZGV4ID4gLTEpIHtcbiAgICAgICAgdmFsdWUgPSAnc3Ryb2tlJztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ2hyZWYnIHx8IGF0dHIgPT09ICd4bGluazpocmVmJyB8fCBhdHRyID09PSAnZm9udCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ2ltYWdlU21vb3RoaW5nJykge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gJ29wdGltaXplUXVhbGl0eScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBhcnNlZCA9IGlzQXJyYXkgPyB2YWx1ZS5tYXAocGFyc2VVbml0KSA6IHBhcnNlVW5pdCh2YWx1ZSwgZm9udFNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiAoIWlzQXJyYXkgJiYgaXNOYU4ocGFyc2VkKSA/IHZhbHVlIDogcGFyc2VkKTtcbiAgfVxuXG4gIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICBmdW5jdGlvbiBnZXRTdmdSZWdleChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgYXJyLmpvaW4oJ3wnKSArICcpXFxcXGInLCAnaScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gcGFyc2VcbiAgICovXG4gIGZ1bmN0aW9uIF9zZXRTdHJva2VGaWxsT3BhY2l0eShhdHRyaWJ1dGVzKSB7XG4gICAgZm9yICh2YXIgYXR0ciBpbiBjb2xvckF0dHJpYnV0ZXMpIHtcblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0gPT09ICd1bmRlZmluZWQnIHx8IGF0dHJpYnV0ZXNbYXR0cl0gPT09ICcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXNbYXR0cl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl07XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzW2F0dHJdLmluZGV4T2YoJ3VybCgnKSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihhdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSBjb2xvci5zZXRBbHBoYSh0b0ZpeGVkKGNvbG9yLmdldEFscGhhKCkgKiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0sIDIpKS50b1JnYmEoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgbm9kZU5hbWVzKSB7XG4gICAgdmFyIG5vZGVOYW1lLCBub2RlQXJyYXkgPSBbXSwgbm9kZUxpc3QsIGksIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGVOYW1lID0gbm9kZU5hbWVzW2ldO1xuICAgICAgbm9kZUxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUobm9kZU5hbWUpO1xuICAgICAgbm9kZUFycmF5ID0gbm9kZUFycmF5LmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZUFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVWYWx1ZSBTdHJpbmcgY29udGFpbmluZyBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIDYgZWxlbWVudHMgcmVwcmVzZW50aW5nIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgKi9cbiAgZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHJvdGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBjb3MgPSBmYWJyaWMudXRpbC5jb3MoYXJnc1swXSksIHNpbiA9IGZhYnJpYy51dGlsLnNpbihhcmdzWzBdKSxcbiAgICAgICAgICB4ID0gMCwgeSA9IDA7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgeCA9IGFyZ3NbMV07XG4gICAgICAgIHkgPSBhcmdzWzJdO1xuICAgICAgfVxuXG4gICAgICBtYXRyaXhbMF0gPSBjb3M7XG4gICAgICBtYXRyaXhbMV0gPSBzaW47XG4gICAgICBtYXRyaXhbMl0gPSAtc2luO1xuICAgICAgbWF0cml4WzNdID0gY29zO1xuICAgICAgbWF0cml4WzRdID0geCAtIChjb3MgKiB4IC0gc2luICogeSk7XG4gICAgICBtYXRyaXhbNV0gPSB5IC0gKHNpbiAqIHggKyBjb3MgKiB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBtdWx0aXBsaWVyWCA9IGFyZ3NbMF0sXG4gICAgICAgICAgbXVsdGlwbGllclkgPSAoYXJncy5sZW5ndGggPT09IDIpID8gYXJnc1sxXSA6IGFyZ3NbMF07XG5cbiAgICAgIG1hdHJpeFswXSA9IG11bHRpcGxpZXJYO1xuICAgICAgbWF0cml4WzNdID0gbXVsdGlwbGllclk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIHBvcykge1xuICAgICAgbWF0cml4W3Bvc10gPSBNYXRoLnRhbihmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICBtYXRyaXhbNF0gPSBhcmdzWzBdO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG1hdHJpeFs1XSA9IGFyZ3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWRlbnRpdHkgbWF0cml4XG4gICAgdmFyIGlNYXRyaXggPSBmYWJyaWMuaU1hdHJpeCxcblxuICAgICAgICAvLyA9PSBiZWdpbiB0cmFuc2Zvcm0gcmVnZXhwXG4gICAgICAgIG51bWJlciA9IGZhYnJpYy5yZU51bSxcblxuICAgICAgICBjb21tYVdzcCA9IGZhYnJpYy5jb21tYVdzcCxcblxuICAgICAgICBza2V3WCA9ICcoPzooc2tld1gpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkpJyxcblxuICAgICAgICBza2V3WSA9ICcoPzooc2tld1kpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkpJyxcblxuICAgICAgICByb3RhdGUgPSAnKD86KHJvdGF0ZSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJykoPzonICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIHNjYWxlID0gJyg/OihzY2FsZSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJykoPzonICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKSk/XFxcXHMqXFxcXCkpJyxcblxuICAgICAgICB0cmFuc2xhdGUgPSAnKD86KHRyYW5zbGF0ZSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJykoPzonICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKSk/XFxcXHMqXFxcXCkpJyxcblxuICAgICAgICBtYXRyaXggPSAnKD86KG1hdHJpeClcXFxccypcXFxcKFxcXFxzKicgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICtcbiAgICAgICAgICAgICAgICAgICdcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHRyYW5zZm9ybSA9ICcoPzonICtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICByb3RhdGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBza2V3WCArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNrZXdZICtcbiAgICAgICAgICAgICAgICAgICAgJyknLFxuXG4gICAgICAgIHRyYW5zZm9ybXMgPSAnKD86JyArIHRyYW5zZm9ybSArICcoPzonICsgY29tbWFXc3AgKyAnKicgKyB0cmFuc2Zvcm0gKyAnKSonICsgJyknLFxuXG4gICAgICAgIHRyYW5zZm9ybUxpc3QgPSAnXlxcXFxzKig/OicgKyB0cmFuc2Zvcm1zICsgJz8pXFxcXHMqJCcsXG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1RyYW5zZm9ybUF0dHJpYnV0ZVxuICAgICAgICByZVRyYW5zZm9ybUxpc3QgPSBuZXcgUmVnRXhwKHRyYW5zZm9ybUxpc3QpLFxuICAgICAgICAvLyA9PSBlbmQgdHJhbnNmb3JtIHJlZ2V4cFxuXG4gICAgICAgIHJlVHJhbnNmb3JtID0gbmV3IFJlZ0V4cCh0cmFuc2Zvcm0sICdnJyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYXR0cmlidXRlVmFsdWUpIHtcblxuICAgICAgLy8gc3RhcnQgd2l0aCBpZGVudGl0eSBtYXRyaXhcbiAgICAgIHZhciBtYXRyaXggPSBpTWF0cml4LmNvbmNhdCgpLFxuICAgICAgICAgIG1hdHJpY2VzID0gW107XG5cbiAgICAgIC8vIHJldHVybiBpZiBubyBhcmd1bWVudCB3YXMgZ2l2ZW4gb3JcbiAgICAgIC8vIGFuIGFyZ3VtZW50IGRvZXMgbm90IG1hdGNoIHRyYW5zZm9ybSBhdHRyaWJ1dGUgcmVnZXhwXG4gICAgICBpZiAoIWF0dHJpYnV0ZVZhbHVlIHx8IChhdHRyaWJ1dGVWYWx1ZSAmJiAhcmVUcmFuc2Zvcm1MaXN0LnRlc3QoYXR0cmlidXRlVmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgfVxuXG4gICAgICBhdHRyaWJ1dGVWYWx1ZS5yZXBsYWNlKHJlVHJhbnNmb3JtLCBmdW5jdGlvbihtYXRjaCkge1xuXG4gICAgICAgIHZhciBtID0gbmV3IFJlZ0V4cCh0cmFuc2Zvcm0pLmV4ZWMobWF0Y2gpLmZpbHRlcihmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgLy8gbWF0Y2ggIT09ICcnICYmIG1hdGNoICE9IG51bGxcbiAgICAgICAgICAgICAgcmV0dXJuICghIW1hdGNoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb3BlcmF0aW9uID0gbVsxXSxcbiAgICAgICAgICAgIGFyZ3MgPSBtLnNsaWNlKDIpLm1hcChwYXJzZUZsb2F0KTtcblxuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG4gICAgICAgICAgICB0cmFuc2xhdGVNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICBhcmdzWzBdID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhhcmdzWzBdKTtcbiAgICAgICAgICAgIHJvdGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgICAgc2NhbGVNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NrZXdYJzpcbiAgICAgICAgICAgIHNrZXdNYXRyaXgobWF0cml4LCBhcmdzLCAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgICAgICAgIHNrZXdNYXRyaXgobWF0cml4LCBhcmdzLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgICAgICBtYXRyaXggPSBhcmdzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzbmFwc2hvdCBjdXJyZW50IG1hdHJpeCBpbnRvIG1hdHJpY2VzIGFycmF5XG4gICAgICAgIG1hdHJpY2VzLnB1c2gobWF0cml4LmNvbmNhdCgpKTtcbiAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgbWF0cml4ID0gaU1hdHJpeC5jb25jYXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY29tYmluZWRNYXRyaXggPSBtYXRyaWNlc1swXTtcbiAgICAgIHdoaWxlIChtYXRyaWNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1hdHJpY2VzLnNoaWZ0KCk7XG4gICAgICAgIGNvbWJpbmVkTWF0cml4ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhjb21iaW5lZE1hdHJpeCwgbWF0cmljZXNbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0cml4O1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpIHtcbiAgICB2YXIgYXR0ciwgdmFsdWU7XG4gICAgc3R5bGUucmVwbGFjZSgvO1xccyokLywgJycpLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHZhciBwYWlyID0gY2h1bmsuc3BsaXQoJzonKTtcblxuICAgICAgYXR0ciA9IHBhaXJbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9ICBwYWlyWzFdLnRyaW0oKTtcblxuICAgICAgb1N0eWxlW2F0dHJdID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSkge1xuICAgIHZhciBhdHRyLCB2YWx1ZTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0eWxlW3Byb3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYXR0ciA9IHByb3AudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICAgIG9TdHlsZVthdHRyXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudChlbGVtZW50LCBzdmdVaWQpIHtcbiAgICB2YXIgc3R5bGVzID0geyB9O1xuICAgIGZvciAodmFyIHJ1bGUgaW4gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF0pIHtcbiAgICAgIGlmIChlbGVtZW50TWF0Y2hlc1J1bGUoZWxlbWVudCwgcnVsZS5zcGxpdCgnICcpKSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXVtydWxlXSkge1xuICAgICAgICAgIHN0eWxlc1twcm9wZXJ0eV0gPSBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXVtydWxlXVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXNSdWxlKGVsZW1lbnQsIHNlbGVjdG9ycykge1xuICAgIHZhciBmaXJzdE1hdGNoaW5nLCBwYXJlbnRNYXRjaGluZyA9IHRydWU7XG4gICAgLy9zdGFydCBmcm9tIHJpZ2h0bW9zdCBzZWxlY3Rvci5cbiAgICBmaXJzdE1hdGNoaW5nID0gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9ycy5wb3AoKSk7XG4gICAgaWYgKGZpcnN0TWF0Y2hpbmcgJiYgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgcGFyZW50TWF0Y2hpbmcgPSBkb2VzU29tZVBhcmVudE1hdGNoKGVsZW1lbnQsIHNlbGVjdG9ycyk7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdE1hdGNoaW5nICYmIHBhcmVudE1hdGNoaW5nICYmIChzZWxlY3RvcnMubGVuZ3RoID09PSAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvZXNTb21lUGFyZW50TWF0Y2goZWxlbWVudCwgc2VsZWN0b3JzKSB7XG4gICAgdmFyIHNlbGVjdG9yLCBwYXJlbnRNYXRjaGluZyA9IHRydWU7XG4gICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgaWYgKHBhcmVudE1hdGNoaW5nKSB7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzLnBvcCgpO1xuICAgICAgfVxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE1hdGNoaW5nID0gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9ycy5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUsXG4gICAgICAgIGNsYXNzTmFtZXMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSxcbiAgICAgICAgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSwgbWF0Y2hlciwgaTtcbiAgICAvLyBpIGNoZWNrIGlmIGEgc2VsZWN0b3IgbWF0Y2hlcyBzbGljaW5nIGF3YXkgcGFydCBmcm9tIGl0LlxuICAgIC8vIGlmIGkgZ2V0IGVtcHR5IHN0cmluZyBpIHNob3VsZCBtYXRjaFxuICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCdeJyArIG5vZGVOYW1lLCAnaScpO1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgaWYgKGlkICYmIHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJyMnICsgaWQgKyAnKD8hW2EtekEtWlxcXFwtXSspJywgJ2knKTtcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWVzICYmIHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuc3BsaXQoJyAnKTtcbiAgICAgIGZvciAoaSA9IGNsYXNzTmFtZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCdcXFxcLicgKyBjbGFzc05hbWVzW2ldICsgJyg/IVthLXpBLVpcXFxcLV0rKScsICdpJyk7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rvci5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdG8gc3VwcG9ydCBJRTggbWlzc2luZyBnZXRFbGVtZW50QnlJZCBvbiBTVkdkb2N1bWVudCBhbmQgb24gbm9kZSB4bWxET01cbiAgICovXG4gIGZ1bmN0aW9uIGVsZW1lbnRCeUlkKGRvYywgaWQpIHtcbiAgICB2YXIgZWw7XG4gICAgZG9jLmdldEVsZW1lbnRCeUlkICYmIChlbCA9IGRvYy5nZXRFbGVtZW50QnlJZChpZCkpO1xuICAgIGlmIChlbCkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICB2YXIgbm9kZSwgaSwgbGVuLCBub2RlbGlzdCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGVsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZWxpc3RbaV07XG4gICAgICBpZiAoaWQgPT09IG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VVc2VEaXJlY3RpdmVzKGRvYykge1xuICAgIHZhciBub2RlbGlzdCA9IF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgWyd1c2UnLCAnc3ZnOnVzZSddKSwgaSA9IDA7XG4gICAgd2hpbGUgKG5vZGVsaXN0Lmxlbmd0aCAmJiBpIDwgbm9kZWxpc3QubGVuZ3RoKSB7XG4gICAgICB2YXIgZWwgPSBub2RlbGlzdFtpXSxcbiAgICAgICAgICB4bGlua0F0dHJpYnV0ZSA9IGVsLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpIHx8IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXG4gICAgICBpZiAoeGxpbmtBdHRyaWJ1dGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeGxpbmsgPSB4bGlua0F0dHJpYnV0ZS5zdWJzdHIoMSksXG4gICAgICAgICAgeCA9IGVsLmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgICAgeSA9IGVsLmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgICAgZWwyID0gZWxlbWVudEJ5SWQoZG9jLCB4bGluaykuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IChlbDIuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJykgKyAnIHRyYW5zbGF0ZSgnICsgeCArICcsICcgKyB5ICsgJyknLFxuICAgICAgICAgIHBhcmVudE5vZGUsXG4gICAgICAgICAgb2xkTGVuZ3RoID0gbm9kZWxpc3QubGVuZ3RoLCBhdHRyLFxuICAgICAgICAgIGosXG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgbGVuLFxuICAgICAgICAgIG5hbWVzcGFjZSA9IGZhYnJpYy5zdmdOUztcblxuICAgICAgYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGVsMik7XG4gICAgICBpZiAoL15zdmckL2kudGVzdChlbDIubm9kZU5hbWUpKSB7XG4gICAgICAgIHZhciBlbDMgPSBlbDIub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAnZycpO1xuICAgICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsMi5hdHRyaWJ1dGVzLCBsZW4gPSBhdHRycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICAgIGVsMy5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbDIuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICAgIHdoaWxlIChlbDIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsMy5hcHBlbmRDaGlsZChlbDIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwyID0gZWwzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsLmF0dHJpYnV0ZXMsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3gnIHx8IGF0dHIubm9kZU5hbWUgPT09ICd5JyB8fFxuICAgICAgICAgIGF0dHIubm9kZU5hbWUgPT09ICd4bGluazpocmVmJyB8fCBhdHRyLm5vZGVOYW1lID09PSAnaHJlZicpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyLm5vZGVOYW1lID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IGF0dHIubm9kZVZhbHVlICsgJyAnICsgY3VycmVudFRyYW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSwgYXR0ci5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGN1cnJlbnRUcmFucyk7XG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCdpbnN0YW50aWF0ZWRfYnlfdXNlJywgJzEnKTtcbiAgICAgIGVsMi5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsMiwgZWwpO1xuICAgICAgLy8gc29tZSBicm93c2VycyBkbyBub3Qgc2hvcnRlbiBub2RlbGlzdCBhZnRlciByZXBsYWNlQ2hpbGQgKElFOClcbiAgICAgIGlmIChub2RlbGlzdC5sZW5ndGggPT09IG9sZExlbmd0aCkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ZpZXdCb3hBdHRyaWJ1dGVcbiAgLy8gbWF0Y2hlcywgZS5nLjogKzE0LjU2ZS0xMiwgZXRjLlxuICB2YXIgcmVWaWV3Qm94QXR0clZhbHVlID0gbmV3IFJlZ0V4cChcbiAgICAnXicgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKicgK1xuICAgICckJ1xuICApO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8Zz4gZWxlbWVudCB0aGF0IGVudmVsb3AgYWxsIGNoaWxkIGVsZW1lbnRzIGFuZCBtYWtlcyB0aGUgdmlld2JveCB0cmFuc2Zvcm1NYXRyaXggZGVzY2VuZCBvbiBhbGwgZWxlbWVudHNcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbGVtZW50KSB7XG4gICAgaWYgKCFmYWJyaWMuc3ZnVmlld0JveEVsZW1lbnRzUmVnRXgudGVzdChlbGVtZW50Lm5vZGVOYW1lKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB2YXIgdmlld0JveEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLFxuICAgICAgICBzY2FsZVggPSAxLFxuICAgICAgICBzY2FsZVkgPSAxLFxuICAgICAgICBtaW5YID0gMCxcbiAgICAgICAgbWluWSA9IDAsXG4gICAgICAgIHZpZXdCb3hXaWR0aCwgdmlld0JveEhlaWdodCwgbWF0cml4LCBlbCxcbiAgICAgICAgd2lkdGhBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgIGhlaWdodEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksXG4gICAgICAgIHggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgIHkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpIHx8ICcnLFxuICAgICAgICBtaXNzaW5nVmlld0JveCA9ICghdmlld0JveEF0dHIgfHwgISh2aWV3Qm94QXR0ciA9IHZpZXdCb3hBdHRyLm1hdGNoKHJlVmlld0JveEF0dHJWYWx1ZSkpKSxcbiAgICAgICAgbWlzc2luZ0RpbUF0dHIgPSAoIXdpZHRoQXR0ciB8fCAhaGVpZ2h0QXR0ciB8fCB3aWR0aEF0dHIgPT09ICcxMDAlJyB8fCBoZWlnaHRBdHRyID09PSAnMTAwJScpLFxuICAgICAgICB0b0JlUGFyc2VkID0gbWlzc2luZ1ZpZXdCb3ggJiYgbWlzc2luZ0RpbUF0dHIsXG4gICAgICAgIHBhcnNlZERpbSA9IHsgfSwgdHJhbnNsYXRlTWF0cml4ID0gJycsIHdpZHRoRGlmZiA9IDAsIGhlaWdodERpZmYgPSAwO1xuXG4gICAgcGFyc2VkRGltLndpZHRoID0gMDtcbiAgICBwYXJzZWREaW0uaGVpZ2h0ID0gMDtcbiAgICBwYXJzZWREaW0udG9CZVBhcnNlZCA9IHRvQmVQYXJzZWQ7XG5cbiAgICBpZiAobWlzc2luZ1ZpZXdCb3gpIHtcbiAgICAgIGlmICgoKHggfHwgeSkgJiYgZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSAhPT0gJyNkb2N1bWVudCcpKSB7XG4gICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9ICcgdHJhbnNsYXRlKCcgKyBwYXJzZVVuaXQoeCkgKyAnICcgKyBwYXJzZVVuaXQoeSkgKyAnKSAnO1xuICAgICAgICBtYXRyaXggPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnKSArIHRyYW5zbGF0ZU1hdHJpeDtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIG1hdHJpeCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd4Jyk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd5Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRvQmVQYXJzZWQpIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuXG4gICAgaWYgKG1pc3NpbmdWaWV3Qm94KSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSBwYXJzZVVuaXQod2lkdGhBdHRyKTtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSBwYXJzZVVuaXQoaGVpZ2h0QXR0cik7XG4gICAgICAvLyBzZXQgYSB0cmFuc2Zvcm0gZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB4IHkgYW5kIGFyZSBpbm5lcihvbmx5KSBTVkdzXG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cbiAgICBtaW5YID0gLXBhcnNlRmxvYXQodmlld0JveEF0dHJbMV0pO1xuICAgIG1pblkgPSAtcGFyc2VGbG9hdCh2aWV3Qm94QXR0clsyXSk7XG4gICAgdmlld0JveFdpZHRoID0gcGFyc2VGbG9hdCh2aWV3Qm94QXR0clszXSk7XG4gICAgdmlld0JveEhlaWdodCA9IHBhcnNlRmxvYXQodmlld0JveEF0dHJbNF0pO1xuICAgIHBhcnNlZERpbS5taW5YID0gbWluWDtcbiAgICBwYXJzZWREaW0ubWluWSA9IG1pblk7XG4gICAgcGFyc2VkRGltLnZpZXdCb3hXaWR0aCA9IHZpZXdCb3hXaWR0aDtcbiAgICBwYXJzZWREaW0udmlld0JveEhlaWdodCA9IHZpZXdCb3hIZWlnaHQ7XG4gICAgaWYgKCFtaXNzaW5nRGltQXR0cikge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gcGFyc2VVbml0KHdpZHRoQXR0cik7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gcGFyc2VVbml0KGhlaWdodEF0dHIpO1xuICAgICAgc2NhbGVYID0gcGFyc2VkRGltLndpZHRoIC8gdmlld0JveFdpZHRoO1xuICAgICAgc2NhbGVZID0gcGFyc2VkRGltLmhlaWdodCAvIHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gdmlld0JveFdpZHRoO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBpcyB0byBwcmVzZXJ2ZSBhc3BlY3QgcmF0aW9cbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZmFicmljLnV0aWwucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWCAhPT0gJ25vbmUnKSB7XG4gICAgICAvL3RyYW5zbGF0ZSBhbGwgY29udGFpbmVyIGZvciB0aGUgZWZmZWN0IG9mIE1pZCwgTWluLCBNYXhcbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgc2NhbGVZID0gc2NhbGVYID0gKHNjYWxlWCA+IHNjYWxlWSA/IHNjYWxlWSA6IHNjYWxlWCk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhZGRpdGlvbmFsIHRyYW5zbGF0aW9uIHRvIG1vdmUgdGhlIHZpZXdib3hcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnc2xpY2UnKSB7XG4gICAgICAgIHNjYWxlWSA9IHNjYWxlWCA9IChzY2FsZVggPiBzY2FsZVkgPyBzY2FsZVggOiBzY2FsZVkpO1xuICAgICAgICAvLyBjYWxjdWxhdGUgYWRkaXRpb25hbCB0cmFuc2xhdGlvbiB0byBtb3ZlIHRoZSB2aWV3Ym94XG4gICAgICB9XG4gICAgICB3aWR0aERpZmYgPSBwYXJzZWREaW0ud2lkdGggLSB2aWV3Qm94V2lkdGggKiBzY2FsZVg7XG4gICAgICBoZWlnaHREaWZmID0gcGFyc2VkRGltLmhlaWdodCAtIHZpZXdCb3hIZWlnaHQgKiBzY2FsZVg7XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaWQnKSB7XG4gICAgICAgIHdpZHRoRGlmZiAvPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25ZID09PSAnTWlkJykge1xuICAgICAgICBoZWlnaHREaWZmIC89IDI7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaW4nKSB7XG4gICAgICAgIHdpZHRoRGlmZiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgIGhlaWdodERpZmYgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxICYmIG1pblggPT09IDAgJiYgbWluWSA9PT0gMCAmJiB4ID09PSAwICYmIHkgPT09IDApIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuICAgIGlmICgoeCB8fCB5KSAmJiBlbGVtZW50LnBhcmVudE5vZGUubm9kZU5hbWUgIT09ICcjZG9jdW1lbnQnKSB7XG4gICAgICB0cmFuc2xhdGVNYXRyaXggPSAnIHRyYW5zbGF0ZSgnICsgcGFyc2VVbml0KHgpICsgJyAnICsgcGFyc2VVbml0KHkpICsgJykgJztcbiAgICB9XG5cbiAgICBtYXRyaXggPSB0cmFuc2xhdGVNYXRyaXggKyAnIG1hdHJpeCgnICsgc2NhbGVYICtcbiAgICAgICAgICAgICAgICAgICcgMCcgK1xuICAgICAgICAgICAgICAgICAgJyAwICcgK1xuICAgICAgICAgICAgICAgICAgc2NhbGVZICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIChtaW5YICogc2NhbGVYICsgd2lkdGhEaWZmKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAobWluWSAqIHNjYWxlWSArIGhlaWdodERpZmYpICsgJykgJztcbiAgICAvLyBzZWVtcyB1bnVzZWQuXG4gICAgLy8gcGFyc2VkRGltLnZpZXdib3hUcmFuc2Zvcm0gPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUobWF0cml4KTtcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgIGVsID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmYWJyaWMuc3ZnTlMsICdnJyk7XG4gICAgICAvLyBlbGVtZW50LmZpcnN0Q2hpbGQgIT0gbnVsbFxuICAgICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWwgPSBlbGVtZW50O1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd4Jyk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3knKTtcbiAgICAgIG1hdHJpeCA9IGVsLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgKyBtYXRyaXg7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICByZXR1cm4gcGFyc2VkRGltO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWxlbWVudCwgbm9kZU5hbWUpIHtcbiAgICB3aGlsZSAoZWxlbWVudCAmJiAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lICYmIG5vZGVOYW1lLnRlc3QoZWxlbWVudC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKVxuICAgICAgICAmJiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2luc3RhbnRpYXRlZF9ieV91c2UnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIGNvbnZlcnRzIGl0IHRvIGFuIGFycmF5IG9mIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzIGFuZCBwYXNzZXMgdGhlbSB0byBhIGNhbGxiYWNrXG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBjYWxsIHdoZW4gcGFyc2luZyBpcyBmaW5pc2hlZDtcbiAgICogSXQncyBiZWluZyBwYXNzZWQgYW4gYXJyYXkgb2YgZWxlbWVudHMgKHBhcnNlZCBmcm9tIGEgZG9jdW1lbnQpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyc2luZ09wdGlvbnNdIG9wdGlvbnMgZm9yIHBhcnNpbmcgZG9jdW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gc2V0dGluZ3NcbiAgICovXG4gIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50ID0gZnVuY3Rpb24oZG9jLCBjYWxsYmFjaywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpO1xuXG4gICAgdmFyIHN2Z1VpZCA9ICBmYWJyaWMuT2JqZWN0Ll9fdWlkKyssIGksIGxlbixcbiAgICAgICAgb3B0aW9ucyA9IGFwcGx5Vmlld2JveFRyYW5zZm9ybShkb2MpLFxuICAgICAgICBkZXNjZW5kYW50cyA9IGZhYnJpYy51dGlsLnRvQXJyYXkoZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpO1xuICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gPSBwYXJzaW5nT3B0aW9ucyAmJiBwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICBvcHRpb25zLnN2Z1VpZCA9IHN2Z1VpZDtcblxuICAgIGlmIChkZXNjZW5kYW50cy5sZW5ndGggPT09IDAgJiYgZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgLy8gd2UncmUgbGlrZWx5IGluIG5vZGUsIHdoZXJlIFwibzMteG1sXCIgbGlicmFyeSBmYWlscyB0byBnRUJUTihcIipcIilcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hamF4b3JnL25vZGUtbzMteG1sL2lzc3Vlcy8yMVxuICAgICAgZGVzY2VuZGFudHMgPSBkb2Muc2VsZWN0Tm9kZXMoJy8vKltuYW1lKC4pIT1cInN2Z1wiXScpO1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGVzY2VuZGFudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gZGVzY2VuZGFudHNbaV07XG4gICAgICB9XG4gICAgICBkZXNjZW5kYW50cyA9IGFycjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbCk7XG4gICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeC50ZXN0KGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpICYmXG4gICAgICAgICAgICAhaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWwsIGZhYnJpYy5zdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXgpOyAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjRGVmc0VsZW1lbnRcbiAgICB9KTtcbiAgICBpZiAoIWVsZW1lbnRzIHx8IChlbGVtZW50cyAmJiAhZWxlbWVudHMubGVuZ3RoKSkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soW10sIHt9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNsaXBQYXRocyA9IHsgfTtcbiAgICBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBlbC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpID09PSAnY2xpcFBhdGgnO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBpZCA9IGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgIGNsaXBQYXRoc1tpZF0gPSBmYWJyaWMudXRpbC50b0FycmF5KGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeC50ZXN0KGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZmFicmljLmdyYWRpZW50RGVmc1tzdmdVaWRdID0gZmFicmljLmdldEdyYWRpZW50RGVmcyhkb2MpO1xuICAgIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdID0gZmFicmljLmdldENTU1J1bGVzKGRvYyk7XG4gICAgZmFicmljLmNsaXBQYXRoc1tzdmdVaWRdID0gY2xpcFBhdGhzO1xuICAgIC8vIFByZWNlZGVuY2Ugb2YgcnVsZXM6ICAgc3R5bGUgPiBjbGFzcyA+IGF0dHJpYnV0ZVxuICAgIGZhYnJpYy5wYXJzZUVsZW1lbnRzKGVsZW1lbnRzLCBmdW5jdGlvbihpbnN0YW5jZXMsIGVsZW1lbnRzKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaW5zdGFuY2VzLCBvcHRpb25zLCBlbGVtZW50cywgZGVzY2VuZGFudHMpO1xuICAgICAgICBkZWxldGUgZmFicmljLmdyYWRpZW50RGVmc1tzdmdVaWRdO1xuICAgICAgICBkZWxldGUgZmFicmljLmNzc1J1bGVzW3N2Z1VpZF07XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY2xpcFBhdGhzW3N2Z1VpZF07XG4gICAgICB9XG4gICAgfSwgY2xvbmUob3B0aW9ucyksIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsoZG9jLCBncmFkaWVudCkge1xuICAgIHZhciBncmFkaWVudHNBdHRycyA9IFsnZ3JhZGllbnRUcmFuc2Zvcm0nLCAneDEnLCAneDInLCAneTEnLCAneTInLCAnZ3JhZGllbnRVbml0cycsICdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5J10sXG4gICAgICAgIHhsaW5rQXR0ciA9ICd4bGluazpocmVmJyxcbiAgICAgICAgeExpbmsgPSBncmFkaWVudC5nZXRBdHRyaWJ1dGUoeGxpbmtBdHRyKS5zdWJzdHIoMSksXG4gICAgICAgIHJlZmVyZW5jZWRHcmFkaWVudCA9IGVsZW1lbnRCeUlkKGRvYywgeExpbmspO1xuICAgIGlmIChyZWZlcmVuY2VkR3JhZGllbnQgJiYgcmVmZXJlbmNlZEdyYWRpZW50LmdldEF0dHJpYnV0ZSh4bGlua0F0dHIpKSB7XG4gICAgICByZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsoZG9jLCByZWZlcmVuY2VkR3JhZGllbnQpO1xuICAgIH1cbiAgICBncmFkaWVudHNBdHRycy5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChyZWZlcmVuY2VkR3JhZGllbnQgJiYgIWdyYWRpZW50Lmhhc0F0dHJpYnV0ZShhdHRyKSAmJiByZWZlcmVuY2VkR3JhZGllbnQuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZShhdHRyLCByZWZlcmVuY2VkR3JhZGllbnQuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWdyYWRpZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIHJlZmVyZW5jZUNsb25lID0gcmVmZXJlbmNlZEdyYWRpZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHdoaWxlIChyZWZlcmVuY2VDbG9uZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGdyYWRpZW50LmFwcGVuZENoaWxkKHJlZmVyZW5jZUNsb25lLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICBncmFkaWVudC5yZW1vdmVBdHRyaWJ1dGUoeGxpbmtBdHRyKTtcbiAgfVxuXG4gIHZhciByZUZvbnREZWNsYXJhdGlvbiA9IG5ldyBSZWdFeHAoXG4gICAgJyhub3JtYWx8aXRhbGljKT9cXFxccyoobm9ybWFsfHNtYWxsLWNhcHMpP1xcXFxzKicgK1xuICAgICcobm9ybWFsfGJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8MTAwfDIwMHwzMDB8NDAwfDUwMHw2MDB8NzAwfDgwMHw5MDApP1xcXFxzKignICtcbiAgICAgIGZhYnJpYy5yZU51bSArXG4gICAgJyg/OnB4fGNtfG1tfGVtfHB0fHBjfGluKSopKD86XFxcXC8obm9ybWFsfCcgKyBmYWJyaWMucmVOdW0gKyAnKSk/XFxcXHMrKC4qKScpO1xuXG4gIGV4dGVuZChmYWJyaWMsIHtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzaG9ydCBmb250IGRlY2xhcmF0aW9uLCBidWlsZGluZyBhZGRpbmcgaXRzIHByb3BlcnRpZXMgdG8gYSBzdHlsZSBvYmplY3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBmb250IGRlY2xhcmF0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9TdHlsZSBkZWZpbml0aW9uXG4gICAgICovXG4gICAgcGFyc2VGb250RGVjbGFyYXRpb246IGZ1bmN0aW9uKHZhbHVlLCBvU3R5bGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlRm9udERlY2xhcmF0aW9uKTtcblxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZm9udFN0eWxlID0gbWF0Y2hbMV0sXG4gICAgICAgICAgLy8gZm9udCB2YXJpYW50IGlzIG5vdCB1c2VkXG4gICAgICAgICAgLy8gZm9udFZhcmlhbnQgPSBtYXRjaFsyXSxcbiAgICAgICAgICBmb250V2VpZ2h0ID0gbWF0Y2hbM10sXG4gICAgICAgICAgZm9udFNpemUgPSBtYXRjaFs0XSxcbiAgICAgICAgICBsaW5lSGVpZ2h0ID0gbWF0Y2hbNV0sXG4gICAgICAgICAgZm9udEZhbWlseSA9IG1hdGNoWzZdO1xuXG4gICAgICBpZiAoZm9udFN0eWxlKSB7XG4gICAgICAgIG9TdHlsZS5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICB9XG4gICAgICBpZiAoZm9udFdlaWdodCkge1xuICAgICAgICBvU3R5bGUuZm9udFdlaWdodCA9IGlzTmFOKHBhcnNlRmxvYXQoZm9udFdlaWdodCkpID8gZm9udFdlaWdodCA6IHBhcnNlRmxvYXQoZm9udFdlaWdodCk7XG4gICAgICB9XG4gICAgICBpZiAoZm9udFNpemUpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRTaXplID0gcGFyc2VVbml0KGZvbnRTaXplKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250RmFtaWx5KSB7XG4gICAgICAgIG9TdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSGVpZ2h0KSB7XG4gICAgICAgIG9TdHlsZS5saW5lSGVpZ2h0ID0gbGluZUhlaWdodCA9PT0gJ25vcm1hbCcgPyAxIDogbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIFNWRyBkb2N1bWVudCwgcmV0dXJuaW5nIGFsbCBvZiB0aGUgZ3JhZGllbnQgZGVjbGFyYXRpb25zIGZvdW5kIGluIGl0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBHcmFkaWVudCBkZWZpbml0aW9uczsga2V5IGNvcnJlc3BvbmRzIHRvIGVsZW1lbnQgaWQsIHZhbHVlIC0tIHRvIGdyYWRpZW50IGRlZmluaXRpb24gZWxlbWVudFxuICAgICAqL1xuICAgIGdldEdyYWRpZW50RGVmczogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgdGFnQXJyYXkgPSBbXG4gICAgICAgICAgICAnbGluZWFyR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3JhZGlhbEdyYWRpZW50JyxcbiAgICAgICAgICAgICdzdmc6bGluZWFyR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3N2ZzpyYWRpYWxHcmFkaWVudCddLFxuICAgICAgICAgIGVsTGlzdCA9IF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgdGFnQXJyYXkpLFxuICAgICAgICAgIGVsLCBqID0gMCwgZ3JhZGllbnREZWZzID0geyB9O1xuICAgICAgaiA9IGVsTGlzdC5sZW5ndGg7XG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGVsID0gZWxMaXN0W2pdO1xuICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJykpIHtcbiAgICAgICAgICByZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsoZG9jLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnREZWZzW2VsLmdldEF0dHJpYnV0ZSgnaWQnKV0gPSBlbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmFkaWVudERlZnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMnIG5hbWUvdmFsdWUsIGdpdmVuIGVsZW1lbnQgYW5kIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcztcbiAgICAgKiBQYXJzZXMgcGFyZW50IFwiZ1wiIG5vZGVzIHJlY3Vyc2l2ZWx5IHVwd2FyZHMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGF0dHJpYnV0ZXMgQXJyYXkgb2YgYXR0cmlidXRlcyB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgcGFyc2VkIGF0dHJpYnV0ZXMnIG5hbWVzL3ZhbHVlc1xuICAgICAqL1xuICAgIHBhcnNlQXR0cmlidXRlczogZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlcywgc3ZnVWlkKSB7XG5cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzID0geyB9LFxuICAgICAgICAgIGZvbnRTaXplLCBwYXJlbnRGb250U2l6ZTtcblxuICAgICAgaWYgKHR5cGVvZiBzdmdVaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN2Z1VpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdmdVaWQnKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZXJlJ3MgYSBwYXJlbnQgY29udGFpbmVyIChgZ2Agb3IgYGFgIG9yIGBzeW1ib2xgIG5vZGUpLCBwYXJzZSBpdHMgYXR0cmlidXRlcyByZWN1cnNpdmVseSB1cHdhcmRzXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmIGZhYnJpYy5zdmdWYWxpZFBhcmVudHNSZWdFeC50ZXN0KGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgcGFyZW50QXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudC5wYXJlbnROb2RlLCBhdHRyaWJ1dGVzLCBzdmdVaWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3duQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGF0dHIpIHtcbiAgICAgICAgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICBtZW1vW2F0dHJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICB9LCB7IH0pO1xuICAgICAgLy8gYWRkIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSwgd2hpY2ggdGFrZSBwcmVjZWRlbmNlIG92ZXIgYXR0cmlidXRlc1xuICAgICAgLy8gKHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0eWxpbmcuaHRtbCNVc2luZ1ByZXNlbnRhdGlvbkF0dHJpYnV0ZXMpXG4gICAgICB2YXIgY3NzQXR0cnMgPSBleHRlbmQoXG4gICAgICAgIGdldEdsb2JhbFN0eWxlc0ZvckVsZW1lbnQoZWxlbWVudCwgc3ZnVWlkKSxcbiAgICAgICAgZmFicmljLnBhcnNlU3R5bGVBdHRyaWJ1dGUoZWxlbWVudClcbiAgICAgICk7XG4gICAgICBvd25BdHRyaWJ1dGVzID0gZXh0ZW5kKFxuICAgICAgICBvd25BdHRyaWJ1dGVzLFxuICAgICAgICBjc3NBdHRyc1xuICAgICAgKTtcbiAgICAgIGlmIChjc3NBdHRyc1tjUGF0aF0pIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoY1BhdGgsIGNzc0F0dHJzW2NQYXRoXSk7XG4gICAgICB9XG4gICAgICBmb250U2l6ZSA9IHBhcmVudEZvbnRTaXplID0gcGFyZW50QXR0cmlidXRlcy5mb250U2l6ZSB8fCBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgICBpZiAob3duQXR0cmlidXRlc1tmU2l6ZV0pIHtcbiAgICAgICAgLy8gbG9va3MgbGlrZSB0aGUgbWluaW11bSBzaG91bGQgYmUgOXB4IHdoZW4gZGVhbGluZyB3aXRoIGVtcy4gdGhpcyBpcyB3aGF0IGxvb2tzIGxpa2UgaW4gYnJvd3NlcnMuXG4gICAgICAgIG93bkF0dHJpYnV0ZXNbZlNpemVdID0gZm9udFNpemUgPSBwYXJzZVVuaXQob3duQXR0cmlidXRlc1tmU2l6ZV0sIHBhcmVudEZvbnRTaXplKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZWRBdHRyLCBub3JtYWxpemVkVmFsdWUsIG5vcm1hbGl6ZWRTdHlsZSA9IHt9O1xuICAgICAgZm9yICh2YXIgYXR0ciBpbiBvd25BdHRyaWJ1dGVzKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRBdHRyID0gbm9ybWFsaXplQXR0cihhdHRyKTtcbiAgICAgICAgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplVmFsdWUobm9ybWFsaXplZEF0dHIsIG93bkF0dHJpYnV0ZXNbYXR0cl0sIHBhcmVudEF0dHJpYnV0ZXMsIGZvbnRTaXplKTtcbiAgICAgICAgbm9ybWFsaXplZFN0eWxlW25vcm1hbGl6ZWRBdHRyXSA9IG5vcm1hbGl6ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub3JtYWxpemVkU3R5bGUgJiYgbm9ybWFsaXplZFN0eWxlLmZvbnQpIHtcbiAgICAgICAgZmFicmljLnBhcnNlRm9udERlY2xhcmF0aW9uKG5vcm1hbGl6ZWRTdHlsZS5mb250LCBub3JtYWxpemVkU3R5bGUpO1xuICAgICAgfVxuICAgICAgdmFyIG1lcmdlZEF0dHJzID0gZXh0ZW5kKHBhcmVudEF0dHJpYnV0ZXMsIG5vcm1hbGl6ZWRTdHlsZSk7XG4gICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4LnRlc3QoZWxlbWVudC5ub2RlTmFtZSkgPyBtZXJnZWRBdHRycyA6IF9zZXRTdHJva2VGaWxsT3BhY2l0eShtZXJnZWRBdHRycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2Ygc3ZnIGVsZW1lbnRzIHRvIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBBcnJheSBvZiBlbGVtZW50cyB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEJlaW5nIHBhc3NlZCBhbiBhcnJheSBvZiBmYWJyaWMgaW5zdGFuY2VzICh0cmFuc2Zvcm1lZCBmcm9tIFNWRyBlbGVtZW50cylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqL1xuICAgIHBhcnNlRWxlbWVudHM6IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgICAgIG5ldyBmYWJyaWMuRWxlbWVudHNQYXJzZXIoZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykucGFyc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIFwic3R5bGVcIiBhdHRyaWJ1dGUsIHJldHVuaW5nIGFuIG9iamVjdCB3aXRoIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdHMgd2l0aCB2YWx1ZXMgcGFyc2VkIGZyb20gc3R5bGUgYXR0cmlidXRlIG9mIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBwYXJzZVN0eWxlQXR0cmlidXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgb1N0eWxlID0geyB9LFxuICAgICAgICAgIHN0eWxlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG9TdHlsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyc2VTdHlsZVN0cmluZyhzdHlsZSwgb1N0eWxlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwYXJzZVN0eWxlT2JqZWN0KHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb1N0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJwb2ludHNcIiBhdHRyaWJ1dGUsIHJldHVybmluZyBhbiBhcnJheSBvZiB2YWx1ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb2ludHMgcG9pbnRzIGF0dHJpYnV0ZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcG9pbnRzXG4gICAgICovXG4gICAgcGFyc2VQb2ludHNBdHRyaWJ1dGU6IGZ1bmN0aW9uKHBvaW50cykge1xuXG4gICAgICAvLyBwb2ludHMgYXR0cmlidXRlIGlzIHJlcXVpcmVkIGFuZCBtdXN0IG5vdCBiZSBlbXB0eVxuICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlcGxhY2UgY29tbWFzIHdpdGggd2hpdGVzcGFjZSBhbmQgcmVtb3ZlIGJvb2tlbmRpbmcgd2hpdGVzcGFjZVxuICAgICAgcG9pbnRzID0gcG9pbnRzLnJlcGxhY2UoLywvZywgJyAnKS50cmltKCk7XG5cbiAgICAgIHBvaW50cyA9IHBvaW50cy5zcGxpdCgvXFxzKy8pO1xuICAgICAgdmFyIHBhcnNlZFBvaW50cyA9IFtdLCBpLCBsZW47XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBwYXJzZWRQb2ludHMucHVzaCh7XG4gICAgICAgICAgeDogcGFyc2VGbG9hdChwb2ludHNbaV0pLFxuICAgICAgICAgIHk6IHBhcnNlRmxvYXQocG9pbnRzW2kgKyAxXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9kZCBudW1iZXIgb2YgcG9pbnRzIGlzIGFuIGVycm9yXG4gICAgICAvLyBpZiAocGFyc2VkUG9pbnRzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBwYXJzZWRQb2ludHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHJ1bGVzIGZvciBhIGdpdmVuIFNWRyBkb2N1bWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ1NTIHJ1bGVzIG9mIHRoaXMgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBnZXRDU1NSdWxlczogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgc3R5bGVzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHlsZScpLCBpLCBsZW4sXG4gICAgICAgICAgYWxsUnVsZXMgPSB7IH0sIHJ1bGVzO1xuXG4gICAgICAvLyB2ZXJ5IGNydWRlIHBhcnNpbmcgb2Ygc3R5bGUgY29udGVudHNcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0eWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgc3R5bGVDb250ZW50cyA9IHN0eWxlc1tpXS50ZXh0Q29udGVudDtcblxuICAgICAgICAvLyByZW1vdmUgY29tbWVudHNcbiAgICAgICAgc3R5bGVDb250ZW50cyA9IHN0eWxlQ29udGVudHMucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy9nLCAnJyk7XG4gICAgICAgIGlmIChzdHlsZUNvbnRlbnRzLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWNvdmVycyBhbGwgdGhlIHJ1bGUgaW4gdGhpcyBmb3JtIGBib2R5IHsgc3R5bGUgY29kZS4uLiB9YFxuICAgICAgICAvLyBydWxlcyA9IHN0eWxlQ29udGVudHMubWF0Y2goL1tee10qXFx7W1xcc1xcU10qP1xcfS9nKTtcbiAgICAgICAgcnVsZXMgPSBzdHlsZUNvbnRlbnRzLnNwbGl0KCd9Jyk7XG4gICAgICAgIC8vIHJlbW92ZSBlbXB0eSBydWxlcy5cbiAgICAgICAgcnVsZXMgPSBydWxlcy5maWx0ZXIoZnVuY3Rpb24ocnVsZSkgeyByZXR1cm4gcnVsZS50cmltKCk7IH0pO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHdlIGhhdmUgaG9wZWZ1bGx5IGFuIGFycmF5IG9mIHJ1bGVzIGBib2R5IHsgc3R5bGUgY29kZS4uLiBgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgcnVsZXMuZm9yRWFjaChmdW5jdGlvbihydWxlKSB7XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBydWxlLnNwbGl0KCd7JyksXG4gICAgICAgICAgICAgIHJ1bGVPYmogPSB7IH0sIGRlY2xhcmF0aW9uID0gbWF0Y2hbMV0udHJpbSgpLFxuICAgICAgICAgICAgICBwcm9wZXJ0eVZhbHVlUGFpcnMgPSBkZWNsYXJhdGlvbi5zcGxpdCgnOycpLmZpbHRlcihmdW5jdGlvbihwYWlyKSB7IHJldHVybiBwYWlyLnRyaW0oKTsgfSk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm9wZXJ0eVZhbHVlUGFpcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcHJvcGVydHlWYWx1ZVBhaXJzW2ldLnNwbGl0KCc6JyksXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYWlyWzBdLnRyaW0oKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhaXJbMV0udHJpbSgpO1xuICAgICAgICAgICAgcnVsZU9ialtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcnVsZSA9IG1hdGNoWzBdLnRyaW0oKTtcbiAgICAgICAgICBydWxlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbihfcnVsZSkge1xuICAgICAgICAgICAgX3J1bGUgPSBfcnVsZS5yZXBsYWNlKC9ec3ZnL2ksICcnKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoX3J1bGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxSdWxlc1tfcnVsZV0pIHtcbiAgICAgICAgICAgICAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChhbGxSdWxlc1tfcnVsZV0sIHJ1bGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFsbFJ1bGVzW19ydWxlXSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShydWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsUnVsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHVybCBjb3JyZXNwb25kaW5nIHRvIGFuIFNWRyBkb2N1bWVudCwgYW5kIHBhcnNlcyBpdCBpbnRvIGEgc2V0IG9mIGZhYnJpYyBvYmplY3RzLlxuICAgICAqIE5vdGUgdGhhdCBTVkcgaXMgZmV0Y2hlZCB2aWEgWE1MSHR0cFJlcXVlc3QsIHNvIGl0IG5lZWRzIHRvIGNvbmZvcm0gdG8gU09QIChTYW1lIE9yaWdpbiBQb2xpY3kpXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIGNyb3NzT3JpZ2luIHNldHRpbmcgdG8gdXNlIGZvciBleHRlcm5hbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBsb2FkU1ZHRnJvbVVSTDogZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgcmV2aXZlciwgb3B0aW9ucykge1xuXG4gICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXlxcblxccyovLCAnJykudHJpbSgpO1xuICAgICAgbmV3IGZhYnJpYy51dGlsLnJlcXVlc3QodXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBvbkNvbXBsZXRlKHIpIHtcblxuICAgICAgICB2YXIgeG1sID0gci5yZXNwb25zZVhNTDtcbiAgICAgICAgaWYgKCF4bWwgfHwgIXhtbC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudCh4bWwuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbiAocmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpO1xuICAgICAgICB9LCByZXZpdmVyLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gYW4gU1ZHIGRvY3VtZW50LCBhbmQgcGFyc2VzIGl0IGludG8gYSBzZXQgb2YgZmFicmljIG9iamVjdHNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gY3Jvc3NPcmlnaW4gc2V0dGluZyB0byB1c2UgZm9yIGV4dGVybmFsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGxvYWRTVkdGcm9tU3RyaW5nOiBmdW5jdGlvbihzdHJpbmcsIGNhbGxiYWNrLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IGZhYnJpYy53aW5kb3cuRE9NUGFyc2VyKCksXG4gICAgICAgICAgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdHJpbmcudHJpbSgpLCAndGV4dC94bWwnKTtcbiAgICAgIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50KGRvYy5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uIChyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpO1xuICAgICAgfSwgcmV2aXZlciwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlciA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMsIGRvYykge1xuICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5yZXZpdmVyID0gcmV2aXZlcjtcbiAgdGhpcy5zdmdVaWQgPSAob3B0aW9ucyAmJiBvcHRpb25zLnN2Z1VpZCkgfHwgMDtcbiAgdGhpcy5wYXJzaW5nT3B0aW9ucyA9IHBhcnNpbmdPcHRpb25zO1xuICB0aGlzLnJlZ2V4VXJsID0gL151cmxcXChbJ1wiXT8jKFteJ1wiXSspWydcIl0/XFwpL2c7XG4gIHRoaXMuZG9jID0gZG9jO1xufTtcblxuKGZ1bmN0aW9uKHByb3RvKSB7XG4gIHByb3RvLnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbnN0YW5jZXMgPSBuZXcgQXJyYXkodGhpcy5lbGVtZW50cy5sZW5ndGgpO1xuICAgIHRoaXMubnVtRWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICB0aGlzLmNyZWF0ZU9iamVjdHMoKTtcbiAgfTtcblxuICBwcm90by5jcmVhdGVPYmplY3RzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N2Z1VpZCcsIF90aGlzLnN2Z1VpZCk7XG4gICAgICBfdGhpcy5jcmVhdGVPYmplY3QoZWxlbWVudCwgaSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdG8uZmluZFRhZyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGZhYnJpY1tmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZShlbC50YWdOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpXTtcbiAgfTtcblxuICBwcm90by5jcmVhdGVPYmplY3QgPSBmdW5jdGlvbihlbCwgaW5kZXgpIHtcbiAgICB2YXIga2xhc3MgPSB0aGlzLmZpbmRUYWcoZWwpO1xuICAgIGlmIChrbGFzcyAmJiBrbGFzcy5mcm9tRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAga2xhc3MuZnJvbUVsZW1lbnQoZWwsIHRoaXMuY3JlYXRlQ2FsbGJhY2soaW5kZXgsIGVsKSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZmFicmljLmxvZyhlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tJZkRvbmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uY3JlYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihpbmRleCwgZWwpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBfb3B0aW9ucztcbiAgICAgIF90aGlzLnJlc29sdmVHcmFkaWVudChvYmosIGVsLCAnZmlsbCcpO1xuICAgICAgX3RoaXMucmVzb2x2ZUdyYWRpZW50KG9iaiwgZWwsICdzdHJva2UnKTtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBmYWJyaWMuSW1hZ2UgJiYgb2JqLl9vcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgX29wdGlvbnMgPSBvYmoucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKGVsKTtcbiAgICAgIH1cbiAgICAgIG9iai5fcmVtb3ZlVHJhbnNmb3JtTWF0cml4KF9vcHRpb25zKTtcbiAgICAgIF90aGlzLnJlc29sdmVDbGlwUGF0aChvYmosIGVsKTtcbiAgICAgIF90aGlzLnJldml2ZXIgJiYgX3RoaXMucmV2aXZlcihlbCwgb2JqKTtcbiAgICAgIF90aGlzLmluc3RhbmNlc1tpbmRleF0gPSBvYmo7XG4gICAgICBfdGhpcy5jaGVja0lmRG9uZSgpO1xuICAgIH07XG4gIH07XG5cbiAgcHJvdG8uZXh0cmFjdFByb3BlcnR5RGVmaW5pdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJvcGVydHksIHN0b3JhZ2UpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcGVydHldLCByZWdleCA9IHRoaXMucmVnZXhVcmw7XG4gICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdleC5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBpZCA9IHJlZ2V4LmV4ZWModmFsdWUpWzFdO1xuICAgIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIGZhYnJpY1tzdG9yYWdlXVt0aGlzLnN2Z1VpZF1baWRdO1xuICB9O1xuXG4gIHByb3RvLnJlc29sdmVHcmFkaWVudCA9IGZ1bmN0aW9uKG9iaiwgZWwsIHByb3BlcnR5KSB7XG4gICAgdmFyIGdyYWRpZW50RGVmID0gdGhpcy5leHRyYWN0UHJvcGVydHlEZWZpbml0aW9uKG9iaiwgcHJvcGVydHksICdncmFkaWVudERlZnMnKTtcbiAgICBpZiAoZ3JhZGllbnREZWYpIHtcbiAgICAgIHZhciBvcGFjaXR5QXR0ciA9IGVsLmdldEF0dHJpYnV0ZShwcm9wZXJ0eSArICctb3BhY2l0eScpO1xuICAgICAgdmFyIGdyYWRpZW50ID0gZmFicmljLkdyYWRpZW50LmZyb21FbGVtZW50KGdyYWRpZW50RGVmLCBvYmosIG9wYWNpdHlBdHRyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgb2JqLnNldChwcm9wZXJ0eSwgZ3JhZGllbnQpO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5jcmVhdGVDbGlwUGF0aENhbGxiYWNrID0gZnVuY3Rpb24ob2JqLCBjb250YWluZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oX25ld09iaikge1xuICAgICAgX25ld09iai5fcmVtb3ZlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICBfbmV3T2JqLmZpbGxSdWxlID0gX25ld09iai5jbGlwUnVsZTtcbiAgICAgIGNvbnRhaW5lci5wdXNoKF9uZXdPYmopO1xuICAgIH07XG4gIH07XG5cbiAgcHJvdG8ucmVzb2x2ZUNsaXBQYXRoID0gZnVuY3Rpb24ob2JqLCB1c2luZ0VsZW1lbnQpIHtcbiAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmV4dHJhY3RQcm9wZXJ0eURlZmluaXRpb24ob2JqLCAnY2xpcFBhdGgnLCAnY2xpcFBhdGhzJyksXG4gICAgICAgIGVsZW1lbnQsIGtsYXNzLCBvYmpUcmFuc2Zvcm1JbnYsIGNvbnRhaW5lciwgZ1RyYW5zZm9ybSwgb3B0aW9ucztcbiAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgIGNvbnRhaW5lciA9IFtdO1xuICAgICAgb2JqVHJhbnNmb3JtSW52ID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG9iai5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgICAgLy8gbW92ZSB0aGUgY2xpcFBhdGggdGFnIGFzIHNpYmxpbmcgdG8gdGhlIHJlYWwgZWxlbWVudCB0aGF0IGlzIHVzaW5nIGl0XG4gICAgICB2YXIgY2xpcFBhdGhUYWcgPSBjbGlwUGF0aFswXS5wYXJlbnROb2RlO1xuICAgICAgdmFyIGNsaXBQYXRoT3duZXIgPSB1c2luZ0VsZW1lbnQ7XG4gICAgICB3aGlsZSAoY2xpcFBhdGhPd25lci5wYXJlbnROb2RlICYmIGNsaXBQYXRoT3duZXIuZ2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnKSAhPT0gb2JqLmNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoT3duZXIgPSBjbGlwUGF0aE93bmVyLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBjbGlwUGF0aE93bmVyLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2xpcFBhdGhUYWcpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gY2xpcFBhdGhbaV07XG4gICAgICAgIGtsYXNzID0gdGhpcy5maW5kVGFnKGVsZW1lbnQpO1xuICAgICAgICBrbGFzcy5mcm9tRWxlbWVudChcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHRoaXMuY3JlYXRlQ2xpcFBhdGhDYWxsYmFjayhvYmosIGNvbnRhaW5lciksXG4gICAgICAgICAgdGhpcy5vcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjbGlwUGF0aCA9IGNvbnRhaW5lclswXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjbGlwUGF0aCA9IG5ldyBmYWJyaWMuR3JvdXAoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIGdUcmFuc2Zvcm0gPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKFxuICAgICAgICBvYmpUcmFuc2Zvcm1JbnYsXG4gICAgICAgIGNsaXBQYXRoLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKVxuICAgICAgKTtcbiAgICAgIGlmIChjbGlwUGF0aC5jbGlwUGF0aCkge1xuICAgICAgICB0aGlzLnJlc29sdmVDbGlwUGF0aChjbGlwUGF0aCwgY2xpcFBhdGhPd25lcik7XG4gICAgICB9XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKGdUcmFuc2Zvcm0pO1xuICAgICAgY2xpcFBhdGguZmxpcFggPSBmYWxzZTtcbiAgICAgIGNsaXBQYXRoLmZsaXBZID0gZmFsc2U7XG4gICAgICBjbGlwUGF0aC5zZXQoJ3NjYWxlWCcsIG9wdGlvbnMuc2NhbGVYKTtcbiAgICAgIGNsaXBQYXRoLnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgY2xpcFBhdGguYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgY2xpcFBhdGguc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgY2xpcFBhdGguc2tld1kgPSAwO1xuICAgICAgY2xpcFBhdGguc2V0UG9zaXRpb25CeU9yaWdpbih7IHg6IG9wdGlvbnMudHJhbnNsYXRlWCwgeTogb3B0aW9ucy50cmFuc2xhdGVZIH0sICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBvYmouY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBpZiBjbGlwLXBhdGggZG9lcyBub3QgcmVzb2x2ZSB0byBhbnkgZWxlbWVudCwgZGVsZXRlIHRoZSBwcm9wZXJ0eS5cbiAgICAgIGRlbGV0ZSBvYmouY2xpcFBhdGg7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLmNoZWNrSWZEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKC0tdGhpcy5udW1FbGVtZW50cyA9PT0gMCkge1xuICAgICAgdGhpcy5pbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuICAgICAgICByZXR1cm4gZWwgIT0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLmluc3RhbmNlcywgdGhpcy5lbGVtZW50cyk7XG4gICAgfVxuICB9O1xufSkoZmFicmljLkVsZW1lbnRzUGFyc2VyLnByb3RvdHlwZSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBBZGFwdGF0aW9uIG9mIHdvcmsgb2YgS2V2aW4gTGluZHNleSAoa2V2aW5Aa2V2bGluZGV2LmNvbSkgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5Qb2ludCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9pbnQgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZmFicmljLlBvaW50ID0gUG9pbnQ7XG5cbiAgLyoqXG4gICAqIFBvaW50IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9pbnRcbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAqL1xuICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgUG9pbnQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuUG9pbnQucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdwb2ludCcsXG5cbiAgICBjb25zdHJ1Y3RvcjogUG9pbnQsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFub3RoZXIgcG9pbnQgdG8gdGhpcyBvbmUgYW5kIHJldHVybnMgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IGluc3RhbmNlIHdpdGggYWRkZWQgdmFsdWVzXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGF0LngsIHRoaXMueSArIHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBwb2ludCB0byB0aGlzIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZEVxdWFsczogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCArPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgKz0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsdWUgdG8gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgd2l0aCBhZGRlZCB2YWx1ZVxuICAgICAqL1xuICAgIHNjYWxhckFkZDogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBzY2FsYXIsIHRoaXMueSArIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsdWUgdG8gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGFyQWRkRXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKz0gc2NhbGFyO1xuICAgICAgdGhpcy55ICs9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgYW5vdGhlciBwb2ludCBmcm9tIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCBvYmplY3Qgd2l0aCBzdWJ0cmFjdGVkIHZhbHVlc1xuICAgICAqL1xuICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSB0aGF0LngsIHRoaXMueSAtIHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbm90aGVyIHBvaW50IGZyb20gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHN1YnRyYWN0RXF1YWxzOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54IC09IHRoYXQueDtcbiAgICAgIHRoaXMueSAtPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHZhbHVlIGZyb20gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHNjYWxhclN1YnRyYWN0OiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHNjYWxhciwgdGhpcy55IC0gc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHZhbHVlIGZyb20gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGFyU3VidHJhY3RFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAtPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgLT0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJNdWx0aXBseSBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyTXVsdGlwbHlFcXVhbHMgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBtdWx0aXBseUVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhckRpdmlkZSBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGRpdmlkZTogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBzY2FsYXIsIHRoaXMueSAvIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhckRpdmlkZUVxdWFscyBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpdmlkZUVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54IC89IHNjYWxhcjtcbiAgICAgIHRoaXMueSAvPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZXE6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA9PT0gdGhhdC54ICYmIHRoaXMueSA9PT0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGx0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPCB0aGF0LnggJiYgdGhpcy55IDwgdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGx0ZTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54IDw9IHRoYXQueCAmJiB0aGlzLnkgPD0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG5cbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGd0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPiB0aGF0LnggJiYgdGhpcy55ID4gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGd0ZTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID49IHRoYXQueCAmJiB0aGlzLnkgPj0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHRoaXMgb25lIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgLCBwb3NpdGlvbiBvZiBpbnRlcnBvbGF0aW9uLCBiZXR3ZWVuIDAgYW5kIDEgZGVmYXVsdCAwLjVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbGVycDogZnVuY3Rpb24gKHRoYXQsIHQpIHtcbiAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdCA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHQgPSBNYXRoLm1heChNYXRoLm1pbigxLCB0KSwgMCk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArICh0aGF0LnggLSB0aGlzLngpICogdCwgdGhpcy55ICsgKHRoYXQueSAtIHRoaXMueSkgKiB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkaXN0YW5jZSBmcm9tIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZGlzdGFuY2VGcm9tOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdmFyIGR4ID0gdGhpcy54IC0gdGhhdC54LFxuICAgICAgICAgIGR5ID0gdGhpcy55IC0gdGhhdC55O1xuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGJldHdlZW4gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtaWRQb2ludEZyb206IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXJwKHRoYXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSBtaW4gb2YgdGhpcyBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtaW46IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWluKHRoaXMueCwgdGhhdC54KSwgTWF0aC5taW4odGhpcy55LCB0aGF0LnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgbWF4IG9mIHRoaXMgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWF4OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLm1heCh0aGlzLngsIHRoYXQueCksIE1hdGgubWF4KHRoaXMueSwgdGhhdC55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKyAnLCcgKyB0aGlzLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeC95IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFhZOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRYOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHkgb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFk6IGZ1bmN0aW9uICh5KSB7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeC95IG9mIHRoaXMgcG9pbnQgZnJvbSBhbm90aGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RnJvbVBvaW50OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54ID0gdGhhdC54O1xuICAgICAgdGhpcy55ID0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN3YXBzIHgveSBvZiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKi9cbiAgICBzd2FwOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgeSA9IHRoaXMueTtcbiAgICAgIHRoaXMueCA9IHRoYXQueDtcbiAgICAgIHRoaXMueSA9IHRoYXQueTtcbiAgICAgIHRoYXQueCA9IHg7XG4gICAgICB0aGF0LnkgPSB5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBjbG9uZWQgaW5zdGFuY2Ugb2YgdGhlIHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIEFkYXB0YXRpb24gb2Ygd29yayBvZiBLZXZpbiBMaW5kc2V5IChrZXZpbkBrZXZsaW5kZXYuY29tKSAqL1xuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5JbnRlcnNlY3Rpb24pIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkludGVyc2VjdGlvbiBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJzZWN0aW9uIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW50ZXJzZWN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcnNlY3Rpb24oc3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgfVxuXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24gPSBJbnRlcnNlY3Rpb247XG5cbiAgZmFicmljLkludGVyc2VjdGlvbi5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5JbnRlcnNlY3Rpb24ucHJvdG90eXBlICovIHtcblxuICAgIGNvbnN0cnVjdG9yOiBJbnRlcnNlY3Rpb24sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgcG9pbnQgdG8gaW50ZXJzZWN0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhcHBlbmRQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHBvaW50cyB0byBpbnRlcnNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGVuZFBvaW50czogZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgdGhpcy5wb2ludHMgPSB0aGlzLnBvaW50cy5jb25jYXQocG9pbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIG9uZSBsaW5lIGludGVyc2VjdHMgYW5vdGhlclxuICAgKiBUT0RPOiByZW5hbWUgaW4gaW50ZXJzZWN0U2VnbWVudFNlZ21lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGEyXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBiMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYjJcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZUxpbmUgPSBmdW5jdGlvbiAoYTEsIGEyLCBiMSwgYjIpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICB1YVQgPSAoYjIueCAtIGIxLngpICogKGExLnkgLSBiMS55KSAtIChiMi55IC0gYjEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICB1YlQgPSAoYTIueCAtIGExLngpICogKGExLnkgLSBiMS55KSAtIChhMi55IC0gYTEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICB1QiA9IChiMi55IC0gYjEueSkgKiAoYTIueCAtIGExLngpIC0gKGIyLnggLSBiMS54KSAqIChhMi55IC0gYTEueSk7XG4gICAgaWYgKHVCICE9PSAwKSB7XG4gICAgICB2YXIgdWEgPSB1YVQgLyB1QixcbiAgICAgICAgICB1YiA9IHViVCAvIHVCO1xuICAgICAgaWYgKDAgPD0gdWEgJiYgdWEgPD0gMSAmJiAwIDw9IHViICYmIHViIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignSW50ZXJzZWN0aW9uJyk7XG4gICAgICAgIHJlc3VsdC5hcHBlbmRQb2ludChuZXcgZmFicmljLlBvaW50KGExLnggKyB1YSAqIChhMi54IC0gYTEueCksIGExLnkgKyB1YSAqIChhMi55IC0gYTEueSkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHVhVCA9PT0gMCB8fCB1YlQgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignQ29pbmNpZGVudCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ1BhcmFsbGVsJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBsaW5lIGludGVyc2VjdHMgcG9seWdvblxuICAgKiBUT0RPOiByZW5hbWUgaW4gaW50ZXJzZWN0U2VnbWVudFBvbHlnb25cbiAgICogZml4IGRldGVjdGlvbiBvZiBjb2luY2lkZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGExXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24gPSBmdW5jdGlvbihhMSwgYTIsIHBvaW50cykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCksXG4gICAgICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGIxLCBiMiwgaW50ZXIsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGIxID0gcG9pbnRzW2ldO1xuICAgICAgYjIgPSBwb2ludHNbKGkgKyAxKSAlIGxlbmd0aF07XG4gICAgICBpbnRlciA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lTGluZShhMSwgYTIsIGIxLCBiMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIGFub3RoZXIgcG9seWdvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50czFcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMxLCBwb2ludHMyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzMS5sZW5ndGgsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhMSA9IHBvaW50czFbaV0sXG4gICAgICAgICAgYTIgPSBwb2ludHMxWyhpICsgMSkgJSBsZW5ndGhdLFxuICAgICAgICAgIGludGVyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGExLCBhMiwgcG9pbnRzMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIHJlY3RhbmdsZVxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcjFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHIyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25SZWN0YW5nbGUgPSBmdW5jdGlvbiAocG9pbnRzLCByMSwgcjIpIHtcbiAgICB2YXIgbWluID0gcjEubWluKHIyKSxcbiAgICAgICAgbWF4ID0gcjEubWF4KHIyKSxcbiAgICAgICAgdG9wUmlnaHQgPSBuZXcgZmFicmljLlBvaW50KG1heC54LCBtaW4ueSksXG4gICAgICAgIGJvdHRvbUxlZnQgPSBuZXcgZmFicmljLlBvaW50KG1pbi54LCBtYXgueSksXG4gICAgICAgIGludGVyMSA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihtaW4sIHRvcFJpZ2h0LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24odG9wUmlnaHQsIG1heCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXIzID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKG1heCwgYm90dG9tTGVmdCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXI0ID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGJvdHRvbUxlZnQsIG1pbiwgcG9pbnRzKSxcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpO1xuXG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjEucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMi5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIzLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjQucG9pbnRzKTtcblxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuQ29sb3IpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNvbG9yIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQ29sb3IgY2xhc3NcbiAgICogVGhlIHB1cnBvc2Ugb2Yge0BsaW5rIGZhYnJpYy5Db2xvcn0gaXMgdG8gYWJzdHJhY3QgYW5kIGVuY2Fwc3VsYXRlIGNvbW1vbiBjb2xvciBvcGVyYXRpb25zO1xuICAgKiB7QGxpbmsgZmFicmljLkNvbG9yfSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBjcmVhdGVzIGluc3RhbmNlcyBvZiB7QGxpbmsgZmFicmljLkNvbG9yfSBvYmplY3RzLlxuICAgKlxuICAgKiBAY2xhc3MgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBvcHRpb25hbCBpbiBoZXggb3IgcmdiKGEpIG9yIGhzbCBmb3JtYXQgb3IgZnJvbSBrbm93biBjb2xvciBsaXN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMi8jY29sb3JzfVxuICAgKi9cbiAgZnVuY3Rpb24gQ29sb3IoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICB0aGlzLnNldFNvdXJjZShbMCwgMCwgMCwgMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3RyeVBhcnNpbmdDb2xvcihjb2xvcik7XG4gICAgfVxuICB9XG5cbiAgZmFicmljLkNvbG9yID0gQ29sb3I7XG5cbiAgZmFicmljLkNvbG9yLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNvbG9yLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBjb2xvciBDb2xvciB2YWx1ZSB0byBwYXJzZVxuICAgICAqL1xuICAgIF90cnlQYXJzaW5nQ29sb3I6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICB2YXIgc291cmNlO1xuXG4gICAgICBpZiAoY29sb3IgaW4gQ29sb3IuY29sb3JOYW1lTWFwKSB7XG4gICAgICAgIGNvbG9yID0gQ29sb3IuY29sb3JOYW1lTWFwW2NvbG9yXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHNvdXJjZSA9IFsyNTUsIDI1NSwgMjU1LCAwXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tUmdiKGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgLy9pZiBjb2xvciBpcyBub3QgcmVjb2duaXplIGxldCdzIG1ha2UgYmxhY2sgYXMgY2FudmFzIGRvZXNcbiAgICAgICAgc291cmNlID0gWzAsIDAsIDAsIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIFJlZCBjb2xvciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBnIEdyZWVuIGNvbG9yIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgQmx1ZSBjb2xvciB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBIc2wgY29sb3JcbiAgICAgKi9cbiAgICBfcmdiVG9Ic2w6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHIgLz0gMjU1OyBnIC89IDI1NTsgYiAvPSAyNTU7XG5cbiAgICAgIHZhciBoLCBzLCBsLFxuICAgICAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heChbciwgZywgYl0pLFxuICAgICAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbihbciwgZywgYl0pO1xuXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gNjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5yb3VuZChoICogMzYwKSxcbiAgICAgICAgTWF0aC5yb3VuZChzICogMTAwKSxcbiAgICAgICAgTWF0aC5yb3VuZChsICogMTAwKVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzb3VyY2Ugb2YgdGhpcyBjb2xvciAod2hlcmUgc291cmNlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uOyBleDogWzIwMCwgMjAwLCAxMDAsIDFdKVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNvdXJjZSBvZiB0aGlzIGNvbG9yICh3aGVyZSBzb3VyY2UgaXMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb247IGV4OiBbMjAwLCAyMDAsIDEwMCwgMV0pXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlXG4gICAgICovXG4gICAgc2V0U291cmNlOiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBSR0IgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgICAqL1xuICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgcmV0dXJuICdyZ2IoJyArIHNvdXJjZVswXSArICcsJyArIHNvdXJjZVsxXSArICcsJyArIHNvdXJjZVsyXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBSR0JBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IHJnYmEoMC0yNTUsMC0yNTUsMC0yNTUsMC0xKVxuICAgICAqL1xuICAgIHRvUmdiYTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHJldHVybiAncmdiYSgnICsgc291cmNlWzBdICsgJywnICsgc291cmNlWzFdICsgJywnICsgc291cmNlWzJdICsgJywnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhTTCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2woMC0zNjAsMCUtMTAwJSwwJS0xMDAlKVxuICAgICAqL1xuICAgIHRvSHNsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbCgnICsgaHNsWzBdICsgJywnICsgaHNsWzFdICsgJyUsJyArIGhzbFsyXSArICclKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSFNMQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2xhKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSwwLTEpXG4gICAgICovXG4gICAgdG9Ic2xhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbGEoJyArIGhzbFswXSArICcsJyArIGhzbFsxXSArICclLCcgKyBoc2xbMl0gKyAnJSwnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhFWCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBGRjU1NTVcbiAgICAgKi9cbiAgICB0b0hleDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSwgciwgZywgYjtcblxuICAgICAgciA9IHNvdXJjZVswXS50b1N0cmluZygxNik7XG4gICAgICByID0gKHIubGVuZ3RoID09PSAxKSA/ICgnMCcgKyByKSA6IHI7XG5cbiAgICAgIGcgPSBzb3VyY2VbMV0udG9TdHJpbmcoMTYpO1xuICAgICAgZyA9IChnLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgZykgOiBnO1xuXG4gICAgICBiID0gc291cmNlWzJdLnRvU3RyaW5nKDE2KTtcbiAgICAgIGIgPSAoYi5sZW5ndGggPT09IDEpID8gKCcwJyArIGIpIDogYjtcblxuICAgICAgcmV0dXJuIHIudG9VcHBlckNhc2UoKSArIGcudG9VcHBlckNhc2UoKSArIGIudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIRVhBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IEZGNTU1NUNDXG4gICAgICovXG4gICAgdG9IZXhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLCBhO1xuXG4gICAgICBhID0gTWF0aC5yb3VuZChzb3VyY2VbM10gKiAyNTUpO1xuICAgICAgYSA9IGEudG9TdHJpbmcoMTYpO1xuICAgICAgYSA9IChhLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgYSkgOiBhO1xuXG4gICAgICByZXR1cm4gdGhpcy50b0hleCgpICsgYS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDAtMVxuICAgICAqL1xuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNvdXJjZSgpWzNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgQWxwaGEgdmFsdWUgMC0xXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0QWxwaGE6IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHNvdXJjZVszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbG9yIHRvIGl0cyBncmF5c2NhbGUgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0dyYXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBhdmVyYWdlID0gcGFyc2VJbnQoKHNvdXJjZVswXSAqIDAuMyArIHNvdXJjZVsxXSAqIDAuNTkgKyBzb3VyY2VbMl0gKiAwLjExKS50b0ZpeGVkKDApLCAxMCksXG4gICAgICAgICAgY3VycmVudEFscGhhID0gc291cmNlWzNdO1xuICAgICAgdGhpcy5zZXRTb3VyY2UoW2F2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGN1cnJlbnRBbHBoYV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29sb3IgdG8gaXRzIGJsYWNrIGFuZCB3aGl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0JsYWNrV2hpdGU6IGZ1bmN0aW9uKHRocmVzaG9sZCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgYXZlcmFnZSA9IChzb3VyY2VbMF0gKiAwLjMgKyBzb3VyY2VbMV0gKiAwLjU5ICsgc291cmNlWzJdICogMC4xMSkudG9GaXhlZCgwKSxcbiAgICAgICAgICBjdXJyZW50QWxwaGEgPSBzb3VyY2VbM107XG5cbiAgICAgIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAxMjc7XG5cbiAgICAgIGF2ZXJhZ2UgPSAoTnVtYmVyKGF2ZXJhZ2UpIDwgTnVtYmVyKHRocmVzaG9sZCkpID8gMCA6IDI1NTtcbiAgICAgIHRoaXMuc2V0U291cmNlKFthdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjdXJyZW50QWxwaGFdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5cyBjb2xvciB3aXRoIGFub3RoZXIgY29sb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xmYWJyaWMuQ29sb3J9IG90aGVyQ29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBvdmVybGF5V2l0aDogZnVuY3Rpb24ob3RoZXJDb2xvcikge1xuICAgICAgaWYgKCEob3RoZXJDb2xvciBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICBvdGhlckNvbG9yID0gbmV3IENvbG9yKG90aGVyQ29sb3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgYWxwaGEgPSB0aGlzLmdldEFscGhhKCksXG4gICAgICAgICAgb3RoZXJBbHBoYSA9IDAuNSxcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIG90aGVyU291cmNlID0gb3RoZXJDb2xvci5nZXRTb3VyY2UoKSwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChNYXRoLnJvdW5kKChzb3VyY2VbaV0gKiAoMSAtIG90aGVyQWxwaGEpKSArIChvdGhlclNvdXJjZVtpXSAqIG90aGVyQWxwaGEpKSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2UocmVzdWx0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gUkdCIG9yIFJHQkEgZm9ybWF0cyAoZXg6IHJnYigwLCAwLCAwKSwgcmdiYSgyNTUsIDEwMCwgMTAsIDAuNSksIHJnYmEoIDI1NSAsIDEwMCAsIDEwICwgMC41ICksIHJnYigxLDEsMSksIHJnYmEoMTAwJSwgNjAlLCAxMCUsIDAuNSkpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGZhYnJpYy5Db2xvci5yZVJHQmEgPSAvXnJnYmE/XFwoXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKixcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqLFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyooPzpcXHMqLFxccyooKD86XFxkKlxcLj9cXGQrKT8pXFxzKik/XFwpJC9pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIU0wgb3IgSFNMQSBmb3JtYXRzIChleDogaHNsKDIwMCwgODAlLCAxMCUpLCBoc2xhKDMwMCwgNTAlLCA4MCUsIDAuNSksIGhzbGEoIDMwMCAsIDUwJSAsIDgwJSAsIDAuNSApKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IucmVIU0xhID0gL15oc2xhP1xcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9XFwlKVxccyosXFxzKihcXGR7MSwzfVxcJSlcXHMqKD86XFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKik/XFwpJC9pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIRVggZm9ybWF0IChleDogI0ZGNTU0NENDLCAjRkY1NTU1LCAwMTAxNTUsIGFmZilcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLnJlSGV4ID0gL14jPyhbMC05YS1mXXs4fXxbMC05YS1mXXs2fXxbMC05YS1mXXs0fXxbMC05YS1mXXszfSkkL2k7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiB0aGUgMTQ4IGNvbG9yIG5hbWVzIHdpdGggSEVYIGNvZGVcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAc2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IuY29sb3JOYW1lTWFwID0ge1xuICAgIGFsaWNlYmx1ZTogICAgICAgICAgICAnI0YwRjhGRicsXG4gICAgYW50aXF1ZXdoaXRlOiAgICAgICAgICcjRkFFQkQ3JyxcbiAgICBhcXVhOiAgICAgICAgICAgICAgICAgJyMwMEZGRkYnLFxuICAgIGFxdWFtYXJpbmU6ICAgICAgICAgICAnIzdGRkZENCcsXG4gICAgYXp1cmU6ICAgICAgICAgICAgICAgICcjRjBGRkZGJyxcbiAgICBiZWlnZTogICAgICAgICAgICAgICAgJyNGNUY1REMnLFxuICAgIGJpc3F1ZTogICAgICAgICAgICAgICAnI0ZGRTRDNCcsXG4gICAgYmxhY2s6ICAgICAgICAgICAgICAgICcjMDAwMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogICAgICAgJyNGRkVCQ0QnLFxuICAgIGJsdWU6ICAgICAgICAgICAgICAgICAnIzAwMDBGRicsXG4gICAgYmx1ZXZpb2xldDogICAgICAgICAgICcjOEEyQkUyJyxcbiAgICBicm93bjogICAgICAgICAgICAgICAgJyNBNTJBMkEnLFxuICAgIGJ1cmx5d29vZDogICAgICAgICAgICAnI0RFQjg4NycsXG4gICAgY2FkZXRibHVlOiAgICAgICAgICAgICcjNUY5RUEwJyxcbiAgICBjaGFydHJldXNlOiAgICAgICAgICAgJyM3RkZGMDAnLFxuICAgIGNob2NvbGF0ZTogICAgICAgICAgICAnI0QyNjkxRScsXG4gICAgY29yYWw6ICAgICAgICAgICAgICAgICcjRkY3RjUwJyxcbiAgICBjb3JuZmxvd2VyYmx1ZTogICAgICAgJyM2NDk1RUQnLFxuICAgIGNvcm5zaWxrOiAgICAgICAgICAgICAnI0ZGRjhEQycsXG4gICAgY3JpbXNvbjogICAgICAgICAgICAgICcjREMxNDNDJyxcbiAgICBjeWFuOiAgICAgICAgICAgICAgICAgJyMwMEZGRkYnLFxuICAgIGRhcmtibHVlOiAgICAgICAgICAgICAnIzAwMDA4QicsXG4gICAgZGFya2N5YW46ICAgICAgICAgICAgICcjMDA4QjhCJyxcbiAgICBkYXJrZ29sZGVucm9kOiAgICAgICAgJyNCODg2MEInLFxuICAgIGRhcmtncmF5OiAgICAgICAgICAgICAnI0E5QTlBOScsXG4gICAgZGFya2dyZXk6ICAgICAgICAgICAgICcjQTlBOUE5JyxcbiAgICBkYXJrZ3JlZW46ICAgICAgICAgICAgJyMwMDY0MDAnLFxuICAgIGRhcmtraGFraTogICAgICAgICAgICAnI0JEQjc2QicsXG4gICAgZGFya21hZ2VudGE6ICAgICAgICAgICcjOEIwMDhCJyxcbiAgICBkYXJrb2xpdmVncmVlbjogICAgICAgJyM1NTZCMkYnLFxuICAgIGRhcmtvcmFuZ2U6ICAgICAgICAgICAnI0ZGOEMwMCcsXG4gICAgZGFya29yY2hpZDogICAgICAgICAgICcjOTkzMkNDJyxcbiAgICBkYXJrcmVkOiAgICAgICAgICAgICAgJyM4QjAwMDAnLFxuICAgIGRhcmtzYWxtb246ICAgICAgICAgICAnI0U5OTY3QScsXG4gICAgZGFya3NlYWdyZWVuOiAgICAgICAgICcjOEZCQzhGJyxcbiAgICBkYXJrc2xhdGVibHVlOiAgICAgICAgJyM0ODNEOEInLFxuICAgIGRhcmtzbGF0ZWdyYXk6ICAgICAgICAnIzJGNEY0RicsXG4gICAgZGFya3NsYXRlZ3JleTogICAgICAgICcjMkY0RjRGJyxcbiAgICBkYXJrdHVycXVvaXNlOiAgICAgICAgJyMwMENFRDEnLFxuICAgIGRhcmt2aW9sZXQ6ICAgICAgICAgICAnIzk0MDBEMycsXG4gICAgZGVlcHBpbms6ICAgICAgICAgICAgICcjRkYxNDkzJyxcbiAgICBkZWVwc2t5Ymx1ZTogICAgICAgICAgJyMwMEJGRkYnLFxuICAgIGRpbWdyYXk6ICAgICAgICAgICAgICAnIzY5Njk2OScsXG4gICAgZGltZ3JleTogICAgICAgICAgICAgICcjNjk2OTY5JyxcbiAgICBkb2RnZXJibHVlOiAgICAgICAgICAgJyMxRTkwRkYnLFxuICAgIGZpcmVicmljazogICAgICAgICAgICAnI0IyMjIyMicsXG4gICAgZmxvcmFsd2hpdGU6ICAgICAgICAgICcjRkZGQUYwJyxcbiAgICBmb3Jlc3RncmVlbjogICAgICAgICAgJyMyMjhCMjInLFxuICAgIGZ1Y2hzaWE6ICAgICAgICAgICAgICAnI0ZGMDBGRicsXG4gICAgZ2FpbnNib3JvOiAgICAgICAgICAgICcjRENEQ0RDJyxcbiAgICBnaG9zdHdoaXRlOiAgICAgICAgICAgJyNGOEY4RkYnLFxuICAgIGdvbGQ6ICAgICAgICAgICAgICAgICAnI0ZGRDcwMCcsXG4gICAgZ29sZGVucm9kOiAgICAgICAgICAgICcjREFBNTIwJyxcbiAgICBncmF5OiAgICAgICAgICAgICAgICAgJyM4MDgwODAnLFxuICAgIGdyZXk6ICAgICAgICAgICAgICAgICAnIzgwODA4MCcsXG4gICAgZ3JlZW46ICAgICAgICAgICAgICAgICcjMDA4MDAwJyxcbiAgICBncmVlbnllbGxvdzogICAgICAgICAgJyNBREZGMkYnLFxuICAgIGhvbmV5ZGV3OiAgICAgICAgICAgICAnI0YwRkZGMCcsXG4gICAgaG90cGluazogICAgICAgICAgICAgICcjRkY2OUI0JyxcbiAgICBpbmRpYW5yZWQ6ICAgICAgICAgICAgJyNDRDVDNUMnLFxuICAgIGluZGlnbzogICAgICAgICAgICAgICAnIzRCMDA4MicsXG4gICAgaXZvcnk6ICAgICAgICAgICAgICAgICcjRkZGRkYwJyxcbiAgICBraGFraTogICAgICAgICAgICAgICAgJyNGMEU2OEMnLFxuICAgIGxhdmVuZGVyOiAgICAgICAgICAgICAnI0U2RTZGQScsXG4gICAgbGF2ZW5kZXJibHVzaDogICAgICAgICcjRkZGMEY1JyxcbiAgICBsYXduZ3JlZW46ICAgICAgICAgICAgJyM3Q0ZDMDAnLFxuICAgIGxlbW9uY2hpZmZvbjogICAgICAgICAnI0ZGRkFDRCcsXG4gICAgbGlnaHRibHVlOiAgICAgICAgICAgICcjQUREOEU2JyxcbiAgICBsaWdodGNvcmFsOiAgICAgICAgICAgJyNGMDgwODAnLFxuICAgIGxpZ2h0Y3lhbjogICAgICAgICAgICAnI0UwRkZGRicsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjRkFGQUQyJyxcbiAgICBsaWdodGdyYXk6ICAgICAgICAgICAgJyNEM0QzRDMnLFxuICAgIGxpZ2h0Z3JleTogICAgICAgICAgICAnI0QzRDNEMycsXG4gICAgbGlnaHRncmVlbjogICAgICAgICAgICcjOTBFRTkwJyxcbiAgICBsaWdodHBpbms6ICAgICAgICAgICAgJyNGRkI2QzEnLFxuICAgIGxpZ2h0c2FsbW9uOiAgICAgICAgICAnI0ZGQTA3QScsXG4gICAgbGlnaHRzZWFncmVlbjogICAgICAgICcjMjBCMkFBJyxcbiAgICBsaWdodHNreWJsdWU6ICAgICAgICAgJyM4N0NFRkEnLFxuICAgIGxpZ2h0c2xhdGVncmF5OiAgICAgICAnIzc3ODg5OScsXG4gICAgbGlnaHRzbGF0ZWdyZXk6ICAgICAgICcjNzc4ODk5JyxcbiAgICBsaWdodHN0ZWVsYmx1ZTogICAgICAgJyNCMEM0REUnLFxuICAgIGxpZ2h0eWVsbG93OiAgICAgICAgICAnI0ZGRkZFMCcsXG4gICAgbGltZTogICAgICAgICAgICAgICAgICcjMDBGRjAwJyxcbiAgICBsaW1lZ3JlZW46ICAgICAgICAgICAgJyMzMkNEMzInLFxuICAgIGxpbmVuOiAgICAgICAgICAgICAgICAnI0ZBRjBFNicsXG4gICAgbWFnZW50YTogICAgICAgICAgICAgICcjRkYwMEZGJyxcbiAgICBtYXJvb246ICAgICAgICAgICAgICAgJyM4MDAwMDAnLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICAgICAnIzY2Q0RBQScsXG4gICAgbWVkaXVtYmx1ZTogICAgICAgICAgICcjMDAwMENEJyxcbiAgICBtZWRpdW1vcmNoaWQ6ICAgICAgICAgJyNCQTU1RDMnLFxuICAgIG1lZGl1bXB1cnBsZTogICAgICAgICAnIzkzNzBEQicsXG4gICAgbWVkaXVtc2VhZ3JlZW46ICAgICAgICcjM0NCMzcxJyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6ICAgICAgJyM3QjY4RUUnLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAgICAnIzAwRkE5QScsXG4gICAgbWVkaXVtdHVycXVvaXNlOiAgICAgICcjNDhEMUNDJyxcbiAgICBtZWRpdW12aW9sZXRyZWQ6ICAgICAgJyNDNzE1ODUnLFxuICAgIG1pZG5pZ2h0Ymx1ZTogICAgICAgICAnIzE5MTk3MCcsXG4gICAgbWludGNyZWFtOiAgICAgICAgICAgICcjRjVGRkZBJyxcbiAgICBtaXN0eXJvc2U6ICAgICAgICAgICAgJyNGRkU0RTEnLFxuICAgIG1vY2Nhc2luOiAgICAgICAgICAgICAnI0ZGRTRCNScsXG4gICAgbmF2YWpvd2hpdGU6ICAgICAgICAgICcjRkZERUFEJyxcbiAgICBuYXZ5OiAgICAgICAgICAgICAgICAgJyMwMDAwODAnLFxuICAgIG9sZGxhY2U6ICAgICAgICAgICAgICAnI0ZERjVFNicsXG4gICAgb2xpdmU6ICAgICAgICAgICAgICAgICcjODA4MDAwJyxcbiAgICBvbGl2ZWRyYWI6ICAgICAgICAgICAgJyM2QjhFMjMnLFxuICAgIG9yYW5nZTogICAgICAgICAgICAgICAnI0ZGQTUwMCcsXG4gICAgb3JhbmdlcmVkOiAgICAgICAgICAgICcjRkY0NTAwJyxcbiAgICBvcmNoaWQ6ICAgICAgICAgICAgICAgJyNEQTcwRDYnLFxuICAgIHBhbGVnb2xkZW5yb2Q6ICAgICAgICAnI0VFRThBQScsXG4gICAgcGFsZWdyZWVuOiAgICAgICAgICAgICcjOThGQjk4JyxcbiAgICBwYWxldHVycXVvaXNlOiAgICAgICAgJyNBRkVFRUUnLFxuICAgIHBhbGV2aW9sZXRyZWQ6ICAgICAgICAnI0RCNzA5MycsXG4gICAgcGFwYXlhd2hpcDogICAgICAgICAgICcjRkZFRkQ1JyxcbiAgICBwZWFjaHB1ZmY6ICAgICAgICAgICAgJyNGRkRBQjknLFxuICAgIHBlcnU6ICAgICAgICAgICAgICAgICAnI0NEODUzRicsXG4gICAgcGluazogICAgICAgICAgICAgICAgICcjRkZDMENCJyxcbiAgICBwbHVtOiAgICAgICAgICAgICAgICAgJyNEREEwREQnLFxuICAgIHBvd2RlcmJsdWU6ICAgICAgICAgICAnI0IwRTBFNicsXG4gICAgcHVycGxlOiAgICAgICAgICAgICAgICcjODAwMDgwJyxcbiAgICByZWJlY2NhcHVycGxlOiAgICAgICAgJyM2NjMzOTknLFxuICAgIHJlZDogICAgICAgICAgICAgICAgICAnI0ZGMDAwMCcsXG4gICAgcm9zeWJyb3duOiAgICAgICAgICAgICcjQkM4RjhGJyxcbiAgICByb3lhbGJsdWU6ICAgICAgICAgICAgJyM0MTY5RTEnLFxuICAgIHNhZGRsZWJyb3duOiAgICAgICAgICAnIzhCNDUxMycsXG4gICAgc2FsbW9uOiAgICAgICAgICAgICAgICcjRkE4MDcyJyxcbiAgICBzYW5keWJyb3duOiAgICAgICAgICAgJyNGNEE0NjAnLFxuICAgIHNlYWdyZWVuOiAgICAgICAgICAgICAnIzJFOEI1NycsXG4gICAgc2Vhc2hlbGw6ICAgICAgICAgICAgICcjRkZGNUVFJyxcbiAgICBzaWVubmE6ICAgICAgICAgICAgICAgJyNBMDUyMkQnLFxuICAgIHNpbHZlcjogICAgICAgICAgICAgICAnI0MwQzBDMCcsXG4gICAgc2t5Ymx1ZTogICAgICAgICAgICAgICcjODdDRUVCJyxcbiAgICBzbGF0ZWJsdWU6ICAgICAgICAgICAgJyM2QTVBQ0QnLFxuICAgIHNsYXRlZ3JheTogICAgICAgICAgICAnIzcwODA5MCcsXG4gICAgc2xhdGVncmV5OiAgICAgICAgICAgICcjNzA4MDkwJyxcbiAgICBzbm93OiAgICAgICAgICAgICAgICAgJyNGRkZBRkEnLFxuICAgIHNwcmluZ2dyZWVuOiAgICAgICAgICAnIzAwRkY3RicsXG4gICAgc3RlZWxibHVlOiAgICAgICAgICAgICcjNDY4MkI0JyxcbiAgICB0YW46ICAgICAgICAgICAgICAgICAgJyNEMkI0OEMnLFxuICAgIHRlYWw6ICAgICAgICAgICAgICAgICAnIzAwODA4MCcsXG4gICAgdGhpc3RsZTogICAgICAgICAgICAgICcjRDhCRkQ4JyxcbiAgICB0b21hdG86ICAgICAgICAgICAgICAgJyNGRjYzNDcnLFxuICAgIHR1cnF1b2lzZTogICAgICAgICAgICAnIzQwRTBEMCcsXG4gICAgdmlvbGV0OiAgICAgICAgICAgICAgICcjRUU4MkVFJyxcbiAgICB3aGVhdDogICAgICAgICAgICAgICAgJyNGNURFQjMnLFxuICAgIHdoaXRlOiAgICAgICAgICAgICAgICAnI0ZGRkZGRicsXG4gICAgd2hpdGVzbW9rZTogICAgICAgICAgICcjRjVGNUY1JyxcbiAgICB5ZWxsb3c6ICAgICAgICAgICAgICAgJyNGRkZGMDAnLFxuICAgIHllbGxvd2dyZWVuOiAgICAgICAgICAnIzlBQ0QzMidcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICB0ICs9IDE7XG4gICAgfVxuICAgIGlmICh0ID4gMSkge1xuICAgICAgdCAtPSAxO1xuICAgIH1cbiAgICBpZiAodCA8IDEgLyA2KSB7XG4gICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAxIC8gMikge1xuICAgICAgcmV0dXJuIHE7XG4gICAgfVxuICAgIGlmICh0IDwgMiAvIDMpIHtcbiAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCIGZvcm1hdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbVJnYihjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBSR0Igb3IgUkdCQSBmb3JtYXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IHJnYigwLTI1NSwwLTI1NSwwLTI1NSksIHJnYigwJS0xMDAlLDAlLTEwMCUsMCUtMTAwJSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21SZ2IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHZhciBtYXRjaCA9IGNvbG9yLm1hdGNoKENvbG9yLnJlUkdCYSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzFdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFsxXSkgPyAyNTUgOiAxKSxcbiAgICAgICAgICBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDI1NSA6IDEpLFxuICAgICAgICAgIGIgPSBwYXJzZUludChtYXRjaFszXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbM10pID8gMjU1IDogMSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHBhcnNlSW50KHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoZywgMTApLFxuICAgICAgICBwYXJzZUludChiLCAxMCksXG4gICAgICAgIG1hdGNoWzRdID8gcGFyc2VGbG9hdChtYXRjaFs0XSkgOiAxXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCQSBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21SZ2JhID0gQ29sb3IuZnJvbVJnYjtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gSFNMIGZvcm1hdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTI2MCwwJS0xMDAlLDAlLTEwMCUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Ic2wgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiBDb2xvci5mcm9tU291cmNlKENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsxMDAsIDEwMCwgMjAwLCAxXSkgb2YgYSBjb2xvciB0aGF0J3MgaW4gSFNMIG9yIEhTTEEgZm9ybWF0LlxuICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTM2MCwwJS0xMDAlLDAlLTEwMCUpIG9yIGhzbGEoMC0zNjAsMCUtMTAwJSwwJS0xMDAlLCAwLTEpXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3VyY2VcbiAgICogQHNlZSBodHRwOi8vaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jaHNsLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbUhzbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ29sb3IucmVIU0xhKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MCxcbiAgICAgICAgcyA9IHBhcnNlRmxvYXQobWF0Y2hbMl0pIC8gKC8lJC8udGVzdChtYXRjaFsyXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgbCA9IHBhcnNlRmxvYXQobWF0Y2hbM10pIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgciwgZywgYjtcblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByID0gZyA9IGIgPSBsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBxID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgICAgcCA9IGwgKiAyIC0gcTtcblxuICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgTWF0aC5yb3VuZChyICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQoZyAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKGIgKiAyNTUpLFxuICAgICAgbWF0Y2hbNF0gPyBwYXJzZUZsb2F0KG1hdGNoWzRdKSA6IDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIU0xBIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhzbGEgPSBDb2xvci5mcm9tSHNsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IEZGNTU1NVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhleCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgZXg6IEZGNTU1NSBvciBGRjU1NDRDQyAoUkdCYSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21IZXggPSBmdW5jdGlvbihjb2xvcikge1xuICAgIGlmIChjb2xvci5tYXRjaChDb2xvci5yZUhleCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNvbG9yLnNsaWNlKGNvbG9yLmluZGV4T2YoJyMnKSArIDEpLFxuICAgICAgICAgIGlzU2hvcnROb3RhdGlvbiA9ICh2YWx1ZS5sZW5ndGggPT09IDMgfHwgdmFsdWUubGVuZ3RoID09PSA0KSxcbiAgICAgICAgICBpc1JHQmEgPSAodmFsdWUubGVuZ3RoID09PSA4IHx8IHZhbHVlLmxlbmd0aCA9PT0gNCksXG4gICAgICAgICAgciA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMCkgKyB2YWx1ZS5jaGFyQXQoMCkpIDogdmFsdWUuc3Vic3RyaW5nKDAsIDIpLFxuICAgICAgICAgIGcgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDEpICsgdmFsdWUuY2hhckF0KDEpKSA6IHZhbHVlLnN1YnN0cmluZygyLCA0KSxcbiAgICAgICAgICBiID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgyKSArIHZhbHVlLmNoYXJBdCgyKSkgOiB2YWx1ZS5zdWJzdHJpbmcoNCwgNiksXG4gICAgICAgICAgYSA9IGlzUkdCYSA/IChpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDMpICsgdmFsdWUuY2hhckF0KDMpKSA6IHZhbHVlLnN1YnN0cmluZyg2LCA4KSkgOiAnRkYnO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBwYXJzZUludChyLCAxNiksXG4gICAgICAgIHBhcnNlSW50KGcsIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoYiwgMTYpLFxuICAgICAgICBwYXJzZUZsb2F0KChwYXJzZUludChhLCAxNikgLyAyNTUpLnRvRml4ZWQoMikpXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGNvbG9yIGluIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzIwMCwgMTAwLCAxMDAsIDAuNV0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Tb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICB2YXIgb0NvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgb0NvbG9yLnNldFNvdXJjZShzb3VyY2UpO1xuICAgIHJldHVybiBvQ29sb3I7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHNjYWxlTWFwID0gWydlJywgJ3NlJywgJ3MnLCAnc3cnLCAndycsICdudycsICduJywgJ25lJywgJ2UnXSxcbiAgICAgIHNrZXdNYXAgPSBbJ25zJywgJ25lc3cnLCAnZXcnLCAnbndzZSddLFxuICAgICAgY29udHJvbHMgPSB7fSxcbiAgICAgIExFRlQgPSAnbGVmdCcsIFRPUCA9ICd0b3AnLCBSSUdIVCA9ICdyaWdodCcsIEJPVFRPTSA9ICdib3R0b20nLCBDRU5URVIgPSAnY2VudGVyJyxcbiAgICAgIG9wcG9zaXRlID0ge1xuICAgICAgICB0b3A6IEJPVFRPTSxcbiAgICAgICAgYm90dG9tOiBUT1AsXG4gICAgICAgIGxlZnQ6IFJJR0hULFxuICAgICAgICByaWdodDogTEVGVCxcbiAgICAgICAgY2VudGVyOiBDRU5URVIsXG4gICAgICB9LCByYWRpYW5zVG9EZWdyZWVzID0gZmFicmljLnV0aWwucmFkaWFuc1RvRGVncmVlcyxcbiAgICAgIHNpZ24gPSAoTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7IH0pO1xuXG4gIC8qKlxuICAgKiBDb21iaW5lIGNvbnRyb2wgcG9zaXRpb24gYW5kIG9iamVjdCBhbmdsZSB0byBmaW5kIHRoZSBjb250cm9sIGRpcmVjdGlvbiBjb21wYXJlZFxuICAgKiB0byB0aGUgb2JqZWN0IGNlbnRlci5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgZm9yIHdoaWNoIHdlIGFyZSByZW5kZXJpbmcgY29udHJvbHNcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCBjbGFzc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDAgLSA3IGEgcXVhZHJhbnQgbnVtYmVyXG4gICAqL1xuICBmdW5jdGlvbiBmaW5kQ29ybmVyUXVhZHJhbnQoZmFicmljT2JqZWN0LCBjb250cm9sKSB7XG4gICAgdmFyIGNvcm5lckFuZ2xlID0gZmFicmljT2JqZWN0LmFuZ2xlICsgcmFkaWFuc1RvRGVncmVlcyhNYXRoLmF0YW4yKGNvbnRyb2wueSwgY29udHJvbC54KSkgKyAzNjA7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGNvcm5lckFuZ2xlICUgMzYwKSAvIDQ1KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudChldmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBjYW52YXMgPSB0YXJnZXQuY2FudmFzLFxuICAgICAgICBjYW52YXNPcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpO1xuICAgIGNhbnZhc09wdGlvbnMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGNhbnZhcyAmJiBjYW52YXMuZmlyZSgnb2JqZWN0OicgKyBldmVudE5hbWUsIGNhbnZhc09wdGlvbnMpO1xuICAgIHRhcmdldC5maXJlKGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSW5zcGVjdCBldmVudCBhbmQgZmFicmljT2JqZWN0IHByb3BlcnRpZXMgdG8gdW5kZXJzdGFuZCBpZiB0aGUgc2NhbGluZyBhY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGZyb20gdGhlIHVzZXIgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGFib3V0IHRvIHNjYWxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc2NhbGUgaXMgcHJvcG9ydGlvbmFsXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZUlzUHJvcG9ydGlvbmFsKGV2ZW50RGF0YSwgZmFicmljT2JqZWN0KSB7XG4gICAgdmFyIGNhbnZhcyA9IGZhYnJpY09iamVjdC5jYW52YXMsIHVuaVNjYWxlS2V5ID0gY2FudmFzLnVuaVNjYWxlS2V5LFxuICAgICAgICB1bmlmb3JtSXNUb2dnbGVkID0gZXZlbnREYXRhW3VuaVNjYWxlS2V5XTtcbiAgICByZXR1cm4gKGNhbnZhcy51bmlmb3JtU2NhbGluZyAmJiAhdW5pZm9ybUlzVG9nZ2xlZCkgfHxcbiAgICAoIWNhbnZhcy51bmlmb3JtU2NhbGluZyAmJiB1bmlmb3JtSXNUb2dnbGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdHJhbnNmb3JtIGlzIGNlbnRlcmVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gdHJhbnNmb3JtIGRhdGFcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0cmFuc2Zvcm0gaXMgY2VudGVyZWRcbiAgICovXG4gIGZ1bmN0aW9uIGlzVHJhbnNmb3JtQ2VudGVyZWQodHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybS5vcmlnaW5YID09PSBDRU5URVIgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IENFTlRFUjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IGZhYnJpY09iamVjdCB0byB1bmRlcnN0YW5kIGlmIHRoZSBjdXJyZW50IHNjYWxpbmcgYWN0aW9uIGlzIGFsbG93ZWRcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgYWJvdXQgdG8gc2NhbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ5ICd4JyBvciAneScgb3IgJydcbiAgICogQHBhcmFtIHtCb29sZWFufSBzY2FsZVByb3BvcnRpb25hbGx5IHRydWUgaWYgd2UgYXJlIHRyeWluZyB0byBzY2FsZSBwcm9wb3J0aW9uYWxseVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNjYWxpbmcgaXMgbm90IGFsbG93ZWQgYXQgY3VycmVudCBjb25kaXRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsaW5nSXNGb3JiaWRkZW4oZmFicmljT2JqZWN0LCBieSwgc2NhbGVQcm9wb3J0aW9uYWxseSkge1xuICAgIHZhciBsb2NrWCA9IGZhYnJpY09iamVjdC5sb2NrU2NhbGluZ1gsIGxvY2tZID0gZmFicmljT2JqZWN0LmxvY2tTY2FsaW5nWTtcbiAgICBpZiAobG9ja1ggJiYgbG9ja1kpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWJ5ICYmIChsb2NrWCB8fCBsb2NrWSkgJiYgc2NhbGVQcm9wb3J0aW9uYWxseSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChsb2NrWCAmJiBieSA9PT0gJ3gnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxvY2tZICYmIGJ5ID09PSAneScpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIHRoZSBjb3JyZWN0IGN1cnNvciBzdHlsZSBmb3IgdGhlIHNjYWxlIGFjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZUN1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIHZhciBub3RBbGxvd2VkID0gJ25vdC1hbGxvd2VkJyxcbiAgICAgICAgc2NhbGVQcm9wb3J0aW9uYWxseSA9IHNjYWxlSXNQcm9wb3J0aW9uYWwoZXZlbnREYXRhLCBmYWJyaWNPYmplY3QpLFxuICAgICAgICBieSA9ICcnO1xuICAgIGlmIChjb250cm9sLnggIT09IDAgJiYgY29udHJvbC55ID09PSAwKSB7XG4gICAgICBieSA9ICd4JztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbC54ID09PSAwICYmIGNvbnRyb2wueSAhPT0gMCkge1xuICAgICAgYnkgPSAneSc7XG4gICAgfVxuICAgIGlmIChzY2FsaW5nSXNGb3JiaWRkZW4oZmFicmljT2JqZWN0LCBieSwgc2NhbGVQcm9wb3J0aW9uYWxseSkpIHtcbiAgICAgIHJldHVybiBub3RBbGxvd2VkO1xuICAgIH1cbiAgICB2YXIgbiA9IGZpbmRDb3JuZXJRdWFkcmFudChmYWJyaWNPYmplY3QsIGNvbnRyb2wpO1xuICAgIHJldHVybiBzY2FsZU1hcFtuXSArICctcmVzaXplJztcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIGNvcnJlY3QgY3Vyc29yIHN0eWxlIGZvciB0aGUgc2tldyBhY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGEgdmFsaWQgY3NzIHN0cmluZyBmb3IgdGhlIGN1cnNvclxuICAgKi9cbiAgZnVuY3Rpb24gc2tld0N1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIHZhciBub3RBbGxvd2VkID0gJ25vdC1hbGxvd2VkJztcbiAgICBpZiAoY29udHJvbC54ICE9PSAwICYmIGZhYnJpY09iamVjdC5sb2NrU2tld2luZ1kpIHtcbiAgICAgIHJldHVybiBub3RBbGxvd2VkO1xuICAgIH1cbiAgICBpZiAoY29udHJvbC55ICE9PSAwICYmIGZhYnJpY09iamVjdC5sb2NrU2tld2luZ1gpIHtcbiAgICAgIHJldHVybiBub3RBbGxvd2VkO1xuICAgIH1cbiAgICB2YXIgbiA9IGZpbmRDb3JuZXJRdWFkcmFudChmYWJyaWNPYmplY3QsIGNvbnRyb2wpICUgNDtcbiAgICByZXR1cm4gc2tld01hcFtuXSArICctcmVzaXplJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lIHNrZXcgYW5kIHNjYWxlIHN0eWxlIGhhbmRsZXJzIHRvIGNvdmVyIGZhYnJpYyBzdGFuZGFyZCB1c2UgY2FzZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICBpZiAoZXZlbnREYXRhW2ZhYnJpY09iamVjdC5jYW52YXMuYWx0QWN0aW9uS2V5XSkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xzLnNrZXdDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbHMuc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3BlY3QgZXZlbnQsIGNvbnRyb2wgYW5kIGZhYnJpY09iamVjdCB0byByZXR1cm4gdGhlIGNvcnJlY3QgYWN0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGFuIGFjdGlvbiBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9yU2tld0FjdGlvbk5hbWUoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICB2YXIgaXNBbHRlcm5hdGl2ZSA9IGV2ZW50RGF0YVtmYWJyaWNPYmplY3QuY2FudmFzLmFsdEFjdGlvbktleV07XG4gICAgaWYgKGNvbnRyb2wueCA9PT0gMCkge1xuICAgICAgLy8gdGhlbiBpcyBzY2FsZVkgb3Igc2tld1hcbiAgICAgIHJldHVybiBpc0FsdGVybmF0aXZlID8gJ3NrZXdYJyA6ICdzY2FsZVknO1xuICAgIH1cbiAgICBpZiAoY29udHJvbC55ID09PSAwKSB7XG4gICAgICAvLyB0aGVuIGlzIHNjYWxlWSBvciBza2V3WFxuICAgICAgcmV0dXJuIGlzQWx0ZXJuYXRpdmUgPyAnc2tld1knIDogJ3NjYWxlWCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGNvcnJlY3Qgc3R5bGUgZm9yIHRoZSBjb250cm9sIHRoYXQgaXMgdXNlZCBmb3Igcm90YXRpb24uXG4gICAqIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzaW1wbGUgYW5kIGl0IGp1c3QgdGFrZSBjYXJlIG9mIG5vdC1hbGxvd2VkIG9yIHN0YW5kYXJkIGN1cnNvclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiByb3RhdGlvblN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIGlmIChmYWJyaWNPYmplY3QubG9ja1JvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gJ25vdC1hbGxvd2VkJztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2wuY3Vyc29yU3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21tb25FdmVudEluZm8oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZTogZXZlbnREYXRhLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBwb2ludGVyOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwIGFuIGFjdGlvbiBoYW5kbGVyIHdpdGggc2F2aW5nL3Jlc3RvcmluZyBvYmplY3QgcG9zaXRpb24gb24gdGhlIHRyYW5zZm9ybS5cbiAgICogdGhpcyBpcyB0aGUgY29kZSB0aGF0IHBlcm1pdHMgdG8gb2JqZWN0cyB0byBrZWVwIHRoZWlyIHBvc2l0aW9uIHdoaWxlIHRyYW5zZm9ybWluZy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uSGFuZGxlciB0aGUgZnVuY3Rpb24gdG8gd3JhcFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB3aXRoIGFuIGFjdGlvbiBoYW5kbGVyIHNpZ25hdHVyZVxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcFdpdGhGaXhlZEFuY2hvcihhY3Rpb25IYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgY2VudGVyUG9pbnQgPSB0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICBjb25zdHJhaW50ID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyUG9pbnQsIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSksXG4gICAgICAgICAgYWN0aW9uUGVyZm9ybWVkID0gYWN0aW9uSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50LCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblkpO1xuICAgICAgcmV0dXJuIGFjdGlvblBlcmZvcm1lZDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXAgYW4gYWN0aW9uIGhhbmRsZXIgd2l0aCBmaXJpbmcgYW4gZXZlbnQgaWYgdGhlIGFjdGlvbiBpcyBwZXJmb3JtZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uSGFuZGxlciB0aGUgZnVuY3Rpb24gdG8gd3JhcFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB3aXRoIGFuIGFjdGlvbiBoYW5kbGVyIHNpZ25hdHVyZVxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcFdpdGhGaXJlRXZlbnQoZXZlbnROYW1lLCBhY3Rpb25IYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgICB2YXIgYWN0aW9uUGVyZm9ybWVkID0gYWN0aW9uSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICBpZiAoYWN0aW9uUGVyZm9ybWVkKSB7XG4gICAgICAgIGZpcmVFdmVudChldmVudE5hbWUsIGNvbW1vbkV2ZW50SW5mbyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvblBlcmZvcm1lZDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYSBwb2ludCBkZXNjcmliZWQgYnkgeCBhbmQgeSBpbiBhIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgb2JqZWN0XG4gICAqIGJvdW5kaW5nIGJveC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtGYWJyaWMuUG9pbnR9IHRoZSBub3JtYWxpemVkIHBvaW50XG4gICAqL1xuICBmdW5jdGlvbiBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgb3JpZ2luWCwgb3JpZ2luWSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW3RyYW5zZm9ybS5jb3JuZXJdLFxuICAgICAgICB6b29tID0gdGFyZ2V0LmNhbnZhcy5nZXRab29tKCksXG4gICAgICAgIHBhZGRpbmcgPSB0YXJnZXQucGFkZGluZyAvIHpvb20sXG4gICAgICAgIGxvY2FsUG9pbnQgPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoeCwgeSksIG9yaWdpblgsIG9yaWdpblkpO1xuICAgIGlmIChsb2NhbFBvaW50LnggPj0gcGFkZGluZykge1xuICAgICAgbG9jYWxQb2ludC54IC09IHBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChsb2NhbFBvaW50LnggPD0gLXBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueCArPSBwYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobG9jYWxQb2ludC55ID49IHBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueSAtPSBwYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobG9jYWxQb2ludC55IDw9IHBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueSArPSBwYWRkaW5nO1xuICAgIH1cbiAgICBsb2NhbFBvaW50LnggLT0gY29udHJvbC5vZmZzZXRYO1xuICAgIGxvY2FsUG9pbnQueSAtPSBjb250cm9sLm9mZnNldFk7XG4gICAgcmV0dXJuIGxvY2FsUG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGlmIHRoZSBmYWJyaWMgb2JqZWN0IGlzIGZsaXBwZWQgb24gb25lIHNpZGUuXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb25lIGZsaXAsIGJ1dCBub3QgdHdvLlxuICAgKi9cbiAgZnVuY3Rpb24gdGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmZsaXBYICE9PSB0YXJnZXQuZmxpcFk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBjb21wZW5zYXRlIHRoZSBzY2FsZSBmYWN0b3Igd2hlbiBza2V3IGlzIGFwcGxpZWQgb24gYm90aCBheGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wZW5zYXRlU2NhbGVGb3JTa2V3KHRhcmdldCwgb3Bwb3NpdGVTa2V3LCBzY2FsZVRvQ29tcGVuc2F0ZSwgYXhpcywgcmVmZXJlbmNlKSB7XG4gICAgaWYgKHRhcmdldFtvcHBvc2l0ZVNrZXddICE9PSAwKSB7XG4gICAgICB2YXIgbmV3RGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKVtheGlzXTtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHJlZmVyZW5jZSAvIG5ld0RpbSAqIHRhcmdldFtzY2FsZVRvQ29tcGVuc2F0ZV07XG4gICAgICB0YXJnZXQuc2V0KHNjYWxlVG9Db21wZW5zYXRlLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyIGZvciBza2V3aW5nIG9uIHRoZSBYIGF4aXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNrZXdPYmplY3RYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIC8vIGZpbmQgaG93IGJpZyB0aGUgb2JqZWN0IHdvdWxkIGJlLCBpZiB0aGVyZSB3YXMgbm8gc2tld1guIHRha2VzIGluIGFjY291bnQgc2NhbGluZ1xuICAgICAgICBkaW1Ob1NrZXcgPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygwLCB0YXJnZXQuc2tld1kpLFxuICAgICAgICBsb2NhbFBvaW50ID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSwgeCwgeSksXG4gICAgICAgIC8vIHRoZSBtb3VzZSBpcyBpbiB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QsIGFuZCB3ZSB3YW50IGl0IHRvIHN0YXkgdGhlcmUuXG4gICAgICAgIC8vIHNvIHRoZSBvYmplY3Qgd2lsbCBncm93IHR3aWNlIGFzIG11Y2ggYXMgdGhlIG1vdXNlLlxuICAgICAgICAvLyB0aGlzIG1ha2VzIHRoZSBza2V3IGdyb3d0aCB0byBsb2NhbFBvaW50ICogMiAtIGRpbU5vU2tldy5cbiAgICAgICAgdG90YWxTa2V3U2l6ZSA9IE1hdGguYWJzKGxvY2FsUG9pbnQueCAqIDIpIC0gZGltTm9Ta2V3LngsXG4gICAgICAgIGN1cnJlbnRTa2V3ID0gdGFyZ2V0LnNrZXdYLCBuZXdTa2V3O1xuICAgIGlmICh0b3RhbFNrZXdTaXplIDwgMikge1xuICAgICAgLy8gbGV0J3MgbWFrZSBpdCBlYXN5IHRvIGdvIGJhY2sgdG8gcG9zaXRpb24gMC5cbiAgICAgIG5ld1NrZXcgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5ld1NrZXcgPSByYWRpYW5zVG9EZWdyZWVzKFxuICAgICAgICBNYXRoLmF0YW4yKCh0b3RhbFNrZXdTaXplIC8gdGFyZ2V0LnNjYWxlWCksIChkaW1Ob1NrZXcueSAvIHRhcmdldC5zY2FsZVkpKVxuICAgICAgKTtcbiAgICAgIC8vIG5vdyB3ZSBoYXZlIHRvIGZpbmQgdGhlIHNpZ24gb2YgdGhlIHNrZXcuXG4gICAgICAvLyBpdCBtb3N0bHkgZGVwZW5kIG9uIHRoZSBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24uXG4gICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09IExFRlQgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IEJPVFRPTSkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09IFJJR0hUICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBUT1ApIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldEhhc09uZUZsaXAodGFyZ2V0KSkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBoYXNTa2V3ZWQgPSBjdXJyZW50U2tldyAhPT0gbmV3U2tldztcbiAgICBpZiAoaGFzU2tld2VkKSB7XG4gICAgICB2YXIgZGltQmVmb3JlU2tld2luZyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueTtcbiAgICAgIHRhcmdldC5zZXQoJ3NrZXdYJywgbmV3U2tldyk7XG4gICAgICBjb21wZW5zYXRlU2NhbGVGb3JTa2V3KHRhcmdldCwgJ3NrZXdZJywgJ3NjYWxlWScsICd5JywgZGltQmVmb3JlU2tld2luZyk7XG4gICAgfVxuICAgIHJldHVybiBoYXNTa2V3ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIgZm9yIHNrZXdpbmcgb24gdGhlIFkgYXhpc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2tld09iamVjdFkoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgLy8gZmluZCBob3cgYmlnIHRoZSBvYmplY3Qgd291bGQgYmUsIGlmIHRoZXJlIHdhcyBubyBza2V3WC4gdGFrZXMgaW4gYWNjb3VudCBzY2FsaW5nXG4gICAgICAgIGRpbU5vU2tldyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKHRhcmdldC5za2V3WCwgMCksXG4gICAgICAgIGxvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZLCB4LCB5KSxcbiAgICAgICAgLy8gdGhlIG1vdXNlIGlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCwgYW5kIHdlIHdhbnQgaXQgdG8gc3RheSB0aGVyZS5cbiAgICAgICAgLy8gc28gdGhlIG9iamVjdCB3aWxsIGdyb3cgdHdpY2UgYXMgbXVjaCBhcyB0aGUgbW91c2UuXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgdGhlIHNrZXcgZ3Jvd3RoIHRvIGxvY2FsUG9pbnQgKiAyIC0gZGltTm9Ta2V3LlxuICAgICAgICB0b3RhbFNrZXdTaXplID0gTWF0aC5hYnMobG9jYWxQb2ludC55ICogMikgLSBkaW1Ob1NrZXcueSxcbiAgICAgICAgY3VycmVudFNrZXcgPSB0YXJnZXQuc2tld1ksIG5ld1NrZXc7XG4gICAgaWYgKHRvdGFsU2tld1NpemUgPCAyKSB7XG4gICAgICAvLyBsZXQncyBtYWtlIGl0IGVhc3kgdG8gZ28gYmFjayB0byBwb3NpdGlvbiAwLlxuICAgICAgbmV3U2tldyA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmV3U2tldyA9IHJhZGlhbnNUb0RlZ3JlZXMoXG4gICAgICAgIE1hdGguYXRhbjIoKHRvdGFsU2tld1NpemUgLyB0YXJnZXQuc2NhbGVZKSwgKGRpbU5vU2tldy54IC8gdGFyZ2V0LnNjYWxlWCkpXG4gICAgICApO1xuICAgICAgLy8gbm93IHdlIGhhdmUgdG8gZmluZCB0aGUgc2lnbiBvZiB0aGUgc2tldy5cbiAgICAgIC8vIGl0IG1vc3RseSBkZXBlbmQgb24gdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gTEVGVCAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gQk9UVE9NKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gUklHSFQgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IFRPUCkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhhc1NrZXdlZCA9IGN1cnJlbnRTa2V3ICE9PSBuZXdTa2V3O1xuICAgIGlmIChoYXNTa2V3ZWQpIHtcbiAgICAgIHZhciBkaW1CZWZvcmVTa2V3aW5nID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS54O1xuICAgICAgdGFyZ2V0LnNldCgnc2tld1knLCBuZXdTa2V3KTtcbiAgICAgIGNvbXBlbnNhdGVTY2FsZUZvclNrZXcodGFyZ2V0LCAnc2tld1gnLCAnc2NhbGVYJywgJ3gnLCBkaW1CZWZvcmVTa2V3aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1NrZXdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVkIEFjdGlvbiBoYW5kbGVyIGZvciBza2V3aW5nIG9uIHRoZSBZIGF4aXMsIHRha2VzIGNhcmUgb2YgdGhlXG4gICAqIHNrZXcgZGlyZWN0aW9uIGFuZCBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIG9yaWdpbiBmb3IgdGhlIGFuY2hvciBwb2ludFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNrZXdIYW5kbGVyWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIC8vIHN0ZXAxIGZpZ3VyZSBvdXQgYW5kIGNoYW5nZSB0cmFuc2Zvcm0gb3JpZ2luLlxuICAgIC8vIGlmIHNrZXdYID4gMCBhbmQgb3JpZ2luWSBib3R0b20gd2UgYW5jaG9yIG9uIHJpZ2h0XG4gICAgLy8gaWYgc2tld1ggPiAwIGFuZCBvcmlnaW5ZIHRvcCB3ZSBhbmNob3Igb24gbGVmdFxuICAgIC8vIGlmIHNrZXdYIDwgMCBhbmQgb3JpZ2luWSBib3R0b20gd2UgYW5jaG9yIG9uIGxlZnRcbiAgICAvLyBpZiBza2V3WCA8IDAgYW5kIG9yaWdpblkgdG9wIHdlIGFuY2hvciBvbiByaWdodFxuICAgIC8vIGlmIHNrZXdYIGlzIDAsIHdlIGxvb2sgZm9yIG1vdXNlIHBvc2l0aW9uIHRvIHVuZGVyc3RhbmQgd2hlcmUgYXJlIHdlIGdvaW5nLlxuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LCBjdXJyZW50U2tldyA9IHRhcmdldC5za2V3WCwgb3JpZ2luWCwgb3JpZ2luWSA9IHRyYW5zZm9ybS5vcmlnaW5ZO1xuICAgIGlmICh0YXJnZXQubG9ja1NrZXdpbmdYKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdXJyZW50U2tldyA9PT0gMCkge1xuICAgICAgdmFyIGxvY2FsUG9pbnRGcm9tQ2VudGVyID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIENFTlRFUiwgQ0VOVEVSLCB4LCB5KTtcbiAgICAgIGlmIChsb2NhbFBvaW50RnJvbUNlbnRlci54ID4gMCkge1xuICAgICAgICAvLyB3ZSBhcmUgcHVsbGluZyByaWdodCwgYW5jaG9yIGxlZnQ7XG4gICAgICAgIG9yaWdpblggPSBMRUZUO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHdlIGFyZSBwdWxsaW5nIHJpZ2h0LCBhbmNob3IgcmlnaHRcbiAgICAgICAgb3JpZ2luWCA9IFJJR0hUO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50U2tldyA+IDApIHtcbiAgICAgICAgb3JpZ2luWCA9IG9yaWdpblkgPT09IFRPUCA/IExFRlQgOiBSSUdIVDtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50U2tldyA8IDApIHtcbiAgICAgICAgb3JpZ2luWCA9IG9yaWdpblkgPT09IFRPUCA/IFJJR0hUIDogTEVGVDtcbiAgICAgIH1cbiAgICAgIC8vIGlzIHRoZSBvYmplY3QgZmxpcHBlZCBvbiBvbmUgc2lkZSBvbmx5PyBzd2FwIHRoZSBvcmlnaW4uXG4gICAgICBpZiAodGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpKSB7XG4gICAgICAgIG9yaWdpblggPSBvcmlnaW5YID09PSBMRUZUID8gUklHSFQgOiBMRUZUO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG9uY2Ugd2UgaGF2ZSB0aGUgb3JpZ2luLCB3ZSBmaW5kIHRoZSBhbmNob3IgcG9pbnRcbiAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9IG9yaWdpblg7XG4gICAgdmFyIGZpbmFsSGFuZGxlciA9IHdyYXBXaXRoRmlyZUV2ZW50KCdza2V3aW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvcihza2V3T2JqZWN0WCkpO1xuICAgIHJldHVybiBmaW5hbEhhbmRsZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZWQgQWN0aW9uIGhhbmRsZXIgZm9yIHNrZXdpbmcgb24gdGhlIFkgYXhpcywgdGFrZXMgY2FyZSBvZiB0aGVcbiAgICogc2tldyBkaXJlY3Rpb24gYW5kIGRldGVybWluZSB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gb3JpZ2luIGZvciB0aGUgYW5jaG9yIHBvaW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2tld0hhbmRsZXJZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgLy8gc3RlcDEgZmlndXJlIG91dCBhbmQgY2hhbmdlIHRyYW5zZm9ybSBvcmlnaW4uXG4gICAgLy8gaWYgc2tld1kgPiAwIGFuZCBvcmlnaW5YIGxlZnQgd2UgYW5jaG9yIG9uIHRvcFxuICAgIC8vIGlmIHNrZXdZID4gMCBhbmQgb3JpZ2luWCByaWdodCB3ZSBhbmNob3Igb24gYm90dG9tXG4gICAgLy8gaWYgc2tld1kgPCAwIGFuZCBvcmlnaW5YIGxlZnQgd2UgYW5jaG9yIG9uIGJvdHRvbVxuICAgIC8vIGlmIHNrZXdZIDwgMCBhbmQgb3JpZ2luWCByaWdodCB3ZSBhbmNob3Igb24gdG9wXG4gICAgLy8gaWYgc2tld1kgaXMgMCwgd2UgbG9vayBmb3IgbW91c2UgcG9zaXRpb24gdG8gdW5kZXJzdGFuZCB3aGVyZSBhcmUgd2UgZ29pbmcuXG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGN1cnJlbnRTa2V3ID0gdGFyZ2V0LnNrZXdZLCBvcmlnaW5ZLCBvcmlnaW5YID0gdHJhbnNmb3JtLm9yaWdpblg7XG4gICAgaWYgKHRhcmdldC5sb2NrU2tld2luZ1kpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRTa2V3ID09PSAwKSB7XG4gICAgICB2YXIgbG9jYWxQb2ludEZyb21DZW50ZXIgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgQ0VOVEVSLCBDRU5URVIsIHgsIHkpO1xuICAgICAgaWYgKGxvY2FsUG9pbnRGcm9tQ2VudGVyLnkgPiAwKSB7XG4gICAgICAgIC8vIHdlIGFyZSBwdWxsaW5nIGRvd24sIGFuY2hvciB1cDtcbiAgICAgICAgb3JpZ2luWSA9IFRPUDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB3ZSBhcmUgcHVsbGluZyB1cCwgYW5jaG9yIGRvd25cbiAgICAgICAgb3JpZ2luWSA9IEJPVFRPTTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY3VycmVudFNrZXcgPiAwKSB7XG4gICAgICAgIG9yaWdpblkgPSBvcmlnaW5YID09PSBMRUZUID8gVE9QIDogQk9UVE9NO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRTa2V3IDwgMCkge1xuICAgICAgICBvcmlnaW5ZID0gb3JpZ2luWCA9PT0gTEVGVCA/IEJPVFRPTSA6IFRPUDtcbiAgICAgIH1cbiAgICAgIC8vIGlzIHRoZSBvYmplY3QgZmxpcHBlZCBvbiBvbmUgc2lkZSBvbmx5PyBzd2FwIHRoZSBvcmlnaW4uXG4gICAgICBpZiAodGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpKSB7XG4gICAgICAgIG9yaWdpblkgPSBvcmlnaW5ZID09PSBUT1AgPyBCT1RUT00gOiBUT1A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb25jZSB3ZSBoYXZlIHRoZSBvcmlnaW4sIHdlIGZpbmQgdGhlIGFuY2hvciBwb2ludFxuICAgIHRyYW5zZm9ybS5vcmlnaW5ZID0gb3JpZ2luWTtcbiAgICB2YXIgZmluYWxIYW5kbGVyID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3NrZXdpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKHNrZXdPYmplY3RZKSk7XG4gICAgcmV0dXJuIGZpbmFsSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIgZm9yIHJvdGF0aW9uIGFuZCBzbmFwcGluZywgd2l0aG91dCBhbmNob3IgcG9pbnQuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcm90YXRpb25XaXRoU25hcHBpbmcoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICB2YXIgdCA9IHRyYW5zZm9ybSxcbiAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsXG4gICAgICAgIHBpdm90UG9pbnQgPSB0YXJnZXQudHJhbnNsYXRlVG9PcmlnaW5Qb2ludCh0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKSwgdC5vcmlnaW5YLCB0Lm9yaWdpblkpO1xuXG4gICAgaWYgKHRhcmdldC5sb2NrUm90YXRpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdEFuZ2xlID0gTWF0aC5hdGFuMih0LmV5IC0gcGl2b3RQb2ludC55LCB0LmV4IC0gcGl2b3RQb2ludC54KSxcbiAgICAgICAgY3VyQW5nbGUgPSBNYXRoLmF0YW4yKHkgLSBwaXZvdFBvaW50LnksIHggLSBwaXZvdFBvaW50LngpLFxuICAgICAgICBhbmdsZSA9IHJhZGlhbnNUb0RlZ3JlZXMoY3VyQW5nbGUgLSBsYXN0QW5nbGUgKyB0LnRoZXRhKSxcbiAgICAgICAgaGFzUm90YXRlZCA9IHRydWU7XG5cbiAgICBpZiAodGFyZ2V0LnNuYXBBbmdsZSA+IDApIHtcbiAgICAgIHZhciBzbmFwQW5nbGUgID0gdGFyZ2V0LnNuYXBBbmdsZSxcbiAgICAgICAgICBzbmFwVGhyZXNob2xkICA9IHRhcmdldC5zbmFwVGhyZXNob2xkIHx8IHNuYXBBbmdsZSxcbiAgICAgICAgICByaWdodEFuZ2xlTG9ja2VkID0gTWF0aC5jZWlsKGFuZ2xlIC8gc25hcEFuZ2xlKSAqIHNuYXBBbmdsZSxcbiAgICAgICAgICBsZWZ0QW5nbGVMb2NrZWQgPSBNYXRoLmZsb29yKGFuZ2xlIC8gc25hcEFuZ2xlKSAqIHNuYXBBbmdsZTtcblxuICAgICAgaWYgKE1hdGguYWJzKGFuZ2xlIC0gbGVmdEFuZ2xlTG9ja2VkKSA8IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgYW5nbGUgPSBsZWZ0QW5nbGVMb2NrZWQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChNYXRoLmFicyhhbmdsZSAtIHJpZ2h0QW5nbGVMb2NrZWQpIDwgc25hcFRocmVzaG9sZCkge1xuICAgICAgICBhbmdsZSA9IHJpZ2h0QW5nbGVMb2NrZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIGFuZ2xlIHRvIHBvc2l0aXZlIHZhbHVlXG4gICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgYW5nbGUgPSAzNjAgKyBhbmdsZTtcbiAgICB9XG4gICAgYW5nbGUgJT0gMzYwO1xuXG4gICAgaGFzUm90YXRlZCA9IHRhcmdldC5hbmdsZSAhPT0gYW5nbGU7XG4gICAgdGFyZ2V0LmFuZ2xlID0gYW5nbGU7XG4gICAgcmV0dXJuIGhhc1JvdGF0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQmFzaWMgc2NhbGluZyBsb2dpYywgcmV1c2VkIHdpdGggZGlmZmVyZW50IGNvbnN0cmFpbiBmb3Igc2NhbGluZyBYLFksIGZyZWVseSBvciBlcXVhbGx5LlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZm9yIHNjYWxpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYnkgJ3gnLCAneScsICdlcXVhbGx5JyBvciAnJyB0byBpbmRpY2F0ZSB0eXBlIG9mIHNjYWxpbmdcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3QoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgbG9ja1NjYWxpbmdYID0gdGFyZ2V0LmxvY2tTY2FsaW5nWCwgbG9ja1NjYWxpbmdZID0gdGFyZ2V0LmxvY2tTY2FsaW5nWSxcbiAgICAgICAgYnkgPSBvcHRpb25zLmJ5LCBuZXdQb2ludCwgc2NhbGVYLCBzY2FsZVksIGRpbSxcbiAgICAgICAgc2NhbGVQcm9wb3J0aW9uYWxseSA9IHNjYWxlSXNQcm9wb3J0aW9uYWwoZXZlbnREYXRhLCB0YXJnZXQpLFxuICAgICAgICBmb3JiaWRTY2FsaW5nID0gc2NhbGluZ0lzRm9yYmlkZGVuKHRhcmdldCwgYnksIHNjYWxlUHJvcG9ydGlvbmFsbHkpLFxuICAgICAgICBzaWduWCwgc2lnblksIGdlc3R1cmVTY2FsZSA9IHRyYW5zZm9ybS5nZXN0dXJlU2NhbGU7XG5cbiAgICBpZiAoZm9yYmlkU2NhbGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZ2VzdHVyZVNjYWxlKSB7XG4gICAgICBzY2FsZVggPSB0cmFuc2Zvcm0uc2NhbGVYICogZ2VzdHVyZVNjYWxlO1xuICAgICAgc2NhbGVZID0gdHJhbnNmb3JtLnNjYWxlWSAqIGdlc3R1cmVTY2FsZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBuZXdQb2ludCA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblksIHgsIHkpO1xuICAgICAgLy8gdXNlIG9mIHNpZ246IFdlIHVzZSBzaWduIHRvIGRldGVjdCBjaGFuZ2Ugb2YgZGlyZWN0aW9uIG9mIGFuIGFjdGlvbi4gc2lnbiB1c3VhbGx5IGNoYW5nZSB3aGVuXG4gICAgICAvLyB3ZSBjcm9zcyB0aGUgb3JpZ2luIHBvaW50IHdpdGggdGhlIG1vdXNlLiBTbyBhIHNjYWxlIGZsaXAgZm9yIGV4YW1wbGUuIFRoZXJlIGlzIGFuIGlzc3VlIHdoZW4gc2NhbGluZ1xuICAgICAgLy8gYnkgY2VudGVyIGFuZCBzY2FsaW5nIHVzaW5nIG9uZSBtaWRkbGUgY29udHJvbCAoIGRlZmF1bHQ6IG1yLCBtdCwgbWwsIG1iKSwgdGhlIG1vdXNlIG1vdmVtZW50IGNhbiBlYXNpbHlcbiAgICAgIC8vIGNyb3NzIG1hbnkgdGltZSB0aGUgb3JpZ2luIHBvaW50IGFuZCBmbGlwIHRoZSBvYmplY3QuIHNvIHdlIG5lZWQgYSB3YXkgdG8gZmlsdGVyIG91dCB0aGUgbm9pc2UuXG4gICAgICAvLyBUaGlzIHRlcm5hcnkgaGVyZSBzaG91bGQgYmUgb2sgdG8gZmlsdGVyIG91dCBYIHNjYWxpbmcgd2hlbiB3ZSB3YW50IFkgb25seSBhbmQgdmljZSB2ZXJzYS5cbiAgICAgIHNpZ25YID0gYnkgIT09ICd5JyA/IHNpZ24obmV3UG9pbnQueCkgOiAxO1xuICAgICAgc2lnblkgPSBieSAhPT0gJ3gnID8gc2lnbihuZXdQb2ludC55KSA6IDE7XG4gICAgICBpZiAoIXRyYW5zZm9ybS5zaWduWCkge1xuICAgICAgICB0cmFuc2Zvcm0uc2lnblggPSBzaWduWDtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNmb3JtLnNpZ25ZKSB7XG4gICAgICAgIHRyYW5zZm9ybS5zaWduWSA9IHNpZ25ZO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0LmxvY2tTY2FsaW5nRmxpcCAmJlxuICAgICAgICAodHJhbnNmb3JtLnNpZ25YICE9PSBzaWduWCB8fCB0cmFuc2Zvcm0uc2lnblkgIT09IHNpZ25ZKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgIC8vIG1pc3NpbmcgZGV0ZWN0aW9uIG9mIGZsaXAgYW5kIGxvZ2ljIHRvIHN3aXRjaCB0aGUgb3JpZ2luXG4gICAgICBpZiAoc2NhbGVQcm9wb3J0aW9uYWxseSAmJiAhYnkpIHtcbiAgICAgICAgLy8gdW5pZm9ybSBzY2FsaW5nXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKG5ld1BvaW50LngpICsgTWF0aC5hYnMobmV3UG9pbnQueSksXG4gICAgICAgICAgICBvcmlnaW5hbCA9IHRyYW5zZm9ybS5vcmlnaW5hbCxcbiAgICAgICAgICAgIG9yaWdpbmFsRGlzdGFuY2UgPSBNYXRoLmFicyhkaW0ueCAqIG9yaWdpbmFsLnNjYWxlWCAvIHRhcmdldC5zY2FsZVgpICtcbiAgICAgICAgICAgICAgTWF0aC5hYnMoZGltLnkgKiBvcmlnaW5hbC5zY2FsZVkgLyB0YXJnZXQuc2NhbGVZKSxcbiAgICAgICAgICAgIHNjYWxlID0gZGlzdGFuY2UgLyBvcmlnaW5hbERpc3RhbmNlO1xuICAgICAgICBzY2FsZVggPSBvcmlnaW5hbC5zY2FsZVggKiBzY2FsZTtcbiAgICAgICAgc2NhbGVZID0gb3JpZ2luYWwuc2NhbGVZICogc2NhbGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gTWF0aC5hYnMobmV3UG9pbnQueCAqIHRhcmdldC5zY2FsZVggLyBkaW0ueCk7XG4gICAgICAgIHNjYWxlWSA9IE1hdGguYWJzKG5ld1BvaW50LnkgKiB0YXJnZXQuc2NhbGVZIC8gZGltLnkpO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgYXJlIHNjYWxpbmcgYnkgY2VudGVyLCB3ZSBuZWVkIHRvIGRvdWJsZSB0aGUgc2NhbGVcbiAgICAgIGlmIChpc1RyYW5zZm9ybUNlbnRlcmVkKHRyYW5zZm9ybSkpIHtcbiAgICAgICAgc2NhbGVYICo9IDI7XG4gICAgICAgIHNjYWxlWSAqPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5zaWduWCAhPT0gc2lnblggJiYgYnkgIT09ICd5Jykge1xuICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9IG9wcG9zaXRlW3RyYW5zZm9ybS5vcmlnaW5YXTtcbiAgICAgICAgc2NhbGVYICo9IC0xO1xuICAgICAgICB0cmFuc2Zvcm0uc2lnblggPSBzaWduWDtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0uc2lnblkgIT09IHNpZ25ZICYmIGJ5ICE9PSAneCcpIHtcbiAgICAgICAgdHJhbnNmb3JtLm9yaWdpblkgPSBvcHBvc2l0ZVt0cmFuc2Zvcm0ub3JpZ2luWV07XG4gICAgICAgIHNjYWxlWSAqPSAtMTtcbiAgICAgICAgdHJhbnNmb3JtLnNpZ25ZID0gc2lnblk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG1pblNjYWxlIGlzIHRha2VuIGFyZSBpbiB0aGUgc2V0dGVyLlxuICAgIHZhciBvbGRTY2FsZVggPSB0YXJnZXQuc2NhbGVYLCBvbGRTY2FsZVkgPSB0YXJnZXQuc2NhbGVZO1xuICAgIGlmICghYnkpIHtcbiAgICAgICFsb2NrU2NhbGluZ1ggJiYgdGFyZ2V0LnNldCgnc2NhbGVYJywgc2NhbGVYKTtcbiAgICAgICFsb2NrU2NhbGluZ1kgJiYgdGFyZ2V0LnNldCgnc2NhbGVZJywgc2NhbGVZKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBmb3JiaWRkZW4gY2FzZXMgYWxyZWFkeSBoYW5kbGVkIG9uIHRvcCBoZXJlLlxuICAgICAgYnkgPT09ICd4JyAmJiB0YXJnZXQuc2V0KCdzY2FsZVgnLCBzY2FsZVgpO1xuICAgICAgYnkgPT09ICd5JyAmJiB0YXJnZXQuc2V0KCdzY2FsZVknLCBzY2FsZVkpO1xuICAgIH1cbiAgICByZXR1cm4gb2xkU2NhbGVYICE9PSB0YXJnZXQuc2NhbGVYIHx8IG9sZFNjYWxlWSAhPT0gdGFyZ2V0LnNjYWxlWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmljIHNjYWxpbmcgbG9naWMsIHRvIHNjYWxlIGZyb20gY29ybmVycyBlaXRoZXIgZXF1YWxseSBvciBmcmVlbHkuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3RGcm9tQ29ybmVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsaW5nIGxvZ2ljIGZvciB0aGUgWCBheGlzLlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT2JqZWN0WChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHJldHVybiBzY2FsZU9iamVjdChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSAsIHsgYnk6ICd4JyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsaW5nIGxvZ2ljIGZvciB0aGUgWSBheGlzLlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT2JqZWN0WShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHJldHVybiBzY2FsZU9iamVjdChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSAsIHsgYnk6ICd5JyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wb3NlZCBhY3Rpb24gaGFuZGxlciB0byBlaXRoZXIgc2NhbGUgWSBvciBza2V3IFhcbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsaW5nWU9yU2tld2luZ1goZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAvLyBvayBzb21lIHNhZmV0eSBuZWVkZWQgaGVyZS5cbiAgICBpZiAoZXZlbnREYXRhW3RyYW5zZm9ybS50YXJnZXQuY2FudmFzLmFsdEFjdGlvbktleV0pIHtcbiAgICAgIHJldHVybiBjb250cm9scy5za2V3SGFuZGxlclgoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbHMuc2NhbGluZ1koZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBvc2VkIGFjdGlvbiBoYW5kbGVyIHRvIGVpdGhlciBzY2FsZSBYIG9yIHNrZXcgWVxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxpbmdYT3JTa2V3aW5nWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIC8vIG9rIHNvbWUgc2FmZXR5IG5lZWRlZCBoZXJlLlxuICAgIGlmIChldmVudERhdGFbdHJhbnNmb3JtLnRhcmdldC5jYW52YXMuYWx0QWN0aW9uS2V5XSkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xzLnNrZXdIYW5kbGVyWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9scy5zY2FsaW5nWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIgdG8gY2hhbmdlIHRleHRib3ggd2lkdGhcbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBjaGFuZ2VXaWR0aChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LCBsb2NhbFBvaW50ID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSwgeCwgeSksXG4gICAgICAgIHN0cm9rZVBhZGRpbmcgPSB0YXJnZXQuc3Ryb2tlV2lkdGggLyAodGFyZ2V0LnN0cm9rZVVuaWZvcm0gPyB0YXJnZXQuc2NhbGVYIDogMSksXG4gICAgICAgIG11bHRpcGxpZXIgPSBpc1RyYW5zZm9ybUNlbnRlcmVkKHRyYW5zZm9ybSkgPyAyIDogMSxcbiAgICAgICAgb2xkV2lkdGggPSB0YXJnZXQud2lkdGgsXG4gICAgICAgIG5ld1dpZHRoID0gTWF0aC5hYnMobG9jYWxQb2ludC54ICogbXVsdGlwbGllciAvIHRhcmdldC5zY2FsZVgpIC0gc3Ryb2tlUGFkZGluZztcbiAgICB0YXJnZXQuc2V0KCd3aWR0aCcsIE1hdGgubWF4KG5ld1dpZHRoLCAwKSk7XG4gICAgcmV0dXJuIG9sZFdpZHRoICE9PSBuZXdXaWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHRyYW5zbGF0aW9uIG9jY3VycmVkXG4gICAqL1xuICBmdW5jdGlvbiBkcmFnSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBuZXdMZWZ0ID0geCAtIHRyYW5zZm9ybS5vZmZzZXRYLFxuICAgICAgICBuZXdUb3AgPSB5IC0gdHJhbnNmb3JtLm9mZnNldFksXG4gICAgICAgIG1vdmVYID0gIXRhcmdldC5nZXQoJ2xvY2tNb3ZlbWVudFgnKSAmJiB0YXJnZXQubGVmdCAhPT0gbmV3TGVmdCxcbiAgICAgICAgbW92ZVkgPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WScpICYmIHRhcmdldC50b3AgIT09IG5ld1RvcDtcbiAgICBtb3ZlWCAmJiB0YXJnZXQuc2V0KCdsZWZ0JywgbmV3TGVmdCk7XG4gICAgbW92ZVkgJiYgdGFyZ2V0LnNldCgndG9wJywgbmV3VG9wKTtcbiAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgIGZpcmVFdmVudCgnbW92aW5nJywgY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlWCB8fCBtb3ZlWTtcbiAgfVxuXG4gIGNvbnRyb2xzLnNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyID0gc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLnNrZXdDdXJzb3JTdHlsZUhhbmRsZXIgPSBza2V3Q3Vyc29yU3R5bGVIYW5kbGVyO1xuICBjb250cm9scy5zY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIgPSBzY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLnJvdGF0aW9uV2l0aFNuYXBwaW5nID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3JvdGF0aW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvcihyb3RhdGlvbldpdGhTbmFwcGluZykpO1xuICBjb250cm9scy5zY2FsaW5nRXF1YWxseSA9IHdyYXBXaXRoRmlyZUV2ZW50KCdzY2FsaW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvciggc2NhbGVPYmplY3RGcm9tQ29ybmVyKSk7XG4gIGNvbnRyb2xzLnNjYWxpbmdYID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3NjYWxpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKHNjYWxlT2JqZWN0WCkpO1xuICBjb250cm9scy5zY2FsaW5nWSA9IHdyYXBXaXRoRmlyZUV2ZW50KCdzY2FsaW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvcihzY2FsZU9iamVjdFkpKTtcbiAgY29udHJvbHMuc2NhbGluZ1lPclNrZXdpbmdYID0gc2NhbGluZ1lPclNrZXdpbmdYO1xuICBjb250cm9scy5zY2FsaW5nWE9yU2tld2luZ1kgPSBzY2FsaW5nWE9yU2tld2luZ1k7XG4gIGNvbnRyb2xzLmNoYW5nZVdpZHRoID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3Jlc2l6aW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvcihjaGFuZ2VXaWR0aCkpO1xuICBjb250cm9scy5za2V3SGFuZGxlclggPSBza2V3SGFuZGxlclg7XG4gIGNvbnRyb2xzLnNrZXdIYW5kbGVyWSA9IHNrZXdIYW5kbGVyWTtcbiAgY29udHJvbHMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcbiAgY29udHJvbHMuc2NhbGVPclNrZXdBY3Rpb25OYW1lID0gc2NhbGVPclNrZXdBY3Rpb25OYW1lO1xuICBjb250cm9scy5yb3RhdGlvblN0eWxlSGFuZGxlciA9IHJvdGF0aW9uU3R5bGVIYW5kbGVyO1xuICBjb250cm9scy5maXJlRXZlbnQgPSBmaXJlRXZlbnQ7XG4gIGNvbnRyb2xzLndyYXBXaXRoRml4ZWRBbmNob3IgPSB3cmFwV2l0aEZpeGVkQW5jaG9yO1xuICBjb250cm9scy53cmFwV2l0aEZpcmVFdmVudCA9IHdyYXBXaXRoRmlyZUV2ZW50O1xuICBjb250cm9scy5nZXRMb2NhbFBvaW50ID0gZ2V0TG9jYWxQb2ludDtcbiAgZmFicmljLmNvbnRyb2xzVXRpbHMgPSBjb250cm9scztcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBjb250cm9scyA9IGZhYnJpYy5jb250cm9sc1V0aWxzO1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSByb3VuZCBjb250cm9sLCBhcyBwZXIgZmFicmljIGZlYXR1cmVzLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gdG8gcmVzcGVjdCBvYmplY3QgcHJvcGVydGllcyBsaWtlIHRyYW5zcGFyZW50Q29ybmVycywgY29ybmVyU2l6ZVxuICAgKiBjb3JuZXJDb2xvciwgY29ybmVyU3Ryb2tlQ29sb3JcbiAgICogcGx1cyB0aGUgYWRkaXRpb24gb2Ygb2Zmc2V0WSBhbmQgb2Zmc2V0WC5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCB4IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIHkgY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG92ZXJyaWRlIGZvciBmYWJyaWMuT2JqZWN0IGNvbnRyb2xzIHN0eWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGZvciB3aGljaCB3ZSBhcmUgcmVuZGVyaW5nIGNvbnRyb2xzXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJDaXJjbGVDb250cm9sIChjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KSB7XG4gICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgdmFyIHhTaXplID0gdGhpcy5zaXplWCB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHlTaXplID0gdGhpcy5zaXplWSB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHRyYW5zcGFyZW50Q29ybmVycyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzIDogZmFicmljT2JqZWN0LnRyYW5zcGFyZW50Q29ybmVycyxcbiAgICAgICAgbWV0aG9kTmFtZSA9IHRyYW5zcGFyZW50Q29ybmVycyA/ICdzdHJva2UnIDogJ2ZpbGwnLFxuICAgICAgICBzdHJva2UgPSAhdHJhbnNwYXJlbnRDb3JuZXJzICYmIChzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHJva2VDb2xvciksXG4gICAgICAgIG15TGVmdCA9IGxlZnQsXG4gICAgICAgIG15VG9wID0gdG9wLCBzaXplO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lckNvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lclN0cm9rZUNvbG9yO1xuICAgIC8vIGFzIHNvb24gYXMgZmFicmljIHJlYWN0IHY1LCByZW1vdmUgaWUxMSwgdXNlIHByb3BlciBlbGxpcHNlIGNvZGUuXG4gICAgaWYgKHhTaXplID4geVNpemUpIHtcbiAgICAgIHNpemUgPSB4U2l6ZTtcbiAgICAgIGN0eC5zY2FsZSgxLjAsIHlTaXplIC8geFNpemUpO1xuICAgICAgbXlUb3AgPSB0b3AgKiB4U2l6ZSAvIHlTaXplO1xuICAgIH1cbiAgICBlbHNlIGlmICh5U2l6ZSA+IHhTaXplKSB7XG4gICAgICBzaXplID0geVNpemU7XG4gICAgICBjdHguc2NhbGUoeFNpemUgLyB5U2l6ZSwgMS4wKTtcbiAgICAgIG15TGVmdCA9IGxlZnQgKiB5U2l6ZSAvIHhTaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNpemUgPSB4U2l6ZTtcbiAgICB9XG4gICAgLy8gdGhpcyBpcyBzdGlsbCB3cm9uZ1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKG15TGVmdCwgbXlUb3AsIHNpemUgLyAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgIGN0eFttZXRob2ROYW1lXSgpO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBzcXVhcmUgY29udHJvbCwgYXMgcGVyIGZhYnJpYyBmZWF0dXJlcy5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyB3cml0dGVuIHRvIHJlc3BlY3Qgb2JqZWN0IHByb3BlcnRpZXMgbGlrZSB0cmFuc3BhcmVudENvcm5lcnMsIGNvcm5lclNpemVcbiAgICogY29ybmVyQ29sb3IsIGNvcm5lclN0cm9rZUNvbG9yXG4gICAqIHBsdXMgdGhlIGFkZGl0aW9uIG9mIG9mZnNldFkgYW5kIG9mZnNldFguXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgeCBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCB5IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvdmVycmlkZSBmb3IgZmFicmljLk9iamVjdCBjb250cm9scyBzdHlsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCBmb3Igd2hpY2ggd2UgYXJlIHJlbmRlcmluZyBjb250cm9sc1xuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyU3F1YXJlQ29udHJvbChjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KSB7XG4gICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgdmFyIHhTaXplID0gdGhpcy5zaXplWCB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHlTaXplID0gdGhpcy5zaXplWSB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHRyYW5zcGFyZW50Q29ybmVycyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzIDogZmFicmljT2JqZWN0LnRyYW5zcGFyZW50Q29ybmVycyxcbiAgICAgICAgbWV0aG9kTmFtZSA9IHRyYW5zcGFyZW50Q29ybmVycyA/ICdzdHJva2UnIDogJ2ZpbGwnLFxuICAgICAgICBzdHJva2UgPSAhdHJhbnNwYXJlbnRDb3JuZXJzICYmIChcbiAgICAgICAgICBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHJva2VDb2xvclxuICAgICAgICApLCB4U2l6ZUJ5MiA9IHhTaXplIC8gMiwgeVNpemVCeTIgPSB5U2l6ZSAvIDI7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgLy8gdGhpcyBpcyBzdGlsbCB3cm9uZ1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC50cmFuc2xhdGUobGVmdCwgdG9wKTtcbiAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnMoZmFicmljT2JqZWN0LmFuZ2xlKSk7XG4gICAgLy8gdGhpcyBkb2VzIG5vdCB3b3JrLCBhbmQgZml4ZWQgd2l0aCAoICYmICkgZG9lcyBub3QgbWFrZSBzZW5zZS5cbiAgICAvLyB0byBoYXZlIHJlYWwgdHJhbnNwYXJlbnQgY29ybmVycyB3ZSBuZWVkIHRoZSBjb250cm9scyBvbiB1cHBlckNhbnZhc1xuICAgIC8vIHRyYW5zcGFyZW50Q29ybmVycyB8fCBjdHguY2xlYXJSZWN0KC14U2l6ZUJ5MiwgLXlTaXplQnkyLCB4U2l6ZSwgeVNpemUpO1xuICAgIGN0eFttZXRob2ROYW1lICsgJ1JlY3QnXSgteFNpemVCeTIsIC15U2l6ZUJ5MiwgeFNpemUsIHlTaXplKTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBjdHguc3Ryb2tlUmVjdCgteFNpemVCeTIsIC15U2l6ZUJ5MiwgeFNpemUsIHlTaXplKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGNvbnRyb2xzLnJlbmRlckNpcmNsZUNvbnRyb2wgPSByZW5kZXJDaXJjbGVDb250cm9sO1xuICBjb250cm9scy5yZW5kZXJTcXVhcmVDb250cm9sID0gcmVuZGVyU3F1YXJlQ29udHJvbDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGZ1bmN0aW9uIENvbnRyb2wob3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgdGhpc1tpXSA9IG9wdGlvbnNbaV07XG4gICAgfVxuICB9XG5cbiAgZmFicmljLkNvbnRyb2wgPSBDb250cm9sO1xuXG4gIGZhYnJpYy5Db250cm9sLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNvbnRyb2wucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIGtlZXAgdHJhY2sgb2YgY29udHJvbCB2aXNpYmlsaXR5LlxuICAgICAqIG1haW5seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKiBpZiB5b3UgZG8gbm90IHdhbnQgdG8gc2VlIGEgY29udHJvbCwgeW91IGNhbiByZW1vdmUgaXRcbiAgICAgKiBmcm9tIHRoZSBjb250cm9sc2V0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB2aXNpYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgYWN0aW9uIHRoYXQgdGhlIGNvbnRyb2wgd2lsbCBsaWtlbHkgZXhlY3V0ZS5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsLiBGYWJyaWNKUyB1c2VzIHRvIGlkZW50aWZ5IHdoYXQgdGhlIHVzZXIgaXMgZG9pbmcgZm9yIHNvbWVcbiAgICAgKiBleHRyYSBvcHRpbWl6YXRpb25zLiBJZiB5b3UgYXJlIHdyaXRpbmcgYSBjdXN0b20gY29udHJvbCBhbmQgeW91IHdhbnQgdG8ga25vd1xuICAgICAqIHNvbWV3aGVyZSBlbHNlIGluIHRoZSBjb2RlIHdoYXQgaXMgZ29pbmcgb24sIHlvdSBjYW4gdXNlIHRoaXMgc3RyaW5nIGhlcmUuXG4gICAgICogeW91IGNhbiBhbHNvIHByb3ZpZGUgYSBjdXN0b20gZ2V0QWN0aW9uTmFtZSBpZiB5b3VyIGNvbnRyb2wgcnVuIG11bHRpcGxlIGFjdGlvbnNcbiAgICAgKiBkZXBlbmRpbmcgb24gc29tZSBleHRlcm5hbCBzdGF0ZS5cbiAgICAgKiBkZWZhdWx0IHRvIHNjYWxlIHNpbmNlIGlzIHRoZSBtb3N0IGNvbW1vbiwgdXNlZCBvbiA0IGNvcm5lcnMgYnkgZGVmYXVsdFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3NjYWxlJ1xuICAgICAqL1xuICAgIGFjdGlvbk5hbWU6ICdzY2FsZScsXG5cbiAgICAvKipcbiAgICAgKiBEcmF3aW5nIGFuZ2xlIG9mIHRoZSBjb250cm9sLlxuICAgICAqIE5PVCB1c2VkIGZvciBub3csIGJ1dCBuYW1lIG1hcmtlZCBhcyBuZWVkZWQgZm9yIGludGVybmFsIGxvZ2ljXG4gICAgICogZXhhbXBsZTogdG8gcmV1c2UgdGhlIHNhbWUgZHJhd2luZyBmdW5jdGlvbiBmb3IgZGlmZmVyZW50IHJvdGF0ZWQgY29udHJvbHNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBhbmdsZTogMCxcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLiBYXG4gICAgICogMCwwIGlzIHRoZSBjZW50ZXIgb2YgdGhlIE9iamVjdCwgd2hpbGUgLTAuNSAobGVmdCkgb3IgMC41IChyaWdodCkgYXJlIHRoZSBleHRyZW1pdGllc1xuICAgICAqIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgeDogMCxcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLiBZXG4gICAgICogMCwwIGlzIHRoZSBjZW50ZXIgb2YgdGhlIE9iamVjdCwgd2hpbGUgLTAuNSAodG9wKSBvciAwLjUgKGJvdHRvbSkgYXJlIHRoZSBleHRyZW1pdGllc1xuICAgICAqIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgeTogMCxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb2Zmc2V0IG9mIHRoZSBjb250cm9sIGZyb20gdGhlIGRlZmluZWQgcG9zaXRpb24uIEluIHBpeGVsc1xuICAgICAqIFBvc2l0aXZlIG9mZnNldCBtb3ZlcyB0aGUgY29udHJvbCB0byB0aGUgcmlnaHQsIG5lZ2F0aXZlIHRvIHRoZSBsZWZ0LlxuICAgICAqIEl0IHVzZWQgd2hlbiB5b3Ugd2FudCB0byBoYXZlIHBvc2l0aW9uIG9mIGNvbnRyb2wgdGhhdCBkb2VzIG5vdCBzY2FsZSB3aXRoXG4gICAgICogdGhlIGJvdW5kaW5nIGJveC4gRXhhbXBsZTogcm90YXRpb24gY29udHJvbCBpcyBwbGFjZWQgYXQgeDowLCB5OiAwLjUgb25cbiAgICAgKiB0aGUgYm91bmRpbmRib3gsIHdpdGggYW4gb2Zmc2V0IG9mIDMwIHBpeGVscyB2ZXJ0aWNhbGx5LiBUaG9zZSAzMCBwaXhlbHMgd2lsbFxuICAgICAqIHN0YXkgMzAgcGl4ZWxzIG5vIG1hdHRlciBob3cgdGhlIG9iamVjdCBpcyBiaWcuIEFub3RoZXIgZXhhbXBsZSBpcyBoYXZpbmcgMlxuICAgICAqIGNvbnRyb2xzIGluIHRoZSBjb3JuZXIsIHRoYXQgc3RheSBpbiB0aGUgc2FtZSBwb3NpdGlvbiB3aGVuIHRoZSBvYmplY3Qgc2NhbGUuXG4gICAgICogb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgb2Zmc2V0IG9mIHRoZSBjb250cm9sIGZyb20gdGhlIGRlZmluZWQgcG9zaXRpb24uIEluIHBpeGVsc1xuICAgICAqIFBvc2l0aXZlIG9mZnNldCBtb3ZlcyB0aGUgY29udHJvbCB0byB0aGUgYm90dG9tLCBuZWdhdGl2ZSB0byB0aGUgdG9wLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsZW5ndGggb2YgdGhlIGNvbnRyb2wuIElmIG51bGwsIGRlZmF1bHRzIHRvIG9iamVjdCdzIGNvcm5lclNpemUuXG4gICAgICogRXhwZWN0cyBib3RoIHNpemVYIGFuZCBzaXplWSB0byBiZSBzZXQgd2hlbiBzZXQuXG4gICAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHNpemVYOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBjb250cm9sLiBJZiBudWxsLCBkZWZhdWx0cyB0byBvYmplY3QncyBjb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCBzaXplWCBhbmQgc2l6ZVkgdG8gYmUgc2V0IHdoZW4gc2V0LlxuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBzaXplWTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxlbmd0aCBvZiB0aGUgdG91Y2ggYXJlYSBvZiB0aGUgY29udHJvbC4gSWYgbnVsbCwgZGVmYXVsdHMgdG8gb2JqZWN0J3MgdG91Y2hDb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCB0b3VjaFNpemVYIGFuZCB0b3VjaFNpemVZIHRvIGJlIHNldCB3aGVuIHNldC5cbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdG91Y2hTaXplWDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgdG91Y2ggYXJlYSBvZiB0aGUgY29udHJvbC4gSWYgbnVsbCwgZGVmYXVsdHMgdG8gb2JqZWN0J3MgdG91Y2hDb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCB0b3VjaFNpemVYIGFuZCB0b3VjaFNpemVZIHRvIGJlIHNldCB3aGVuIHNldC5cbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdG91Y2hTaXplWTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENzcyBjdXJzb3Igc3R5bGUgdG8gZGlzcGxheSB3aGVuIHRoZSBjb250cm9sIGlzIGhvdmVyZWQuXG4gICAgICogaWYgdGhlIG1ldGhvZCBgY3Vyc29yU3R5bGVIYW5kbGVyYCBpcyBwcm92aWRlZCwgdGhpcyBwcm9wZXJ0eSBpcyBpZ25vcmVkLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ2Nyb3NzaGFpcidcbiAgICAgKi9cbiAgICBjdXJzb3JTdHlsZTogJ2Nyb3NzaGFpcicsXG5cbiAgICAvKipcbiAgICAgKiBJZiBjb250cm9scyBoYXMgYW4gb2Zmc2V0WSBvciBvZmZzZXRYLCBkcmF3IGEgbGluZSB0aGF0IGNvbm5lY3RzXG4gICAgICogdGhlIGNvbnRyb2wgdG8gdGhlIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgd2l0aENvbm5lY3Rpb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgYWN0aW9uSGFuZGxlciwgcHJvdmlkZSBvbmUgdG8gaGFuZGxlIGFjdGlvbiAoIGNvbnRyb2wgYmVpbmcgbW92ZWQgKVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybURhdGEgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhY3Rpb24vZXZlbnQgbW9kaWZpZWQgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgdHJhbnNmb3JtRGF0YSwgeCwgeSAqLykgeyB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgaGFuZGxlciBmb3IgbW91c2UgZG93biwgcHJvdmlkZSBvbmUgdG8gaGFuZGxlIG1vdXNlIGRvd24gb24gY29udHJvbFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybURhdGEgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhY3Rpb24vZXZlbnQgbW9kaWZpZWQgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIG1vdXNlRG93bkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgdHJhbnNmb3JtRGF0YSwgeCwgeSAqLykgeyB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgbW91c2VVcEhhbmRsZXIsIHByb3ZpZGUgb25lIHRvIGhhbmRsZSBhbiBlZmZlY3Qgb24gbW91c2UgdXAuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtRGF0YSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFjdGlvbi9ldmVudCBtb2RpZmllZCB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgbW91c2VVcEhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgdHJhbnNmb3JtRGF0YSwgeCwgeSAqLykgeyB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9sIGFjdGlvbkhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgY29udHJvbCBmb3Igd2hpY2ggdGhlIGFjdGlvbiBoYW5kbGVyIGlzIGJlaW5nIGFza2VkXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBhY3Rpb24gaGFuZGxlclxuICAgICAqL1xuICAgIGdldEFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgZmFicmljT2JqZWN0LCBjb250cm9sICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3Rpb25IYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgbW91c2VEb3duIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgY29udHJvbCBmb3Igd2hpY2ggdGhlIGFjdGlvbiBoYW5kbGVyIGlzIGJlaW5nIGFza2VkXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBhY3Rpb24gaGFuZGxlclxuICAgICAqL1xuICAgIGdldE1vdXNlRG93bkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgZmFicmljT2JqZWN0LCBjb250cm9sICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZURvd25IYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgbW91c2VVcCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIGNvbnRyb2wgZm9yIHdoaWNoIHRoZSBhY3Rpb24gaGFuZGxlciBpcyBiZWluZyBhc2tlZFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgYWN0aW9uIGhhbmRsZXJcbiAgICAgKi9cbiAgICBnZXRNb3VzZVVwSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCBmYWJyaWNPYmplY3QsIGNvbnRyb2wgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlVXBIYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgY3Vyc29yU3R5bGUgZm9yIGNzcyB1c2luZyBjdXJzb3JTdHlsZS4gSWYgeW91IG5lZWQgYSBtb3JlIGVsYWJvcmF0ZVxuICAgICAqIGZ1bmN0aW9uIHlvdSBjYW4gcGFzcyBvbmUgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogdGhlIGN1cnNvclN0eWxlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjdXJyZW50IGNvbnRyb2wgKCBsaWtlbHkgdGhpcylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBmdW5jdGlvbihldmVudERhdGEsIGNvbnRyb2wgLyogZmFicmljT2JqZWN0ICovKSB7XG4gICAgICByZXR1cm4gY29udHJvbC5jdXJzb3JTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0aW9uIG5hbWUuIFRoZSBiYXNpYyBpbXBsZW1lbnRhdGlvbiBqdXN0IHJldHVybiB0aGUgYWN0aW9uTmFtZSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGN1cnJlbnQgY29udHJvbCAoIGxpa2VseSB0aGlzKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBY3Rpb25OYW1lOiBmdW5jdGlvbihldmVudERhdGEsIGNvbnRyb2wgLyogZmFicmljT2JqZWN0ICovKSB7XG4gICAgICByZXR1cm4gY29udHJvbC5hY3Rpb25OYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2xzIHZpc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbEtleSBrZXkgd2hlcmUgdGhlIGNvbnRyb2wgaXMgbWVtb3JpemVkIG9uIHRoZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0VmlzaWJpbGl0eTogZnVuY3Rpb24oZmFicmljT2JqZWN0LCBjb250cm9sS2V5KSB7XG4gICAgICB2YXIgb2JqZWN0VmlzaWJpbGl0eSA9IGZhYnJpY09iamVjdC5fY29udHJvbHNWaXNpYmlsaXR5O1xuICAgICAgaWYgKG9iamVjdFZpc2liaWxpdHkgJiYgdHlwZW9mIG9iamVjdFZpc2liaWxpdHlbY29udHJvbEtleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RWaXNpYmlsaXR5W2NvbnRyb2xLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb250cm9scyB2aXNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmlsaXR5IGZvciB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBzZXRWaXNpYmlsaXR5OiBmdW5jdGlvbih2aXNpYmlsaXR5IC8qIG5hbWUsIGZhYnJpY09iamVjdCAqLykge1xuICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJpbGl0eTtcbiAgICB9LFxuXG5cbiAgICBwb3NpdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKGRpbSwgZmluYWxNYXRyaXggLyosIGZhYnJpY09iamVjdCwgY3VycmVudENvbnRyb2wgKi8pIHtcbiAgICAgIHZhciBwb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHtcbiAgICAgICAgeDogdGhpcy54ICogZGltLnggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IHRoaXMueSAqIGRpbS55ICsgdGhpcy5vZmZzZXRZIH0sIGZpbmFsTWF0cml4KTtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRzIGZvciB0aGlzIGNvbnRyb2wgYmFzZWQgb24gb2JqZWN0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2JqZWN0QW5nbGUgYW5nbGUgZnJvbSB0aGUgZmFicmljIG9iamVjdCBob2xkaW5nIHRoZSBjb250cm9sXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9iamVjdENvcm5lclNpemUgY29ybmVyU2l6ZSBmcm9tIHRoZSBmYWJyaWMgb2JqZWN0IGhvbGRpbmcgdGhlIGNvbnRyb2wgKG9yIHRvdWNoQ29ybmVyU2l6ZSBpZlxuICAgICAqICAgaXNUb3VjaCBpcyB0cnVlKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjZW50ZXJYIHggY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRlclkgeSBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVG91Y2ggdHJ1ZSBpZiB0b3VjaCBjb3JuZXIsIGZhbHNlIGlmIG5vcm1hbCBjb3JuZXJcbiAgICAgKi9cbiAgICBjYWxjQ29ybmVyQ29vcmRzOiBmdW5jdGlvbihvYmplY3RBbmdsZSwgb2JqZWN0Q29ybmVyU2l6ZSwgY2VudGVyWCwgY2VudGVyWSwgaXNUb3VjaCkge1xuICAgICAgdmFyIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgc2luSGFsZk9mZnNldCxcbiAgICAgICAgICBjb3NIYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICBzaW5IYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICB4U2l6ZSA9IChpc1RvdWNoKSA/IHRoaXMudG91Y2hTaXplWCA6IHRoaXMuc2l6ZVgsXG4gICAgICAgICAgeVNpemUgPSAoaXNUb3VjaCkgPyB0aGlzLnRvdWNoU2l6ZVkgOiB0aGlzLnNpemVZO1xuICAgICAgaWYgKHhTaXplICYmIHlTaXplICYmIHhTaXplICE9PSB5U2l6ZSkge1xuICAgICAgICAvLyBoYW5kbGUgcmVjdGFuZ3VsYXIgY29ybmVyc1xuICAgICAgICB2YXIgY29udHJvbFRyaWFuZ2xlQW5nbGUgPSBNYXRoLmF0YW4yKHlTaXplLCB4U2l6ZSk7XG4gICAgICAgIHZhciBjb3JuZXJIeXBvdGVudXNlID0gTWF0aC5zcXJ0KHhTaXplICogeFNpemUgKyB5U2l6ZSAqIHlTaXplKSAvIDI7XG4gICAgICAgIHZhciBuZXdUaGV0YSA9IGNvbnRyb2xUcmlhbmdsZUFuZ2xlIC0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhvYmplY3RBbmdsZSk7XG4gICAgICAgIHZhciBuZXdUaGV0YUNvbXAgPSBNYXRoLlBJIC8gMiAtIGNvbnRyb2xUcmlhbmdsZUFuZ2xlIC0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhvYmplY3RBbmdsZSk7XG4gICAgICAgIGNvc0hhbGZPZmZzZXQgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuY29zKG5ld1RoZXRhKTtcbiAgICAgICAgc2luSGFsZk9mZnNldCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5zaW4obmV3VGhldGEpO1xuICAgICAgICAvLyB1c2UgY29tcGxlbWVudGFyeSBhbmdsZSBmb3IgdHdvIGNvcm5lcnNcbiAgICAgICAgY29zSGFsZk9mZnNldENvbXAgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuY29zKG5ld1RoZXRhQ29tcCk7XG4gICAgICAgIHNpbkhhbGZPZmZzZXRDb21wID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLnNpbihuZXdUaGV0YUNvbXApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBzcXVhcmUgY29ybmVyc1xuICAgICAgICAvLyB1c2UgZGVmYXVsdCBvYmplY3QgY29ybmVyIHNpemUgdW5sZXNzIHNpemUgaXMgZGVmaW5lZFxuICAgICAgICB2YXIgY29ybmVyU2l6ZSA9ICh4U2l6ZSAmJiB5U2l6ZSkgPyB4U2l6ZSA6IG9iamVjdENvcm5lclNpemU7XG4gICAgICAgIC8qIDAuNzA3MTA2NzgxMiBzdGFuZHMgZm9yIHNxcnQoMikvMiAqL1xuICAgICAgICBjb3JuZXJIeXBvdGVudXNlID0gY29ybmVyU2l6ZSAqIDAuNzA3MTA2NzgxMjtcbiAgICAgICAgLy8gY29tcGxlbWVudGFyeSBhbmdsZXMgYXJlIGVxdWFsIHNpbmNlIHRoZXkncmUgYm90aCA0NSBkZWdyZWVzXG4gICAgICAgIHZhciBuZXdUaGV0YSA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoNDUgLSBvYmplY3RBbmdsZSk7XG4gICAgICAgIGNvc0hhbGZPZmZzZXQgPSBjb3NIYWxmT2Zmc2V0Q29tcCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5jb3MobmV3VGhldGEpO1xuICAgICAgICBzaW5IYWxmT2Zmc2V0ID0gc2luSGFsZk9mZnNldENvbXAgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuc2luKG5ld1RoZXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGw6IHtcbiAgICAgICAgICB4OiBjZW50ZXJYIC0gc2luSGFsZk9mZnNldENvbXAsXG4gICAgICAgICAgeTogY2VudGVyWSAtIGNvc0hhbGZPZmZzZXRDb21wLFxuICAgICAgICB9LFxuICAgICAgICB0cjoge1xuICAgICAgICAgIHg6IGNlbnRlclggKyBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgIHk6IGNlbnRlclkgLSBzaW5IYWxmT2Zmc2V0LFxuICAgICAgICB9LFxuICAgICAgICBibDoge1xuICAgICAgICAgIHg6IGNlbnRlclggLSBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgIHk6IGNlbnRlclkgKyBzaW5IYWxmT2Zmc2V0LFxuICAgICAgICB9LFxuICAgICAgICBicjoge1xuICAgICAgICAgIHg6IGNlbnRlclggKyBzaW5IYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICB5OiBjZW50ZXJZICsgY29zSGFsZk9mZnNldENvbXAsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJlbmRlciBmdW5jdGlvbiBmb3IgdGhlIGNvbnRyb2wuXG4gICAgKiBXaGVuIHRoaXMgZnVuY3Rpb24gcnVucyB0aGUgY29udGV4dCBpcyB1bnNjYWxlZC4gdW5yb3RhdGUuIEp1c3QgcmV0aW5hIHNjYWxlZC5cbiAgICAqIGFsbCB0aGUgZnVuY3Rpb25zIHdpbGwgaGF2ZSB0byB0cmFuc2xhdGUgdG8gdGhlIHBvaW50IGxlZnQsdG9wIGJlZm9yZSBzdGFydGluZyBEcmF3aW5nXG4gICAgKiBpZiB0aGV5IHdhbnQgdG8gZHJhdyBhIGNvbnRyb2wgd2hlcmUgdGhlIHBvc2l0aW9uIGlzIGRldGVjdGVkLlxuICAgICogbGVmdCBhbmQgdG9wIGFyZSB0aGUgcmVzdWx0IG9mIHRoZSBwb3NpdGlvbkhhbmRsZXIgZnVuY3Rpb25cbiAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdGhlIGNvbnRleHQgd2hlcmUgdGhlIGNvbnRyb2wgd2lsbCBiZSBkcmF3blxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgcG9zaXRpb24gb2YgdGhlIGNhbnZhcyB3aGVyZSB3ZSBhcmUgYWJvdXQgdG8gcmVuZGVyIHRoZSBjb250cm9sLlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBwb3NpdGlvbiBvZiB0aGUgY2FudmFzIHdoZXJlIHdlIGFyZSBhYm91dCB0byByZW5kZXIgdGhlIGNvbnRyb2wuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZVxuICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIG9iamVjdCB3aGVyZSB0aGUgY29udHJvbCBpcyBhYm91dCB0byBiZSByZW5kZXJlZFxuICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHN3aXRjaCAoc3R5bGVPdmVycmlkZS5jb3JuZXJTdHlsZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICBmYWJyaWMuY29udHJvbHNVdGlscy5yZW5kZXJDaXJjbGVDb250cm9sLmNhbGwodGhpcywgY3R4LCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZmFicmljLmNvbnRyb2xzVXRpbHMucmVuZGVyU3F1YXJlQ29udHJvbC5jYWxsKHRoaXMsIGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICBmdW5jdGlvbiBnZXRDb2xvclN0b3AoZWwsIG11bHRpcGxpZXIpIHtcbiAgICB2YXIgc3R5bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyksXG4gICAgICAgIG9mZnNldCA9IGVsLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykgfHwgMCxcbiAgICAgICAgY29sb3IsIGNvbG9yQWxwaGEsIG9wYWNpdHksIGk7XG5cbiAgICAvLyBjb252ZXJ0IHBlcmNlbnRzIHRvIGFic29sdXRlIHZhbHVlc1xuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQob2Zmc2V0KSAvICgvJSQvLnRlc3Qob2Zmc2V0KSA/IDEwMCA6IDEpO1xuICAgIG9mZnNldCA9IG9mZnNldCA8IDAgPyAwIDogb2Zmc2V0ID4gMSA/IDEgOiBvZmZzZXQ7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICB2YXIga2V5VmFsdWVQYWlycyA9IHN0eWxlLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgICAgaWYgKGtleVZhbHVlUGFpcnNba2V5VmFsdWVQYWlycy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAga2V5VmFsdWVQYWlycy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0ga2V5VmFsdWVQYWlycy5sZW5ndGg7IGktLTsgKSB7XG5cbiAgICAgICAgdmFyIHNwbGl0ID0ga2V5VmFsdWVQYWlyc1tpXS5zcGxpdCgvXFxzKjpcXHMqLyksXG4gICAgICAgICAgICBrZXkgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgICAgICB2YWx1ZSA9IHNwbGl0WzFdLnRyaW0oKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnc3RvcC1jb2xvcicpIHtcbiAgICAgICAgICBjb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0b3Atb3BhY2l0eScpIHtcbiAgICAgICAgICBvcGFjaXR5ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICBjb2xvciA9IGVsLmdldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicpIHx8ICdyZ2IoMCwwLDApJztcbiAgICB9XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICBvcGFjaXR5ID0gZWwuZ2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknKTtcbiAgICB9XG5cbiAgICBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpO1xuICAgIGNvbG9yQWxwaGEgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgIG9wYWNpdHkgPSBpc05hTihwYXJzZUZsb2F0KG9wYWNpdHkpKSA/IDEgOiBwYXJzZUZsb2F0KG9wYWNpdHkpO1xuICAgIG9wYWNpdHkgKj0gY29sb3JBbHBoYSAqIG11bHRpcGxpZXI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjb2xvcjogY29sb3IudG9SZ2IoKSxcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZWFyQ29vcmRzKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBlbC5nZXRBdHRyaWJ1dGUoJ3gxJykgfHwgMCxcbiAgICAgIHkxOiBlbC5nZXRBdHRyaWJ1dGUoJ3kxJykgfHwgMCxcbiAgICAgIHgyOiBlbC5nZXRBdHRyaWJ1dGUoJ3gyJykgfHwgJzEwMCUnLFxuICAgICAgeTI6IGVsLmdldEF0dHJpYnV0ZSgneTInKSB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhZGlhbENvb3JkcyhlbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogZWwuZ2V0QXR0cmlidXRlKCdmeCcpIHx8IGVsLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnNTAlJyxcbiAgICAgIHkxOiBlbC5nZXRBdHRyaWJ1dGUoJ2Z5JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc1MCUnLFxuICAgICAgcjE6IDAsXG4gICAgICB4MjogZWwuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc1MCUnLFxuICAgICAgeTI6IGVsLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnNTAlJyxcbiAgICAgIHIyOiBlbC5nZXRBdHRyaWJ1dGUoJ3InKSB8fCAnNTAlJ1xuICAgIH07XG4gIH1cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICB2YXIgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgLyoqXG4gICAqIEdyYWRpZW50IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuR3JhZGllbnRcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjZ3JhZGllbnRzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuR3JhZGllbnQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5HcmFkaWVudCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkdyYWRpZW50LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIG9mZnNldCBmb3IgYWxpZ25pbmcgZ3JhZGllbnRzIGNvbWluZyBmcm9tIFNWRyB3aGVuIG91dHNpZGUgcGF0aGdyb3Vwc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgb2Zmc2V0IGZvciBhbGlnbmluZyBncmFkaWVudHMgY29taW5nIGZyb20gU1ZHIHdoZW4gb3V0c2lkZSBwYXRoZ3JvdXBzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYW5zZm9ybSBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGdyYWRpZW50IGJlZm9yZSBwYWludGluZy5cbiAgICAgKiBJbXBvcnRlZCBmcm9tIHN2ZyBncmFkaWVudHMsIGlzIG5vdCBhcHBsaWVkIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNmb3JtIGluIHRoZSBjZW50ZXIuXG4gICAgICogQmVmb3JlIHRoaXMgdHJhbnNmb3JtIGlzIGFwcGxpZWQsIHRoZSBvcmlnaW4gcG9pbnQgaXMgYXQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgb2JqZWN0XG4gICAgICogcGx1cyB0aGUgYWRkaXRpb24gb2Ygb2Zmc2V0WSBhbmQgb2Zmc2V0WC5cbiAgICAgKiBAdHlwZSBOdW1iZXJbXVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBncmFkaWVudFRyYW5zZm9ybTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGNvb3JkaW5hdGVzIHVuaXRzIGZvciBjb29yZHMuXG4gICAgICogSWYgYHBpeGVsc2AsIHRoZSBudW1iZXIgb2YgY29vcmRzIGFyZSBpbiB0aGUgc2FtZSB1bml0IG9mIHdpZHRoIC8gaGVpZ2h0LlxuICAgICAqIElmIHNldCBhcyBgcGVyY2VudGFnZWAgdGhlIGNvb3JkcyBhcmUgc3RpbGwgYSBudW1iZXIsIGJ1dCAxIG1lYW5zIDEwMCUgb2Ygd2lkdGhcbiAgICAgKiBmb3IgdGhlIFggYW5kIDEwMCUgb2YgdGhlIGhlaWdodCBmb3IgdGhlIHkuIEl0IGNhbiBiZSBiaWdnZXIgdGhhbiAxIGFuZCBuZWdhdGl2ZS5cbiAgICAgKiBhbGxvd2VkIHZhbHVlcyBwaXhlbHMgb3IgcGVyY2VudGFnZS5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAncGl4ZWxzJ1xuICAgICAqL1xuICAgIGdyYWRpZW50VW5pdHM6ICdwaXhlbHMnLFxuXG4gICAgLyoqXG4gICAgICogR3JhZGllbnQgdHlwZSBsaW5lYXIgb3IgcmFkaWFsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHQgJ3BpeGVscydcbiAgICAgKi9cbiAgICB0eXBlOiAnbGluZWFyJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3Qgd2l0aCB0eXBlLCBjb29yZHMsIGdyYWRpZW50VW5pdHMgYW5kIGNvbG9yU3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHlwZV0gZ3JhZGllbnQgdHlwZSBsaW5lYXIgb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmdyYWRpZW50VW5pdHNdIGdyYWRpZW50IHVuaXRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm9mZnNldFhdIFNWRyBpbXBvcnQgY29tcGF0aWJpbGl0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5vZmZzZXRZXSBTVkcgaW1wb3J0IGNvbXBhdGliaWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvcHRpb25zLmNvbG9yU3RvcHMgY29udGFpbnMgdGhlIGNvbG9yc3RvcHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuY29vcmRzIGNvbnRhaW5zIHRoZSBjb29yZHMgb2YgdGhlIGdyYWRpZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy54MV0gWCBjb29yZGlhbnRlIG9mIHRoZSBmaXJzdCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBmb2NhbCBwb2ludCBmb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy55MV0gWSBjb29yZGlhbnRlIG9mIHRoZSBmaXJzdCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBmb2NhbCBwb2ludCBmb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy54Ml0gWCBjb29yZGlhbnRlIG9mIHRoZSBzZWNvbmQgcG9pbnQgZm9yIGxpbmVhciBvciBvZiB0aGUgY2VudGVyIHBvaW50IGZvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLnkyXSBZIGNvb3JkaWFudGUgb2YgdGhlIHNlY29uZCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMucjFdIG9ubHkgZm9yIHJhZGlhbCBncmFkaWVudCwgcmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLnIyXSBvbmx5IGZvciByYWRpYWwgZ3JhZGllbnQsIHJhZGl1cyBvZiB0aGUgZXh0ZXJuYWwgY2lyY2xlXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICBvcHRpb25zLmNvb3JkcyB8fCAob3B0aW9ucy5jb29yZHMgPSB7IH0pO1xuXG4gICAgICB2YXIgY29vcmRzLCBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIHNldHMgZXZlcnl0aGluZywgdGhlbiBjb29yZHMgYW5kIGNvbG9yc3RvcHMgZ2V0IHNldHMgYWdhaW5cbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgIF90aGlzW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgdGhpcy5pZCArPSAnXycgKyBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5pZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIH1cblxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4MTogb3B0aW9ucy5jb29yZHMueDEgfHwgMCxcbiAgICAgICAgeTE6IG9wdGlvbnMuY29vcmRzLnkxIHx8IDAsXG4gICAgICAgIHgyOiBvcHRpb25zLmNvb3Jkcy54MiB8fCAwLFxuICAgICAgICB5Mjogb3B0aW9ucy5jb29yZHMueTIgfHwgMFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgY29vcmRzLnIxID0gb3B0aW9ucy5jb29yZHMucjEgfHwgMDtcbiAgICAgICAgY29vcmRzLnIyID0gb3B0aW9ucy5jb29yZHMucjIgfHwgMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb29yZHMgPSBjb29yZHM7XG4gICAgICB0aGlzLmNvbG9yU3RvcHMgPSBvcHRpb25zLmNvbG9yU3RvcHMuc2xpY2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIGNvbG9yU3RvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvclN0b3AgT2JqZWN0IHdpdGggb2Zmc2V0IGFuZCBjb2xvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGFkZENvbG9yU3RvcDogZnVuY3Rpb24oY29sb3JTdG9wcykge1xuICAgICAgZm9yICh2YXIgcG9zaXRpb24gaW4gY29sb3JTdG9wcykge1xuICAgICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yU3RvcHNbcG9zaXRpb25dKTtcbiAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgICAgIG9mZnNldDogcGFyc2VGbG9hdChwb3NpdGlvbiksXG4gICAgICAgICAgY29sb3I6IGNvbG9yLnRvUmdiKCksXG4gICAgICAgICAgb3BhY2l0eTogY29sb3IuZ2V0QWxwaGEoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIGdyYWRpZW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9iamVjdCA9IHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBjb29yZHM6IHRoaXMuY29vcmRzLFxuICAgICAgICBjb2xvclN0b3BzOiB0aGlzLmNvbG9yU3RvcHMsXG4gICAgICAgIG9mZnNldFg6IHRoaXMub2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogdGhpcy5vZmZzZXRZLFxuICAgICAgICBncmFkaWVudFVuaXRzOiB0aGlzLmdyYWRpZW50VW5pdHMsXG4gICAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiB0aGlzLmdyYWRpZW50VHJhbnNmb3JtID8gdGhpcy5ncmFkaWVudFRyYW5zZm9ybS5jb25jYXQoKSA6IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm1cbiAgICAgIH07XG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYW4gZ3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYSBncmFkaWVudCBmb3JcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBncmFkaWVudCAobGluZWFyL3JhZGlhbClcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgY29vcmRzID0gY2xvbmUodGhpcy5jb29yZHMsIHRydWUpLCBpLCBsZW4sIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICAgIG1hcmt1cCwgY29tbW9uQXR0cmlidXRlcywgY29sb3JTdG9wcyA9IGNsb25lKHRoaXMuY29sb3JTdG9wcywgdHJ1ZSksXG4gICAgICAgICAgbmVlZHNTd2FwID0gY29vcmRzLnIxID4gY29vcmRzLnIyLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmNvbmNhdCgpIDogZmFicmljLmlNYXRyaXguY29uY2F0KCksXG4gICAgICAgICAgb2Zmc2V0WCA9IC10aGlzLm9mZnNldFgsIG9mZnNldFkgPSAtdGhpcy5vZmZzZXRZLFxuICAgICAgICAgIHdpdGhWaWV3cG9ydCA9ICEhb3B0aW9ucy5hZGRpdGlvbmFsVHJhbnNmb3JtLFxuICAgICAgICAgIGdyYWRpZW50VW5pdHMgPSB0aGlzLmdyYWRpZW50VW5pdHMgPT09ICdwaXhlbHMnID8gJ3VzZXJTcGFjZU9uVXNlJyA6ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgICAvLyBjb2xvclN0b3BzIG11c3QgYmUgc29ydGVkIGFzY2VuZGluZ1xuICAgICAgY29sb3JTdG9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEub2Zmc2V0IC0gYi5vZmZzZXQ7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcpIHtcbiAgICAgICAgb2Zmc2V0WCAvPSBvYmplY3Qud2lkdGg7XG4gICAgICAgIG9mZnNldFkgLz0gb2JqZWN0LmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRYICs9IG9iamVjdC53aWR0aCAvIDI7XG4gICAgICAgIG9mZnNldFkgKz0gb2JqZWN0LmhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdwYXRoJyAmJiB0aGlzLmdyYWRpZW50VW5pdHMgIT09ICdwZXJjZW50YWdlJykge1xuICAgICAgICBvZmZzZXRYIC09IG9iamVjdC5wYXRoT2Zmc2V0Lng7XG4gICAgICAgIG9mZnNldFkgLT0gb2JqZWN0LnBhdGhPZmZzZXQueTtcbiAgICAgIH1cblxuXG4gICAgICB0cmFuc2Zvcm1bNF0gLT0gb2Zmc2V0WDtcbiAgICAgIHRyYW5zZm9ybVs1XSAtPSBvZmZzZXRZO1xuXG4gICAgICBjb21tb25BdHRyaWJ1dGVzID0gJ2lkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgICAgJ1wiIGdyYWRpZW50VW5pdHM9XCInICsgZ3JhZGllbnRVbml0cyArICdcIic7XG4gICAgICBjb21tb25BdHRyaWJ1dGVzICs9ICcgZ3JhZGllbnRUcmFuc2Zvcm09XCInICsgKHdpdGhWaWV3cG9ydCA/XG4gICAgICAgIG9wdGlvbnMuYWRkaXRpb25hbFRyYW5zZm9ybSArICcgJyA6ICcnKSArIGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKHRyYW5zZm9ybSkgKyAnXCIgJztcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICc8bGluZWFyR3JhZGllbnQgJyxcbiAgICAgICAgICBjb21tb25BdHRyaWJ1dGVzLFxuICAgICAgICAgICcgeDE9XCInLCBjb29yZHMueDEsXG4gICAgICAgICAgJ1wiIHkxPVwiJywgY29vcmRzLnkxLFxuICAgICAgICAgICdcIiB4Mj1cIicsIGNvb3Jkcy54MixcbiAgICAgICAgICAnXCIgeTI9XCInLCBjb29yZHMueTIsXG4gICAgICAgICAgJ1wiPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgLy8gc3ZnIHJhZGlhbCBncmFkaWVudCBoYXMganVzdCAxIHJhZGl1cy4gdGhlIGJpZ2dlc3QuXG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnPHJhZGlhbEdyYWRpZW50ICcsXG4gICAgICAgICAgY29tbW9uQXR0cmlidXRlcyxcbiAgICAgICAgICAnIGN4PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLngxIDogY29vcmRzLngyLFxuICAgICAgICAgICdcIiBjeT1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy55MSA6IGNvb3Jkcy55MixcbiAgICAgICAgICAnXCIgcj1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy5yMSA6IGNvb3Jkcy5yMixcbiAgICAgICAgICAnXCIgZng9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueDIgOiBjb29yZHMueDEsXG4gICAgICAgICAgJ1wiIGZ5PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnkyIDogY29vcmRzLnkxLFxuICAgICAgICAgICdcIj5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGlmIChuZWVkc1N3YXApIHtcbiAgICAgICAgICAvLyBzdmcgZ29lcyBmcm9tIGludGVybmFsIHRvIGV4dGVybmFsIHJhZGl1cy4gaWYgcmFkaXVzIGFyZSBpbnZlcnRlZCwgc3dhcCBjb2xvciBzdG9wcy5cbiAgICAgICAgICBjb2xvclN0b3BzID0gY29sb3JTdG9wcy5jb25jYXQoKTtcbiAgICAgICAgICBjb2xvclN0b3BzLnJldmVyc2UoKTtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb2xvclN0b3BzW2ldLm9mZnNldCA9IDEgLSBjb2xvclN0b3BzW2ldLm9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pblJhZGl1cyA9IE1hdGgubWluKGNvb3Jkcy5yMSwgY29vcmRzLnIyKTtcbiAgICAgICAgaWYgKG1pblJhZGl1cyA+IDApIHtcbiAgICAgICAgICAvLyBpIGhhdmUgdG8gc2hpZnQgYWxsIGNvbG9yU3RvcHMgYW5kIGFkZCBuZXcgb25lIGluIDAuXG4gICAgICAgICAgdmFyIG1heFJhZGl1cyA9IE1hdGgubWF4KGNvb3Jkcy5yMSwgY29vcmRzLnIyKSxcbiAgICAgICAgICAgICAgcGVyY2VudGFnZVNoaWZ0ID0gbWluUmFkaXVzIC8gbWF4UmFkaXVzO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0ICs9IHBlcmNlbnRhZ2VTaGlmdCAqICgxIC0gY29sb3JTdG9wc1tpXS5vZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xvclN0b3AgPSBjb2xvclN0b3BzW2ldO1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHN0b3AgJyxcbiAgICAgICAgICAnb2Zmc2V0PVwiJywgKGNvbG9yU3RvcC5vZmZzZXQgKiAxMDApICsgJyUnLFxuICAgICAgICAgICdcIiBzdHlsZT1cInN0b3AtY29sb3I6JywgY29sb3JTdG9wLmNvbG9yLFxuICAgICAgICAgICh0eXBlb2YgY29sb3JTdG9wLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnID8gJztzdG9wLW9wYWNpdHk6ICcgKyBjb2xvclN0b3Aub3BhY2l0eSA6ICc7JyksXG4gICAgICAgICAgJ1wiLz5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKCh0aGlzLnR5cGUgPT09ICdsaW5lYXInID8gJzwvbGluZWFyR3JhZGllbnQ+XFxuJyA6ICc8L3JhZGlhbEdyYWRpZW50PlxcbicpKTtcblxuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDYW52YXNHcmFkaWVudFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNHcmFkaWVudH1cbiAgICAgKi9cbiAgICB0b0xpdmU6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGdyYWRpZW50LCBjb29yZHMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5jb29yZHMpLCBpLCBsZW47XG5cbiAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoXG4gICAgICAgICAgY29vcmRzLngxLCBjb29yZHMueTEsIGNvb3Jkcy54MiwgY29vcmRzLnkyKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgICAgY29vcmRzLngxLCBjb29yZHMueTEsIGNvb3Jkcy5yMSwgY29vcmRzLngyLCBjb29yZHMueTIsIGNvb3Jkcy5yMik7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yU3RvcHNbaV0uY29sb3IsXG4gICAgICAgICAgICBvcGFjaXR5ID0gdGhpcy5jb2xvclN0b3BzW2ldLm9wYWNpdHksXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmNvbG9yU3RvcHNbaV0ub2Zmc2V0O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpLnNldEFscGhhKG9wYWNpdHkpLnRvUmdiYSgpO1xuICAgICAgICB9XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChvZmZzZXQsIGNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuR3JhZGllbnQsIHtcblxuICAgIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuR3JhZGllbnR9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5HcmFkaWVudFxuICAgICAqIEBwYXJhbSB7U1ZHR3JhZGllbnRFbGVtZW50fSBlbCBTVkcgZ3JhZGllbnQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3BhY2l0eUF0dHIgQSBmaWxsLW9wYWNpdHkgb3Igc3Ryb2tlLW9wYWNpdHkgYXR0cmlidXRlIHRvIG11bHRpcGx5IHRvIGVhY2ggc3RvcCdzIG9wYWNpdHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2Z09wdGlvbnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNpemUgb2YgdGhlIFNWRyBpbiBvcmRlciB0byBwYXJzZSBjb3JyZWN0bHkgZ3JhZGllbnRzXG4gICAgICogdGhhdCB1c2VzIGdyYWRpZW50VW5pdHMgYXMgJ3VzZXJTcGFjZU9uVXNlJyBhbmQgcGVyY2VudGFnZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSB2aWV3Qm94V2lkdGggd2lkdGggcGFydCBvZiB0aGUgdmlld0JveCBhdHRyaWJ1dGUgb24gc3ZnXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSB2aWV3Qm94SGVpZ2h0IGhlaWdodCBwYXJ0IG9mIHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSBvbiBzdmdcbiAgICAgKiBAcGFyYW0ge09iamVjdC5udW1iZXJ9IHdpZHRoIHdpZHRoIHBhcnQgb2YgdGhlIHN2ZyB0YWcgaWYgdmlld0JveCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSBoZWlnaHQgaGVpZ2h0IHBhcnQgb2YgdGhlIHN2ZyB0YWcgaWYgdmlld0JveCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSBHcmFkaWVudCBpbnN0YW5jZVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BzZXJ2ZXJzLmh0bWwjTGluZWFyR3JhZGllbnRFbGVtZW50XG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcHNlcnZlcnMuaHRtbCNSYWRpYWxHcmFkaWVudEVsZW1lbnRcbiAgICAgKi9cbiAgICBmcm9tRWxlbWVudDogZnVuY3Rpb24oZWwsIGluc3RhbmNlLCBvcGFjaXR5QXR0ciwgc3ZnT3B0aW9ucykge1xuICAgICAgLyoqXG4gICAgICAgKiAgQGV4YW1wbGU6XG4gICAgICAgKlxuICAgICAgICogIDxsaW5lYXJHcmFkaWVudCBpZD1cImxpbmVhckdyYWQxXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjEwMCVcIiBzdG9wLWNvbG9yPVwiYmxhY2tcIi8+XG4gICAgICAgKiAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPGxpbmVhckdyYWRpZW50IGlkPVwibGluZWFyR3JhZDJcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdHlsZT1cInN0b3AtY29sb3I6cmdiKDI1NSwyNTUsMjU1KVwiLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdHlsZT1cInN0b3AtY29sb3I6cmdiKDAsMCwwKVwiLz5cbiAgICAgICAqICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJyYWRpYWxHcmFkMVwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIiBzdG9wLW9wYWNpdHk9XCIxXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjUwJVwiIHN0b3AtY29sb3I9XCJibGFja1wiIHN0b3Atb3BhY2l0eT1cIjAuNVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIgc3RvcC1vcGFjaXR5PVwiMVwiIC8+XG4gICAgICAgKiAgPC9yYWRpYWxHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPHJhZGlhbEdyYWRpZW50IGlkPVwicmFkaWFsR3JhZDJcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdG9wLWNvbG9yPVwicmdiKDI1NSwyNTUsMjU1KVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwLjVcIiBzdG9wLWNvbG9yPVwicmdiKDAsMCwwKVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3RvcC1jb2xvcj1cInJnYigyNTUsMjU1LDI1NSlcIiAvPlxuICAgICAgICogIDwvcmFkaWFsR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHZhciBtdWx0aXBsaWVyID0gcGFyc2VGbG9hdChvcGFjaXR5QXR0cikgLyAoLyUkLy50ZXN0KG9wYWNpdHlBdHRyKSA/IDEwMCA6IDEpO1xuICAgICAgbXVsdGlwbGllciA9IG11bHRpcGxpZXIgPCAwID8gMCA6IG11bHRpcGxpZXIgPiAxID8gMSA6IG11bHRpcGxpZXI7XG4gICAgICBpZiAoaXNOYU4obXVsdGlwbGllcikpIHtcbiAgICAgICAgbXVsdGlwbGllciA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvclN0b3BFbHMgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3RvcCcpLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZ3JhZGllbnRVbml0cyA9IGVsLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycpID09PSAndXNlclNwYWNlT25Vc2UnID9cbiAgICAgICAgICAgICdwaXhlbHMnIDogJ3BlcmNlbnRhZ2UnLFxuICAgICAgICAgIGdyYWRpZW50VHJhbnNmb3JtID0gZWwuZ2V0QXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpIHx8ICcnLFxuICAgICAgICAgIGNvbG9yU3RvcHMgPSBbXSxcbiAgICAgICAgICBjb29yZHMsIGksIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMCxcbiAgICAgICAgICB0cmFuc2Zvcm1NYXRyaXg7XG4gICAgICBpZiAoZWwubm9kZU5hbWUgPT09ICdsaW5lYXJHcmFkaWVudCcgfHwgZWwubm9kZU5hbWUgPT09ICdMSU5FQVJHUkFESUVOVCcpIHtcbiAgICAgICAgdHlwZSA9ICdsaW5lYXInO1xuICAgICAgICBjb29yZHMgPSBnZXRMaW5lYXJDb29yZHMoZWwpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHR5cGUgPSAncmFkaWFsJztcbiAgICAgICAgY29vcmRzID0gZ2V0UmFkaWFsQ29vcmRzKGVsKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gY29sb3JTdG9wRWxzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29sb3JTdG9wcy5wdXNoKGdldENvbG9yU3RvcChjb2xvclN0b3BFbHNbaV0sIG11bHRpcGxpZXIpKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNmb3JtTWF0cml4ID0gZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKGdyYWRpZW50VHJhbnNmb3JtKTtcblxuICAgICAgX19jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMoaW5zdGFuY2UsIGNvb3Jkcywgc3ZnT3B0aW9ucywgZ3JhZGllbnRVbml0cyk7XG5cbiAgICAgIGlmIChncmFkaWVudFVuaXRzID09PSAncGl4ZWxzJykge1xuICAgICAgICBvZmZzZXRYID0gLWluc3RhbmNlLmxlZnQ7XG4gICAgICAgIG9mZnNldFkgPSAtaW5zdGFuY2UudG9wO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgZmFicmljLkdyYWRpZW50KHtcbiAgICAgICAgaWQ6IGVsLmdldEF0dHJpYnV0ZSgnaWQnKSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgY29vcmRzOiBjb29yZHMsXG4gICAgICAgIGNvbG9yU3RvcHM6IGNvbG9yU3RvcHMsXG4gICAgICAgIGdyYWRpZW50VW5pdHM6IGdyYWRpZW50VW5pdHMsXG4gICAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiB0cmFuc2Zvcm1NYXRyaXgsXG4gICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IG9mZnNldFksXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9fY29udmVydFBlcmNlbnRVbml0c1RvVmFsdWVzKGluc3RhbmNlLCBvcHRpb25zLCBzdmdPcHRpb25zLCBncmFkaWVudFVuaXRzKSB7XG4gICAgdmFyIHByb3BWYWx1ZSwgZmluYWxWYWx1ZTtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHByb3BWYWx1ZSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICBpZiAocHJvcFZhbHVlID09PSAnSW5maW5pdHknKSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJvcFZhbHVlID09PSAnLUluZmluaXR5Jykge1xuICAgICAgICBmaW5hbFZhbHVlID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmaW5hbFZhbHVlID0gcGFyc2VGbG9hdChvcHRpb25zW3Byb3BdLCAxMCk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAnc3RyaW5nJyAmJiAvXihcXGQrXFwuXFxkKyklfChcXGQrKSUkLy50ZXN0KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICBmaW5hbFZhbHVlICo9IDAuMDE7XG4gICAgICAgICAgaWYgKGdyYWRpZW50VW5pdHMgPT09ICdwaXhlbHMnKSB7XG4gICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gZml4IHRob3NlIHBlcmNlbnRhZ2VzIGhlcmUgaW4gc3ZnIHBhcnNpbmdcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAneDEnIHx8IHByb3AgPT09ICd4MicgfHwgcHJvcCA9PT0gJ3IyJykge1xuICAgICAgICAgICAgICBmaW5hbFZhbHVlICo9IHN2Z09wdGlvbnMudmlld0JveFdpZHRoIHx8IHN2Z09wdGlvbnMud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3kxJyB8fCBwcm9wID09PSAneTInKSB7XG4gICAgICAgICAgICAgIGZpbmFsVmFsdWUgKj0gc3ZnT3B0aW9ucy52aWV3Qm94SGVpZ2h0IHx8IHN2Z09wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0aW9uc1twcm9wXSA9IGZpbmFsVmFsdWU7XG4gICAgfSk7XG4gIH1cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgLyoqXG4gICAqIFBhdHRlcm4gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vcGF0dGVybnN8UGF0dGVybiBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2R5bmFtaWMtcGF0dGVybnN8RHluYW1pY1BhdHRlcm4gZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBhdHRlcm4jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG5cblxuICBmYWJyaWMuUGF0dGVybiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLlBhdHRlcm4ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJlcGVhdCBwcm9wZXJ0eSBvZiBhIHBhdHRlcm4gKG9uZSBvZiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSBvciBuby1yZXBlYXQpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZXBlYXQ6ICdyZXBlYXQnLFxuXG4gICAgLyoqXG4gICAgICogUGF0dGVybiBob3Jpem9udGFsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gdmVydGljYWwgb2Zmc2V0IGZyb20gb2JqZWN0J3MgbGVmdC90b3AgY29ybmVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogY3Jvc3NPcmlnaW4gdmFsdWUgKG9uZSBvZiBcIlwiLCBcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiKVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Jvc3NPcmlnaW46ICcnLFxuXG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtIG1hdHJpeCB0byBjaGFuZ2UgdGhlIHBhdHRlcm4sIGltcG9ydGVkIGZyb20gc3Zncy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0dGVyblRyYW5zZm9ybTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIGNhbGxiYWNrIGluaXQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdHRlcm59IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMuaWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMuc291cmNlIHx8IChvcHRpb25zLnNvdXJjZSAmJiB0eXBlb2Ygb3B0aW9ucy5zb3VyY2UgIT09ICdzdHJpbmcnKSkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGltZyBzcmMgc3RyaW5nXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc291cmNlID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKTtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKG9wdGlvbnMuc291cmNlLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgICAgICBfdGhpcy5zb3VyY2UgPSBpbWc7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soX3RoaXMsIGlzRXJyb3IpO1xuICAgICAgICB9LCBudWxsLCB0aGlzLmNyb3NzT3JpZ2luKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVybiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBzb3VyY2UsIG9iamVjdDtcblxuICAgICAgLy8gPGltZz4gZWxlbWVudFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZS5zcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLnNyYztcbiAgICAgIH1cbiAgICAgIC8vIDxjYW52YXM+IGVsZW1lbnRcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ29iamVjdCcgJiYgdGhpcy5zb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLnRvRGF0YVVSTCgpO1xuICAgICAgfVxuXG4gICAgICBvYmplY3QgPSB7XG4gICAgICAgIHR5cGU6ICdwYXR0ZXJuJyxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHJlcGVhdDogdGhpcy5yZXBlYXQsXG4gICAgICAgIGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luLFxuICAgICAgICBvZmZzZXRYOiB0b0ZpeGVkKHRoaXMub2Zmc2V0WCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgIG9mZnNldFk6IHRvRml4ZWQodGhpcy5vZmZzZXRZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgcGF0dGVyblRyYW5zZm9ybTogdGhpcy5wYXR0ZXJuVHJhbnNmb3JtID8gdGhpcy5wYXR0ZXJuVHJhbnNmb3JtLmNvbmNhdCgpIDogbnVsbFxuICAgICAgfTtcbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBwYXR0ZXJuU291cmNlID0gdHlwZW9mIHRoaXMuc291cmNlID09PSAnZnVuY3Rpb24nID8gdGhpcy5zb3VyY2UoKSA6IHRoaXMuc291cmNlLFxuICAgICAgICAgIHBhdHRlcm5XaWR0aCA9IHBhdHRlcm5Tb3VyY2Uud2lkdGggLyBvYmplY3Qud2lkdGgsXG4gICAgICAgICAgcGF0dGVybkhlaWdodCA9IHBhdHRlcm5Tb3VyY2UuaGVpZ2h0IC8gb2JqZWN0LmhlaWdodCxcbiAgICAgICAgICBwYXR0ZXJuT2Zmc2V0WCA9IHRoaXMub2Zmc2V0WCAvIG9iamVjdC53aWR0aCxcbiAgICAgICAgICBwYXR0ZXJuT2Zmc2V0WSA9IHRoaXMub2Zmc2V0WSAvIG9iamVjdC5oZWlnaHQsXG4gICAgICAgICAgcGF0dGVybkltZ1NyYyA9ICcnO1xuICAgICAgaWYgKHRoaXMucmVwZWF0ID09PSAncmVwZWF0LXgnIHx8IHRoaXMucmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgICAgICBwYXR0ZXJuSGVpZ2h0ID0gMTtcbiAgICAgICAgaWYgKHBhdHRlcm5PZmZzZXRZKSB7XG4gICAgICAgICAgcGF0dGVybkhlaWdodCArPSBNYXRoLmFicyhwYXR0ZXJuT2Zmc2V0WSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlcGVhdCA9PT0gJ3JlcGVhdC15JyB8fCB0aGlzLnJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICAgICAgcGF0dGVybldpZHRoID0gMTtcbiAgICAgICAgaWYgKHBhdHRlcm5PZmZzZXRYKSB7XG4gICAgICAgICAgcGF0dGVybldpZHRoICs9IE1hdGguYWJzKHBhdHRlcm5PZmZzZXRYKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBpZiAocGF0dGVyblNvdXJjZS5zcmMpIHtcbiAgICAgICAgcGF0dGVybkltZ1NyYyA9IHBhdHRlcm5Tb3VyY2Uuc3JjO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocGF0dGVyblNvdXJjZS50b0RhdGFVUkwpIHtcbiAgICAgICAgcGF0dGVybkltZ1NyYyA9IHBhdHRlcm5Tb3VyY2UudG9EYXRhVVJMKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPHBhdHRlcm4gaWQ9XCJTVkdJRF8nICsgdGhpcy5pZCArXG4gICAgICAgICAgICAgICAgICAgICdcIiB4PVwiJyArIHBhdHRlcm5PZmZzZXRYICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHk9XCInICsgcGF0dGVybk9mZnNldFkgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgd2lkdGg9XCInICsgcGF0dGVybldpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGhlaWdodD1cIicgKyBwYXR0ZXJuSGVpZ2h0ICsgJ1wiPlxcbicgK1xuICAgICAgICAgICAgICAgJzxpbWFnZSB4PVwiMFwiIHk9XCIwXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAnIHdpZHRoPVwiJyArIHBhdHRlcm5Tb3VyY2Uud2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInICsgcGF0dGVyblNvdXJjZS5oZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAgICdcIiB4bGluazpocmVmPVwiJyArIHBhdHRlcm5JbWdTcmMgK1xuICAgICAgICAgICAgICAgJ1wiPjwvaW1hZ2U+XFxuJyArXG4gICAgICAgICAgICAgJzwvcGF0dGVybj5cXG4nO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgQ2FudmFzUGF0dGVyblxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBjcmVhdGUgcGF0dGVyblxuICAgICAqIEByZXR1cm4ge0NhbnZhc1BhdHRlcm59XG4gICAgICovXG4gICAgdG9MaXZlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgIC8vIGlmIHRoZSBpbWFnZSBmYWlsZWQgdG8gbG9hZCwgcmV0dXJuLCBhbmQgYWxsb3cgcmVzdCB0byBjb250aW51ZSBsb2FkaW5nXG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGFuIGltYWdlXG4gICAgICBpZiAodHlwZW9mIHNvdXJjZS5zcmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghc291cmNlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UubmF0dXJhbFdpZHRoID09PSAwIHx8IHNvdXJjZS5uYXR1cmFsSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4oc291cmNlLCB0aGlzLnJlcGVhdCk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICBpZiAoZmFicmljLlNoYWRvdykge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuU2hhZG93IGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogU2hhZG93IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuU2hhZG93XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vc2hhZG93c3xTaGFkb3cgZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlNoYWRvdyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlNoYWRvdyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLlNoYWRvdy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogU2hhZG93IGNvbG9yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb2xvcjogJ3JnYigwLDAsMCknLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IGJsdXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBibHVyOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IGhvcml6b250YWwgb2Zmc2V0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IHZlcnRpY2FsIG9mZnNldFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHNoYWRvdyBzaG91bGQgYWZmZWN0IHN0cm9rZSBvcGVyYXRpb25zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWZmZWN0U3Ryb2tlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRvT2JqZWN0IHNob3VsZCBpbmNsdWRlIGRlZmF1bHQgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW5jbHVkZURlZmF1bHRWYWx1ZXM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIHRoZSBzaGFkb3cgd2lsbCBzY2FsZSB3aXRoIHRoZSBvYmplY3QuXG4gICAgICogV2hlbiBgdHJ1ZWAsIHRoZSBzaGFkb3cncyBvZmZzZXRYLCBvZmZzZXRZLCBhbmQgYmx1ciB3aWxsIG5vdCBiZSBhZmZlY3RlZCBieSB0aGUgb2JqZWN0J3Mgc2NhbGUuXG4gICAgICogZGVmYXVsdCB0byBmYWxzZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG5vblNjYWxpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIGFueSBvZiBjb2xvciwgYmx1ciwgb2Zmc2V0WCwgb2Zmc2V0WSBwcm9wZXJ0aWVzIG9yIHN0cmluZyAoZS5nLiBcInJnYmEoMCwwLDAsMC4yKSAycHggMnB4IDEwcHhcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuU2hhZG93fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZVNoYWRvdyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFkb3cgU2hhZG93IHZhbHVlIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBTaGFkb3cgb2JqZWN0IHdpdGggY29sb3IsIG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXJcbiAgICAgKi9cbiAgICBfcGFyc2VTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgdmFyIHNoYWRvd1N0ciA9IHNoYWRvdy50cmltKCksXG4gICAgICAgICAgb2Zmc2V0c0FuZEJsdXIgPSBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIuZXhlYyhzaGFkb3dTdHIpIHx8IFtdLFxuICAgICAgICAgIGNvbG9yID0gc2hhZG93U3RyLnJlcGxhY2UoZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyLCAnJykgfHwgJ3JnYigwLDAsMCknO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xvcjogY29sb3IudHJpbSgpLFxuICAgICAgICBvZmZzZXRYOiBwYXJzZUZsb2F0KG9mZnNldHNBbmRCbHVyWzFdLCAxMCkgfHwgMCxcbiAgICAgICAgb2Zmc2V0WTogcGFyc2VGbG9hdChvZmZzZXRzQW5kQmx1clsyXSwgMTApIHx8IDAsXG4gICAgICAgIGJsdXI6IHBhcnNlRmxvYXQob2Zmc2V0c0FuZEJsdXJbM10sIDEwKSB8fCAwXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MtdGV4dC1kZWNvci0zLyN0ZXh0LXNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBDU1MzIHRleHQtc2hhZG93IGRlY2xhcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgdGhpcy5ibHVyLCB0aGlzLmNvbG9yXS5qb2luKCdweCAnKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgZkJveFggPSA0MCwgZkJveFkgPSA0MCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBvZmZzZXQgPSBmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoXG4gICAgICAgICAgICB7IHg6IHRoaXMub2Zmc2V0WCwgeTogdGhpcy5vZmZzZXRZIH0sXG4gICAgICAgICAgICBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKC1vYmplY3QuYW5nbGUpKSxcbiAgICAgICAgICBCTFVSX0JPWCA9IDIwLCBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcik7XG5cbiAgICAgIGlmIChvYmplY3Qud2lkdGggJiYgb2JqZWN0LmhlaWdodCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjRmlsdGVyRWZmZWN0c1JlZ2lvblxuICAgICAgICAvLyB3ZSBhZGQgc29tZSBleHRyYSBzcGFjZSB0byBmaWx0ZXIgYm94IHRvIGNvbnRhaW4gdGhlIGJsdXIgKCAyMCApXG4gICAgICAgIGZCb3hYID0gdG9GaXhlZCgoTWF0aC5hYnMob2Zmc2V0LngpICsgdGhpcy5ibHVyKSAvIG9iamVjdC53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgICAgZkJveFkgPSB0b0ZpeGVkKChNYXRoLmFicyhvZmZzZXQueSkgKyB0aGlzLmJsdXIpIC8gb2JqZWN0LmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZmxpcFgpIHtcbiAgICAgICAgb2Zmc2V0LnggKj0gLTE7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsaXBZKSB7XG4gICAgICAgIG9mZnNldC55ICo9IC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAnPGZpbHRlciBpZD1cIlNWR0lEXycgKyB0aGlzLmlkICsgJ1wiIHk9XCItJyArIGZCb3hZICsgJyVcIiBoZWlnaHQ9XCInICsgKDEwMCArIDIgKiBmQm94WSkgKyAnJVwiICcgK1xuICAgICAgICAgICd4PVwiLScgKyBmQm94WCArICclXCIgd2lkdGg9XCInICsgKDEwMCArIDIgKiBmQm94WCkgKyAnJVwiICcgKyAnPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVHYXVzc2lhbkJsdXIgaW49XCJTb3VyY2VBbHBoYVwiIHN0ZERldmlhdGlvbj1cIicgK1xuICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmJsdXIgPyB0aGlzLmJsdXIgLyAyIDogMCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCI+PC9mZUdhdXNzaWFuQmx1cj5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlT2Zmc2V0IGR4PVwiJyArIHRvRml4ZWQob2Zmc2V0LngsIE5VTV9GUkFDVElPTl9ESUdJVFMpICtcbiAgICAgICAgICAnXCIgZHk9XCInICsgdG9GaXhlZChvZmZzZXQueSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgcmVzdWx0PVwib0JsdXJcIiA+PC9mZU9mZnNldD5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlRmxvb2QgZmxvb2QtY29sb3I9XCInICsgY29sb3IudG9SZ2IoKSArICdcIiBmbG9vZC1vcGFjaXR5PVwiJyArIGNvbG9yLmdldEFscGhhKCkgKyAnXCIvPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVDb21wb3NpdGUgaW4yPVwib0JsdXJcIiBvcGVyYXRvcj1cImluXCIgLz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlTWVyZ2U+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgJ1xcdDwvZmVNZXJnZT5cXG4nICtcbiAgICAgICAgJzwvZmlsdGVyPlxcbicpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93IGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBibHVyOiB0aGlzLmJsdXIsXG4gICAgICAgICAgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgICBhZmZlY3RTdHJva2U6IHRoaXMuYWZmZWN0U3Ryb2tlLFxuICAgICAgICAgIG5vblNjYWxpbmc6IHRoaXMubm9uU2NhbGluZ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHsgfSwgcHJvdG8gPSBmYWJyaWMuU2hhZG93LnByb3RvdHlwZTtcblxuICAgICAgWydjb2xvcicsICdibHVyJywgJ29mZnNldFgnLCAnb2Zmc2V0WScsICdhZmZlY3RTdHJva2UnLCAnbm9uU2NhbGluZyddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAodGhpc1twcm9wXSAhPT0gcHJvdG9bcHJvcF0pIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBzaGFkb3cgb2Zmc2V0WCwgb2Zmc2V0WSBhbmQgYmx1ciAoZXg6IFwiMnB4IDJweCAxMHB4IHJnYmEoMCwwLDAsMC4yKVwiLCBcInJnYigwLDI1NSwwKSAycHggMnB4XCIpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuU2hhZG93XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIgPSAvKD86XFxzfF4pKC0/XFxkKyg/OlxcLlxcZCopPyg/OnB4KT8oPzpcXHM/fCQpKT8oLT9cXGQrKD86XFwuXFxkKik/KD86cHgpPyg/Olxccz98JCkpPyhcXGQrKD86XFwuXFxkKik/KD86cHgpPyk/KD86XFxzP3wkKSg/OiR8XFxzKS87XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoZmFicmljLlN0YXRpY0NhbnZhcykge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuU3RhdGljQ2FudmFzIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhbGlhc2VzIGZvciBmYXN0ZXIgcmVzb2x1dGlvblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGdldEVsZW1lbnRPZmZzZXQgPSBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0LFxuICAgICAgcmVtb3ZlRnJvbUFycmF5ID0gZmFicmljLnV0aWwucmVtb3ZlRnJvbUFycmF5LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICB0cmFuc2Zvcm1Qb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50LFxuICAgICAgaW52ZXJ0VHJhbnNmb3JtID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtLFxuICAgICAgZ2V0Tm9kZUNhbnZhcyA9IGZhYnJpYy51dGlsLmdldE5vZGVDYW52YXMsXG4gICAgICBjcmVhdGVDYW52YXNFbGVtZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCxcblxuICAgICAgQ0FOVkFTX0lOSVRfRVJST1IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBpbml0aWFsaXplIGBjYW52YXNgIGVsZW1lbnQnKTtcblxuICAvKipcbiAgICogU3RhdGljIGNhbnZhcyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlN0YXRpY0NhbnZhc1xuICAgKiBAbWl4ZXMgZmFicmljLkNvbGxlY3Rpb25cbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vc3RhdGljX2NhbnZhc3xTdGF0aWNDYW52YXMgZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAZmlyZXMgYmVmb3JlOnJlbmRlclxuICAgKiBAZmlyZXMgYWZ0ZXI6cmVuZGVyXG4gICAqIEBmaXJlcyBjYW52YXM6Y2xlYXJlZFxuICAgKiBAZmlyZXMgb2JqZWN0OmFkZGVkXG4gICAqIEBmaXJlcyBvYmplY3Q6cmVtb3ZlZFxuICAgKi9cbiAgZmFicmljLlN0YXRpY0NhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Db21tb25NZXRob2RzLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCA9IHRoaXMucmVuZGVyQW5kUmVzZXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kID0gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9pbml0U3RhdGljKGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0QmFja2dyb3VuZENvbG9yfS5cbiAgICAgKiBAdHlwZSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBpbWFnZSBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogc2luY2UgMi40LjAgaW1hZ2UgY2FjaGluZyBpcyBhY3RpdmUsIHBsZWFzZSB3aGVuIHB1dHRpbmcgYW4gaW1hZ2UgYXMgYmFja2dyb3VuZCwgYWRkIHRvIHRoZVxuICAgICAqIGNhbnZhcyBwcm9wZXJ0eSBhIHJlZmVyZW5jZSB0byB0aGUgY2FudmFzIGl0IGlzIG9uLiBPdGhlcndpc2UgdGhlIGltYWdlIGNhbm5vdCBkZXRlY3QgdGhlIHpvb21cbiAgICAgKiB2YWxlLiBBcyBhbiBhbHRlcm5hdGl2ZSB5b3UgY2FuIGRpc2FibGUgaW1hZ2Ugb2JqZWN0Q2FjaGluZ1xuICAgICAqIEB0eXBlIGZhYnJpYy5JbWFnZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZEltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheSBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0T3ZlcmxheUNvbG9yfVxuICAgICAqIEBzaW5jZSAxLjMuOVxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5IGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBzaW5jZSAyLjQuMCBpbWFnZSBjYWNoaW5nIGlzIGFjdGl2ZSwgcGxlYXNlIHdoZW4gcHV0dGluZyBhbiBpbWFnZSBhcyBvdmVybGF5LCBhZGQgdG8gdGhlXG4gICAgICogY2FudmFzIHByb3BlcnR5IGEgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXMgaXQgaXMgb24uIE90aGVyd2lzZSB0aGUgaW1hZ2UgY2Fubm90IGRldGVjdCB0aGUgem9vbVxuICAgICAqIHZhbGUuIEFzIGFuIGFsdGVybmF0aXZlIHlvdSBjYW4gZGlzYWJsZSBpbWFnZSBvYmplY3RDYWNoaW5nXG4gICAgICogQHR5cGUgZmFicmljLkltYWdlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGF5SW1hZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0b09iamVjdC90b0RhdGFsZXNzT2JqZWN0IHNob3VsZCBpbmNsdWRlIGRlZmF1bHQgdmFsdWVzXG4gICAgICogaWYgc2V0IHRvIGZhbHNlLCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIG9iamVjdCB2YWx1ZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdHMnIHN0YXRlIHNob3VsZCBiZSBzYXZlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0YXRlZnVsOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5hZGR9LCB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24uaW5zZXJ0QXR9IGFuZCB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24ucmVtb3ZlfSxcbiAgICAgKiB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcy5tb3ZlVG99LCB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcy5jbGVhcn0gYW5kIG1hbnkgbW9yZSwgc2hvdWxkIGFsc28gcmUtcmVuZGVyIGNhbnZhcy5cbiAgICAgKiBEaXNhYmxpbmcgdGhpcyBvcHRpb24gd2lsbCBub3QgZ2l2ZSBhIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gYWRkaW5nL3JlbW92aW5nIGEgbG90IG9mIG9iamVjdHMgdG8vZnJvbSBjYW52YXMgYXQgb25jZVxuICAgICAqIHNpbmNlIHRoZSByZW5kZXJzIGFyZSBxdWVxdWVkIGFuZCBleGVjdXRlZCBvbmUgcGVyIGZyYW1lLlxuICAgICAqIERpc2FibGluZyBpcyBzdWdnZXN0ZWQgYW55d2F5IGFuZCBtYW5hZ2luZyB0aGUgcmVuZGVycyBvZiB0aGUgYXBwIG1hbnVhbGx5IGlzIG5vdCBhIGJpZyBlZmZvcnQgKCBjYW52YXMucmVxdWVzdFJlbmRlckFsbCgpIClcbiAgICAgKiBMZWZ0IGRlZmF1bHQgdG8gdHJ1ZSB0byBkbyBub3QgYnJlYWsgZG9jdW1lbnRhdGlvbiBhbmQgb2xkIGFwcCwgZmlkZGxlcy5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZW5kZXJPbkFkZFJlbW92ZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdCBjb250cm9scyAoYm9yZGVycy9jb250cm9scykgYXJlIHJlbmRlcmVkIGFib3ZlIG92ZXJsYXkgaW1hZ2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb250cm9sc0Fib3ZlT3ZlcmxheTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYnJvd3NlciBjYW4gYmUgc2Nyb2xsZWQgd2hlbiB1c2luZyBhIHRvdWNoc2NyZWVuIGFuZCBkcmFnZ2luZyBvbiB0aGUgY2FudmFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWxsb3dUb3VjaFNjcm9sbGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNhbnZhcyB3aWxsIHVzZSBpbWFnZSBzbW9vdGhpbmcsIHRoaXMgaXMgb24gYnkgZGVmYXVsdCBpbiBicm93c2Vyc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGltYWdlU21vb3RoaW5nRW5hYmxlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2Zvcm1hdGlvbiAoYSBDYW52YXMgMkQgQVBJIHRyYW5zZm9ybSBtYXRyaXgpIHdoaWNoIGZvY3VzZXMgdGhlIHZpZXdwb3J0XG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWZhdWx0IHRyYW5zZm9ybTwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMudmlld3BvcnRUcmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2NhbGUgYnkgNzAlIGFuZCB0cmFuc2xhdGUgdG93YXJkIGJvdHRvbS1yaWdodCBieSA1MCwgd2l0aG91dCBza2V3aW5nPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSA9IFswLjcsIDAsIDAsIDAuNywgNTAsIDUwXTtcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHZpZXdwb3J0VHJhbnNmb3JtOiBmYWJyaWMuaU1hdHJpeC5jb25jYXQoKSxcblxuICAgIC8qKlxuICAgICAqIGlmIHNldCB0byBmYWxzZSBiYWNrZ3JvdW5kIGltYWdlIGlzIG5vdCBhZmZlY3RlZCBieSB2aWV3cG9ydCB0cmFuc2Zvcm1cbiAgICAgKiBAc2luY2UgMS42LjNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kVnB0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogaWYgc2V0IHRvIGZhbHNlIG92ZXJseWEgaW1hZ2UgaXMgbm90IGFmZmVjdGVkIGJ5IHZpZXdwb3J0IHRyYW5zZm9ybVxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlWcHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGNhbnZhcyBpcyBzY2FsZWQgYnkgZGV2aWNlUGl4ZWxSYXRpbyBmb3IgYmV0dGVyIHJlbmRlcmluZyBvbiByZXRpbmEgc2NyZWVuc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVuYWJsZVJldGluYVNjYWxpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBjYW52YXMgZWxlbWVudCBleHRlbnNpb24gb3ZlciBkZXNpZ25cbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSB0bCx0cixibCxici5cbiAgICAgKiBpZiBjYW52YXMgaXMgbm90IHpvb21lZC9wYW5uZWQgdGhvc2UgcG9pbnRzIGFyZSB0aGUgZm91ciBjb3JuZXIgb2YgY2FudmFzXG4gICAgICogaWYgY2FudmFzIGlzIHZpZXdwb3J0VHJhbnNmb3JtZWQgeW91IHRob3NlIHBvaW50cyBpbmRpY2F0ZSB0aGUgZXh0ZW5zaW9uXG4gICAgICogb2YgY2FudmFzIGVsZW1lbnQgaW4gcGxhaW4gdW50cmFzZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkIHdpdGggQG1ldGhvZCBjYWxjVmlld3BvcnRCb3VuZGFyaWVzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZwdENvb3JkczogeyB9LFxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdnB0Q29vcmRzIGFuZCBvYmplY3QuYUNvb3Jkcywgc2tpcCByZW5kZXJpbmcgb2Ygb2JqZWN0cyB0aGF0XG4gICAgICogYXJlIG5vdCBpbmNsdWRlZCBpbiBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAqIE1heSBncmVhdGx5IGhlbHAgaW4gYXBwbGljYXRpb25zIHdpdGggY3Jvd2RlZCBjYW52YXMgYW5kIHVzZSBvZiB6b29tL3BhblxuICAgICAqIElmIE9uZSBvZiB0aGUgY29ybmVyIG9mIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG9iamVjdCBpcyBvbiB0aGUgY2FudmFzXG4gICAgICogdGhlIG9iamVjdHMgZ2V0IHJlbmRlcmVkLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBPZmZzY3JlZW46IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBhIGZhYnJpY09iamVjdCB0aGF0LCB3aXRob3V0IHN0cm9rZSBkZWZpbmUgYSBjbGlwcGluZyBhcmVhIHdpdGggdGhlaXIgc2hhcGUuIGZpbGxlZCBpbiBibGFja1xuICAgICAqIHRoZSBjbGlwUGF0aCBvYmplY3QgZ2V0cyB1c2VkIHdoZW4gdGhlIGNhbnZhcyBoYXMgcmVuZGVyZWQsIGFuZCB0aGUgY29udGV4dCBpcyBwbGFjZWQgaW4gdGhlXG4gICAgICogdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMuXG4gICAgICogY2xpcFBhdGggd2lsbCBjbGlwIGF3YXkgY29udHJvbHMsIGlmIHlvdSBkbyBub3Qgd2FudCB0aGlzIHRvIGhhcHBlbiB1c2UgY29udHJvbHNBYm92ZU92ZXJsYXkgPSB0cnVlXG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFxuICAgICAqL1xuICAgIGNsaXBQYXRoOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdFN0YXRpYzogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYiA9IHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdGhpcy5fY3JlYXRlTG93ZXJDYW52YXMoZWwpO1xuICAgICAgdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAvLyBvbmx5IGluaXRpYWxpemUgcmV0aW5hIHNjYWxpbmcgb25jZVxuICAgICAgaWYgKCF0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2luaXRSZXRpbmFTY2FsaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm92ZXJsYXlJbWFnZSkge1xuICAgICAgICB0aGlzLnNldE92ZXJsYXlJbWFnZShvcHRpb25zLm92ZXJsYXlJbWFnZSwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZEltYWdlKG9wdGlvbnMuYmFja2dyb3VuZEltYWdlLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm92ZXJsYXlDb2xvcikge1xuICAgICAgICB0aGlzLnNldE92ZXJsYXlDb2xvcihvcHRpb25zLm92ZXJsYXlDb2xvciwgY2IpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzUmV0aW5hU2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvID4gMSAmJiB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcmV0aW5hU2NhbGluZyBpZiBhcHBsaWVkLCBvdGhlcndpc2UgMTtcbiAgICAgKi9cbiAgICBnZXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1JldGluYVNjYWxpbmcoKSA/IE1hdGgubWF4KDEsIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvKSA6IDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5faXNSZXRpbmFTY2FsaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNjYWxlUmF0aW8gPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIHRoaXMuX19pbml0UmV0aW5hU2NhbGluZyhzY2FsZVJhdGlvLCB0aGlzLmxvd2VyQ2FudmFzRWwsIHRoaXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICBpZiAodGhpcy51cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMuX19pbml0UmV0aW5hU2NhbGluZyhzY2FsZVJhdGlvLCB0aGlzLnVwcGVyQ2FudmFzRWwsIHRoaXMuY29udGV4dFRvcCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9faW5pdFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKHNjYWxlUmF0aW8sIGNhbnZhcywgY29udGV4dCkge1xuICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoICogc2NhbGVSYXRpbyk7XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmhlaWdodCAqIHNjYWxlUmF0aW8pO1xuICAgICAgY29udGV4dC5zY2FsZShzY2FsZVJhdGlvLCBzY2FsZVJhdGlvKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGNhbnZhcyBlbGVtZW50IG9mZnNldCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnRcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF0dGFjaGVkIGFzIFwicmVzaXplXCIgZXZlbnQgaGFuZGxlciBvZiB3aW5kb3dcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjYWxjT2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vZmZzZXQgPSBnZXRFbGVtZW50T2Zmc2V0KHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5SW1hZ2V8b3ZlcmxheSBpbWFnZX0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoZmFicmljLkltYWdlfFN0cmluZyl9IGltYWdlIGZhYnJpYy5JbWFnZSBpbnN0YW5jZSBvciBVUkwgb2YgYW4gaW1hZ2UgdG8gc2V0IG92ZXJsYXkgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBhbiBvdmVybGF5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zIHRvIHNldCBmb3IgdGhlIHtAbGluayBmYWJyaWMuSW1hZ2V8b3ZlcmxheSBpbWFnZX0uXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL01uekhUL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBvdmVybGF5SW1hZ2Ugd2l0aCBsZWZ0L3RvcCA9IDA8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBvdmVybGF5SW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPm92ZXJsYXlJbWFnZSB3aXRoIGRpZmZlcmVudCBwcm9wZXJ0aWVzPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIG92ZXJsYXlJbWFnZSAjMSAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogZmFicmljLkltYWdlLmZyb21VUkwoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAqICAgIGltZy5zZXQoe3dpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodCwgb3JpZ2luWDogJ2xlZnQnLCBvcmlnaW5ZOiAndG9wJ30pO1xuICAgICAqICAgIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoaW1nLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIG92ZXJsYXlJbWFnZSAjMiAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICogICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICogICAvLyBOZWVkZWQgdG8gcG9zaXRpb24gb3ZlcmxheUltYWdlIGF0IDAvMFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5vdmVybGF5SW1hZ2UgbG9hZGVkIGZyb20gY3Jvc3Mtb3JpZ2luPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAqICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0T3ZlcmxheUltYWdlOiBmdW5jdGlvbiAoaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUltYWdlKCdvdmVybGF5SW1hZ2UnLCBpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRJbWFnZXxiYWNrZ3JvdW5kIGltYWdlfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlIG9yIFVSTCBvZiBhbiBpbWFnZSB0byBzZXQgYmFja2dyb3VuZCB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGJhY2tncm91bmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxiYWNrZ3JvdW5kIGltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZGpucjhvN2EvMjgvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIGJhY2tncm91bmRJbWFnZSB3aXRoIGxlZnQvdG9wID0gMDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBiYWNrZ3JvdW5kSW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmJhY2tncm91bmRJbWFnZSB3aXRoIGRpZmZlcmVudCBwcm9wZXJ0aWVzPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgb3BhY2l0eTogMC41LFxuICAgICAqICAgYW5nbGU6IDQ1LFxuICAgICAqICAgbGVmdDogNDAwLFxuICAgICAqICAgdG9wOiA0MDAsXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBiYWNrZ3JvdW5kSW1hZ2UgIzEgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGZhYnJpYy5JbWFnZS5mcm9tVVJMKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICogICAgaW1nLnNldCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LCBvcmlnaW5YOiAnbGVmdCcsIG9yaWdpblk6ICd0b3AnfSk7XG4gICAgICogICAgY2FudmFzLnNldEJhY2tncm91bmRJbWFnZShpbWcsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgYmFja2dyb3VuZEltYWdlICMyIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICogICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICogICAvLyBOZWVkZWQgdG8gcG9zaXRpb24gYmFja2dyb3VuZEltYWdlIGF0IDAvMFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5iYWNrZ3JvdW5kSW1hZ2UgbG9hZGVkIGZyb20gY3Jvc3Mtb3JpZ2luPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgb3BhY2l0eTogMC41LFxuICAgICAqICAgYW5nbGU6IDQ1LFxuICAgICAqICAgbGVmdDogNDAwLFxuICAgICAqICAgdG9wOiA0MDAsXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJyxcbiAgICAgKiAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIC8vIFRPRE86IGZpeCBzdHJldGNoZWQgZXhhbXBsZXNcbiAgICBzZXRCYWNrZ3JvdW5kSW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ2JhY2tncm91bmRJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjb3ZlcmxheUNvbG9yfGZvcmVncm91bmQgY29sb3J9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9IG92ZXJsYXlDb2xvciBDb2xvciBvciBwYXR0ZXJuIHRvIHNldCBmb3JlZ3JvdW5kIGNvbG9yIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gZm9yZWdyb3VuZCBjb2xvciBpcyBzZXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvcEI1NWgvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlDb2xvciAtIGNvbG9yIHZhbHVlPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3IoJ3JnYmEoMjU1LCA3MywgNjQsIDAuNiknLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBvdmVybGF5Q29sb3I8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJ1xuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIG92ZXJsYXlDb2xvciB3aXRoIHJlcGVhdCBhbmQgb2Zmc2V0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZycsXG4gICAgICogICByZXBlYXQ6ICdyZXBlYXQnLFxuICAgICAqICAgb2Zmc2V0WDogMjAwLFxuICAgICAqICAgb2Zmc2V0WTogMTAwXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqL1xuICAgIHNldE92ZXJsYXlDb2xvcjogZnVuY3Rpb24ob3ZlcmxheUNvbG9yLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlDb2xvcignb3ZlcmxheUNvbG9yJywgb3ZlcmxheUNvbG9yLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZENvbG9yfGJhY2tncm91bmQgY29sb3J9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9IGJhY2tncm91bmRDb2xvciBDb2xvciBvciBwYXR0ZXJuIHRvIHNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYmFja2dyb3VuZCBjb2xvciBpcyBzZXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvaFh6dmsvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIGJhY2tncm91bmRDb2xvciAtIGNvbG9yIHZhbHVlPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3IoJ3JnYmEoMjU1LCA3MywgNjQsIDAuNiknLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBiYWNrZ3JvdW5kQ29sb3I8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJ1xuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIGJhY2tncm91bmRDb2xvciB3aXRoIHJlcGVhdCBhbmQgb2Zmc2V0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZycsXG4gICAgICogICByZXBlYXQ6ICdyZXBlYXQnLFxuICAgICAqICAgb2Zmc2V0WDogMjAwLFxuICAgICAqICAgb2Zmc2V0WTogMTAwXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqL1xuICAgIHNldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oYmFja2dyb3VuZENvbG9yLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlDb2xvcignYmFja2dyb3VuZENvbG9yJywgYmFja2dyb3VuZENvbG9yLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoe0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmRJbWFnZX1cbiAgICAgKiBvciB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5SW1hZ2V8b3ZlcmxheUltYWdlfSlcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nfG51bGwpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2UsIFVSTCBvZiBhbiBpbWFnZSBvciBudWxsIHRvIHNldCBiYWNrZ3JvdW5kIG9yIG92ZXJsYXkgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBiYWNrZ3JvdW5kIG9yIG92ZXJsYXkuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgY3JlYXRlZCBpbWFnZSwgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBhIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGFuIGVycm9yIG9jY3VycmVkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxpbWFnZX0uXG4gICAgICovXG4gICAgX19zZXRCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24ocHJvcGVydHksIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKGltYWdlLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgICAgICBpZiAoaW1nKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgZmFicmljLkltYWdlKGltZywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaW5zdGFuY2UuY2FudmFzID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW1nLCBpc0Vycm9yKTtcbiAgICAgICAgfSwgdGhpcywgb3B0aW9ucyAmJiBvcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zICYmIGltYWdlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gaW1hZ2U7XG4gICAgICAgIGltYWdlICYmIChpbWFnZS5jYW52YXMgPSB0aGlzKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW1hZ2UsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoe0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZENvbG9yfGJhY2tncm91bmRDb2xvcn1cbiAgICAgKiBvciB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5Q29sb3J8b3ZlcmxheUNvbG9yfSlcbiAgICAgKiBAcGFyYW0geyhPYmplY3R8U3RyaW5nfG51bGwpfSBjb2xvciBPYmplY3Qgd2l0aCBwYXR0ZXJuIGluZm9ybWF0aW9uLCBjb2xvciB2YWx1ZSBvciBudWxsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gY29sb3IgaXMgc2V0XG4gICAgICovXG4gICAgX19zZXRCZ092ZXJsYXlDb2xvcjogZnVuY3Rpb24ocHJvcGVydHksIGNvbG9yLCBjYWxsYmFjaykge1xuICAgICAgdGhpc1twcm9wZXJ0eV0gPSBjb2xvcjtcbiAgICAgIHRoaXMuX2luaXRHcmFkaWVudChjb2xvciwgcHJvcGVydHkpO1xuICAgICAgdGhpcy5faW5pdFBhdHRlcm4oY29sb3IsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB0aHJvdyBDQU5WQVNfSU5JVF9FUlJPUjtcbiAgICAgIH1cbiAgICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlID0geyB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmdldENvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0VsID0gdGhpcy5sb3dlckNhbnZhc0VsO1xuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgcGFyc2VJbnQobG93ZXJDYW52YXNFbC53aWR0aCwgMTApIHx8IDA7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuaGVpZ2h0IHx8IHBhcnNlSW50KGxvd2VyQ2FudmFzRWwuaGVpZ2h0LCAxMCkgfHwgMDtcblxuICAgICAgaWYgKCF0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb3dlckNhbnZhc0VsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIGxvd2VyQ2FudmFzRWwuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGxvd2VyQ2FudmFzRWwuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgIGxvd2VyQ2FudmFzRWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm90dG9tIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NhbnZhc0VsXVxuICAgICAqL1xuICAgIF9jcmVhdGVMb3dlckNhbnZhczogZnVuY3Rpb24gKGNhbnZhc0VsKSB7XG4gICAgICAvLyBjYW52YXNFbCA9PT0gJ0hUTUxDYW52YXNFbGVtZW50JyBkb2VzIG5vdCB3b3JrIG9uIGpzZG9tL25vZGVcbiAgICAgIGlmIChjYW52YXNFbCAmJiBjYW52YXNFbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGZhYnJpYy51dGlsLmdldEJ5SWQoY2FudmFzRWwpIHx8IHRoaXMuX2NyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5sb3dlckNhbnZhc0VsLCAnbG93ZXItY2FudmFzJyk7XG4gICAgICB0aGlzLl9vcmlnaW5hbENhbnZhc1N0eWxlID0gdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlO1xuICAgICAgaWYgKHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlDYW52YXNTdHlsZSh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHRDb250YWluZXIgPSB0aGlzLmxvd2VyQ2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYW52YXMgd2lkdGggKGluIHB4KVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIGhlaWdodCAoaW4gcHgpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdpZHRoIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZSB0byBzZXQgd2lkdGggdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXREaW1lbnNpb25zKHsgd2lkdGg6IHZhbHVlIH0sIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGhlaWdodCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgdG8gc2V0IGhlaWdodCB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICAgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmJhY2tzdG9yZU9ubHk9ZmFsc2VdIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNhbnZhcyBiYWNrc3RvcmUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuY3NzT25seT1mYWxzZV0gICAgICAgU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY3NzIGRpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldEhlaWdodDogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXREaW1lbnNpb25zKHsgaGVpZ2h0OiB2YWx1ZSB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBkaW1lbnNpb25zICh3aWR0aCwgaGVpZ2h0KSBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZS4gd2hlbiBvcHRpb25zLmNzc09ubHkgZmxhZyBhY3RpdmUgeW91IHNob3VsZCBhbHNvIHN1cHBseSB0aGUgdW5pdCBvZiBtZWFzdXJlIChweC8lL2VtKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgZGltZW5zaW9ucyAgICAgICAgICAgICAgICAgICAgT2JqZWN0IHdpdGggd2lkdGgvaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtkaW1lbnNpb25zLndpZHRoXSAgICAgICAgICAgIFdpZHRoIG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZGltZW5zaW9ucy5oZWlnaHRdICAgICAgICAgICBIZWlnaHQgb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbiAoZGltZW5zaW9ucywgb3B0aW9ucykge1xuICAgICAgdmFyIGNzc1ZhbHVlO1xuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBkaW1lbnNpb25zKSB7XG4gICAgICAgIGNzc1ZhbHVlID0gZGltZW5zaW9uc1twcm9wXTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuY3NzT25seSkge1xuICAgICAgICAgIHRoaXMuX3NldEJhY2tzdG9yZURpbWVuc2lvbihwcm9wLCBkaW1lbnNpb25zW3Byb3BdKTtcbiAgICAgICAgICBjc3NWYWx1ZSArPSAncHgnO1xuICAgICAgICAgIHRoaXMuaGFzTG9zdENvbnRleHQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmJhY2tzdG9yZU9ubHkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRDc3NEaW1lbnNpb24ocHJvcCwgY3NzVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2guX3NldEJydXNoU3R5bGVzKHRoaXMuY29udGV4dFRvcCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5jc3NPbmx5KSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZvciBzZXR0aW5nIHdpZHRoL2hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgcHJvcGVydHkgKHdpZHRofGhlaWdodClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gc2V0IHByb3BlcnR5IHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBfc2V0QmFja3N0b3JlRGltZW5zaW9uOiBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbFtwcm9wXSA9IHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy51cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbFtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYWNoZUNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMuY2FjaGVDYW52YXNFbFtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZm9yIHNldHRpbmcgY3NzIHdpZHRoL2hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgcHJvcGVydHkgKHdpZHRofGhlaWdodClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdmFsdWUgdG8gc2V0IHByb3BlcnR5IHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBfc2V0Q3NzRGltZW5zaW9uOiBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy51cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy53cmFwcGVyRWwpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIHpvb20gbGV2ZWxcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Wm9vbTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bMF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmlld3BvcnQgdHJhbnNmb3JtYXRpb24gb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2cHQgYSBDYW52YXMgMkQgQVBJIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldFZpZXdwb3J0VHJhbnNmb3JtOiBmdW5jdGlvbiAodnB0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGJhY2tncm91bmRPYmplY3QgPSB0aGlzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICBvdmVybGF5T2JqZWN0ID0gdGhpcy5vdmVybGF5SW1hZ2UsXG4gICAgICAgICAgb2JqZWN0LCBpLCBsZW47XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdnB0O1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICBvYmplY3QuZ3JvdXAgfHwgb2JqZWN0LnNldENvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgYWN0aXZlT2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgaWYgKGJhY2tncm91bmRPYmplY3QpIHtcbiAgICAgICAgYmFja2dyb3VuZE9iamVjdC5zZXRDb29yZHModHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcmxheU9iamVjdCkge1xuICAgICAgICBvdmVybGF5T2JqZWN0LnNldENvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHpvb20gbGV2ZWwgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UsIHRoZSB6b29tIGNlbnRlcmVkIGFyb3VuZCBwb2ludFxuICAgICAqIG1lYW5pbmcgdGhhdCBmb2xsb3dpbmcgem9vbSB0byBwb2ludCB3aXRoIHRoZSBzYW1lIHBvaW50IHdpbGwgaGF2ZSB0aGUgdmlzdWFsXG4gICAgICogZWZmZWN0IG9mIHRoZSB6b29tIG9yaWdpbmF0aW5nIGZyb20gdGhhdCBwb2ludC4gVGhlIHBvaW50IHdvbid0IG1vdmUuXG4gICAgICogSXQgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCBjYW52YXMgY2VudGVyIG9yIHZpc3VhbCBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCB0byB6b29tIHdpdGggcmVzcGVjdCB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB0byBzZXQgem9vbSB0bywgbGVzcyB0aGFuIDEgem9vbXMgb3V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICB6b29tVG9Qb2ludDogZnVuY3Rpb24gKHBvaW50LCB2YWx1ZSkge1xuICAgICAgLy8gVE9ETzoganVzdCBjaGFuZ2UgdGhlIHNjYWxlLCBwcmVzZXJ2ZSBvdGhlciB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIHZhciBiZWZvcmUgPSBwb2ludCwgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgwKTtcbiAgICAgIHBvaW50ID0gdHJhbnNmb3JtUG9pbnQocG9pbnQsIGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKSk7XG4gICAgICB2cHRbMF0gPSB2YWx1ZTtcbiAgICAgIHZwdFszXSA9IHZhbHVlO1xuICAgICAgdmFyIGFmdGVyID0gdHJhbnNmb3JtUG9pbnQocG9pbnQsIHZwdCk7XG4gICAgICB2cHRbNF0gKz0gYmVmb3JlLnggLSBhZnRlci54O1xuICAgICAgdnB0WzVdICs9IGJlZm9yZS55IC0gYWZ0ZXIueTtcbiAgICAgIHJldHVybiB0aGlzLnNldFZpZXdwb3J0VHJhbnNmb3JtKHZwdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgem9vbSBsZXZlbCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB0byBzZXQgem9vbSB0bywgbGVzcyB0aGFuIDEgem9vbXMgb3V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRab29tOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMuem9vbVRvUG9pbnQobmV3IGZhYnJpYy5Qb2ludCgwLCAwKSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbiB2aWV3cG9ydCBzbyBhcyB0byBwbGFjZSBwb2ludCBhdCB0b3AgbGVmdCBjb3JuZXIgb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IHRvIG1vdmUgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIGFic29sdXRlUGFuOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHZhciB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLnNsaWNlKDApO1xuICAgICAgdnB0WzRdID0gLXBvaW50Lng7XG4gICAgICB2cHRbNV0gPSAtcG9pbnQueTtcbiAgICAgIHJldHVybiB0aGlzLnNldFZpZXdwb3J0VHJhbnNmb3JtKHZwdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbnMgdmlld3BvaW50IHJlbGF0aXZlbHlcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgKHBvc2l0aW9uIHZlY3RvcikgdG8gbW92ZSBieVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgcmVsYXRpdmVQYW46IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzb2x1dGVQYW4obmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgLXBvaW50LnggLSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzRdLFxuICAgICAgICAtcG9pbnQueSAtIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bNV1cbiAgICAgICkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zICZsdDtjYW52YXM+IGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGlzIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubG93ZXJDYW52YXNFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdGhhdCB3YXMgYWRkZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RBZGRlZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB0aGlzLnN0YXRlZnVsICYmIG9iai5zZXR1cFN0YXRlKCk7XG4gICAgICBvYmouX3NldCgnY2FudmFzJywgdGhpcyk7XG4gICAgICBvYmouc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmZpcmUoJ29iamVjdDphZGRlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICBvYmouZmlyZSgnYWRkZWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdGhhdCB3YXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6cmVtb3ZlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICBvYmouZmlyZSgncmVtb3ZlZCcpO1xuICAgICAgZGVsZXRlIG9iai5jYW52YXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBzcGVjaWZpZWQgY29udGV4dCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBjbGVhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2xlYXJDb250ZXh0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udGV4dCBvZiBjYW52YXMgd2hlcmUgb2JqZWN0cyBhcmUgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dENvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjb250ZXh0cyAoYmFja2dyb3VuZCwgbWFpbiwgdG9wKSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVtb3ZlLmFwcGx5KHRoaXMsIHRoaXMuZ2V0T2JqZWN0cygpKTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlID0gbnVsbDtcbiAgICAgIHRoaXMub3ZlcmxheUltYWdlID0gbnVsbDtcbiAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJyc7XG4gICAgICB0aGlzLm92ZXJsYXlDb2xvciA9ICcnO1xuICAgICAgaWYgKHRoaXMuX2hhc0lUZXh0SGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy5vZmYoJ21vdXNlOnVwJywgdGhpcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuX2lUZXh0SW5zdGFuY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGFzSVRleHRIYW5kbGVycyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhckNvbnRleHQodGhpcy5jb250ZXh0Q29udGFpbmVyKTtcbiAgICAgIHRoaXMuZmlyZSgnY2FudmFzOmNsZWFyZWQnKTtcbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY2FudmFzXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FudmFzVG9EcmF3T24gPSB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNUb0RyYXdPbiwgdGhpcy5fb2JqZWN0cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gY3JlYXRlZCB0byBiZSBpbnN0YW5jZSBib3VuZCBhdCBpbml0aWFsaXphdGlvblxuICAgICAqIHVzZWQgaW4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHJlbmRlcmluZ1xuICAgICAqIExldCB0aGUgZmFicmljSlMgY2FsbCBpdC4gSWYgeW91IGNhbGwgaXQgbWFudWFsbHkgeW91IGNvdWxkIGhhdmUgbW9yZVxuICAgICAqIGFuaW1hdGlvbkZyYW1lIHN0YWNraW5nIG9uIHRvIG9mIGVhY2ggb3RoZXJcbiAgICAgKiBmb3IgYW4gaW1wZXJhdGl2ZSByZW5kZXJpbmcsIHVzZSBjYW52YXMucmVuZGVyQWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbmRSZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhIHJlbmRlckFsbCByZXF1ZXN0IHRvIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqIHVubGVzcyBvbmUgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgaW4gdGhhdCBjYXNlIG5vdGhpbmcgaXMgZG9uZVxuICAgICAqIGEgYm9vbGVhbiBmbGFnIHdpbGwgYXZvaWQgYXBwZW5kaW5nIG1vcmUuXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVxdWVzdFJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWJyaWMudXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgNCBjb3JuZXIgb2YgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBoZWxwcyB0byBkZXRlcm1pbmF0ZSB3aGVuIGFuIG9iamVjdCBpcyBpbiB0aGUgY3VycmVudCByZW5kZXJpbmcgdmlld3BvcnQgdXNpbmdcbiAgICAgKiBvYmplY3QgYWJzb2x1dGUgY29vcmRpbmF0ZXMgKCBhQ29vcmRzIClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBvaW50cy50bFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjYWxjVmlld3BvcnRCb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSB7IH0sIHdpZHRoID0gdGhpcy53aWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgICAgaVZwdCA9IGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHBvaW50cy50bCA9IHRyYW5zZm9ybVBvaW50KHsgeDogMCwgeTogMCB9LCBpVnB0KTtcbiAgICAgIHBvaW50cy5iciA9IHRyYW5zZm9ybVBvaW50KHsgeDogd2lkdGgsIHk6IGhlaWdodCB9LCBpVnB0KTtcbiAgICAgIHBvaW50cy50ciA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzLmJyLngsIHBvaW50cy50bC55KTtcbiAgICAgIHBvaW50cy5ibCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzLnRsLngsIHBvaW50cy5ici55KTtcbiAgICAgIHRoaXMudnB0Q29vcmRzID0gcG9pbnRzO1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9LFxuXG4gICAgY2FuY2VsUmVxdWVzdGVkUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLmlzUmVuZGVyaW5nKTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYmFja2dyb3VuZCwgb2JqZWN0cywgb3ZlcmxheSBhbmQgY29udHJvbHMuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQ2FudmFzOiBmdW5jdGlvbihjdHgsIG9iamVjdHMpIHtcbiAgICAgIHZhciB2ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgcGF0aCA9IHRoaXMuY2xpcFBhdGg7XG4gICAgICB0aGlzLmNhbmNlbFJlcXVlc3RlZFJlbmRlcigpO1xuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgZmFicmljLnV0aWwuc2V0SW1hZ2VTbW9vdGhpbmcoY3R4LCB0aGlzLmltYWdlU21vb3RoaW5nRW5hYmxlZCk7XG4gICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpyZW5kZXInLCB7IGN0eDogY3R4LCB9KTtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoY3R4KTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vYXBwbHkgdmlld3BvcnQgdHJhbnNmb3JtIG9uY2UgZm9yIGFsbCByZW5kZXJpbmcgcHJvY2Vzc1xuICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgIHRoaXMuX3JlbmRlck9iamVjdHMoY3R4LCBvYmplY3RzKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBpZiAoIXRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcGF0aC5jYW52YXMgPSB0aGlzO1xuICAgICAgICAvLyBuZWVkZWQgdG8gc2V0dXAgYSBjb3VwbGUgb2YgdmFyaWFibGVzXG4gICAgICAgIHBhdGguc2hvdWxkQ2FjaGUoKTtcbiAgICAgICAgcGF0aC5fdHJhbnNmb3JtRG9uZSA9IHRydWU7XG4gICAgICAgIHBhdGgucmVuZGVyQ2FjaGUoeyBmb3JDbGlwcGluZzogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5kcmF3Q2xpcFBhdGhPbkNhbnZhcyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyT3ZlcmxheShjdHgpO1xuICAgICAgaWYgKHRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInLCB7IGN0eDogY3R4LCB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIGNhY2hlZCBjbGlwUGF0aCBvbiB0aGUgbG93ZXJDYW52YXNFbFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2xpcFBhdGhPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIHBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICAvLyBERUJVRzogdW5jb21tZW50IHRoaXMgbGluZSwgY29tbWVudCB0aGUgZm9sbG93aW5nXG4gICAgICAvLyBjdHguZ2xvYmFsQWxwaGEgPSAwLjQ7XG4gICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgIHBhdGgudHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHguc2NhbGUoMSAvIHBhdGguem9vbVgsIDEgLyBwYXRoLnpvb21ZKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UocGF0aC5fY2FjaGVDYW52YXMsIC1wYXRoLmNhY2hlVHJhbnNsYXRpb25YLCAtcGF0aC5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlclxuICAgICAqL1xuICAgIF9yZW5kZXJPYmplY3RzOiBmdW5jdGlvbihjdHgsIG9iamVjdHMpIHtcbiAgICAgIHZhciBpLCBsZW47XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIG9iamVjdHNbaV0gJiYgb2JqZWN0c1tpXS5yZW5kZXIoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5ICdiYWNrZ3JvdW5kJyBvciAnb3ZlcmxheSdcbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheTogZnVuY3Rpb24oY3R4LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIGZpbGwgPSB0aGlzW3Byb3BlcnR5ICsgJ0NvbG9yJ10sIG9iamVjdCA9IHRoaXNbcHJvcGVydHkgKyAnSW1hZ2UnXSxcbiAgICAgICAgICB2ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgbmVlZHNWcHQgPSB0aGlzW3Byb3BlcnR5ICsgJ1ZwdCddO1xuICAgICAgaWYgKCFmaWxsICYmICFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHgubGluZVRvKHRoaXMud2lkdGgsIDApO1xuICAgICAgICBjdHgubGluZVRvKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwudG9MaXZlXG4gICAgICAgICAgPyBmaWxsLnRvTGl2ZShjdHgsIHRoaXMpXG4gICAgICAgICAgOiBmaWxsO1xuICAgICAgICBpZiAobmVlZHNWcHQpIHtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgZmlsbC5vZmZzZXRYIHx8IDAsIGZpbGwub2Zmc2V0WSB8fCAwKTtcbiAgICAgICAgdmFyIG0gPSBmaWxsLmdyYWRpZW50VHJhbnNmb3JtIHx8IGZpbGwucGF0dGVyblRyYW5zZm9ybTtcbiAgICAgICAgbSAmJiBjdHgudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZiAobmVlZHNWcHQpIHtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5yZW5kZXIoY3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheShjdHgsICdiYWNrZ3JvdW5kJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJPdmVybGF5OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXkoY3R4LCAnb3ZlcmxheScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgY2VudGVyIG9mIGNhbnZhcy5cbiAgICAgKiBSZXR1cm5lZCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCB0b3AgYW5kIGxlZnQgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0aGlzLmhlaWdodCAvIDIsXG4gICAgICAgIGxlZnQ6IHRoaXMud2lkdGggLyAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqL1xuICAgIGNlbnRlck9iamVjdEg6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHRoaXMuZ2V0Q2VudGVyKCkubGVmdCwgb2JqZWN0LmdldENlbnRlclBvaW50KCkueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGluIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdFY6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLngsIHRoaXMuZ2V0Q2VudGVyKCkudG9wKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQoY2VudGVyLmxlZnQsIGNlbnRlci50b3ApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCB2cENlbnRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBpbiB0aGUgdmlld3BvcnQsIG9iamVjdC50b3AgaXMgdW5jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0SDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG4gICAgICB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHZwQ2VudGVyLngsIG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLnkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBWZXJ0aWNhbGx5IGluIHRoZSB2aWV3cG9ydCwgb2JqZWN0LnRvcCBpcyB1bmNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3RWOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQob2JqZWN0LmdldENlbnRlclBvaW50KCkueCwgdnBDZW50ZXIueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50IGluIGNhbnZhcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIGNlbnRlciBvZiBhY3R1YWwgdmlld3BvcnQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB2cENlbnRlciwgdmlld3BvcnQgY2VudGVyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGdldFZwQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxuICAgICAgICAgIGlWcHQgPSBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtUG9pbnQoeyB4OiBjZW50ZXIubGVmdCwgeTogY2VudGVyLnRvcCB9LCBpVnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciBDZW50ZXIgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9jZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3MgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBqc29uIHN0cmluZ1xuICAgICAqL1xuICAgIHRvRGF0YWxlc3NKU09OOiBmdW5jdGlvbiAocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9EYXRhbGVzc09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3RNZXRob2QoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3RNZXRob2QoJ3RvRGF0YWxlc3NPYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3RNZXRob2Q6IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG5cbiAgICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGgsIGRhdGEgPSB7XG4gICAgICAgIHZlcnNpb246IGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICBvYmplY3RzOiB0aGlzLl90b09iamVjdHMobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSksXG4gICAgICB9O1xuICAgICAgaWYgKGNsaXBQYXRoICYmICFjbGlwUGF0aC5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBkYXRhLmNsaXBQYXRoID0gdGhpcy5fdG9PYmplY3QodGhpcy5jbGlwUGF0aCwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9XG4gICAgICBleHRlbmQoZGF0YSwgdGhpcy5fX3NlcmlhbGl6ZUJnT3ZlcmxheShtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG5cbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgZGF0YSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdHM6IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmZpbHRlcihmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuICFvYmplY3QuZXhjbHVkZUZyb21FeHBvcnQ7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0KGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvcmlnaW5hbFZhbHVlO1xuXG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSA9IGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0ID0gaW5zdGFuY2VbbWV0aG9kTmFtZV0ocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3NlcmlhbGl6ZUJnT3ZlcmxheTogZnVuY3Rpb24obWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIGRhdGEgPSB7fSwgYmdJbWFnZSA9IHRoaXMuYmFja2dyb3VuZEltYWdlLCBvdmVybGF5SW1hZ2UgPSB0aGlzLm92ZXJsYXlJbWFnZSxcbiAgICAgICAgICBiZ0NvbG9yID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IsIG92ZXJsYXlDb2xvciA9IHRoaXMub3ZlcmxheUNvbG9yO1xuXG4gICAgICBpZiAoYmdDb2xvciAmJiBiZ0NvbG9yLnRvT2JqZWN0KSB7XG4gICAgICAgIGlmICghYmdDb2xvci5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICAgIGRhdGEuYmFja2dyb3VuZCA9IGJnQ29sb3IudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgZGF0YS5iYWNrZ3JvdW5kID0gYmdDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKG92ZXJsYXlDb2xvciAmJiBvdmVybGF5Q29sb3IudG9PYmplY3QpIHtcbiAgICAgICAgaWYgKCFvdmVybGF5Q29sb3IuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBkYXRhLm92ZXJsYXkgPSBvdmVybGF5Q29sb3IudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG92ZXJsYXlDb2xvcikge1xuICAgICAgICBkYXRhLm92ZXJsYXkgPSBvdmVybGF5Q29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChiZ0ltYWdlICYmICFiZ0ltYWdlLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgIGRhdGEuYmFja2dyb3VuZEltYWdlID0gdGhpcy5fdG9PYmplY3QoYmdJbWFnZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcmxheUltYWdlICYmICFvdmVybGF5SW1hZ2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgZGF0YS5vdmVybGF5SW1hZ2UgPSB0aGlzLl90b09iamVjdChvdmVybGF5SW1hZ2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGdldFN2Z1RyYW5zZm9ybSgpIHdpbGwgYXBwbHkgdGhlIFN0YXRpY0NhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSB0byB0aGUgU1ZHIHRyYW5zZm9ybWF0aW9uLiBXaGVuIHRydWUsXG4gICAgICogYSB6b29tZWQgY2FudmFzIHdpbGwgdGhlbiBwcm9kdWNlIHpvb21lZCBTVkcgb3V0cHV0LlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb246IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IGZvciBTVkcgb3V0cHV0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdXBwcmVzc1ByZWFtYmxlPWZhbHNlXSBJZiB0cnVlIHhtbCB0YWcgaXMgbm90IGluY2x1ZGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnZpZXdCb3hdIFNWRyB2aWV3Ym94IG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LnhdIHgtY29vcmRpbmF0ZSBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gueV0geS1jb29yZGluYXRlIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC53aWR0aF0gV2lkdGggb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LmhlaWdodF0gSGVpZ2h0IG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9VVRGLThdIEVuY29kaW5nIG9mIFNWRyBvdXRwdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2lkdGhdIGRlc2lyZWQgd2lkdGggb2Ygc3ZnIHdpdGggb3Igd2l0aG91dCB1bml0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5oZWlnaHRdIGRlc2lyZWQgaGVpZ2h0IG9mIHN2ZyB3aXRoIG9yIHdpdGhvdXQgdW5pdHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNvbnZlcnRlZCBpbnRvIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyBzdHJpbmdcbiAgICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNzZXJpYWxpemF0aW9ufVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvalEzWlovfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIFNWRyBvdXRwdXQ8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRygpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aG91dCBwcmVhbWJsZSAod2l0aG91dCAmbHQ7P3htbCAuLi8+KTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtzdXBwcmVzc1ByZWFtYmxlOiB0cnVlfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRoIHZpZXdCb3ggYXR0cmlidXRlPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe1xuICAgICAqICAgdmlld0JveDoge1xuICAgICAqICAgICB4OiAxMDAsXG4gICAgICogICAgIHk6IDEwMCxcbiAgICAgKiAgICAgd2lkdGg6IDIwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAzMDBcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGggZGlmZmVyZW50IGVuY29kaW5nIChkZWZhdWx0OiBVVEYtOCk8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7ZW5jb2Rpbmc6ICdJU08tODg1OS0xJ30pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk1vZGlmeSBTVkcgb3V0cHV0IHdpdGggcmV2aXZlciBmdW5jdGlvbjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKG51bGwsIGZ1bmN0aW9uKHN2Zykge1xuICAgICAqICAgcmV0dXJuIHN2Zy5yZXBsYWNlKCdzdHJva2UtZGFzaGFycmF5OiA7IHN0cm9rZS1saW5lY2FwOiBidXR0OyBzdHJva2UtbGluZWpvaW46IG1pdGVyOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7ICcsICcnKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob3B0aW9ucywgcmV2aXZlcikge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICBvcHRpb25zLnJldml2ZXIgPSByZXZpdmVyO1xuICAgICAgdmFyIG1hcmt1cCA9IFtdO1xuXG4gICAgICB0aGlzLl9zZXRTVkdQcmVhbWJsZShtYXJrdXAsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0U1ZHSGVhZGVyKG1hcmt1cCwgb3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaCgnPGcgY2xpcC1wYXRoPVwidXJsKCMnICsgdGhpcy5jbGlwUGF0aC5jbGlwUGF0aElkICsgJylcIiA+XFxuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlDb2xvcihtYXJrdXAsICdiYWNrZ3JvdW5kJyk7XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShtYXJrdXAsICdiYWNrZ3JvdW5kSW1hZ2UnLCByZXZpdmVyKTtcbiAgICAgIHRoaXMuX3NldFNWR09iamVjdHMobWFya3VwLCByZXZpdmVyKTtcbiAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlDb2xvcihtYXJrdXAsICdvdmVybGF5Jyk7XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShtYXJrdXAsICdvdmVybGF5SW1hZ2UnLCByZXZpdmVyKTtcblxuICAgICAgbWFya3VwLnB1c2goJzwvc3ZnPicpO1xuXG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdQcmVhbWJsZTogZnVuY3Rpb24obWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1ByZWFtYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiJywgKG9wdGlvbnMuZW5jb2RpbmcgfHwgJ1VURi04JyksICdcIiBzdGFuZGFsb25lPVwibm9cIiA/PlxcbicsXG4gICAgICAgICc8IURPQ1RZUEUgc3ZnIFBVQkxJQyBcIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOXCIgJyxcbiAgICAgICAgJ1wiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkXCI+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHSGVhZGVyOiBmdW5jdGlvbihtYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB0aGlzLmhlaWdodCxcbiAgICAgICAgICB2cHQsIHZpZXdCb3ggPSAndmlld0JveD1cIjAgMCAnICsgdGhpcy53aWR0aCArICcgJyArIHRoaXMuaGVpZ2h0ICsgJ1wiICcsXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcblxuICAgICAgaWYgKG9wdGlvbnMudmlld0JveCkge1xuICAgICAgICB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCInICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gueCArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LnkgKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC53aWR0aCArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LmhlaWdodCArICdcIiAnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb24pIHtcbiAgICAgICAgICB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgICAgIHZpZXdCb3ggPSAndmlld0JveD1cIicgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCgtdnB0WzRdIC8gdnB0WzBdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKC12cHRbNV0gLyB2cHRbM10sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCAvIHZwdFswXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCAvIHZwdFszXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxzdmcgJyxcbiAgICAgICAgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnLFxuICAgICAgICAneG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgJyxcbiAgICAgICAgJ3ZlcnNpb249XCIxLjFcIiAnLFxuICAgICAgICAnd2lkdGg9XCInLCB3aWR0aCwgJ1wiICcsXG4gICAgICAgICdoZWlnaHQ9XCInLCBoZWlnaHQsICdcIiAnLFxuICAgICAgICB2aWV3Qm94LFxuICAgICAgICAneG1sOnNwYWNlPVwicHJlc2VydmVcIj5cXG4nLFxuICAgICAgICAnPGRlc2M+Q3JlYXRlZCB3aXRoIEZhYnJpYy5qcyAnLCBmYWJyaWMudmVyc2lvbiwgJzwvZGVzYz5cXG4nLFxuICAgICAgICAnPGRlZnM+XFxuJyxcbiAgICAgICAgdGhpcy5jcmVhdGVTVkdGb250RmFjZXNNYXJrdXAoKSxcbiAgICAgICAgdGhpcy5jcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cCgpLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR0NsaXBQYXRoTWFya3VwKG9wdGlvbnMpLFxuICAgICAgICAnPC9kZWZzPlxcbidcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVNWR0NsaXBQYXRoTWFya3VwOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoLmNsaXBQYXRoSWQgPSAnQ0xJUFBBVEhfJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgcmV0dXJuICAnPGNsaXBQYXRoIGlkPVwiJyArIGNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnXCIgPlxcbicgK1xuICAgICAgICAgIHRoaXMuY2xpcFBhdGgudG9DbGlwUGF0aFNWRyhvcHRpb25zLnJldml2ZXIpICtcbiAgICAgICAgICAnPC9jbGlwUGF0aD5cXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG1hcmt1cCBjb250YWluaW5nIFNWRyByZWZlcmVuY2VkIGVsZW1lbnRzIGxpa2UgcGF0dGVybnMsIGdyYWRpZW50cyBldGMuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgbWFya3VwID0gWydiYWNrZ3JvdW5kJywgJ292ZXJsYXknXS5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBfdGhpc1twcm9wICsgJ0NvbG9yJ107XG4gICAgICAgICAgICBpZiAoZmlsbCAmJiBmaWxsLnRvTGl2ZSkge1xuICAgICAgICAgICAgICB2YXIgc2hvdWxkVHJhbnNmb3JtID0gX3RoaXNbcHJvcCArICdWcHQnXSwgdnB0ID0gX3RoaXMudmlld3BvcnRUcmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICBvYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfdGhpcy53aWR0aCAvIChzaG91bGRUcmFuc2Zvcm0gPyB2cHRbMF0gOiAxKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfdGhpcy5oZWlnaHQgLyAoc2hvdWxkVHJhbnNmb3JtID8gdnB0WzNdIDogMSlcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBmaWxsLnRvU1ZHKFxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgICB7IGFkZGl0aW9uYWxUcmFuc2Zvcm06IHNob3VsZFRyYW5zZm9ybSA/IGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKHZwdCkgOiAnJyB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG1hcmt1cCBjb250YWluaW5nIFNWRyBmb250IGZhY2VzLFxuICAgICAqIGZvbnQgVVJMcyBmb3IgZm9udCBmYWNlcyBtdXN0IGJlIGNvbGxlY3RlZCBieSBkZXZlbG9wZXJzXG4gICAgICogYW5kIGFyZSBub3QgZXh0cmFjdGVkIGZyb20gdGhlIERPTSBieSBmYWJyaWNqc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgQXJyYXkgb2YgZmFicmljIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgY3JlYXRlU1ZHRm9udEZhY2VzTWFya3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrdXAgPSAnJywgZm9udExpc3QgPSB7IH0sIG9iaiwgZm9udEZhbWlseSxcbiAgICAgICAgICBzdHlsZSwgcm93LCByb3dJbmRleCwgX2NoYXIsIGNoYXJJbmRleCwgaSwgbGVuLFxuICAgICAgICAgIGZvbnRQYXRocyA9IGZhYnJpYy5mb250UGF0aHMsIG9iamVjdHMgPSBbXTtcblxuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QuX29iamVjdHMpIHtcbiAgICAgICAgICBvYmplY3QuX29iamVjdHMuZm9yRWFjaChhZGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvYmogPSBvYmplY3RzW2ldO1xuICAgICAgICBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHk7XG4gICAgICAgIGlmIChvYmoudHlwZS5pbmRleE9mKCd0ZXh0JykgPT09IC0xIHx8IGZvbnRMaXN0W2ZvbnRGYW1pbHldIHx8ICFmb250UGF0aHNbZm9udEZhbWlseV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb250TGlzdFtmb250RmFtaWx5XSA9IHRydWU7XG4gICAgICAgIGlmICghb2JqLnN0eWxlcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlID0gb2JqLnN0eWxlcztcbiAgICAgICAgZm9yIChyb3dJbmRleCBpbiBzdHlsZSkge1xuICAgICAgICAgIHJvdyA9IHN0eWxlW3Jvd0luZGV4XTtcbiAgICAgICAgICBmb3IgKGNoYXJJbmRleCBpbiByb3cpIHtcbiAgICAgICAgICAgIF9jaGFyID0gcm93W2NoYXJJbmRleF07XG4gICAgICAgICAgICBmb250RmFtaWx5ID0gX2NoYXIuZm9udEZhbWlseTtcbiAgICAgICAgICAgIGlmICghZm9udExpc3RbZm9udEZhbWlseV0gJiYgZm9udFBhdGhzW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgICAgICAgIGZvbnRMaXN0W2ZvbnRGYW1pbHldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiBpbiBmb250TGlzdCkge1xuICAgICAgICBtYXJrdXAgKz0gW1xuICAgICAgICAgICdcXHRcXHRAZm9udC1mYWNlIHtcXG4nLFxuICAgICAgICAgICdcXHRcXHRcXHRmb250LWZhbWlseTogXFwnJywgaiwgJ1xcJztcXG4nLFxuICAgICAgICAgICdcXHRcXHRcXHRzcmM6IHVybChcXCcnLCBmb250UGF0aHNbal0sICdcXCcpO1xcbicsXG4gICAgICAgICAgJ1xcdFxcdH1cXG4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICdcXHQ8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+JyxcbiAgICAgICAgICAnPCFbQ0RBVEFbXFxuJyxcbiAgICAgICAgICBtYXJrdXAsXG4gICAgICAgICAgJ11dPicsXG4gICAgICAgICAgJzwvc3R5bGU+XFxuJ1xuICAgICAgICBdLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3RzOiBmdW5jdGlvbihtYXJrdXAsIHJldml2ZXIpIHtcbiAgICAgIHZhciBpbnN0YW5jZSwgaSwgbGVuLCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cztcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYmplY3RzW2ldO1xuICAgICAgICBpZiAoaW5zdGFuY2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdPYmplY3QobWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgbWFya3VwLnB1c2goaW5zdGFuY2UudG9TVkcocmV2aXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24obWFya3VwLCBwcm9wZXJ0eSwgcmV2aXZlcikge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICYmICF0aGlzW3Byb3BlcnR5XS5leGNsdWRlRnJvbUV4cG9ydCAmJiB0aGlzW3Byb3BlcnR5XS50b1NWRykge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzW3Byb3BlcnR5XS50b1NWRyhyZXZpdmVyKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR0JnT3ZlcmxheUNvbG9yOiBmdW5jdGlvbihtYXJrdXAsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgZmlsbGVyID0gdGhpc1twcm9wZXJ0eSArICdDb2xvciddLCB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLCBmaW5hbFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBmaW5hbEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgaWYgKCFmaWxsZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgdmFyIHJlcGVhdCA9IGZpbGxlci5yZXBlYXQsIGlWcHQgPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odnB0KSwgc2hvdWxkSW52ZXJ0ID0gdGhpc1twcm9wZXJ0eSArICdWcHQnXSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSBzaG91bGRJbnZlcnQgPyBmYWJyaWMudXRpbC5tYXRyaXhUb1NWRyhpVnB0KSA6ICcnO1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgdHJhbnNmb3JtPVwiJyArIGFkZGl0aW9uYWxUcmFuc2Zvcm0gKyAnIHRyYW5zbGF0ZSgnLCBmaW5hbFdpZHRoIC8gMiwgJywnLCBmaW5hbEhlaWdodCAvIDIsICcpXCInLFxuICAgICAgICAgICcgeD1cIicsIGZpbGxlci5vZmZzZXRYIC0gZmluYWxXaWR0aCAvIDIsXG4gICAgICAgICAgJ1wiIHk9XCInLCBmaWxsZXIub2Zmc2V0WSAtIGZpbmFsSGVpZ2h0IC8gMiwgJ1wiICcsXG4gICAgICAgICAgJ3dpZHRoPVwiJyxcbiAgICAgICAgICAocmVwZWF0ID09PSAncmVwZWF0LXknIHx8IHJlcGVhdCA9PT0gJ25vLXJlcGVhdCdcbiAgICAgICAgICAgID8gZmlsbGVyLnNvdXJjZS53aWR0aFxuICAgICAgICAgICAgOiBmaW5hbFdpZHRoICksXG4gICAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgICAgKHJlcGVhdCA9PT0gJ3JlcGVhdC14JyB8fCByZXBlYXQgPT09ICduby1yZXBlYXQnXG4gICAgICAgICAgICA/IGZpbGxlci5zb3VyY2UuaGVpZ2h0XG4gICAgICAgICAgICA6IGZpbmFsSGVpZ2h0KSxcbiAgICAgICAgICAnXCIgZmlsbD1cInVybCgjU1ZHSURfJyArIGZpbGxlci5pZCArICcpXCInLFxuICAgICAgICAgICc+PC9yZWN0PlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiAnLFxuICAgICAgICAgICdmaWxsPVwiJywgZmlsbGVyLCAnXCInLFxuICAgICAgICAgICc+PC9yZWN0PlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIHRoZSBvYmplY3RzIG9mIGEgbXVsdGlwbGUgc2VsZWN0aW9uXG4gICAgICogdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kIHRvIGJhY2tcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbmRUb0JhY2s6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIHRoZSBvYmplY3RzIG9mIGEgbXVsdGlwbGUgc2VsZWN0aW9uXG4gICAgICogdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIGEgc2VsZWN0aW9uIGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEFuIG9wdGlvbmFsIHBhcmFtZXRlciwgaW50ZXJzZWN0aW5nIGFsbG93cyB0byBtb3ZlIHRoZSBvYmplY3QgaW4gYmVoaW5kXG4gICAgICogdGhlIGZpcnN0IGludGVyc2VjdGluZyBvYmplY3QuIFdoZXJlIGludGVyc2VjdGlvbiBpcyBjYWxjdWxhdGVkIHdpdGhcbiAgICAgKiBib3VuZGluZyBib3guIElmIG5vIGludGVyc2VjdGlvbiBpcyBmb3VuZCwgdGhlcmUgd2lsbCBub3QgYmUgY2hhbmdlIGluIHRoZVxuICAgICAqIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGJlaGluZCBuZXh0IGxvd2VyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uIChvYmplY3QsIGludGVyc2VjdGluZykge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgaWR4LCBuZXdJZHgsIG9ianMsIG9ianNNb3ZlZCA9IDA7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmopO1xuICAgICAgICAgIGlmIChpZHggPiAwICsgb2Jqc01vdmVkKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpZHggLSAxO1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ianNNb3ZlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgICAgIGlmIChpZHggIT09IDApIHtcbiAgICAgICAgICAvLyBpZiBvYmplY3QgaXMgbm90IG9uIHRoZSBib3R0b20gb2Ygc3RhY2tcbiAgICAgICAgICBuZXdJZHggPSB0aGlzLl9maW5kTmV3TG93ZXJJbmRleChvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE5ld0xvd2VySW5kZXg6IGZ1bmN0aW9uKG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIHZhciBuZXdJZHgsIGk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4O1xuXG4gICAgICAgIC8vIHRyYXZlcnNlIGRvd24gdGhlIHN0YWNrIGxvb2tpbmcgZm9yIHRoZSBuZWFyZXN0IGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgICAgZm9yIChpID0gaWR4IC0gMTsgaSA+PSAwOyAtLWkpIHtcblxuICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IG9iamVjdC5pbnRlcnNlY3RzV2l0aE9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uaXNDb250YWluZWRXaXRoaW5PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgbmV3SWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJZHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciBhIHNlbGVjdGlvbiB1cCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQW4gb3B0aW9uYWwgcGFyYW1ldGVyLCBpbnRlcnNlY3RpbmcgYWxsb3dzIHRvIG1vdmUgdGhlIG9iamVjdCBpbiBmcm9udFxuICAgICAqIG9mIHRoZSBmaXJzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0LiBXaGVyZSBpbnRlcnNlY3Rpb24gaXMgY2FsY3VsYXRlZCB3aXRoXG4gICAgICogYm91bmRpbmcgYm94LiBJZiBubyBpbnRlcnNlY3Rpb24gaXMgZm91bmQsIHRoZXJlIHdpbGwgbm90IGJlIGNoYW5nZSBpbiB0aGVcbiAgICAgKiBzdGFjay5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBpbiBmcm9udCBvZiBuZXh0IHVwcGVyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJyaW5nRm9yd2FyZDogZnVuY3Rpb24gKG9iamVjdCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBpZHgsIG5ld0lkeCwgb2Jqcywgb2Jqc01vdmVkID0gMDtcblxuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSBvYmpzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iaik7XG4gICAgICAgICAgaWYgKGlkeCA8IHRoaXMuX29iamVjdHMubGVuZ3RoIC0gMSAtIG9ianNNb3ZlZCkge1xuICAgICAgICAgICAgbmV3SWR4ID0gaWR4ICsgMTtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpzTW92ZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgICAgICBpZiAoaWR4ICE9PSB0aGlzLl9vYmplY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBpZiBvYmplY3QgaXMgbm90IG9uIHRvcCBvZiBzdGFjayAobGFzdCBpdGVtIGluIGFuIGFycmF5KVxuICAgICAgICAgIG5ld0lkeCA9IHRoaXMuX2ZpbmROZXdVcHBlckluZGV4KG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTmV3VXBwZXJJbmRleDogZnVuY3Rpb24ob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZykge1xuICAgICAgdmFyIG5ld0lkeCwgaSwgbGVuO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeDtcblxuICAgICAgICAvLyB0cmF2ZXJzZSB1cCB0aGUgc3RhY2sgbG9va2luZyBmb3IgdGhlIG5lYXJlc3QgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAgICBmb3IgKGkgPSBpZHggKyAxLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgICB2YXIgaXNJbnRlcnNlY3RpbmcgPSBvYmplY3QuaW50ZXJzZWN0c1dpdGhPYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgICBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdJZHggPSBpZHggKyAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3SWR4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gc3BlY2lmaWVkIGxldmVsIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBQb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBtb3ZlVG86IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4KSB7XG4gICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKGluZGV4LCAwLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhIGNhbnZhcyBlbGVtZW50IGFuZCBkaXNwb3NlIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNhbmNlbCBldmVudHVhbGx5IG9uZ29pbmcgcmVuZGVyc1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuaXNSZW5kZXJpbmcpO1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LmRpc3Bvc2UgJiYgb2JqZWN0LmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZEltYWdlICYmIHRoaXMuYmFja2dyb3VuZEltYWdlLmRpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSBudWxsO1xuICAgICAgaWYgKHRoaXMub3ZlcmxheUltYWdlICYmIHRoaXMub3ZlcmxheUltYWdlLmRpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5SW1hZ2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vdmVybGF5SW1hZ2UgPSBudWxsO1xuICAgICAgdGhpcy5faVRleHRJbnN0YW5jZXMgPSBudWxsO1xuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gbnVsbDtcbiAgICAgIC8vIHJlc3RvcmUgY2FudmFzIHN0eWxlXG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuY2xhc3NMaXN0LnJlbW92ZSgnbG93ZXItY2FudmFzJyk7XG4gICAgICBmYWJyaWMudXRpbC5zZXRTdHlsZSh0aGlzLmxvd2VyQ2FudmFzRWwsIHRoaXMuX29yaWdpbmFsQ2FudmFzU3R5bGUpO1xuICAgICAgZGVsZXRlIHRoaXMuX29yaWdpbmFsQ2FudmFzU3R5bGU7XG4gICAgICAvLyByZXN0b3JlIGNhbnZhcyBzaXplIHRvIG9yaWdpbmFsIHNpemUgaW4gY2FzZSByZXRpbmEgc2NhbGluZyB3YXMgYXBwbGllZFxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoKTtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5DYW52YXMgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpOiAnICtcbiAgICAgICAgICAgICAgICd7IG9iamVjdHM6ICcgKyB0aGlzLl9vYmplY3RzLmxlbmd0aCArICcgfT4nO1xuICAgIH1cbiAgfSk7XG5cbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLkNvbGxlY3Rpb24pO1xuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5EYXRhVVJMRXhwb3J0ZXIpO1xuXG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgRU1QVFlfSlNPTjogJ3tcIm9iamVjdHNcIjogW10sIFwiYmFja2dyb3VuZFwiOiBcIndoaXRlXCJ9JyxcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgd2F5IHRvIGNoZWNrIHN1cHBvcnQgb2Ygc29tZSBvZiB0aGUgY2FudmFzIG1ldGhvZHNcbiAgICAgKiAoZWl0aGVyIHRob3NlIG9mIEhUTUxDYW52YXNFbGVtZW50IGl0c2VsZiwgb3IgcmVuZGVyaW5nIGNvbnRleHQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZSBNZXRob2QgdG8gY2hlY2sgc3VwcG9ydCBmb3I7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgQ291bGQgYmUgb25lIG9mIFwic2V0TGluZURhc2hcIlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW4gfCBudWxsfSBgdHJ1ZWAgaWYgbWV0aG9kIGlzIHN1cHBvcnRlZCAob3IgYXQgbGVhc3QgZXhpc3RzKSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYG51bGxgIGlmIGNhbnZhcyBlbGVtZW50IG9yIGNvbnRleHQgY2FuIG5vdCBiZSBpbml0aWFsaXplZFxuICAgICAqL1xuICAgIHN1cHBvcnRzOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGVsID0gY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuXG4gICAgICBpZiAoIWVsIHx8ICFlbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gZWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcblxuICAgICAgICBjYXNlICdzZXRMaW5lRGFzaCc6XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjdHguc2V0TGluZURhc2ggIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAqIHRoaXMgYWxpYXMgaXMgcHJvdmlkZWQgYmVjYXVzZSBpZiB5b3UgY2FsbCBKU09OLnN0cmluZ2lmeSBvbiBhbiBpbnN0YW5jZSxcbiAgICogdGhlIHRvSlNPTiBvYmplY3Qgd2lsbCBiZSBpbnZva2VkIGlmIGl0IGV4aXN0cy5cbiAgICogSGF2aW5nIGEgdG9KU09OIG1ldGhvZCBtZWFucyB5b3UgY2FuIGRvIEpTT04uc3RyaW5naWZ5KG15Q2FudmFzKVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT04gY29tcGF0aWJsZSBvYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9wZWM4Ni98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRob3V0IGFkZGl0aW9uYWwgcHJvcGVydGllczwvY2FwdGlvbj5cbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW5jbHVkZWQ8L2NhcHRpb24+XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTihbJ2xvY2tNb3ZlbWVudFgnLCAnbG9ja01vdmVtZW50WScsICdsb2NrUm90YXRpb24nLCAnbG9ja1NjYWxpbmdYJywgJ2xvY2tTY2FsaW5nWSddKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRob3V0IGRlZmF1bHQgdmFsdWVzPC9jYXB0aW9uPlxuICAgKiBjYW52YXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBmYWxzZTtcbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKCk7XG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS50b0pTT04gPSBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS50b09iamVjdDtcblxuICBpZiAoZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmNyZWF0ZVBOR1N0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGltcGwgPSBnZXROb2RlQ2FudmFzKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICByZXR1cm4gaW1wbCAmJiBpbXBsLmNyZWF0ZVBOR1N0cmVhbSgpO1xuICAgIH07XG4gICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuY3JlYXRlSlBFR1N0cmVhbSA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgIHZhciBpbXBsID0gZ2V0Tm9kZUNhbnZhcyh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgcmV0dXJuIGltcGwgJiYgaW1wbC5jcmVhdGVKUEVHU3RyZWFtKG9wdHMpO1xuICAgIH07XG4gIH1cbn0pKCk7XG5cblxuLyoqXG4gKiBCYXNlQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuQmFzZUJydXNoXG4gKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZyZWVkcmF3aW5nfEZyZWVkcmF3aW5nIGRlbW99XG4gKi9cbmZhYnJpYy5CYXNlQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5CYXNlQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQ29sb3Igb2YgYSBicnVzaFxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGNvbG9yOiAncmdiKDAsIDAsIDApJyxcblxuICAvKipcbiAgICogV2lkdGggb2YgYSBicnVzaCwgaGFzIHRvIGJlIGEgTnVtYmVyLCBubyBzdHJpbmcgbGl0ZXJhbHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogMSxcblxuICAvKipcbiAgICogU2hhZG93IG9iamVjdCByZXByZXNlbnRpbmcgc2hhZG93IG9mIHRoaXMgc2hhcGUuXG4gICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJzaGFkb3dDb2xvclwiIChTdHJpbmcpLCBcInNoYWRvd09mZnNldFhcIiAoTnVtYmVyKSxcbiAgICogXCJzaGFkb3dPZmZzZXRZXCIgKE51bWJlcikgYW5kIFwic2hhZG93Qmx1clwiIChOdW1iZXIpIHNpbmNlIHYxLjIuMTJcbiAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc2hhZG93OiBudWxsLFxuXG4gIC8qKlxuICAgKiBMaW5lIGVuZGluZ3Mgc3R5bGUgb2YgYSBicnVzaCAob25lIG9mIFwiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCIpXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTGluZUNhcDogJ3JvdW5kJyxcblxuICAvKipcbiAgICogQ29ybmVyIHN0eWxlIG9mIGEgYnJ1c2ggKG9uZSBvZiBcImJldmVsXCIsIFwicm91bmRcIiwgXCJtaXRlclwiKVxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZUxpbmVKb2luOiAncm91bmQnLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG1pdGVyIGxlbmd0aCAodXNlZCBmb3Igc3Ryb2tlTGluZUpvaW4gPSBcIm1pdGVyXCIpIG9mIGEgYnJ1c2gnc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgMTAsXG5cbiAgLyoqXG4gICAqIFN0cm9rZSBEYXNoIEFycmF5LlxuICAgKiBAdHlwZSBBcnJheVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlRGFzaEFycmF5OiBudWxsLFxuXG4gIC8qKlxuICAgKiBXaGVuIGB0cnVlYCwgdGhlIGZyZWUgZHJhd2luZyBpcyBsaW1pdGVkIHRvIHRoZSB3aGl0ZWJvYXJkIHNpemUuIERlZmF1bHQgdG8gZmFsc2UuXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgKi9cblxuICBsaW1pdGVkVG9DYW52YXNTaXplOiBmYWxzZSxcblxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBfc2V0QnJ1c2hTdHlsZXM6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0O1xuICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW47XG4gICAgY3R4LnNldExpbmVEYXNoKHRoaXMuc3Ryb2tlRGFzaEFycmF5IHx8IFtdKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtYXRpb24gb24gZ2l2ZW4gY29udGV4dFxuICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHQyZH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2F2ZUFuZFRyYW5zZm9ybTogZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc2hhZG93IHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFNoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcyxcbiAgICAgICAgc2hhZG93ID0gdGhpcy5zaGFkb3csXG4gICAgICAgIGN0eCA9IGNhbnZhcy5jb250ZXh0VG9wLFxuICAgICAgICB6b29tID0gY2FudmFzLmdldFpvb20oKTtcbiAgICBpZiAoY2FudmFzICYmIGNhbnZhcy5faXNSZXRpbmFTY2FsaW5nKCkpIHtcbiAgICAgIHpvb20gKj0gZmFicmljLmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gc2hhZG93LmNvbG9yO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXIgKiB6b29tO1xuICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gc2hhZG93Lm9mZnNldFggKiB6b29tO1xuICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc2hhZG93Lm9mZnNldFkgKiB6b29tO1xuICB9LFxuXG4gIG5lZWRzRnVsbFJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKTtcbiAgICByZXR1cm4gY29sb3IuZ2V0QWxwaGEoKSA8IDEgfHwgISF0aGlzLnNoYWRvdztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBicnVzaCBzaGFkb3cgc3R5bGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gJyc7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSBjdHguc2hhZG93T2Zmc2V0WCA9IGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaXMgcG9pbnRlciBpcyBvdXRzaWRlIGNhbnZhcyBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqIEBwcml2YXRlXG4gICovXG4gIF9pc091dFNpZGVDYW52YXM6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICByZXR1cm4gcG9pbnRlci54IDwgMCB8fCBwb2ludGVyLnggPiB0aGlzLmNhbnZhcy5nZXRXaWR0aCgpIHx8IHBvaW50ZXIueSA8IDAgfHwgcG9pbnRlci55ID4gdGhpcy5jYW52YXMuZ2V0SGVpZ2h0KCk7XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIFBlbmNpbEJydXNoIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGVuY2lsQnJ1c2hcbiAgICogQGV4dGVuZHMgZmFicmljLkJhc2VCcnVzaFxuICAgKi9cbiAgZmFicmljLlBlbmNpbEJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuUGVuY2lsQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIERpc2NhcmQgcG9pbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBgZGVjaW1hdGVgIHBpeGVsIGRpc3RhbnQgZnJvbSBlYWNoIG90aGVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC40XG4gICAgICovXG4gICAgZGVjaW1hdGU6IDAuNCxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgc3RyYWlnaHQgbGluZSBiZXR3ZWVuIGxhc3QgcmVjb3JkZWQgcG9pbnQgdG8gY3VycmVudCBwb2ludGVyXG4gICAgICogVXNlZCBmb3IgYHNoaWZ0YCBmdW5jdGlvbmFsaXR5XG4gICAgICpcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkcmF3U3RyYWlnaHRMaW5lOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBtb2RpZmllciBrZXkgdGhhdCBtYWtlcyB0aGUgYnJ1c2ggZHJhdyBhIHN0cmFpZ2h0IGxpbmUuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5IHRoZSBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIEB0eXBlIHsnYWx0S2V5JyB8ICdzaGlmdEtleScgfCAnY3RybEtleScgfCAnbm9uZScgfCB1bmRlZmluZWQgfCBudWxsfVxuICAgICAqL1xuICAgIHN0cmFpZ2h0TGluZUtleTogJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGVuY2lsQnJ1c2h9IEluc3RhbmNlIG9mIGEgcGVuY2lsIGJydXNoXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuX3BvaW50cyA9IFtdO1xuICAgIH0sXG5cbiAgICBuZWVkc0Z1bGxSZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcignbmVlZHNGdWxsUmVuZGVyJykgfHwgdGhpcy5faGFzU3RyYWlnaHRMaW5lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIGluc2lkZSBvbiBtb3VzZSBkb3duIGFuZCBtb3VzZSBtb3ZlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBfZHJhd1NlZ21lbnQ6IGZ1bmN0aW9uIChjdHgsIHAxLCBwMikge1xuICAgICAgdmFyIG1pZFBvaW50ID0gcDEubWlkUG9pbnRGcm9tKHAyKTtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHAxLngsIHAxLnksIG1pZFBvaW50LngsIG1pZFBvaW50LnkpO1xuICAgICAgcmV0dXJuIG1pZFBvaW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIG9uIG1vdXNlIGRvd25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzLl9pc01haW5FdmVudChvcHRpb25zLmUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd1N0cmFpZ2h0TGluZSA9IG9wdGlvbnMuZVt0aGlzLnN0cmFpZ2h0TGluZUtleV07XG4gICAgICB0aGlzLl9wcmVwYXJlRm9yRHJhd2luZyhwb2ludGVyKTtcbiAgICAgIC8vIGNhcHR1cmUgY29vcmRpbmF0ZXMgaW1tZWRpYXRlbHlcbiAgICAgIC8vIHRoaXMgYWxsb3dzIHRvIGRyYXcgZG90cyAod2hlbiBtb3ZlbWVudCBuZXZlciBvY2N1cnMpXG4gICAgICB0aGlzLl9jYXB0dXJlRHJhd2luZ1BhdGgocG9pbnRlcik7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlciwgb3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcy5faXNNYWluRXZlbnQob3B0aW9ucy5lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdTdHJhaWdodExpbmUgPSBvcHRpb25zLmVbdGhpcy5zdHJhaWdodExpbmVLZXldO1xuICAgICAgaWYgKHRoaXMubGltaXRlZFRvQ2FudmFzU2l6ZSA9PT0gdHJ1ZSAmJiB0aGlzLl9pc091dFNpZGVDYW52YXMocG9pbnRlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NhcHR1cmVEcmF3aW5nUGF0aChwb2ludGVyKSAmJiB0aGlzLl9wb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAodGhpcy5uZWVkc0Z1bGxSZW5kZXIoKSkge1xuICAgICAgICAgIC8vIHJlZHJhdyBjdXJ2ZVxuICAgICAgICAgIC8vIGNsZWFyIHRvcCBjYW52YXNcbiAgICAgICAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cywgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCwgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgICAgICAvLyBkcmF3IHRoZSBjdXJ2ZSB1cGRhdGVcbiAgICAgICAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgICAgaWYgKHRoaXMub2xkRW5kKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMub2xkRW5kLngsIHRoaXMub2xkRW5kLnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9sZEVuZCA9IHRoaXMuX2RyYXdTZWdtZW50KGN0eCwgcG9pbnRzW2xlbmd0aCAtIDJdLCBwb2ludHNbbGVuZ3RoIC0gMV0sIHRydWUpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb24gbW91c2UgdXBcbiAgICAgKi9cbiAgICBvbk1vdXNlVXA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMuX2lzTWFpbkV2ZW50KG9wdGlvbnMuZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdTdHJhaWdodExpbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMub2xkRW5kID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fZmluYWxpemVBbmRBZGRQYXRoKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgQWN0dWFsIG1vdXNlIHBvc2l0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfcHJlcGFyZUZvckRyYXdpbmc6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcblxuICAgICAgdmFyIHAgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcblxuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIHRoaXMuX2FkZFBvaW50KHApO1xuICAgICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBiZSBhZGRlZCB0byBwb2ludHMgYXJyYXlcbiAgICAgKi9cbiAgICBfYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICBpZiAodGhpcy5fcG9pbnRzLmxlbmd0aCA+IDEgJiYgcG9pbnQuZXEodGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZHJhd1N0cmFpZ2h0TGluZSAmJiB0aGlzLl9wb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLl9oYXNTdHJhaWdodExpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wb2ludHMucG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wb2ludHMucHVzaChwb2ludCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgcG9pbnRzIGFycmF5IGFuZCBzZXQgY29udGV4dFRvcCBjYW52YXMgc3R5bGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcG9pbnRzID0gW107XG4gICAgICB0aGlzLl9zZXRCcnVzaFN0eWxlcyh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuX3NldFNoYWRvdygpO1xuICAgICAgdGhpcy5faGFzU3RyYWlnaHRMaW5lID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgQWN0dWFsIG1vdXNlIHBvc2l0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfY2FwdHVyZURyYXdpbmdQYXRoOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkUG9pbnQocG9pbnRlclBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIHNtb290aCBwYXRoIG9uIHRoZSB0b3BDYW52YXMgdXNpbmcgcXVhZHJhdGljQ3VydmVUb1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjdHhdXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgaSwgbGVuLFxuICAgICAgICAgIHAxID0gdGhpcy5fcG9pbnRzWzBdLFxuICAgICAgICAgIHAyID0gdGhpcy5fcG9pbnRzWzFdO1xuICAgICAgY3R4ID0gY3R4IHx8IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAvL2lmIHdlIG9ubHkgaGF2ZSAyIHBvaW50cyBpbiB0aGUgcGF0aCBhbmQgdGhleSBhcmUgdGhlIHNhbWVcbiAgICAgIC8vaXQgbWVhbnMgdGhhdCB0aGUgdXNlciBvbmx5IGNsaWNrZWQgdGhlIGNhbnZhcyB3aXRob3V0IG1vdmluZyB0aGUgbW91c2VcbiAgICAgIC8vdGhlbiB3ZSBzaG91bGQgYmUgZHJhd2luZyBhIGRvdC4gQSBwYXRoIGlzbid0IGRyYXduIGJldHdlZW4gdHdvIGlkZW50aWNhbCBkb3RzXG4gICAgICAvL3RoYXQncyB3aHkgd2Ugc2V0IHRoZW0gYXBhcnQgYSBiaXRcbiAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoID09PSAyICYmIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueSkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoIC8gMTAwMDtcbiAgICAgICAgcDEgPSBuZXcgZmFicmljLlBvaW50KHAxLngsIHAxLnkpO1xuICAgICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocDIueCwgcDIueSk7XG4gICAgICAgIHAxLnggLT0gd2lkdGg7XG4gICAgICAgIHAyLnggKz0gd2lkdGg7XG4gICAgICB9XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuXG4gICAgICBmb3IgKGkgPSAxLCBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gd2UgcGljayB0aGUgcG9pbnQgYmV0d2VlbiBwaSArIDEgJiBwaSArIDIgYXMgdGhlXG4gICAgICAgIC8vIGVuZCBwb2ludCBhbmQgcDEgYXMgb3VyIGNvbnRyb2wgcG9pbnQuXG4gICAgICAgIHRoaXMuX2RyYXdTZWdtZW50KGN0eCwgcDEsIHAyKTtcbiAgICAgICAgcDEgPSB0aGlzLl9wb2ludHNbaV07XG4gICAgICAgIHAyID0gdGhpcy5fcG9pbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIERyYXcgbGFzdCBsaW5lIGFzIGEgc3RyYWlnaHQgbGluZSB3aGlsZVxuICAgICAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgcG9pbnQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGVcbiAgICAgIC8vIHRoZSBiZXppZXIgY29udHJvbCBwb2ludFxuICAgICAgY3R4LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHBvaW50cyB0byBTVkcgcGF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHNcbiAgICAgKiBAcmV0dXJuIHsoc3RyaW5nfG51bWJlcilbXVtdfSBTVkcgcGF0aCBjb21tYW5kc1xuICAgICAqL1xuICAgIGNvbnZlcnRQb2ludHNUb1NWR1BhdGg6IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgIHZhciBjb3JyZWN0aW9uID0gdGhpcy53aWR0aCAvIDEwMDA7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwuZ2V0U21vb3RoUGF0aEZyb21Qb2ludHMocG9pbnRzLCBjb3JyZWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKVtdW119IHBhdGhEYXRhIFNWRyBwYXRoIGNvbW1hbmRzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgX2lzRW1wdHlTVkdQYXRoOiBmdW5jdGlvbiAocGF0aERhdGEpIHtcbiAgICAgIHZhciBwYXRoU3RyaW5nID0gZmFicmljLnV0aWwuam9pblBhdGgocGF0aERhdGEpO1xuICAgICAgcmV0dXJuIHBhdGhTdHJpbmcgPT09ICdNIDAgMCBRIDAgMCAwIDAgTCAwIDAnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGZhYnJpYy5QYXRoIG9iamVjdCB0byBhZGQgb24gY2FudmFzXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcilbXVtdfSBwYXRoRGF0YSBQYXRoIGRhdGFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0aH0gUGF0aCB0byBhZGQgb24gY2FudmFzXG4gICAgICovXG4gICAgY3JlYXRlUGF0aDogZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gbmV3IGZhYnJpYy5QYXRoKHBhdGhEYXRhLCB7XG4gICAgICAgIGZpbGw6IG51bGwsXG4gICAgICAgIHN0cm9rZTogdGhpcy5jb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIHN0cm9rZUxpbmVDYXA6IHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdDogdGhpcy5zdHJva2VNaXRlckxpbWl0LFxuICAgICAgICBzdHJva2VMaW5lSm9pbjogdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiB0aGlzLnN0cm9rZURhc2hBcnJheSxcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIHRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSA9IHRydWU7XG4gICAgICAgIHBhdGguc2hhZG93ID0gbmV3IGZhYnJpYy5TaGFkb3codGhpcy5zaGFkb3cpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaW1hdGUgcG9pbnRzIGFycmF5IHdpdGggdGhlIGRlY2ltYXRlIHZhbHVlXG4gICAgICovXG4gICAgZGVjaW1hdGVQb2ludHM6IGZ1bmN0aW9uKHBvaW50cywgZGlzdGFuY2UpIHtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgIH1cbiAgICAgIHZhciB6b29tID0gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpLCBhZGp1c3RlZERpc3RhbmNlID0gTWF0aC5wb3coZGlzdGFuY2UgLyB6b29tLCAyKSxcbiAgICAgICAgICBpLCBsID0gcG9pbnRzLmxlbmd0aCAtIDEsIGxhc3RQb2ludCA9IHBvaW50c1swXSwgbmV3UG9pbnRzID0gW2xhc3RQb2ludF0sXG4gICAgICAgICAgY0Rpc3RhbmNlO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGwgLSAxOyBpKyspIHtcbiAgICAgICAgY0Rpc3RhbmNlID0gTWF0aC5wb3cobGFzdFBvaW50LnggLSBwb2ludHNbaV0ueCwgMikgKyBNYXRoLnBvdyhsYXN0UG9pbnQueSAtIHBvaW50c1tpXS55LCAyKTtcbiAgICAgICAgaWYgKGNEaXN0YW5jZSA+PSBhZGp1c3RlZERpc3RhbmNlKSB7XG4gICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIG5ld1BvaW50cy5wdXNoKGxhc3RQb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQWRkIHRoZSBsYXN0IHBvaW50IGZyb20gdGhlIG9yaWdpbmFsIGxpbmUgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgKiBUaGlzIGVuc3VyZXMgZGVjaW1hdGUgZG9lc24ndCBkZWxldGUgdGhlIGxhc3QgcG9pbnQgb24gdGhlIGxpbmUsIGFuZCBlbnN1cmVzIHRoZSBsaW5lIGlzID4gMSBwb2ludC5cbiAgICAgICAqL1xuICAgICAgbmV3UG9pbnRzLnB1c2gocG9pbnRzW2xdKTtcbiAgICAgIHJldHVybiBuZXdQb2ludHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNldXAgYWZ0ZXIgZHJhd2luZyB0aGUgcGF0aCBvbiBjb250ZXh0VG9wIGNhbnZhc1xuICAgICAqIHdlIHVzZSB0aGUgcG9pbnRzIGNhcHR1cmVkIHRvIGNyZWF0ZSBhbiBuZXcgZmFicmljIHBhdGggb2JqZWN0XG4gICAgICogYW5kIGFkZCBpdCB0byB0aGUgZmFicmljIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfZmluYWxpemVBbmRBZGRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgaWYgKHRoaXMuZGVjaW1hdGUpIHtcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gdGhpcy5kZWNpbWF0ZVBvaW50cyh0aGlzLl9wb2ludHMsIHRoaXMuZGVjaW1hdGUpO1xuICAgICAgfVxuICAgICAgdmFyIHBhdGhEYXRhID0gdGhpcy5jb252ZXJ0UG9pbnRzVG9TVkdQYXRoKHRoaXMuX3BvaW50cyk7XG4gICAgICBpZiAodGhpcy5faXNFbXB0eVNWR1BhdGgocGF0aERhdGEpKSB7XG4gICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgMCB3aWR0aC9oZWlnaHQgcGF0aHMsIGFzIHRoZXkgYXJlXG4gICAgICAgIC8vIHJlbmRlcmVkIGluY29uc2lzdGVudGx5IGFjcm9zcyBicm93c2Vyc1xuICAgICAgICAvLyBGaXJlZm94IDQsIGZvciBleGFtcGxlLCByZW5kZXJzIGEgZG90LFxuICAgICAgICAvLyB3aGVyZWFzIENocm9tZSAxMCByZW5kZXJzIG5vdGhpbmdcbiAgICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRoID0gdGhpcy5jcmVhdGVQYXRoKHBhdGhEYXRhKTtcbiAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ2JlZm9yZTpwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IHBhdGggfSk7XG4gICAgICB0aGlzLmNhbnZhcy5hZGQocGF0aCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICBwYXRoLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcblxuXG4gICAgICAvLyBmaXJlIGV2ZW50ICdwYXRoJyBjcmVhdGVkXG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IHBhdGggfSk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuLyoqXG4gKiBDaXJjbGVCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5DaXJjbGVCcnVzaFxuICovXG5mYWJyaWMuQ2lyY2xlQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGVCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6IDEwLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlQnJ1c2h9IEluc3RhbmNlIG9mIGEgY2lyY2xlIGJydXNoXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGluc2lkZSBvbiBtb3VzZSBkb3duIGFuZCBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBkcmF3RG90OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5hZGRQb2ludChwb2ludGVyKSxcbiAgICAgICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgdGhpcy5kb3QoY3R4LCBwb2ludCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICBkb3Q6IGZ1bmN0aW9uKGN0eCwgcG9pbnQpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gcG9pbnQuZmlsbDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBwb2ludC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgZG93blxuICAgKi9cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9zZXRTaGFkb3coKTtcbiAgICB0aGlzLmRyYXdEb3QocG9pbnRlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgZnVsbCBzdGF0ZSBvZiB0aGUgYnJ1c2hcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgbGVuLFxuICAgICAgICBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmRvdChjdHgsIHBvaW50c1tpXSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICBpZiAodGhpcy5saW1pdGVkVG9DYW52YXNTaXplID09PSB0cnVlICYmIHRoaXMuX2lzT3V0U2lkZUNhbnZhcyhwb2ludGVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWVkc0Z1bGxSZW5kZXIoKSkge1xuICAgICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdGhpcy5hZGRQb2ludChwb2ludGVyKTtcbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZHJhd0RvdChwb2ludGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgdXBcbiAgICovXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSwgaSwgbGVuO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gZmFsc2U7XG5cbiAgICB2YXIgY2lyY2xlcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMucG9pbnRzW2ldLFxuICAgICAgICAgIGNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKHtcbiAgICAgICAgICAgIHJhZGl1czogcG9pbnQucmFkaXVzLFxuICAgICAgICAgICAgbGVmdDogcG9pbnQueCxcbiAgICAgICAgICAgIHRvcDogcG9pbnQueSxcbiAgICAgICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgICBmaWxsOiBwb2ludC5maWxsXG4gICAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2hhZG93ICYmIChjaXJjbGUuc2hhZG93ID0gbmV3IGZhYnJpYy5TaGFkb3codGhpcy5zaGFkb3cpKTtcblxuICAgICAgY2lyY2xlcy5wdXNoKGNpcmNsZSk7XG4gICAgfVxuICAgIHZhciBncm91cCA9IG5ldyBmYWJyaWMuR3JvdXAoY2lyY2xlcyk7XG4gICAgZ3JvdXAuY2FudmFzID0gdGhpcy5jYW52YXM7XG5cbiAgICB0aGlzLmNhbnZhcy5maXJlKCdiZWZvcmU6cGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IEp1c3QgYWRkZWQgcG9pbnRlciBwb2ludFxuICAgKi9cbiAgYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSksXG5cbiAgICAgICAgY2lyY2xlUmFkaXVzID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KFxuICAgICAgICAgIE1hdGgubWF4KDAsIHRoaXMud2lkdGggLSAyMCksIHRoaXMud2lkdGggKyAyMCkgLyAyLFxuXG4gICAgICAgIGNpcmNsZUNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKVxuICAgICAgICAgIC5zZXRBbHBoYShmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMClcbiAgICAgICAgICAudG9SZ2JhKCk7XG5cbiAgICBwb2ludGVyUG9pbnQucmFkaXVzID0gY2lyY2xlUmFkaXVzO1xuICAgIHBvaW50ZXJQb2ludC5maWxsID0gY2lyY2xlQ29sb3I7XG5cbiAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50ZXJQb2ludCk7XG5cbiAgICByZXR1cm4gcG9pbnRlclBvaW50O1xuICB9XG59KTtcblxuXG4vKipcbiAqIFNwcmF5QnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuU3ByYXlCcnVzaFxuICovXG5mYWJyaWMuU3ByYXlCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKCBmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5TcHJheUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgc3ByYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogICAgICAgICAgICAgIDEwLFxuXG4gIC8qKlxuICAgKiBEZW5zaXR5IG9mIGEgc3ByYXkgKG51bWJlciBvZiBkb3RzIHBlciBjaHVuaylcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkZW5zaXR5OiAgICAgICAgICAgIDIwLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBzcHJheSBkb3RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZG90V2lkdGg6ICAgICAgICAgICAxLFxuXG4gIC8qKlxuICAgKiBXaWR0aCB2YXJpYW5jZSBvZiBzcHJheSBkb3RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZG90V2lkdGhWYXJpYW5jZTogICAxLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9wYWNpdHkgb2YgYSBkb3Qgc2hvdWxkIGJlIHJhbmRvbVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICByYW5kb21PcGFjaXR5OiAgICAgICAgZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3ZlcmxhcHBpbmcgZG90cyAocmVjdGFuZ2xlcykgc2hvdWxkIGJlIHJlbW92ZWQgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBvcHRpbWl6ZU92ZXJsYXBwaW5nOiAgdHJ1ZSxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICogQHJldHVybiB7ZmFicmljLlNwcmF5QnJ1c2h9IEluc3RhbmNlIG9mIGEgc3ByYXkgYnJ1c2hcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc3ByYXlDaHVua3MgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuc3ByYXlDaHVua3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fc2V0U2hhZG93KCk7XG5cbiAgICB0aGlzLmFkZFNwcmF5Q2h1bmsocG9pbnRlcik7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIGlmICh0aGlzLmxpbWl0ZWRUb0NhbnZhc1NpemUgPT09IHRydWUgJiYgdGhpcy5faXNPdXRTaWRlQ2FudmFzKHBvaW50ZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWRkU3ByYXlDaHVuayhwb2ludGVyKTtcbiAgICB0aGlzLnJlbmRlcih0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIHZhciByZWN0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFyIHNwcmF5Q2h1bmsgPSB0aGlzLnNwcmF5Q2h1bmtzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IHNwcmF5Q2h1bmsubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgZmFicmljLlJlY3Qoe1xuICAgICAgICAgIHdpZHRoOiBzcHJheUNodW5rW2pdLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogc3ByYXlDaHVua1tqXS53aWR0aCxcbiAgICAgICAgICBsZWZ0OiBzcHJheUNodW5rW2pdLnggKyAxLFxuICAgICAgICAgIHRvcDogc3ByYXlDaHVua1tqXS55ICsgMSxcbiAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yXG4gICAgICAgIH0pO1xuICAgICAgICByZWN0cy5wdXNoKHJlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGltaXplT3ZlcmxhcHBpbmcpIHtcbiAgICAgIHJlY3RzID0gdGhpcy5fZ2V0T3B0aW1pemVkUmVjdHMocmVjdHMpO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IG5ldyBmYWJyaWMuR3JvdXAocmVjdHMpO1xuICAgIHRoaXMuc2hhZG93ICYmIGdyb3VwLnNldCgnc2hhZG93JywgbmV3IGZhYnJpYy5TaGFkb3codGhpcy5zaGFkb3cpKTtcbiAgICB0aGlzLmNhbnZhcy5maXJlKCdiZWZvcmU6cGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZWN0c1xuICAgKi9cbiAgX2dldE9wdGltaXplZFJlY3RzOiBmdW5jdGlvbihyZWN0cykge1xuXG4gICAgLy8gYXZvaWQgY3JlYXRpbmcgZHVwbGljYXRlIHJlY3RzIGF0IHRoZSBzYW1lIGNvb3JkaW5hdGVzXG4gICAgdmFyIHVuaXF1ZVJlY3RzID0geyB9LCBrZXksIGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSByZWN0c1tpXS5sZWZ0ICsgJycgKyByZWN0c1tpXS50b3A7XG4gICAgICBpZiAoIXVuaXF1ZVJlY3RzW2tleV0pIHtcbiAgICAgICAgdW5pcXVlUmVjdHNba2V5XSA9IHJlY3RzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW5pcXVlUmVjdHNBcnJheSA9IFtdO1xuICAgIGZvciAoa2V5IGluIHVuaXF1ZVJlY3RzKSB7XG4gICAgICB1bmlxdWVSZWN0c0FycmF5LnB1c2godW5pcXVlUmVjdHNba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXF1ZVJlY3RzQXJyYXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBuZXcgY2h1bmsgb2Ygc3ByYXkgYnJ1c2hcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24oc3ByYXlDaHVuaykge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBsZW47XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG5cbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzcHJheUNodW5rLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBzcHJheUNodW5rW2ldO1xuICAgICAgaWYgKHR5cGVvZiBwb2ludC5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBwb2ludC5vcGFjaXR5O1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxSZWN0KHBvaW50LngsIHBvaW50LnksIHBvaW50LndpZHRoLCBwb2ludC53aWR0aCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhbGwgc3ByYXkgY2h1bmtzXG4gICAqL1xuICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgaWxlbjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcblxuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rc1tpXSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBhZGRTcHJheUNodW5rOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5zcHJheUNodW5rUG9pbnRzID0gW107XG5cbiAgICB2YXIgeCwgeSwgd2lkdGgsIHJhZGl1cyA9IHRoaXMud2lkdGggLyAyLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGVuc2l0eTsgaSsrKSB7XG5cbiAgICAgIHggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQocG9pbnRlci54IC0gcmFkaXVzLCBwb2ludGVyLnggKyByYWRpdXMpO1xuICAgICAgeSA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChwb2ludGVyLnkgLSByYWRpdXMsIHBvaW50ZXIueSArIHJhZGl1cyk7XG5cbiAgICAgIGlmICh0aGlzLmRvdFdpZHRoVmFyaWFuY2UpIHtcbiAgICAgICAgd2lkdGggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoXG4gICAgICAgICAgLy8gYm90dG9tIGNsYW1wIHdpZHRoIHRvIDFcbiAgICAgICAgICBNYXRoLm1heCgxLCB0aGlzLmRvdFdpZHRoIC0gdGhpcy5kb3RXaWR0aFZhcmlhbmNlKSxcbiAgICAgICAgICB0aGlzLmRvdFdpZHRoICsgdGhpcy5kb3RXaWR0aFZhcmlhbmNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aWR0aCA9IHRoaXMuZG90V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgICBwb2ludC53aWR0aCA9IHdpZHRoO1xuXG4gICAgICBpZiAodGhpcy5yYW5kb21PcGFjaXR5KSB7XG4gICAgICAgIHBvaW50Lm9wYWNpdHkgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zcHJheUNodW5rUG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc3ByYXlDaHVua3MucHVzaCh0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9XG59KTtcblxuXG4vKipcbiAqIFBhdHRlcm5CcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuQnJ1c2hcbiAqIEBleHRlbmRzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqL1xuZmFicmljLlBhdHRlcm5CcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5QZW5jaWxCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuUGF0dGVybkJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgZ2V0UGF0dGVyblNyYzogZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZG90V2lkdGggPSAyMCxcbiAgICAgICAgZG90RGlzdGFuY2UgPSA1LFxuICAgICAgICBwYXR0ZXJuQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICBwYXR0ZXJuQ3R4ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgcGF0dGVybkNhbnZhcy53aWR0aCA9IHBhdHRlcm5DYW52YXMuaGVpZ2h0ID0gZG90V2lkdGggKyBkb3REaXN0YW5jZTtcblxuICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBwYXR0ZXJuQ3R4LmJlZ2luUGF0aCgpO1xuICAgIHBhdHRlcm5DdHguYXJjKGRvdFdpZHRoIC8gMiwgZG90V2lkdGggLyAyLCBkb3RXaWR0aCAvIDIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgcGF0dGVybkN0eC5jbG9zZVBhdGgoKTtcbiAgICBwYXR0ZXJuQ3R4LmZpbGwoKTtcblxuICAgIHJldHVybiBwYXR0ZXJuQ2FudmFzO1xuICB9LFxuXG4gIGdldFBhdHRlcm5TcmNGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLmdldFBhdHRlcm5TcmMpLnJlcGxhY2UoJ3RoaXMuY29sb3InLCAnXCInICsgdGhpcy5jb2xvciArICdcIicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFwicGF0dGVyblwiIGluc3RhbmNlIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIGdldFBhdHRlcm46IGZ1bmN0aW9uKGN0eCkge1xuICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0aGlzLnNvdXJjZSB8fCB0aGlzLmdldFBhdHRlcm5TcmMoKSwgJ3JlcGVhdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHN0eWxlc1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBfc2V0QnJ1c2hTdHlsZXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0QnJ1c2hTdHlsZXMnLCBjdHgpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0UGF0dGVybihjdHgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHBhdGhcbiAgICovXG4gIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLmNhbGxTdXBlcignY3JlYXRlUGF0aCcsIHBhdGhEYXRhKSxcbiAgICAgICAgdG9wTGVmdCA9IHBhdGguX2dldExlZnRUb3BDb29yZHMoKS5zY2FsYXJBZGQocGF0aC5zdHJva2VXaWR0aCAvIDIpO1xuXG4gICAgcGF0aC5zdHJva2UgPSBuZXcgZmFicmljLlBhdHRlcm4oe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSB8fCB0aGlzLmdldFBhdHRlcm5TcmNGdW5jdGlvbigpLFxuICAgICAgb2Zmc2V0WDogLXRvcExlZnQueCxcbiAgICAgIG9mZnNldFk6IC10b3BMZWZ0LnlcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBnZXRQb2ludGVyID0gZmFicmljLnV0aWwuZ2V0UG9pbnRlcixcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgaXNUb3VjaEV2ZW50ID0gZmFicmljLnV0aWwuaXNUb3VjaEV2ZW50O1xuXG4gIC8qKlxuICAgKiBDYW52YXMgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5DYW52YXNcbiAgICogQGV4dGVuZHMgZmFicmljLlN0YXRpY0NhbnZhc1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNjYW52YXN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5DYW52YXMjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICpcbiAgICogQGZpcmVzIG9iamVjdDptb2RpZmllZCBhdCB0aGUgZW5kIG9mIGEgdHJhbnNmb3JtIG9yIGFueSBjaGFuZ2Ugd2hlbiBzdGF0ZWZ1bGwgaXMgdHJ1ZVxuICAgKiBAZmlyZXMgb2JqZWN0OnJvdGF0aW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyByb3RhdGVkIGZyb20gdGhlIGNvbnRyb2xcbiAgICogQGZpcmVzIG9iamVjdDpzY2FsaW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyBzY2FsZWQgYnkgY29udHJvbHNcbiAgICogQGZpcmVzIG9iamVjdDptb3Zpbmcgd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIGRyYWdnZWRcbiAgICogQGZpcmVzIG9iamVjdDpza2V3aW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyBza2V3ZWQgZnJvbSB0aGUgY29udHJvbHNcbiAgICpcbiAgICogQGZpcmVzIGJlZm9yZTp0cmFuc2Zvcm0gYmVmb3JlIGEgdHJhbnNmb3JtIGlzIGlzIHN0YXJ0ZWRcbiAgICogQGZpcmVzIGJlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNsZWFyZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjp1cGRhdGVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y3JlYXRlZFxuICAgKlxuICAgKiBAZmlyZXMgcGF0aDpjcmVhdGVkIGFmdGVyIGEgZHJhd2luZyBvcGVyYXRpb24gZW5kcyBhbmQgdGhlIHBhdGggaXMgYWRkZWRcbiAgICogQGZpcmVzIG1vdXNlOmRvd25cbiAgICogQGZpcmVzIG1vdXNlOm1vdmVcbiAgICogQGZpcmVzIG1vdXNlOnVwXG4gICAqIEBmaXJlcyBtb3VzZTpkb3duOmJlZm9yZSAgb24gbW91c2UgZG93biwgYmVmb3JlIHRoZSBpbm5lciBmYWJyaWMgbG9naWMgcnVuc1xuICAgKiBAZmlyZXMgbW91c2U6bW92ZTpiZWZvcmUgb24gbW91c2UgbW92ZSwgYmVmb3JlIHRoZSBpbm5lciBmYWJyaWMgbG9naWMgcnVuc1xuICAgKiBAZmlyZXMgbW91c2U6dXA6YmVmb3JlIG9uIG1vdXNlIHVwLCBiZWZvcmUgdGhlIGlubmVyIGZhYnJpYyBsb2dpYyBydW5zXG4gICAqIEBmaXJlcyBtb3VzZTpvdmVyXG4gICAqIEBmaXJlcyBtb3VzZTpvdXRcbiAgICogQGZpcmVzIG1vdXNlOmRibGNsaWNrIHdoZW5ldmVyIGEgbmF0aXZlIGRibCBjbGljayBldmVudCBmaXJlcyBvbiB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBAZmlyZXMgZHJhZ292ZXJcbiAgICogQGZpcmVzIGRyYWdlbnRlclxuICAgKiBAZmlyZXMgZHJhZ2xlYXZlXG4gICAqIEBmaXJlcyBkcm9wOmJlZm9yZSBiZWZvcmUgZHJvcCBldmVudC4gc2FtZSBuYXRpdmUgZXZlbnQuIFRoaXMgaXMgYWRkZWQgdG8gaGFuZGxlIGVkZ2UgY2FzZXNcbiAgICogQGZpcmVzIGRyb3BcbiAgICogQGZpcmVzIGFmdGVyOnJlbmRlciBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXIgcHJvY2VzcywgcmVjZWl2ZXMgdGhlIGNvbnRleHQgaW4gdGhlIGNhbGxiYWNrXG4gICAqIEBmaXJlcyBiZWZvcmU6cmVuZGVyIGF0IHN0YXJ0IHRoZSByZW5kZXIgcHJvY2VzcywgcmVjZWl2ZXMgdGhlIGNvbnRleHQgaW4gdGhlIGNhbGxiYWNrXG4gICAqXG4gICAqL1xuICBmYWJyaWMuQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlN0YXRpY0NhbnZhcywgLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLnJlbmRlckFuZFJlc2V0Qm91bmQgPSB0aGlzLnJlbmRlckFuZFJlc2V0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGxCb3VuZCA9IHRoaXMucmVxdWVzdFJlbmRlckFsbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5faW5pdFN0YXRpYyhlbCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0SW50ZXJhY3RpdmUoKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0cyBjYW4gYmUgdHJhbnNmb3JtZWQgYnkgb25lIHNpZGUgKHVucHJvcG9ydGlvbmFsbHkpXG4gICAgICogd2hlbiBkcmFnZ2VkIG9uIHRoZSBjb3JuZXJzIHRoYXQgbm9ybWFsbHkgd291bGQgbm90IGRvIHRoYXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHNpbmNlIGZhYnJpYyA0LjAgLy8gY2hhbmdlZCBuYW1lIGFuZCBkZWZhdWx0IHZhbHVlXG4gICAgICovXG4gICAgdW5pZm9ybVNjYWxpbmc6ICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgc3dpdGNoZXMgdW5pZm9ybSBzY2FsaW5nLlxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIHRvdGFsbHkgd3JvbmcgbmFtZWQuIHRoaXMgc291bmRzIGxpa2UgYHVuaWZvcm0gc2NhbGluZ2BcbiAgICAgKiBpZiBDYW52YXMudW5pZm9ybVNjYWxpbmcgaXMgdHJ1ZSwgcHJlc3NpbmcgdGhpcyB3aWxsIHNldCBpdCB0byBmYWxzZVxuICAgICAqIGFuZCB2aWNldmVyc2EuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1bmlTY2FsZUtleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHNjYWxlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRTY2FsaW5nOiAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHJvdGF0ZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkUm90YXRpb246ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgY2VudGVyZWQgVHJhbnNmb3JtXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQgZmVhdHVyZSBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkS2V5OiAgICAgICAgICAgJ2FsdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBhbHRlcm5hdGUgYWN0aW9uIG9uIGNvcm5lclxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbHRBY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgY2FudmFzIGlzIGludGVyYWN0aXZlLiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnRlcmFjdGl2ZTogICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgZ3JvdXAgc2VsZWN0aW9uIHNob3VsZCBiZSBlbmFibGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgb3Iga2V5cyBlbmFibGUgbXVsdGlwbGUgY2xpY2sgc2VsZWN0aW9uXG4gICAgICogUGFzcyB2YWx1ZSBhcyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciBlbXB0eSBvciBjb250YWluaW5nIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ3xBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uS2V5OiAgICAgICAgICAgJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGFsdGVybmF0aXZlIHNlbGVjdGlvblxuICAgICAqIGluIGNhc2Ugb2YgdGFyZ2V0IG92ZXJsYXBwaW5nIHdpdGggYWN0aXZlIG9iamVjdFxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBGb3IgYSBzZXJpZXMgb2YgcmVhc29uIHRoYXQgY29tZSBmcm9tIHRoZSBnZW5lcmFsIGV4cGVjdGF0aW9ucyBvbiBob3dcbiAgICAgKiB0aGluZ3Mgc2hvdWxkIHdvcmssIHRoaXMgZmVhdHVyZSB3b3JrcyBvbmx5IGZvciBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nIHRydWUuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAdHlwZSBudWxsfFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWx0U2VsZWN0aW9uS2V5OiAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHNlbGVjdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQ29sb3I6ICAgICAgICAgJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC4zKScsIC8vIGJsdWVcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZGFzaCBhcnJheSBwYXR0ZXJuXG4gICAgICogSWYgbm90IGVtcHR5IHRoZSBzZWxlY3Rpb24gYm9yZGVyIGlzIGRhc2hlZFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc2VsZWN0aW9uRGFzaEFycmF5OiAgICAgW10sXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0aGUgYm9yZGVyIG9mIHNlbGVjdGlvbiAodXN1YWxseSBzbGlnaHRseSBkYXJrZXIgdGhhbiBjb2xvciBvZiBzZWxlY3Rpb24gaXRzZWxmKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQm9yZGVyQ29sb3I6ICAgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIGxpbmUgdXNlZCBpbiBvYmplY3QvZ3JvdXAgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25MaW5lV2lkdGg6ICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IG9ubHkgc2hhcGVzIHRoYXQgYXJlIGZ1bGx5IGNvbnRhaW5lZCBpbiB0aGUgZHJhZ2dlZCBzZWxlY3Rpb24gcmVjdGFuZ2xlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBob3ZlcmluZyBvdmVyIGFuIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhvdmVyQ3Vyc29yOiAgICAgICAgICAgICdtb3ZlJyxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBtb3ZpbmcgYW4gb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgJ21vdmUnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCBmb3IgdGhlIGVudGlyZSBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGRlZmF1bHRDdXJzb3I6ICAgICAgICAgICdkZWZhdWx0JyxcblxuICAgIC8qKlxuICAgICAqIEN1cnNvciB2YWx1ZSB1c2VkIGR1cmluZyBmcmVlIGRyYXdpbmdcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZyZWVEcmF3aW5nQ3Vyc29yOiAgICAgICdjcm9zc2hhaXInLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZm9yIGRpc2FibGVkIGVsZW1lbnRzICggY29ybmVycyB3aXRoIGRpc2FibGVkIGFjdGlvbiApXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBub3RBbGxvd2VkQ3Vyc29yOiAgICAgICAgICdub3QtYWxsb3dlZCcsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGVsZW1lbnQgY2xhc3MgdGhhdCdzIGdpdmVuIHRvIHdyYXBwZXIgKGRpdikgZWxlbWVudCBvZiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbnRhaW5lckNsYXNzOiAgICAgICAgICdjYW52YXMtY29udGFpbmVyJyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0IGRldGVjdGlvbiBoYXBwZW5zIG9uIHBlci1waXhlbCBiYXNpcyByYXRoZXIgdGhhbiBvbiBwZXItYm91bmRpbmctYm94XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGVyUGl4ZWxUYXJnZXRGaW5kOiAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGFyb3VuZCB0YXJnZXQgcGl4ZWwgdG8gdG9sZXJhdGUgKGNvbnNpZGVyIGFjdGl2ZSkgZHVyaW5nIG9iamVjdCBkZXRlY3Rpb25cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRhcmdldEZpbmRUb2xlcmFuY2U6ICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRhcmdldCBkZXRlY3Rpb24gaXMgc2tpcHBlZC4gVGFyZ2V0IGRldGVjdGlvbiB3aWxsIHJldHVybiBhbHdheXMgdW5kZWZpbmVkLlxuICAgICAqIGNsaWNrIHNlbGVjdGlvbiB3b24ndCB3b3JrIGFueW1vcmUsIGV2ZW50cyB3aWxsIGZpcmUgd2l0aCBubyB0YXJnZXRzLlxuICAgICAqIGlmIHNvbWV0aGluZyBpcyBzZWxlY3RlZCBiZWZvcmUgc2V0dGluZyBpdCB0byB0cnVlLCBpdCB3aWxsIGJlIGRlc2VsZWN0ZWQgYXQgdGhlIGZpcnN0IGNsaWNrLlxuICAgICAqIGFyZWEgc2VsZWN0aW9uIHdpbGwgc3RpbGwgd29yay4gY2hlY2sgdGhlIGBzZWxlY3Rpb25gIHByb3BlcnR5IHRvby5cbiAgICAgKiBpZiB5b3UgZGVhY3RpdmF0ZSBib3RoLCB5b3Ugc2hvdWxkIGxvb2sgaW50byBzdGF0aWNDYW52YXMuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tpcFRhcmdldEZpbmQ6ICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG1vdXNlIGV2ZW50cyBvbiBjYW52YXMgKG1vdXNlZG93bi9tb3VzZW1vdmUvbW91c2V1cCkgcmVzdWx0IGluIGZyZWUgZHJhd2luZy5cbiAgICAgKiBBZnRlciBtb3VzZWRvd24sIG1vdXNlbW92ZSBjcmVhdGVzIGEgc2hhcGUsXG4gICAgICogYW5kIHRoZW4gbW91c2V1cCBmaW5hbGl6ZXMgaXQgYW5kIGFkZHMgYW4gaW5zdGFuY2Ugb2YgYGZhYnJpYy5QYXRoYCBvbnRvIGNhbnZhcy5cbiAgICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtNCNmcmVlX2RyYXdpbmd9XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaXNEcmF3aW5nTW9kZTogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3RzIHNob3VsZCByZW1haW4gaW4gY3VycmVudCBzdGFjayBwb3NpdGlvbiB3aGVuIHNlbGVjdGVkLlxuICAgICAqIFdoZW4gZmFsc2Ugb2JqZWN0cyBhcmUgYnJvdWdodCB0byB0b3AgYW5kIHJlbmRlcmVkIGFzIHBhcnQgb2YgdGhlIHNlbGVjdGlvbiBncm91cFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHByZXNlcnZlT2JqZWN0U3RhY2tpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBhbmdsZSB0aGF0IGFuIG9iamVjdCB3aWxsIGxvY2sgdG8gd2hpbGUgcm90YXRpbmcuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHNpbmNlIDEuNi43XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzbmFwQW5nbGU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHNuYXBBbmdsZSB0aGUgcm90YXRpb24gd2lsbCBsb2NrIHRvIHRoZSBzbmFwQW5nbGUuXG4gICAgICogV2hlbiBgbnVsbGAsIHRoZSBzbmFwVGhyZXNob2xkIHdpbGwgZGVmYXVsdCB0byB0aGUgc25hcEFuZ2xlLlxuICAgICAqIEB0eXBlIG51bGx8TnVtYmVyXG4gICAgICogQHNpbmNlIDEuNi43XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzbmFwVGhyZXNob2xkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSByaWdodCBjbGljayBvbiBjYW52YXMgY2FuIG91dHB1dCB0aGUgY29udGV4dCBtZW51IG9yIG5vdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0b3BDb250ZXh0TWVudTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNhbnZhcyBjYW4gZmlyZSByaWdodCBjbGljayBldmVudHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaXJlUmlnaHRDbGljazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNhbnZhcyBjYW4gZmlyZSBtaWRkbGUgY2xpY2sgZXZlbnRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjcuOFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlyZU1pZGRsZUNsaWNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEtlZXAgdHJhY2sgb2YgdGhlIHN1YlRhcmdldHMgZm9yIE1vdXNlIEV2ZW50c1xuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RbXVxuICAgICAqL1xuICAgIHRhcmdldHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgb3B0aW9uIGlzIGVuYWJsZWQsIFBvaW50ZXJFdmVudCBpcyB1c2VkIGluc3RlYWQgb2YgTW91c2VFdmVudC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlbmFibGVQb2ludGVyRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEtlZXAgdHJhY2sgb2YgdGhlIGhvdmVyZWQgdGFyZ2V0XG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hvdmVyZWRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBob2xkIHRoZSBsaXN0IG9mIG5lc3RlZCB0YXJnZXRzIGhvdmVyZWRcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0W11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ob3ZlcmVkVGFyZ2V0czogW10sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0SW50ZXJhY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IG51bGw7XG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX2luaXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgdGhpcy5fY3JlYXRlVXBwZXJDYW52YXMoKTtcbiAgICAgIHRoaXMuX2luaXRFdmVudExpc3RlbmVycygpO1xuXG4gICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuXG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggPSBmYWJyaWMuUGVuY2lsQnJ1c2ggJiYgbmV3IGZhYnJpYy5QZW5jaWxCcnVzaCh0aGlzKTtcblxuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgb2JqZWN0cyBpbiB0d28gZ3JvdXBzLCBvbmUgdG8gcmVuZGVyIGltbWVkaWF0ZWx5XG4gICAgICogYW5kIG9uZSB0byByZW5kZXIgYXMgYWN0aXZlR3JvdXAuXG4gICAgICogQHJldHVybiB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyIGltbWVkaWF0ZWx5IGFuZCBwdXNoZXMgdGhlIG90aGVyIGluIHRoZSBhY3RpdmVHcm91cC5cbiAgICAgKi9cbiAgICBfY2hvb3NlT2JqZWN0c1RvUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgb2JqZWN0LCBvYmpzVG9SZW5kZXIsIGFjdGl2ZUdyb3VwT2JqZWN0cztcblxuICAgICAgaWYgKGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMCAmJiAhdGhpcy5wcmVzZXJ2ZU9iamVjdFN0YWNraW5nKSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IFtdO1xuICAgICAgICBhY3RpdmVHcm91cE9iamVjdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICAgIGlmIChhY3RpdmVPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEgKSB7XG4gICAgICAgICAgICBvYmpzVG9SZW5kZXIucHVzaChvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZUdyb3VwT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVPYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QuX29iamVjdHMgPSBhY3RpdmVHcm91cE9iamVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2guYXBwbHkob2Jqc1RvUmVuZGVyLCBhY3RpdmVHcm91cE9iamVjdHMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IHRoaXMuX29iamVjdHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Jqc1RvUmVuZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJvdGggdGhlIHRvcCBjYW52YXMgYW5kIHRoZSBzZWNvbmRhcnkgY29udGFpbmVyIGNhbnZhcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRUb3BEaXJ0eSAmJiAhdGhpcy5fZ3JvdXBTZWxlY3RvciAmJiAhdGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNMb3N0Q29udGV4dCkge1xuICAgICAgICB0aGlzLnJlbmRlclRvcExheWVyKHRoaXMuY29udGV4dFRvcCk7XG4gICAgICAgIHRoaXMuaGFzTG9zdENvbnRleHQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXNUb0RyYXdPbiA9IHRoaXMuY29udGV4dENvbnRhaW5lcjtcbiAgICAgIHRoaXMucmVuZGVyQ2FudmFzKGNhbnZhc1RvRHJhd09uLCB0aGlzLl9jaG9vc2VPYmplY3RzVG9SZW5kZXIoKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVuZGVyVG9wTGF5ZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUgJiYgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2guX3JlbmRlcigpO1xuICAgICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyB3ZSByZW5kZXIgdGhlIHRvcCBjb250ZXh0IC0gbGFzdCBvYmplY3RcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiAmJiB0aGlzLl9ncm91cFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTZWxlY3Rpb24oY3R4KTtcbiAgICAgICAgdGhpcy5jb250ZXh0VG9wRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHJlbmRlciBvbmx5IHRoZSB0b3AgY2FudmFzLlxuICAgICAqIEFsc28gdXNlZCB0byByZW5kZXIgdGhlIGdyb3VwIHNlbGVjdGlvbiBib3guXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJUb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRUb3A7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5yZW5kZXJUb3BMYXllcihjdHgpO1xuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVQb2ludGVyOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludGVyKSB7XG4gICAgICB2YXIgbSA9IG9iamVjdC5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgaW52ZXJ0ZWRNID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG0pLFxuICAgICAgICAgIHZwdFBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZwdFBvaW50ZXIsIGludmVydGVkTSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgdHJhbnNwYXJlbnQgYXQgYSBjZXJ0YWluIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVG9wIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVGFyZ2V0VHJhbnNwYXJlbnQ6IGZ1bmN0aW9uICh0YXJnZXQsIHgsIHkpIHtcbiAgICAgIC8vIGluIGNhc2UgdGhlIHRhcmdldCBpcyB0aGUgYWN0aXZlT2JqZWN0LCB3ZSBjYW5ub3QgZXhlY3V0ZSB0aGlzIG9wdGltaXphdGlvblxuICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGRyYXcgY29udHJvbHMgdG9vLlxuICAgICAgaWYgKHRhcmdldC5zaG91bGRDYWNoZSgpICYmIHRhcmdldC5fY2FjaGVDYW52YXMgJiYgdGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRQb2ludGVyID0gdGhpcy5fbm9ybWFsaXplUG9pbnRlcih0YXJnZXQsIHt4OiB4LCB5OiB5fSksXG4gICAgICAgICAgICB0YXJnZXRSZWxhdGl2ZVggPSBNYXRoLm1heCh0YXJnZXQuY2FjaGVUcmFuc2xhdGlvblggKyAobm9ybWFsaXplZFBvaW50ZXIueCAqIHRhcmdldC56b29tWCksIDApLFxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmVZID0gTWF0aC5tYXgodGFyZ2V0LmNhY2hlVHJhbnNsYXRpb25ZICsgKG5vcm1hbGl6ZWRQb2ludGVyLnkgKiB0YXJnZXQuem9vbVkpLCAwKTtcblxuICAgICAgICB2YXIgaXNUcmFuc3BhcmVudCA9IGZhYnJpYy51dGlsLmlzVHJhbnNwYXJlbnQoXG4gICAgICAgICAgdGFyZ2V0Ll9jYWNoZUNvbnRleHQsIE1hdGgucm91bmQodGFyZ2V0UmVsYXRpdmVYKSwgTWF0aC5yb3VuZCh0YXJnZXRSZWxhdGl2ZVkpLCB0aGlzLnRhcmdldEZpbmRUb2xlcmFuY2UpO1xuXG4gICAgICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0Q2FjaGUsXG4gICAgICAgICAgb3JpZ2luYWxDb2xvciA9IHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IsIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuXG4gICAgICB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yID0gJyc7XG5cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgdGFyZ2V0LnJlbmRlcihjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciA9IG9yaWdpbmFsQ29sb3I7XG5cbiAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZmFicmljLnV0aWwuaXNUcmFuc3BhcmVudChcbiAgICAgICAgY3R4LCB4LCB5LCB0aGlzLnRhcmdldEZpbmRUb2xlcmFuY2UpO1xuXG4gICAgICByZXR1cm4gaXNUcmFuc3BhcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGFrZXMgYW4gZXZlbnQgYW5kIGRldGVybWluZXMgaWYgc2VsZWN0aW9uIGtleSBoYXMgYmVlbiBwcmVzc2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9pc1NlbGVjdGlvbktleVByZXNzZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25LZXlQcmVzc2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5zZWxlY3Rpb25LZXkpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHNlbGVjdGlvbktleVByZXNzZWQgPSAhIXRoaXMuc2VsZWN0aW9uS2V5LmZpbmQoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBlW2tleV0gPT09IHRydWU7IH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbktleVByZXNzZWQgPSBlW3RoaXMuc2VsZWN0aW9uS2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGVjdGlvbktleVByZXNzZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9zaG91bGRDbGVhclNlbGVjdGlvbjogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgICF0YXJnZXRcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdHMuaW5kZXhPZih0YXJnZXQpID09PSAtMSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0ICYmXG4gICAgICAgICAgIXRoaXMuX2lzU2VsZWN0aW9uS2V5UHJlc3NlZChlKSlcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJiAhdGFyZ2V0LmV2ZW50ZWQpXG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICAhdGFyZ2V0LnNlbGVjdGFibGUgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgIT09IHRhcmdldClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNlbnRlcmVkU2NhbGluZyBmcm9tIG9iamVjdCBjYW4ndCBvdmVycmlkZSBjZW50ZXJlZFNjYWxpbmcgZnJvbSBjYW52YXMuXG4gICAgICogdGhpcyBzaG91bGQgYmUgZml4ZWQsIHNpbmNlIG9iamVjdCBzZXR0aW5nIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBjYW52YXMuXG4gICAgICogYWxzbyB0aGlzIHNob3VsZCBiZSBzb21ldGhpbmcgdGhhdCB3aWxsIGJlIG1pZ3JhdGVkIGluIHRoZSBjb250cm9sIHByb3BlcnRpZXMuXG4gICAgICogYXMgYWJpbGl0eSB0byBkZWZpbmUgdGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24gdGhhdCB0aGUgY29udHJvbCBwcm92aWRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbHRLZXlcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2VudGVyVHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0LCBhY3Rpb24sIGFsdEtleSkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VudGVyVHJhbnNmb3JtO1xuXG4gICAgICBpZiAoYWN0aW9uID09PSAnc2NhbGUnIHx8IGFjdGlvbiA9PT0gJ3NjYWxlWCcgfHwgYWN0aW9uID09PSAnc2NhbGVZJyB8fCBhY3Rpb24gPT09ICdyZXNpemluZycpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFNjYWxpbmcgfHwgdGFyZ2V0LmNlbnRlcmVkU2NhbGluZztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFJvdGF0aW9uIHx8IHRhcmdldC5jZW50ZXJlZFJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2VudGVyVHJhbnNmb3JtID8gIWFsdEtleSA6IGFsdEtleTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2hvdWxkIGRpc2FwcGVhciBiZWZvcmUgcmVsZWFzZSA0LjBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRPcmlnaW5Gcm9tQ29ybmVyOiBmdW5jdGlvbih0YXJnZXQsIGNvcm5lcikge1xuICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgeDogdGFyZ2V0Lm9yaWdpblgsXG4gICAgICAgIHk6IHRhcmdldC5vcmlnaW5ZXG4gICAgICB9O1xuXG4gICAgICBpZiAoY29ybmVyID09PSAnbWwnIHx8IGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdibCcpIHtcbiAgICAgICAgb3JpZ2luLnggPSAncmlnaHQnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnbXInIHx8IGNvcm5lciA9PT0gJ3RyJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnggPSAnbGVmdCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICd0bCcgfHwgY29ybmVyID09PSAnbXQnIHx8IGNvcm5lciA9PT0gJ3RyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnYmwnIHx8IGNvcm5lciA9PT0gJ21iJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnkgPSAndG9wJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbHJlYWR5U2VsZWN0ZWQgdHJ1ZSBpZiB0YXJnZXQgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb3JuZXIgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXIgbWwsIG1yLCB0bCAuLi5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW3RhcmdldF0gaW5zZXJ0ZWQgYmFjayB0byBoZWxwIG92ZXJyaWRpbmcuIFVudXNlZFxuICAgICAqL1xuICAgIF9nZXRBY3Rpb25Gcm9tQ29ybmVyOiBmdW5jdGlvbihhbHJlYWR5U2VsZWN0ZWQsIGNvcm5lciwgZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoIWNvcm5lciB8fCAhYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiAnZHJhZyc7XG4gICAgICB9XG4gICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdO1xuICAgICAgcmV0dXJuIGNvbnRyb2wuZ2V0QWN0aW9uTmFtZShlLCBjb250cm9sLCB0YXJnZXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2V0dXBDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbiAoZSwgdGFyZ2V0LCBhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksIGNvcm5lciA9IHRhcmdldC5fX2Nvcm5lcixcbiAgICAgICAgICBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl0sXG4gICAgICAgICAgYWN0aW9uSGFuZGxlciA9IChhbHJlYWR5U2VsZWN0ZWQgJiYgY29ybmVyKSA/XG4gICAgICAgICAgICBjb250cm9sLmdldEFjdGlvbkhhbmRsZXIoZSwgdGFyZ2V0LCBjb250cm9sKSA6IGZhYnJpYy5jb250cm9sc1V0aWxzLmRyYWdIYW5kbGVyLFxuICAgICAgICAgIGFjdGlvbiA9IHRoaXMuX2dldEFjdGlvbkZyb21Db3JuZXIoYWxyZWFkeVNlbGVjdGVkLCBjb3JuZXIsIGUsIHRhcmdldCksXG4gICAgICAgICAgb3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luRnJvbUNvcm5lcih0YXJnZXQsIGNvcm5lciksXG4gICAgICAgICAgYWx0S2V5ID0gZVt0aGlzLmNlbnRlcmVkS2V5XSxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgYWN0aW9uSGFuZGxlcjogYWN0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICAgICAgc2NhbGVYOiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICAgICAgc2tld1g6IHRhcmdldC5za2V3WCxcbiAgICAgICAgICAgIHNrZXdZOiB0YXJnZXQuc2tld1ksXG4gICAgICAgICAgICAvLyB1c2VkIGJ5IHRyYW5zYXRpb25cbiAgICAgICAgICAgIG9mZnNldFg6IHBvaW50ZXIueCAtIHRhcmdldC5sZWZ0LFxuICAgICAgICAgICAgb2Zmc2V0WTogcG9pbnRlci55IC0gdGFyZ2V0LnRvcCxcbiAgICAgICAgICAgIG9yaWdpblg6IG9yaWdpbi54LFxuICAgICAgICAgICAgb3JpZ2luWTogb3JpZ2luLnksXG4gICAgICAgICAgICBleDogcG9pbnRlci54LFxuICAgICAgICAgICAgZXk6IHBvaW50ZXIueSxcbiAgICAgICAgICAgIGxhc3RYOiBwb2ludGVyLngsXG4gICAgICAgICAgICBsYXN0WTogcG9pbnRlci55LFxuICAgICAgICAgICAgLy8gdW5zdXJlIHRoZXkgYXJlIHVzZWZ1bCBhbnltb3JlLlxuICAgICAgICAgICAgLy8gbGVmdDogdGFyZ2V0LmxlZnQsXG4gICAgICAgICAgICAvLyB0b3A6IHRhcmdldC50b3AsXG4gICAgICAgICAgICB0aGV0YTogZGVncmVlc1RvUmFkaWFucyh0YXJnZXQuYW5nbGUpLFxuICAgICAgICAgICAgLy8gZW5kIG9mIHVuc3VyZVxuICAgICAgICAgICAgd2lkdGg6IHRhcmdldC53aWR0aCAqIHRhcmdldC5zY2FsZVgsXG4gICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGFsdEtleTogYWx0S2V5LFxuICAgICAgICAgICAgb3JpZ2luYWw6IGZhYnJpYy51dGlsLnNhdmVPYmplY3RUcmFuc2Zvcm0odGFyZ2V0KSxcbiAgICAgICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2VudGVyVHJhbnNmb3JtKHRhcmdldCwgYWN0aW9uLCBhbHRLZXkpKSB7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gJ2NlbnRlcic7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5ZID0gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0ub3JpZ2luYWwub3JpZ2luWCA9IG9yaWdpbi54O1xuICAgICAgdHJhbnNmb3JtLm9yaWdpbmFsLm9yaWdpblkgPSBvcmlnaW4ueTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICB0aGlzLl9iZWZvcmVUcmFuc2Zvcm0oZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3Vyc29yIHR5cGUgb2YgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIEN1cnNvciB0eXBlIG9mIHRoZSBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdWkvI2N1cnNvclxuICAgICAqL1xuICAgIHNldEN1cnNvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuc3R5bGUuY3Vyc29yID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0byBkcmF3IHRoZSBzZWxlY3Rpb24gb25cbiAgICAgKi9cbiAgICBfZHJhd1NlbGVjdGlvbjogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3RvcixcbiAgICAgICAgICB2aWV3cG9ydFN0YXJ0ID0gbmV3IGZhYnJpYy5Qb2ludChzZWxlY3Rvci5leCwgc2VsZWN0b3IuZXkpLFxuICAgICAgICAgIHN0YXJ0ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQodmlld3BvcnRTdGFydCwgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSksXG4gICAgICAgICAgdmlld3BvcnRFeHRlbnQgPSBuZXcgZmFicmljLlBvaW50KHNlbGVjdG9yLmV4ICsgc2VsZWN0b3IubGVmdCwgc2VsZWN0b3IuZXkgKyBzZWxlY3Rvci50b3ApLFxuICAgICAgICAgIGV4dGVudCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZpZXdwb3J0RXh0ZW50LCB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKSxcbiAgICAgICAgICBtaW5YID0gTWF0aC5taW4oc3RhcnQueCwgZXh0ZW50LngpLFxuICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihzdGFydC55LCBleHRlbnQueSksXG4gICAgICAgICAgbWF4WCA9IE1hdGgubWF4KHN0YXJ0LngsIGV4dGVudC54KSxcbiAgICAgICAgICBtYXhZID0gTWF0aC5tYXgoc3RhcnQueSwgZXh0ZW50LnkpLFxuICAgICAgICAgIHN0cm9rZU9mZnNldCA9IHRoaXMuc2VsZWN0aW9uTGluZVdpZHRoIC8gMjtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uQ29sb3IpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uTGluZVdpZHRoIHx8ICF0aGlzLnNlbGVjdGlvbkJvcmRlckNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQm9yZGVyQ29sb3I7XG5cbiAgICAgIG1pblggKz0gc3Ryb2tlT2Zmc2V0O1xuICAgICAgbWluWSArPSBzdHJva2VPZmZzZXQ7XG4gICAgICBtYXhYIC09IHN0cm9rZU9mZnNldDtcbiAgICAgIG1heFkgLT0gc3Ryb2tlT2Zmc2V0O1xuICAgICAgLy8gc2VsZWN0aW9uIGJvcmRlclxuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldExpbmVEYXNoLmNhbGwodGhpcywgY3R4LCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICBjdHguc3Ryb2tlUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZXRlcm1pbmVzIHdoYXQgb2JqZWN0IHdlIGFyZSBjbGlja2luZyBvblxuICAgICAqIHRoZSBza2lwR3JvdXAgcGFyYW1ldGVyIGlzIGZvciBpbnRlcm5hbCB1c2UsIGlzIG5lZWRlZCBmb3Igc2hpZnQrY2xpY2sgYWN0aW9uXG4gICAgICogMTEvMDkvMjAxOCBUT0RPOiB3b3VsZCBiZSBjb29sIGlmIGZpbmRUYXJnZXQgY291bGQgZGlzY2VybiBiZXR3ZWVuIGJlaW5nIGEgZnVsbCB0YXJnZXRcbiAgICAgKiBvciB0aGUgb3V0c2lkZSBwYXJ0IG9mIHRoZSBjb3JuZXIuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcEdyb3VwIHdoZW4gdHJ1ZSwgYWN0aXZlR3JvdXAgaXMgc2tpcHBlZCBhbmQgb25seSBvYmplY3RzIGFyZSB0cmF2ZXJzZWQgdGhyb3VnaFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoZSB0YXJnZXQgZm91bmRcbiAgICAgKi9cbiAgICBmaW5kVGFyZ2V0OiBmdW5jdGlvbiAoZSwgc2tpcEdyb3VwKSB7XG4gICAgICBpZiAodGhpcy5za2lwVGFyZ2V0RmluZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZSxcbiAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUsIGlnbm9yZVpvb20pLFxuICAgICAgICAgIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBhT2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFjdGl2ZVRhcmdldCwgYWN0aXZlVGFyZ2V0U3VicyxcbiAgICAgICAgICBpc1RvdWNoID0gaXNUb3VjaEV2ZW50KGUpLFxuICAgICAgICAgIHNob3VsZExvb2tGb3JBY3RpdmUgPSAoYU9iamVjdHMubGVuZ3RoID4gMSAmJiAhc2tpcEdyb3VwKSB8fCBhT2JqZWN0cy5sZW5ndGggPT09IDE7XG5cbiAgICAgIC8vIGZpcnN0IGNoZWNrIGN1cnJlbnQgZ3JvdXAgKGlmIG9uZSBleGlzdHMpXG4gICAgICAvLyBhY3RpdmUgZ3JvdXAgZG9lcyBub3QgY2hlY2sgc3ViIHRhcmdldHMgbGlrZSBub3JtYWwgZ3JvdXBzLlxuICAgICAgLy8gaWYgYWN0aXZlIGdyb3VwIGp1c3QgZXhpdHMuXG4gICAgICB0aGlzLnRhcmdldHMgPSBbXTtcblxuICAgICAgLy8gaWYgd2UgaGl0IHRoZSBjb3JuZXIgb2YgYW4gYWN0aXZlT2JqZWN0LCBsZXQncyByZXR1cm4gdGhhdC5cbiAgICAgIGlmIChzaG91bGRMb29rRm9yQWN0aXZlICYmIGFjdGl2ZU9iamVjdC5fZmluZFRhcmdldENvcm5lcihwb2ludGVyLCBpc1RvdWNoKSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGFPYmplY3RzLmxlbmd0aCA+IDEgJiYgIXNraXBHcm91cCAmJiBhY3RpdmVPYmplY3QgPT09IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyhbYWN0aXZlT2JqZWN0XSwgcG9pbnRlcikpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChhT2JqZWN0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgYWN0aXZlT2JqZWN0ID09PSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHMoW2FjdGl2ZU9iamVjdF0sIHBvaW50ZXIpKSB7XG4gICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZU9iamVjdFN0YWNraW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY3RpdmVUYXJnZXQgPSBhY3RpdmVPYmplY3Q7XG4gICAgICAgICAgYWN0aXZlVGFyZ2V0U3VicyA9IHRoaXMudGFyZ2V0cztcbiAgICAgICAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyh0aGlzLl9vYmplY3RzLCBwb2ludGVyKTtcbiAgICAgIGlmIChlW3RoaXMuYWx0U2VsZWN0aW9uS2V5XSAmJiB0YXJnZXQgJiYgYWN0aXZlVGFyZ2V0ICYmIHRhcmdldCAhPT0gYWN0aXZlVGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldCA9IGFjdGl2ZVRhcmdldDtcbiAgICAgICAgdGhpcy50YXJnZXRzID0gYWN0aXZlVGFyZ2V0U3VicztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50ZXJdIHgseSBvYmplY3Qgb2YgcG9pbnQgY29vcmRpbmF0ZXMgd2Ugd2FudCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdG8gdGVzdCBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtnbG9iYWxQb2ludGVyXSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcyB1c2VkIHRvIHNlYXJjaCBwZXIgcGl4ZWwgdGFyZ2V0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiBhbiBhcmVhIG9mIGdpdmVuIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoZWNrVGFyZ2V0OiBmdW5jdGlvbihwb2ludGVyLCBvYmosIGdsb2JhbFBvaW50ZXIpIHtcbiAgICAgIGlmIChvYmogJiZcbiAgICAgICAgICBvYmoudmlzaWJsZSAmJlxuICAgICAgICAgIG9iai5ldmVudGVkICYmXG4gICAgICAgICAgLy8gaHR0cDovL3d3dy5nZW9nLnViYy5jYS9jb3Vyc2VzL2tsaW5rL2dpcy5ub3Rlcy9uY2dpYS91MzIuaHRtbFxuICAgICAgICAgIC8vIGh0dHA6Ly9pZGF2LnVjZGF2aXMuZWR1L35va3JleWxvcy9UQXNoaXAvU3ByaW5nMjAwMC9Qb2ludEluUG9seWdvbi5odG1sXG4gICAgICAgICAgb2JqLmNvbnRhaW5zUG9pbnQocG9pbnRlcilcbiAgICAgICkge1xuICAgICAgICBpZiAoKHRoaXMucGVyUGl4ZWxUYXJnZXRGaW5kIHx8IG9iai5wZXJQaXhlbFRhcmdldEZpbmQpICYmICFvYmouaXNFZGl0aW5nKSB7XG4gICAgICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSB0aGlzLmlzVGFyZ2V0VHJhbnNwYXJlbnQob2JqLCBnbG9iYWxQb2ludGVyLngsIGdsb2JhbFBvaW50ZXIueSk7XG4gICAgICAgICAgaWYgKCFpc1RyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBzZWFyY2ggaW5zaWRlIG9iamVjdHMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9pbnRlciBpbiBib3VuZGluZyBib3ggb3IgdGhhdCBjb250YWlucyBwb2ludGVyT25DYW52YXMgd2hlbiBwYWludGVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29iamVjdHNdIG9iamVjdHMgYXJyYXkgdG8gbG9vayBpbnRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludGVyXSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHdlIHdhbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlYXJjaFBvc3NpYmxlVGFyZ2V0czogZnVuY3Rpb24ob2JqZWN0cywgcG9pbnRlcikge1xuICAgICAgLy8gQ2FjaGUgYWxsIHRhcmdldHMgd2hlcmUgdGhlaXIgYm91bmRpbmcgYm94IGNvbnRhaW5zIHBvaW50LlxuICAgICAgdmFyIHRhcmdldCwgaSA9IG9iamVjdHMubGVuZ3RoLCBzdWJUYXJnZXQ7XG4gICAgICAvLyBEbyBub3QgY2hlY2sgZm9yIGN1cnJlbnRseSBncm91cGVkIG9iamVjdHMsIHNpbmNlIHdlIGNoZWNrIHRoZSBwYXJlbnQgZ3JvdXAgaXRzZWxmLlxuICAgICAgLy8gdW50aWwgd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIHNwZWNpZmljYWxseSB0byBzZWFyY2ggaW5zaWRlIHRoZSBhY3RpdmVHcm91cFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgb2JqVG9DaGVjayA9IG9iamVjdHNbaV07XG4gICAgICAgIHZhciBwb2ludGVyVG9Vc2UgPSBvYmpUb0NoZWNrLmdyb3VwID9cbiAgICAgICAgICB0aGlzLl9ub3JtYWxpemVQb2ludGVyKG9ialRvQ2hlY2suZ3JvdXAsIHBvaW50ZXIpIDogcG9pbnRlcjtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrVGFyZ2V0KHBvaW50ZXJUb1VzZSwgb2JqVG9DaGVjaywgcG9pbnRlcikpIHtcbiAgICAgICAgICB0YXJnZXQgPSBvYmplY3RzW2ldO1xuICAgICAgICAgIGlmICh0YXJnZXQuc3ViVGFyZ2V0Q2hlY2sgJiYgdGFyZ2V0IGluc3RhbmNlb2YgZmFicmljLkdyb3VwKSB7XG4gICAgICAgICAgICBzdWJUYXJnZXQgPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHModGFyZ2V0Ll9vYmplY3RzLCBwb2ludGVyKTtcbiAgICAgICAgICAgIHN1YlRhcmdldCAmJiB0aGlzLnRhcmdldHMucHVzaChzdWJUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHdpdGhvdXQgdGhlIGVmZmVjdCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIHJlc3RvcmVQb2ludGVyVnB0OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHBvaW50ZXIsXG4gICAgICAgIGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcy5cbiAgICAgKiBDYW4gcmV0dXJuIGNvb3JkaW5hdGVzIHdpdGggb3Igd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBpZ25vcmVab29tIGZhbHNlIGdpdmVzIGJhY2sgY29vcmRpbmF0ZXMgdGhhdCByZXByZXNlbnRcbiAgICAgKiB0aGUgcG9pbnQgY2xpY2tlZCBvbiBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBpZ25vcmVab29tIHRydWUgZ2l2ZXMgYmFjayBjb29yZGluYXRlcyBhZnRlciBiZWluZyBwcm9jZXNzZWRcbiAgICAgKiBieSB0aGUgdmlld3BvcnRUcmFuc2Zvcm0gKCBzb3J0IG9mIGNvb3JkaW5hdGVzIG9mIHdoYXQgaXMgZGlzcGxheWVkXG4gICAgICogb24gdGhlIGNhbnZhcyB3aGVyZSB5b3UgYXJlIGNsaWNraW5nLlxuICAgICAqIGlnbm9yZVpvb20gdHJ1ZSA9IEhUTUxFbGVtZW50IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRvcCxsZWZ0XG4gICAgICogaWdub3JlWm9vbSBmYWxzZSwgZGVmYXVsdCA9IGZhYnJpYyBzcGFjZSBjb29yZGluYXRlcywgdGhlIHNhbWUgdXNlZCBmb3Igc2hhcGUgcG9zaXRpb25cbiAgICAgKiBUbyBpbnRlcmFjdCB3aXRoIHlvdXIgc2hhcGVzIHRvcCBhbmQgbGVmdCB5b3Ugd2FudCB0byB1c2UgaWdub3JlWm9vbSB0cnVlXG4gICAgICogbW9zdCBvZiB0aGUgdGltZSwgd2hpbGUgaWdub3JlWm9vbSBmYWxzZSB3aWxsIGdpdmUgeW91IGNvb3JkaW5hdGVzXG4gICAgICogY29tcGF0aWJsZSB3aXRoIHRoZSBvYmplY3Qub0Nvb3JkcyBzeXN0ZW0uXG4gICAgICogb2YgdGhlIHRpbWUuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlWm9vbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXRQb2ludGVyOiBmdW5jdGlvbiAoZSwgaWdub3JlWm9vbSkge1xuICAgICAgLy8gcmV0dXJuIGNhY2hlZCB2YWx1ZXMgaWYgd2UgYXJlIGluIHRoZSBldmVudCBwcm9jZXNzaW5nIGNoYWluXG4gICAgICBpZiAodGhpcy5fYWJzb2x1dGVQb2ludGVyICYmICFpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcG9pbnRlciAmJiBpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IGdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdXBwZXJDYW52YXNFbCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBib3VuZHMgPSB1cHBlckNhbnZhc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGJvdW5kc1dpZHRoID0gYm91bmRzLndpZHRoIHx8IDAsXG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzLmhlaWdodCB8fCAwLFxuICAgICAgICAgIGNzc1NjYWxlO1xuXG4gICAgICBpZiAoIWJvdW5kc1dpZHRoIHx8ICFib3VuZHNIZWlnaHQgKSB7XG4gICAgICAgIGlmICgndG9wJyBpbiBib3VuZHMgJiYgJ2JvdHRvbScgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gTWF0aC5hYnMoIGJvdW5kcy50b3AgLSBib3VuZHMuYm90dG9tICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdyaWdodCcgaW4gYm91bmRzICYmICdsZWZ0JyBpbiBib3VuZHMpIHtcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IE1hdGguYWJzKCBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgICAgcG9pbnRlci54ID0gcG9pbnRlci54IC0gdGhpcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwb2ludGVyLnkgPSBwb2ludGVyLnkgLSB0aGlzLl9vZmZzZXQudG9wO1xuICAgICAgaWYgKCFpZ25vcmVab29tKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0aW5hU2NhbGluZyA9IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpO1xuICAgICAgaWYgKHJldGluYVNjYWxpbmcgIT09IDEpIHtcbiAgICAgICAgcG9pbnRlci54IC89IHJldGluYVNjYWxpbmc7XG4gICAgICAgIHBvaW50ZXIueSAvPSByZXRpbmFTY2FsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRzV2lkdGggPT09IDAgfHwgYm91bmRzSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIC8vIElmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSAoaS5lLiBub3QgdmlzaWJsZSksIGRvIG5vdCBhcHBseSBzY2FsZS5cbiAgICAgICAgY3NzU2NhbGUgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjc3NTY2FsZSA9IHtcbiAgICAgICAgICB3aWR0aDogdXBwZXJDYW52YXNFbC53aWR0aCAvIGJvdW5kc1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdXBwZXJDYW52YXNFbC5oZWlnaHQgLyBib3VuZHNIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9pbnRlci54ICogY3NzU2NhbGUud2lkdGgsXG4gICAgICAgIHk6IHBvaW50ZXIueSAqIGNzc1NjYWxlLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGhyb3dzIHtDQU5WQVNfSU5JVF9FUlJPUn0gSWYgY2FudmFzIGNhbiBub3QgYmUgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlVXBwZXJDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0NsYXNzID0gdGhpcy5sb3dlckNhbnZhc0VsLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqbG93ZXItY2FudmFzXFxzKi8sICcnKSxcbiAgICAgICAgICBsb3dlckNhbnZhc0VsID0gdGhpcy5sb3dlckNhbnZhc0VsLCB1cHBlckNhbnZhc0VsID0gdGhpcy51cHBlckNhbnZhc0VsO1xuXG4gICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIGNyZWF0ZSBhIG5ldyB1cHBlckNhbnZhcyBlbGVtZW50IGlmIHdlIGhhdmUgYWxyZWFkeSBvbmUuXG4gICAgICBpZiAodXBwZXJDYW52YXNFbCkge1xuICAgICAgICB1cHBlckNhbnZhc0VsLmNsYXNzTmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHVwcGVyQ2FudmFzRWwgPSB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbCA9IHVwcGVyQ2FudmFzRWw7XG4gICAgICB9XG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh1cHBlckNhbnZhc0VsLCAndXBwZXItY2FudmFzICcgKyBsb3dlckNhbnZhc0NsYXNzKTtcblxuICAgICAgdGhpcy53cmFwcGVyRWwuYXBwZW5kQ2hpbGQodXBwZXJDYW52YXNFbCk7XG5cbiAgICAgIHRoaXMuX2NvcHlDYW52YXNTdHlsZShsb3dlckNhbnZhc0VsLCB1cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodXBwZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSB1cHBlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwgPSB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGgpO1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5jb250ZXh0Q2FjaGUgPSB0aGlzLmNhY2hlQ2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLndyYXBwZXJFbCA9IGZhYnJpYy51dGlsLndyYXBFbGVtZW50KHRoaXMubG93ZXJDYW52YXNFbCwgJ2RpdicsIHtcbiAgICAgICAgJ2NsYXNzJzogdGhpcy5jb250YWluZXJDbGFzc1xuICAgICAgfSk7XG4gICAgICBmYWJyaWMudXRpbC5zZXRTdHlsZSh0aGlzLndyYXBwZXJFbCwge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQgKyAncHgnLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfSk7XG4gICAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZSh0aGlzLndyYXBwZXJFbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBjYW52YXMgZWxlbWVudCB0byBhcHBseSBzdHlsZXMgb25cbiAgICAgKi9cbiAgICBfYXBwbHlDYW52YXNTdHlsZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggfHwgZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcblxuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUoZWxlbWVudCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyAncHgnLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgICd0b3VjaC1hY3Rpb24nOiB0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmcgPyAnbWFuaXB1bGF0aW9uJyA6ICdub25lJyxcbiAgICAgICAgJy1tcy10b3VjaC1hY3Rpb24nOiB0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmcgPyAnbWFuaXB1bGF0aW9uJyA6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICBlbGVtZW50LmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IHRoZSBlbnRpcmUgaW5saW5lIHN0eWxlIGZyb20gb25lIGVsZW1lbnQgKGZyb21FbCkgdG8gYW5vdGhlciAodG9FbClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbUVsIEVsZW1lbnQgc3R5bGUgaXMgY29waWVkIGZyb21cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRvRWwgRWxlbWVudCBjb3BpZWQgc3R5bGUgaXMgYXBwbGllZCB0b1xuICAgICAqL1xuICAgIF9jb3B5Q2FudmFzU3R5bGU6IGZ1bmN0aW9uIChmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHRvRWwuc3R5bGUuY3NzVGV4dCA9IGZyb21FbC5zdHlsZS5jc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdCBzZWxlY3Rpb24gaXMgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0VG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zICZsdDtjYW52YXM+IGVsZW1lbnQgb24gd2hpY2ggb2JqZWN0IHNlbGVjdGlvbiBpcyBkcmF3blxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwcGVyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudGx5IGFjdGl2ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBhY3RpdmUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGN1cnJlbnQgc2VsZWN0ZWQgb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IGFjdGl2ZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVPYmplY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWN0aXZlID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBpZiAoYWN0aXZlLnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nICYmIGFjdGl2ZS5fb2JqZWN0cykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmUuX29iamVjdHMuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFthY3RpdmVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIC8vIHJlbW92aW5nIGFjdGl2ZSBvYmplY3Qgc2hvdWxkIGZpcmUgXCJzZWxlY3Rpb246Y2xlYXJlZFwiIGV2ZW50c1xuICAgICAgaWYgKG9iaiA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgICAgb2JqLmZpcmUoJ2Rlc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmogPT09IHRoaXMuX2hvdmVyZWRUYXJnZXQpe1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfb25PYmplY3RSZW1vdmVkJywgb2JqKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDb21wYXJlcyB0aGUgb2xkIGFjdGl2ZU9iamVjdCB3aXRoIHRoZSBjdXJyZW50IG9uZSBhbmQgZmlyZXMgY29ycmVjdCBldmVudHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBvbGQgYWN0aXZlT2JqZWN0XG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25FdmVudHM6IGZ1bmN0aW9uKG9sZE9iamVjdHMsIGUpIHtcbiAgICAgIHZhciBzb21ldGhpbmdDaGFuZ2VkID0gZmFsc2UsIG9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhZGRlZCA9IFtdLCByZW1vdmVkID0gW107XG4gICAgICBvbGRPYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2xkT2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RzLmluZGV4T2Yob2xkT2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgICBzb21ldGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBvbGRPYmplY3QuZmlyZSgnZGVzZWxlY3RlZCcsIHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IG9sZE9iamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlbW92ZWQucHVzaChvbGRPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9sZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSkge1xuICAgICAgICAgIHNvbWV0aGluZ0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIG9iamVjdC5maXJlKCdzZWxlY3RlZCcsIHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IG9iamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFkZGVkLnB1c2gob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAob2xkT2JqZWN0cy5sZW5ndGggPiAwICYmIG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzb21ldGhpbmdDaGFuZ2VkICYmIHRoaXMuZmlyZSgnc2VsZWN0aW9uOnVwZGF0ZWQnLCB7XG4gICAgICAgICAgZTogZSxcbiAgICAgICAgICBzZWxlY3RlZDogYWRkZWQsXG4gICAgICAgICAgZGVzZWxlY3RlZDogcmVtb3ZlZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y3JlYXRlZCcsIHtcbiAgICAgICAgICBlOiBlLFxuICAgICAgICAgIHNlbGVjdGVkOiBhZGRlZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvbGRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHtcbiAgICAgICAgICBlOiBlLFxuICAgICAgICAgIGRlc2VsZWN0ZWQ6IHJlbW92ZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGdpdmVuIG9iamVjdCBhcyB0aGUgb25seSBhY3RpdmUgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZXQgYXMgYW4gYWN0aXZlIG9uZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCAocGFzc2VkIGFsb25nIHdoZW4gZmlyaW5nIFwib2JqZWN0OnNlbGVjdGVkXCIpXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QsIGUpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlT2JqZWN0KG9iamVjdCwgZSk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVzLCBlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgcHJpdmF0ZSBtZXRob2QgZm9yIG5vdy5cbiAgICAgKiBUaGlzIGlzIHN1cHBvc2VkIHRvIGJlIGVxdWl2YWxlbnQgdG8gc2V0QWN0aXZlT2JqZWN0IGJ1dCB3aXRob3V0IGZpcmluZ1xuICAgICAqIGFueSBldmVudC4gVGhlcmUgaXMgY29tbWl0bWVudCB0byBoYXZlIHRoaXMgc3RheSB0aGlzIHdheS5cbiAgICAgKiBUaGlzIGlzIHRoZSBmdW5jdGlvbmFsIHBhcnQgb2Ygc2V0QWN0aXZlT2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZXQgYXMgYWN0aXZlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IChwYXNzZWQgYWxvbmcgd2hlbiBmaXJpbmcgXCJvYmplY3Q6c2VsZWN0ZWRcIilcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzZWxlY3Rpb24gaGFwcGVuZWRcbiAgICAgKi9cbiAgICBfc2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIGUpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVPYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoZSwgb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm9uU2VsZWN0KHsgZTogZSB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QgPSBvYmplY3Q7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHByaXZhdGUgbWV0aG9kIGZvciBub3cuXG4gICAgICogVGhpcyBpcyBzdXBwb3NlZCB0byBiZSBlcXVpdmFsZW50IHRvIGRpc2NhcmRBY3RpdmVPYmplY3QgYnV0IHdpdGhvdXQgZmlyaW5nXG4gICAgICogYW55IGV2ZW50cy4gVGhlcmUgaXMgY29tbWl0bWVudCB0byBoYXZlIHRoaXMgc3RheSB0aGlzIHdheS5cbiAgICAgKiBUaGlzIGlzIHRoZSBmdW5jdGlvbmFsIHBhcnQgb2YgZGlzY2FyZEFjdGl2ZU9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpkZXNlbGVjdGVkXCIpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZXQgYXMgYWN0aXZlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGhhcHBlbmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24oZSwgb2JqZWN0KSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKG9iaikge1xuICAgICAgICAvLyBvbkRlc2VsZWN0IHJldHVybiBUUlVFIHRvIGNhbmNlbCBzZWxlY3Rpb247XG4gICAgICAgIGlmIChvYmoub25EZXNlbGVjdCh7IGU6IGUsIG9iamVjdDogb2JqZWN0IH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzY2FyZHMgY3VycmVudGx5IGFjdGl2ZSBvYmplY3QgYW5kIGZpcmUgZXZlbnRzLiBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGZhYnJpY1xuICAgICAqIGFzIGEgY29uc2VxdWVuY2Ugb2YgYSBtb3VzZSBldmVudCwgdGhlIGV2ZW50IGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBhbmRcbiAgICAgKiBzZW50IHRvIHRoZSBmaXJlIGZ1bmN0aW9uIGZvciB0aGUgY3VzdG9tIGV2ZW50cy4gV2hlbiB1c2VkIGFzIGEgbWV0aG9kIHRoZVxuICAgICAqIGUgcGFyYW0gZG9lcyBub3QgaGF2ZSBhbnkgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtldmVudH0gZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLCBhY3RpdmVPYmplY3QgPSB0aGlzLmdldEFjdGl2ZU9iamVjdCgpO1xuICAgICAgaWYgKGN1cnJlbnRBY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBhY3RpdmVPYmplY3QsIGU6IGUgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kaXNjYXJkQWN0aXZlT2JqZWN0KGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGEgY2FudmFzIGVsZW1lbnQgYW5kIHJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0aGlzLndyYXBwZXJFbDtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMudXBwZXJDYW52YXNFbCk7XG4gICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmNvbnRleHRDYWNoZSA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSBudWxsO1xuICAgICAgWyd1cHBlckNhbnZhc0VsJywgJ2NhY2hlQ2FudmFzRWwnXS5mb3JFYWNoKChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpc1tlbGVtZW50XSk7XG4gICAgICAgIHRoaXNbZWxlbWVudF0gPSB1bmRlZmluZWQ7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICAgIGlmICh3cmFwcGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgd3JhcHBlci5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0aGlzLmxvd2VyQ2FudmFzRWwsIHRoaXMud3JhcHBlckVsKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLndyYXBwZXJFbDtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNvbnRleHRzIChiYWNrZ3JvdW5kLCBtYWluLCB0b3ApIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdGhpcy5kaXNjYXJkQWN0aXZlR3JvdXAoKTtcbiAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQodGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcignY2xlYXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3Mgb2JqZWN0cycgY29udHJvbHMgKGJvcmRlcnMvY29udHJvbHMpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBjb250cm9scyBvblxuICAgICAqL1xuICAgIGRyYXdDb250cm9sczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICBpZiAoYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIGFjdGl2ZU9iamVjdC5fcmVuZGVyQ29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgcGFydCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gZ3JvdXAsIGl0IHNob3VsZFxuICAgICAgLy9iZSB0cmFuc2Zvcm1lZCBhcHByb3ByaWF0ZWx5XG4gICAgICAvL2kuZS4gaXQgc2hvdWxkIGJlIHNlcmlhbGlzZWQgYXMgaXQgd291bGQgYXBwZWFyIGlmIHRoZSBzZWxlY3Rpb24gZ3JvdXBcbiAgICAgIC8vd2VyZSB0byBiZSBkZXN0cm95ZWQuXG4gICAgICB2YXIgb3JpZ2luYWxQcm9wZXJ0aWVzID0gdGhpcy5fcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UpLFxuICAgICAgICAgIG9iamVjdCA9IHRoaXMuY2FsbFN1cGVyKCdfdG9PYmplY3QnLCBpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAvL1VuZG8gdGhlIGRhbWFnZSB3ZSBkaWQgYnkgY2hhbmdpbmcgYWxsIG9mIGl0cyBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLl91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlLCBvcmlnaW5hbFByb3BlcnRpZXMpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhbGlzZXMgYW4gb2JqZWN0J3MgZ3JvdXAgdHJhbnNmb3JtYXRpb24gb24gaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW2luc3RhbmNlXSB0aGUgb2JqZWN0IHRvIHRyYW5zZm9ybSAoZ2V0cyBtdXRhdGVkKVxuICAgICAqIEByZXR1cm5zIHRoZSBvcmlnaW5hbCB2YWx1ZXMgb2YgaW5zdGFuY2Ugd2hpY2ggd2VyZSBjaGFuZ2VkXG4gICAgICovXG4gICAgX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgaWYgKGluc3RhbmNlLmdyb3VwICYmIGluc3RhbmNlLmdyb3VwLnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nICYmIHRoaXMuX2FjdGl2ZU9iamVjdCA9PT0gaW5zdGFuY2UuZ3JvdXApIHtcbiAgICAgICAgdmFyIGxheW91dFByb3BzID0gWydhbmdsZScsICdmbGlwWCcsICdmbGlwWScsICdsZWZ0JywgJ3NjYWxlWCcsICdzY2FsZVknLCAnc2tld1gnLCAnc2tld1knLCAndG9wJ107XG4gICAgICAgIC8vQ29weSBhbGwgdGhlIHBvc2l0aW9uYWxseSByZWxldmFudCBwcm9wZXJ0aWVzIGFjcm9zcyBub3dcbiAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWVzID0ge307XG4gICAgICAgIGxheW91dFByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgIG9yaWdpbmFsVmFsdWVzW3Byb3BdID0gaW5zdGFuY2VbcHJvcF07XG4gICAgICAgIH0pO1xuICAgICAgICBmYWJyaWMudXRpbC5hZGRUcmFuc2Zvcm1Ub09iamVjdChpbnN0YW5jZSwgdGhpcy5fYWN0aXZlT2JqZWN0LmNhbGNPd25NYXRyaXgoKSk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFZhbHVlcztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgdGhlIGNoYW5nZWQgcHJvcGVydGllcyBvZiBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdW4tdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcmlnaW5hbFZhbHVlc10gdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSwgYXMgcmV0dXJuZWQgYnkgX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0XG4gICAgICovXG4gICAgX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlLCBvcmlnaW5hbFZhbHVlcykge1xuICAgICAgaWYgKG9yaWdpbmFsVmFsdWVzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldChvcmlnaW5hbFZhbHVlcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgLy9JZiB0aGUgb2JqZWN0IGlzIGluIGEgc2VsZWN0aW9uIGdyb3VwLCBzaW11bGF0ZSB3aGF0IHdvdWxkIGhhcHBlbiB0byB0aGF0XG4gICAgICAvL29iamVjdCB3aGVuIHRoZSBncm91cCBpcyBkZXNlbGVjdGVkXG4gICAgICB2YXIgb3JpZ2luYWxQcm9wZXJ0aWVzID0gdGhpcy5fcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXRTVkdPYmplY3QnLCBtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKTtcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIHNldFZpZXdwb3J0VHJhbnNmb3JtOiBmdW5jdGlvbiAodnB0KSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGhpcy5fYWN0aXZlT2JqZWN0LmlzRWRpdGluZykge1xuICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB9XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZXRWaWV3cG9ydFRyYW5zZm9ybS5jYWxsKHRoaXMsIHZwdCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBjb3B5aW5nIHN0YXRpYyBwcm9wZXJ0aWVzIG1hbnVhbGx5IHRvIHdvcmsgYXJvdW5kIE9wZXJhJ3MgYnVnLFxuICAvLyB3aGVyZSBcInByb3RvdHlwZVwiIHByb3BlcnR5IGlzIGVudW1lcmFibGUgYW5kIG92ZXJyaWRlcyBleGlzdGluZyBwcm90b3R5cGVcbiAgZm9yICh2YXIgcHJvcCBpbiBmYWJyaWMuU3RhdGljQ2FudmFzKSB7XG4gICAgaWYgKHByb3AgIT09ICdwcm90b3R5cGUnKSB7XG4gICAgICBmYWJyaWMuQ2FudmFzW3Byb3BdID0gZmFicmljLlN0YXRpY0NhbnZhc1twcm9wXTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBhZGRMaXN0ZW5lciA9IGZhYnJpYy51dGlsLmFkZExpc3RlbmVyLFxuICAgICAgcmVtb3ZlTGlzdGVuZXIgPSBmYWJyaWMudXRpbC5yZW1vdmVMaXN0ZW5lcixcbiAgICAgIFJJR0hUX0NMSUNLID0gMywgTUlERExFX0NMSUNLID0gMiwgTEVGVF9DTElDSyA9IDEsXG4gICAgICBhZGRFdmVudE9wdGlvbnMgPSB7IHBhc3NpdmU6IGZhbHNlIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGljayhlLCB2YWx1ZSkge1xuICAgIHJldHVybiBlLmJ1dHRvbiAmJiAoZS5idXR0b24gPT09IHZhbHVlIC0gMSk7XG4gIH1cblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5DYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIHRoZSBpZCBvZiB0aGUgdG91Y2ggZXZlbnQgdGhhdCBvd25zIHRoZSBmYWJyaWMgdHJhbnNmb3JtXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtYWluVG91Y2hJZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgbW91c2UgbGlzdGVuZXJzIHRvIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaW4gY2FzZSB3ZSBpbml0aWFsaXplZCB0aGUgY2xhc3MgdHdpY2UuIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gbm9ybWFsbHlcbiAgICAgIC8vIGJ1dCBpbiBzb21lIGtpbmQgb2YgYXBwbGljYXRpb25zIHdoZXJlIHRoZSBjYW52YXMgZWxlbWVudCBtYXkgYmUgY2hhbmdlZFxuICAgICAgLy8gdGhpcyBpcyBhIHdvcmthcm91bmQgdG8gaGF2aW5nIGRvdWJsZSBsaXN0ZW5lcnMuXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5hZGRPclJlbW92ZShhZGRMaXN0ZW5lciwgJ2FkZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYW4gZXZlbnQgcHJlZml4IHBvaW50ZXIgb3IgbW91c2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0RXZlbnRQcmVmaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuYWJsZVBvaW50ZXJFdmVudHMgPyAncG9pbnRlcicgOiAnbW91c2UnO1xuICAgIH0sXG5cbiAgICBhZGRPclJlbW92ZTogZnVuY3Rpb24oZnVuY3RvciwgZXZlbnRqc0Z1bmN0b3IpIHtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICBmdW5jdG9yKGZhYnJpYy53aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnb3V0JywgdGhpcy5fb25Nb3VzZU91dCk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdlbnRlcicsIHRoaXMuX29uTW91c2VFbnRlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICd3aGVlbCcsIHRoaXMuX29uTW91c2VXaGVlbCk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2RyYWdvdmVyJywgdGhpcy5fb25EcmFnT3Zlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcmFnZW50ZXInLCB0aGlzLl9vbkRyYWdFbnRlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcmFnbGVhdmUnLCB0aGlzLl9vbkRyYWdMZWF2ZSk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcm9wJywgdGhpcy5fb25Ecm9wKTtcbiAgICAgIGlmICghdGhpcy5lbmFibGVQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGV2ZW50anMgIT09ICd1bmRlZmluZWQnICYmIGV2ZW50anNGdW5jdG9yIGluIGV2ZW50anMpIHtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ2dlc3R1cmUnLCB0aGlzLl9vbkdlc3R1cmUpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKGNhbnZhc0VsZW1lbnQsICdvcmllbnRhdGlvbicsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnc2hha2UnLCB0aGlzLl9vblNoYWtlKTtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ2xvbmdwcmVzcycsIHRoaXMuX29uTG9uZ1ByZXNzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkT3JSZW1vdmUocmVtb3ZlTGlzdGVuZXIsICdyZW1vdmUnKTtcbiAgICAgIC8vIGlmIHlvdSBkaXNwb3NlIG9uIGEgbW91c2VEb3duLCBiZWZvcmUgbW91c2UgdXAsIHlvdSBuZWVkIHRvIGNsZWFuIGRvY3VtZW50IHRvLi4uXG4gICAgICB2YXIgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ3VwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50c0JvdW5kKSB7XG4gICAgICAgIC8vIGZvciBhbnkgcmVhc29uIHdlIHBhc3MgaGVyZSB0d2ljZSB3ZSBkbyBub3Qgd2FudCB0byBiaW5kIGV2ZW50cyB0d2ljZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fb25Nb3VzZURvd24gPSB0aGlzLl9vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Ub3VjaFN0YXJ0ID0gdGhpcy5fb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uVG91Y2hFbmQgPSB0aGlzLl9vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblJlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkdlc3R1cmUgPSB0aGlzLl9vbkdlc3R1cmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25TaGFrZSA9IHRoaXMuX29uU2hha2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTG9uZ1ByZXNzID0gdGhpcy5fb25Mb25nUHJlc3MuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UgPSB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlV2hlZWwgPSB0aGlzLl9vbk1vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VPdXQgPSB0aGlzLl9vbk1vdXNlT3V0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlRW50ZXIgPSB0aGlzLl9vbk1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uQ29udGV4dE1lbnUgPSB0aGlzLl9vbkNvbnRleHRNZW51LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRvdWJsZUNsaWNrID0gdGhpcy5fb25Eb3VibGVDbGljay5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnT3ZlciA9IHRoaXMuX29uRHJhZ092ZXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJhZ0VudGVyID0gdGhpcy5fc2ltcGxlRXZlbnRIYW5kbGVyLmJpbmQodGhpcywgJ2RyYWdlbnRlcicpO1xuICAgICAgdGhpcy5fb25EcmFnTGVhdmUgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAnZHJhZ2xlYXZlJyk7XG4gICAgICB0aGlzLl9vbkRyb3AgPSB0aGlzLl9vbkRyb3AuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuZXZlbnRzQm91bmQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgZ2VzdHVyZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25HZXN0dXJlOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25UcmFuc2Zvcm1HZXN0dXJlICYmIHRoaXMuX19vblRyYW5zZm9ybUdlc3R1cmUoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBkcmFnXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbkRyYWc6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbkRyYWcgJiYgdGhpcy5fX29uRHJhZyhlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIHdoZWVsIGV2ZW50XG4gICAgICovXG4gICAgX29uTW91c2VXaGVlbDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5fX29uTW91c2VXaGVlbChlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZU91dDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2hvdmVyZWRUYXJnZXQ7XG4gICAgICB0aGlzLmZpcmUoJ21vdXNlOm91dCcsIHsgdGFyZ2V0OiB0YXJnZXQsIGU6IGUgfSk7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRhcmdldCAmJiB0YXJnZXQuZmlyZSgnbW91c2VvdXQnLCB7IGU6IGUgfSk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uKF90YXJnZXQpe1xuICAgICAgICBfdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGFyZ2V0LCBlOiBlIH0pO1xuICAgICAgICBfdGFyZ2V0ICYmIHRhcmdldC5maXJlKCdtb3VzZW91dCcsIHsgZTogZSB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgIHRoaXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIG9iai5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2VlbnRlclxuICAgICAqL1xuICAgIF9vbk1vdXNlRW50ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIFRoaXMgZmluZCB0YXJnZXQgYW5kIGNvbnNlcXVlbnQgJ21vdXNlOm92ZXInIGlzIHVzZWQgdG9cbiAgICAgIC8vIGNsZWFyIG9sZCBpbnN0YW5jZXMgb24gaG92ZXJlZCB0YXJnZXQuXG4gICAgICAvLyBjYWxsaW5nIGZpbmRUYXJnZXQgaGFzIHRoZSBzaWRlIGVmZmVjdCBvZiBraWxsaW5nIHRhcmdldC5fX2Nvcm5lci5cbiAgICAgIC8vIGFzIGEgc2hvcnQgdGVybSBmaXggd2UgYXJlIG5vdCBmaXJpbmcgdGhpcyBpZiB3ZSBhcmUgY3VycmVudGx5IHRyYW5zZm9ybWluZy5cbiAgICAgIC8vIGFzIGEgbG9uZyB0ZXJtIGZpeCB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBhY3Rpb24gb2YgZmluZGluZyBhIHRhcmdldCB3aXRoIHRoZVxuICAgICAgLy8gc2lkZSBlZmZlY3RzIHdlIGFkZGVkIHRvIGl0LlxuICAgICAgaWYgKCF0aGlzLl9jdXJyZW50VHJhbnNmb3JtICYmICF0aGlzLmZpbmRUYXJnZXQoZSkpIHtcbiAgICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdmVyJywgeyB0YXJnZXQ6IG51bGwsIGU6IGUgfSk7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgb3JpZW50YXRpb24gY2hhbmdlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbk9yaWVudGF0aW9uQ2hhbmdlOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25PcmllbnRhdGlvbkNoYW5nZSAmJiB0aGlzLl9fb25PcmllbnRhdGlvbkNoYW5nZShlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vblNoYWtlOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25TaGFrZSAmJiB0aGlzLl9fb25TaGFrZShlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbkxvbmdQcmVzczogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uTG9uZ1ByZXNzICYmIHRoaXMuX19vbkxvbmdQcmVzcyhlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcHJldmVudCBkZWZhdWx0IHRvIGFsbG93IGRyb3AgZXZlbnQgdG8gYmUgZmlyZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgc2hha2VcbiAgICAgKi9cbiAgICBfb25EcmFnT3ZlcjogZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlcignZHJhZ292ZXInLCBlKTtcbiAgICAgIHRoaXMuX2ZpcmVFbnRlckxlYXZlRXZlbnRzKHRhcmdldCwgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGBkcm9wOmJlZm9yZWAgaXMgYSBhbiBldmVudCB0aGF0IGFsbG93IHlvdSB0byBzY2hlZHVsZSBsb2dpY1xuICAgICAqIGJlZm9yZSB0aGUgYGRyb3BgIGV2ZW50LiBQcmVmZXIgYGRyb3BgIGV2ZW50IGFsd2F5cywgYnV0IGlmIHlvdSBuZWVkXG4gICAgICogdG8gcnVuIHNvbWUgZHJvcC1kaXNhYmxpbmcgbG9naWMgb24gYW4gZXZlbnQsIHNpbmNlIHRoZXJlIGlzIG5vIHdheVxuICAgICAqIHRvIGhhbmRsZSBldmVudCBoYW5kbGVycyBvcmRlcmluZywgdXNlIGBkcm9wOmJlZm9yZWBcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgX29uRHJvcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlcignZHJvcDpiZWZvcmUnLCBlKTtcbiAgICAgIHJldHVybiB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIoJ2Ryb3AnLCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Db250ZXh0TWVudTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzLnN0b3BDb250ZXh0TWVudSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkYmxjbGljaycpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHRoZSBpZCBvZiBhbiBldmVudC5cbiAgICAgKiByZXR1cm5zIGVpdGhlciB0aGUgcG9pbnRlcklkIG9yIHRoZSBpZGVudGlmaWVyIG9yIDAgZm9yIHRoZSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZ0IEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIGdldFBvaW50ZXJJZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBldnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgIGlmIChjaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlZFRvdWNoZXNbMF0gJiYgY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZW5hYmxlUG9pbnRlckV2ZW50cykge1xuICAgICAgICByZXR1cm4gZXZ0LnBvaW50ZXJJZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGFuIGV2ZW50IGhhcyB0aGUgaWQgb2YgdGhlIGV2ZW50IHRoYXQgaXMgY29uc2lkZXJlZCBtYWluXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2V2dH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX2lzTWFpbkV2ZW50OiBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmIChldnQuaXNQcmltYXJ5ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2dC5pc1ByaW1hcnkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQudHlwZSA9PT0gJ3RvdWNoZW5kJyAmJiBldnQudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgIHJldHVybiBldnQuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllciA9PT0gdGhpcy5tYWluVG91Y2hJZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICh0aGlzLm1haW5Ub3VjaElkID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMubWFpblRvdWNoSWQgPSB0aGlzLmdldFBvaW50ZXJJZChlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vbk1vdXNlRG93bihlKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB2YXIgY2FudmFzRWxlbWVudCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICAvLyBVbmJpbmQgbW91c2Vkb3duIHRvIHByZXZlbnQgZG91YmxlIHRyaWdnZXJzIGZyb20gdG91Y2ggZGV2aWNlc1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ2Rvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fX29uTW91c2VEb3duKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAndXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vblRvdWNoRW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHN0aWxsIHRvdWNoZXMgc3RvcCBoZXJlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vbk1vdXNlVXAoZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdGhpcy5tYWluVG91Y2hJZCA9IG51bGw7XG4gICAgICB2YXIgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLl93aWxsQWRkTW91c2VEb3duKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl93aWxsQWRkTW91c2VEb3duKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3dpbGxBZGRNb3VzZURvd24gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBXYWl0IDQwMG1zIGJlZm9yZSByZWJpbmRpbmcgbW91c2Vkb3duIHRvIHByZXZlbnQgZG91YmxlIHRyaWdnZXJzXG4gICAgICAgIC8vIGZyb20gdG91Y2ggZGV2aWNlc1xuICAgICAgICBhZGRMaXN0ZW5lcihfdGhpcy51cHBlckNhbnZhc0VsLCBldmVudFR5cGVQcmVmaXggKyAnZG93bicsIF90aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICAgIF90aGlzLl93aWxsQWRkTW91c2VEb3duID0gMDtcbiAgICAgIH0sIDQwMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICBpZiAodGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAndXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICAgIGFkZExpc3RlbmVyKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgIXRoaXMuYWxsb3dUb3VjaFNjcm9sbGluZyAmJiBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX19vbk1vdXNlTW92ZShlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGVzIHdoZXRoZXIgdGhlIGNhbnZhcyBzaG91bGQgYmUgcmVkcmF3biBpbiBtb3VzZXVwIGFuZCBtb3VzZWRvd24gZXZlbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9zaG91bGRSZW5kZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcblxuICAgICAgaWYgKFxuICAgICAgICAhIWFjdGl2ZU9iamVjdCAhPT0gISF0YXJnZXQgfHxcbiAgICAgICAgKGFjdGl2ZU9iamVjdCAmJiB0YXJnZXQgJiYgKGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0KSlcbiAgICAgICkge1xuICAgICAgICAvLyB0aGlzIGNvdmVyczogc3dpdGNoIG9mIHRhcmdldCwgZnJvbSB0YXJnZXQgdG8gbm8gdGFyZ2V0LCBzZWxlY3Rpb24gb2YgdGFyZ2V0XG4gICAgICAgIC8vIG11bHRpU2VsZWN0aW9uIHdpdGgga2V5IGFuZCBtb3VzZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QuaXNFZGl0aW5nKSB7XG4gICAgICAgIC8vIGlmIHdlIG1vdXNlIHVwL2Rvd24gb3ZlciBhIGVkaXRpbmcgdGV4dGJveCBhIGN1cnNvciBjaGFuZ2UsXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmUgcmVuZGVyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIHJlbGVhc2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXJzLCBzdG9yZSB0aGUgaW1hZ2UgY29ybmVyXG4gICAgICogcG9zaXRpb24gaW4gdGhlIGltYWdlIG9iamVjdCBhbmQgcmVuZGVyIHRoZSBjYW52YXMgb24gdG9wLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9fb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHRhcmdldCwgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICBncm91cFNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3Rvciwgc2hvdWxkUmVuZGVyID0gZmFsc2UsXG4gICAgICAgICAgaXNDbGljayA9ICghZ3JvdXBTZWxlY3RvciB8fCAoZ3JvdXBTZWxlY3Rvci5sZWZ0ID09PSAwICYmIGdyb3VwU2VsZWN0b3IudG9wID09PSAwKSk7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRhcmdldCA9IHRoaXMuX3RhcmdldDtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cDpiZWZvcmUnKTtcbiAgICAgIC8vIGlmIHJpZ2h0L21pZGRsZSBjbGljayBqdXN0IGZpcmUgZXZlbnRzIGFuZCByZXR1cm5cbiAgICAgIC8vIHRhcmdldCB1bmRlZmluZWQgd2lsbCBtYWtlIHRoZSBfaGFuZGxlRXZlbnQgc2VhcmNoIHRoZSB0YXJnZXRcbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIFJJR0hUX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlUmlnaHRDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcsIFJJR0hUX0NMSUNLLCBpc0NsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIE1JRERMRV9DTElDSykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZU1pZGRsZUNsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJywgTUlERExFX0NMSUNLLCBpc0NsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUgJiYgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuX29uTW91c2VVcEluRHJhd2luZ01vZGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pc01haW5FdmVudChlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybShlKTtcbiAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNDbGljaykge1xuICAgICAgICB2YXIgdGFyZ2V0V2FzQWN0aXZlID0gdGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAgIHRoaXMuX21heWJlR3JvdXBPYmplY3RzKGUpO1xuICAgICAgICBpZiAoIXNob3VsZFJlbmRlcikge1xuICAgICAgICAgIHNob3VsZFJlbmRlciA9IChcbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQpIHx8XG4gICAgICAgICAgICAoIXRhcmdldFdhc0FjdGl2ZSAmJiB0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY29ybmVyLCBwb2ludGVyO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb3JuZXIgPSB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIoXG4gICAgICAgICAgdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpLFxuICAgICAgICAgIGZhYnJpYy51dGlsLmlzVG91Y2hFdmVudChlKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGFyZ2V0LnNlbGVjdGFibGUgJiYgdGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGFyZ2V0LmFjdGl2ZU9uID09PSAndXAnKSB7XG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QodGFyZ2V0LCBlKTtcbiAgICAgICAgICBzaG91bGRSZW5kZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl0sXG4gICAgICAgICAgICAgIG1vdXNlVXBIYW5kbGVyID0gY29udHJvbCAmJiBjb250cm9sLmdldE1vdXNlVXBIYW5kbGVyKGUsIHRhcmdldCwgY29udHJvbCk7XG4gICAgICAgICAgaWYgKG1vdXNlVXBIYW5kbGVyKSB7XG4gICAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgICAgICAgbW91c2VVcEhhbmRsZXIoZSwgdHJhbnNmb3JtLCBwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgYXJlIGVuZGluZyB1cCBhIHRyYW5zZm9ybSBvbiBhIGRpZmZlcmVudCBjb250cm9sIG9yIGEgbmV3IG9iamVjdFxuICAgICAgLy8gZmlyZSB0aGUgb3JpZ2luYWwgbW91c2UgdXAgZnJvbSB0aGUgY29ybmVyIHRoYXQgc3RhcnRlZCB0aGUgdHJhbnNmb3JtXG4gICAgICBpZiAodHJhbnNmb3JtICYmICh0cmFuc2Zvcm0udGFyZ2V0ICE9PSB0YXJnZXQgfHwgdHJhbnNmb3JtLmNvcm5lciAhPT0gY29ybmVyKSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb250cm9sID0gdHJhbnNmb3JtLnRhcmdldCAmJiB0cmFuc2Zvcm0udGFyZ2V0LmNvbnRyb2xzW3RyYW5zZm9ybS5jb3JuZXJdLFxuICAgICAgICAgICAgb3JpZ2luYWxNb3VzZVVwSGFuZGxlciA9IG9yaWdpbmFsQ29udHJvbCAmJiBvcmlnaW5hbENvbnRyb2wuZ2V0TW91c2VVcEhhbmRsZXIoZSwgdGFyZ2V0LCBjb250cm9sKTtcbiAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgfHwgdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgICBvcmlnaW5hbE1vdXNlVXBIYW5kbGVyICYmIG9yaWdpbmFsTW91c2VVcEhhbmRsZXIoZSwgdHJhbnNmb3JtLCBwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRDdXJzb3JGcm9tRXZlbnQoZSwgdGFyZ2V0KTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcsIExFRlRfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbnVsbDtcbiAgICAgIC8vIHJlc2V0IHRoZSB0YXJnZXQgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2ggY29ybmVyIGlzIHNlbGVjdGVkXG4gICAgICB0YXJnZXQgJiYgKHRhcmdldC5fX2Nvcm5lciA9IDApO1xuICAgICAgaWYgKHNob3VsZFJlbmRlcikge1xuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc0NsaWNrKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVG9wKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogSGFuZGxlIGV2ZW50IGZpcmluZyBmb3IgdGFyZ2V0IGFuZCBzdWJ0YXJnZXRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBldmVudCBmcm9tIG1vdXNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBldmVudCB0byBmaXJlICh1cCwgZG93biBvciBtb3ZlKVxuICAgICAqIEByZXR1cm4ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCByZXR1cm4gdGhlIHRoZSB0YXJnZXQgZm91bmQsIGZvciBpbnRlcm5hbCByZWFzb25zLlxuICAgICAqL1xuICAgIF9zaW1wbGVFdmVudEhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKSxcbiAgICAgICAgICB0YXJnZXRzID0gdGhpcy50YXJnZXRzLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBzdWJUYXJnZXRzOiB0YXJnZXRzLFxuICAgICAgICAgIH07XG4gICAgICB0aGlzLmZpcmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIHRhcmdldCAmJiB0YXJnZXQuZmlyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgaWYgKCF0YXJnZXRzKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0c1tpXS5maXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEhhbmRsZSBldmVudCBmaXJpbmcgZm9yIHRhcmdldCBhbmQgc3VidGFyZ2V0c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnQgZnJvbSBtb3VzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdG8gZmlyZSAodXAsIGRvd24gb3IgbW92ZSlcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldE9iaiByZWNlaXZpbmcgZXZlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2J1dHRvbl0gYnV0dG9uIHVzZWQgaW4gdGhlIGV2ZW50IDEgPSBsZWZ0LCAyID0gbWlkZGxlLCAzID0gcmlnaHRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2xpY2sgZm9yIGxlZnQgYnV0dG9uIG9ubHksIGluZGljYXRlcyB0aGF0IHRoZSBtb3VzZSB1cCBoYXBwZW5lZCB3aXRob3V0IG1vdmUuXG4gICAgICovXG4gICAgX2hhbmRsZUV2ZW50OiBmdW5jdGlvbihlLCBldmVudFR5cGUsIGJ1dHRvbiwgaXNDbGljaykge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCxcbiAgICAgICAgICB0YXJnZXRzID0gdGhpcy50YXJnZXRzIHx8IFtdLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBzdWJUYXJnZXRzOiB0YXJnZXRzLFxuICAgICAgICAgICAgYnV0dG9uOiBidXR0b24gfHwgTEVGVF9DTElDSyxcbiAgICAgICAgICAgIGlzQ2xpY2s6IGlzQ2xpY2sgfHwgZmFsc2UsXG4gICAgICAgICAgICBwb2ludGVyOiB0aGlzLl9wb2ludGVyLFxuICAgICAgICAgICAgYWJzb2x1dGVQb2ludGVyOiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm1cbiAgICAgICAgICB9O1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ3VwJykge1xuICAgICAgICBvcHRpb25zLmN1cnJlbnRUYXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSk7XG4gICAgICAgIG9wdGlvbnMuY3VycmVudFN1YlRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcmUoJ21vdXNlOicgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgdGFyZ2V0ICYmIHRhcmdldC5maXJlKCdtb3VzZScgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldHNbaV0uZmlyZSgnbW91c2UnICsgZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIHNlbmQgdGhlIG1vdXNlIGV2ZW50IHRoYXQgZ2VuZXJhdGUgdGhlIGZpbmFsaXplIGRvd24sIHNvIGl0IGNhbiBiZSB1c2VkIGluIHRoZSBldmVudFxuICAgICAqL1xuICAgIF9maW5hbGl6ZUN1cnJlbnRUcmFuc2Zvcm06IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICBhY3Rpb246IHRyYW5zZm9ybS5hY3Rpb24sXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKHRhcmdldC5fc2NhbGluZykge1xuICAgICAgICB0YXJnZXQuX3NjYWxpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnNldENvb3JkcygpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCB8fCAodGhpcy5zdGF0ZWZ1bCAmJiB0YXJnZXQuaGFzU3RhdGVDaGFuZ2VkKCkpKSB7XG4gICAgICAgIHRoaXMuX2ZpcmUoJ21vZGlmaWVkJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmdldEFjdGl2ZU9iamVjdCgpKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdChlKS5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlRG93bihwb2ludGVyLCB7IGU6IGUsIHBvaW50ZXI6IHBvaW50ZXIgfSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9vbk1vdXNlTW92ZUluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlTW92ZShwb2ludGVyLCB7IGU6IGUsIHBvaW50ZXI6IHBvaW50ZXIgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmZyZWVEcmF3aW5nQ3Vyc29yKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyA9IHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlVXAoeyBlOiBlLCBwb2ludGVyOiBwb2ludGVyIH0pO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBjbGlja2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIGluaXRzIHRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlcnMgYW5kIHJlbmRlcnMgYWxsIHRoZVxuICAgICAqIGNhbnZhcyBzbyB0aGUgY3VycmVudCBpbWFnZSBjYW4gYmUgcGxhY2VkIG9uIHRoZSB0b3AgY2FudmFzIGFuZCB0aGUgcmVzdFxuICAgICAqIGluIG9uIHRoZSBjb250YWluZXIgb25lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX19vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd246YmVmb3JlJyk7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgLy8gaWYgcmlnaHQgY2xpY2sganVzdCBmaXJlIGV2ZW50c1xuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgUklHSFRfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nLCBSSUdIVF9DTElDSyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBNSURETEVfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVNaWRkbGVDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJywgTUlERExFX0NMSUNLKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZURvd25JbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBpZ25vcmUgaWYgc29tZSBvYmplY3QgaXMgYmVpbmcgdHJhbnNmb3JtZWQgYXQgdGhpcyBtb21lbnRcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLl9wb2ludGVyO1xuICAgICAgLy8gc2F2ZSBwb2ludGVyIGZvciBjaGVjayBpbiBfX29uTW91c2VVcCBldmVudFxuICAgICAgdGhpcy5fcHJldmlvdXNQb2ludGVyID0gcG9pbnRlcjtcbiAgICAgIHZhciBzaG91bGRSZW5kZXIgPSB0aGlzLl9zaG91bGRSZW5kZXIodGFyZ2V0KSxcbiAgICAgICAgICBzaG91bGRHcm91cCA9IHRoaXMuX3Nob3VsZEdyb3VwKGUsIHRhcmdldCk7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJTZWxlY3Rpb24oZSwgdGFyZ2V0KSkge1xuICAgICAgICB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzaG91bGRHcm91cCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVHcm91cGluZyhlLCB0YXJnZXQpO1xuICAgICAgICB0YXJnZXQgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiAmJiAoIXRhcmdldCB8fFxuICAgICAgICAoIXRhcmdldC5zZWxlY3RhYmxlICYmICF0YXJnZXQuaXNFZGl0aW5nICYmIHRhcmdldCAhPT0gdGhpcy5fYWN0aXZlT2JqZWN0KSkpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IHtcbiAgICAgICAgICBleDogdGhpcy5fYWJzb2x1dGVQb2ludGVyLngsXG4gICAgICAgICAgZXk6IHRoaXMuX2Fic29sdXRlUG9pbnRlci55LFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGFscmVhZHlTZWxlY3RlZCA9IHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgICBpZiAodGFyZ2V0LnNlbGVjdGFibGUgJiYgdGFyZ2V0LmFjdGl2ZU9uID09PSAnZG93bicpIHtcbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdCh0YXJnZXQsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3JuZXIgPSB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIoXG4gICAgICAgICAgdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpLFxuICAgICAgICAgIGZhYnJpYy51dGlsLmlzVG91Y2hFdmVudChlKVxuICAgICAgICApO1xuICAgICAgICB0YXJnZXQuX19jb3JuZXIgPSBjb3JuZXI7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdCAmJiAoY29ybmVyIHx8ICFzaG91bGRHcm91cCkpIHtcbiAgICAgICAgICB0aGlzLl9zZXR1cEN1cnJlbnRUcmFuc2Zvcm0oZSwgdGFyZ2V0LCBhbHJlYWR5U2VsZWN0ZWQpO1xuICAgICAgICAgIHZhciBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl0sXG4gICAgICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksXG4gICAgICAgICAgICAgIG1vdXNlRG93bkhhbmRsZXIgPSBjb250cm9sICYmIGNvbnRyb2wuZ2V0TW91c2VEb3duSGFuZGxlcihlLCB0YXJnZXQsIGNvbnRyb2wpO1xuICAgICAgICAgIGlmIChtb3VzZURvd25IYW5kbGVyKSB7XG4gICAgICAgICAgICBtb3VzZURvd25IYW5kbGVyKGUsIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sIHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJyk7XG4gICAgICAvLyB3ZSBtdXN0IHJlbmRlckFsbCBzbyB0aGF0IHdlIHVwZGF0ZSB0aGUgdmlzdWFsc1xuICAgICAgKHNob3VsZFJlbmRlciB8fCBzaG91bGRHcm91cCkgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlc2V0IGNhY2hlIGZvcm0gY29tbW9uIGluZm9ybWF0aW9uIG5lZWRlZCBkdXJpbmcgZXZlbnQgcHJvY2Vzc2luZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9wb2ludGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2Fic29sdXRlUG9pbnRlciA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhY2hlIGNvbW1vbiBpbmZvcm1hdGlvbiBuZWVkZWQgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIGV2ZW50XG4gICAgICovXG4gICAgX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhOiBmdW5jdGlvbihlKSB7XG4gICAgICAvLyByZXNldCBpbiBvcmRlciB0byBhdm9pZCBzdGFsZSBjYWNoaW5nXG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdGhpcy5fcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKTtcbiAgICAgIHRoaXMuX2Fic29sdXRlUG9pbnRlciA9IHRoaXMucmVzdG9yZVBvaW50ZXJWcHQodGhpcy5fcG9pbnRlcik7XG4gICAgICB0aGlzLl90YXJnZXQgPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID8gdGhpcy5fY3VycmVudFRyYW5zZm9ybS50YXJnZXQgOiB0aGlzLmZpbmRUYXJnZXQoZSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmVmb3JlVHJhbnNmb3JtOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG4gICAgICB0aGlzLnN0YXRlZnVsICYmIHQudGFyZ2V0LnNhdmVTdGF0ZSgpO1xuICAgICAgdGhpcy5maXJlKCdiZWZvcmU6dHJhbnNmb3JtJywge1xuICAgICAgICBlOiBlLFxuICAgICAgICB0cmFuc2Zvcm06IHQsXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIGhvdmVyaW5nIHRoZSBjYW52YXMuXG4gICAgICogVGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVyIHdpbGwgZGVmaW5lIHdoZXRoZXIgdGhlIHVzZXIgaXMgcm90YXRpbmcvc2NhbGluZy90cmFuc2xhdGluZ1xuICAgICAqIGFuIGltYWdlIG9yIG5laXRoZXIgb2YgdGhlbSAob25seSBob3ZlcmluZykuIEEgZ3JvdXAgc2VsZWN0aW9uIGlzIGFsc28gcG9zc2libGUgYW5kIHdvdWxkIGNhbmNlbFxuICAgICAqIGFsbCBhbnkgb3RoZXIgdHlwZSBvZiBhY3Rpb24uXG4gICAgICogSW4gY2FzZSBvZiBhbiBpbWFnZSB0cmFuc2Zvcm1hdGlvbiBvbmx5IHRoZSB0b3AgY2FudmFzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmU6YmVmb3JlJyk7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHZhciB0YXJnZXQsIHBvaW50ZXI7XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3I7XG5cbiAgICAgIC8vIFdlIGluaXRpYWxseSBjbGlja2VkIGluIGFuIGVtcHR5IGFyZWEsIHNvIHdlIGRyYXcgYSBib3ggZm9yIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAgaWYgKGdyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgcG9pbnRlciA9IHRoaXMuX2Fic29sdXRlUG9pbnRlcjtcblxuICAgICAgICBncm91cFNlbGVjdG9yLmxlZnQgPSBwb2ludGVyLnggLSBncm91cFNlbGVjdG9yLmV4O1xuICAgICAgICBncm91cFNlbGVjdG9yLnRvcCA9IHBvaW50ZXIueSAtIGdyb3VwU2VsZWN0b3IuZXk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJUb3AoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCF0aGlzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKSB8fCBudWxsO1xuICAgICAgICB0aGlzLl9zZXRDdXJzb3JGcm9tRXZlbnQoZSwgdGFyZ2V0KTtcbiAgICAgICAgdGhpcy5fZmlyZU92ZXJPdXRFdmVudHModGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1PYmplY3QoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnbW92ZScpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBtb3VzZW91dCwgbW91c2VvdmVyIGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3Qgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHRoZSB0YXJnZXQgd2hlcmUgdGhlIHRhcmdldCBmcm9tIHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlT3Zlck91dEV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgX2hvdmVyZWRUYXJnZXQgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0LFxuICAgICAgICAgIF9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMuX2hvdmVyZWRUYXJnZXRzLCB0YXJnZXRzID0gdGhpcy50YXJnZXRzLFxuICAgICAgICAgIGxlbmd0aCA9IE1hdGgubWF4KF9ob3ZlcmVkVGFyZ2V0cy5sZW5ndGgsIHRhcmdldHMubGVuZ3RoKTtcblxuICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0LCBlLCB7XG4gICAgICAgIG9sZFRhcmdldDogX2hvdmVyZWRUYXJnZXQsXG4gICAgICAgIGV2dE91dDogJ21vdXNlb3V0JyxcbiAgICAgICAgY2FudmFzRXZ0T3V0OiAnbW91c2U6b3V0JyxcbiAgICAgICAgZXZ0SW46ICdtb3VzZW92ZXInLFxuICAgICAgICBjYW52YXNFdnRJbjogJ21vdXNlOm92ZXInLFxuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0c1tpXSwgZSwge1xuICAgICAgICAgIG9sZFRhcmdldDogX2hvdmVyZWRUYXJnZXRzW2ldLFxuICAgICAgICAgIGV2dE91dDogJ21vdXNlb3V0JyxcbiAgICAgICAgICBldnRJbjogJ21vdXNlb3ZlcicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2UgdGhlIGRyYWdFbnRlciwgZHJhZ0xlYXZlIGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3RzIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgb25EcmFnIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gb25kcmFnXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUVudGVyTGVhdmVFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIF9kcmFnZ2Vkb3ZlclRhcmdldCA9IHRoaXMuX2RyYWdnZWRvdmVyVGFyZ2V0LFxuICAgICAgICAgIF9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMuX2hvdmVyZWRUYXJnZXRzLCB0YXJnZXRzID0gdGhpcy50YXJnZXRzLFxuICAgICAgICAgIGxlbmd0aCA9IE1hdGgubWF4KF9ob3ZlcmVkVGFyZ2V0cy5sZW5ndGgsIHRhcmdldHMubGVuZ3RoKTtcblxuICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0LCBlLCB7XG4gICAgICAgIG9sZFRhcmdldDogX2RyYWdnZWRvdmVyVGFyZ2V0LFxuICAgICAgICBldnRPdXQ6ICdkcmFnbGVhdmUnLFxuICAgICAgICBldnRJbjogJ2RyYWdlbnRlcicsXG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0c1tpXSwgZSwge1xuICAgICAgICAgIG9sZFRhcmdldDogX2hvdmVyZWRUYXJnZXRzW2ldLFxuICAgICAgICAgIGV2dE91dDogJ2RyYWdsZWF2ZScsXG4gICAgICAgICAgZXZ0SW46ICdkcmFnZW50ZXInLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RyYWdnZWRvdmVyVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2UgdGhlIHN5bnRoZXRpYyBpbi9vdXQgZXZlbnRzIGZvciB0aGUgZmFicmljIG9iamVjdHMgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHRoZSB0YXJnZXQgd2hlcmUgdGhlIHRhcmdldCBmcm9tIHRoZSBzdXBwb3J0ZWQgZXZlbnRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBmdW5jdGlvbiB0byB3b3JrXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy50YXJnZXROYW1lIHByb3BlcnR5IG9uIHRoZSBjYW52YXMgd2hlcmUgdGhlIG9sZCB0YXJnZXQgaXMgc3RvcmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuY2FudmFzRXZ0T3V0XSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGF0IGNhbnZhcyBsZXZlbCBmb3Igb3V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5ldnRPdXQgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBmb3Igb3V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuY2FudmFzRXZ0SW5dIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgYXQgY2FudmFzIGxldmVsIGZvciBpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZ0SW4gbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBmb3IgaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNJbk91dEV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlLCBjb25maWcpIHtcbiAgICAgIHZhciBpbk9wdCwgb3V0T3B0LCBvbGRUYXJnZXQgPSBjb25maWcub2xkVGFyZ2V0LCBvdXRGaXJlcywgaW5GaXJlcyxcbiAgICAgICAgICB0YXJnZXRDaGFuZ2VkID0gb2xkVGFyZ2V0ICE9PSB0YXJnZXQsIGNhbnZhc0V2dEluID0gY29uZmlnLmNhbnZhc0V2dEluLCBjYW52YXNFdnRPdXQgPSBjb25maWcuY2FudmFzRXZ0T3V0O1xuICAgICAgaWYgKHRhcmdldENoYW5nZWQpIHtcbiAgICAgICAgaW5PcHQgPSB7IGU6IGUsIHRhcmdldDogdGFyZ2V0LCBwcmV2aW91c1RhcmdldDogb2xkVGFyZ2V0IH07XG4gICAgICAgIG91dE9wdCA9IHsgZTogZSwgdGFyZ2V0OiBvbGRUYXJnZXQsIG5leHRUYXJnZXQ6IHRhcmdldCB9O1xuICAgICAgfVxuICAgICAgaW5GaXJlcyA9IHRhcmdldCAmJiB0YXJnZXRDaGFuZ2VkO1xuICAgICAgb3V0RmlyZXMgPSBvbGRUYXJnZXQgJiYgdGFyZ2V0Q2hhbmdlZDtcbiAgICAgIGlmIChvdXRGaXJlcykge1xuICAgICAgICBjYW52YXNFdnRPdXQgJiYgdGhpcy5maXJlKGNhbnZhc0V2dE91dCwgb3V0T3B0KTtcbiAgICAgICAgb2xkVGFyZ2V0LmZpcmUoY29uZmlnLmV2dE91dCwgb3V0T3B0KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbkZpcmVzKSB7XG4gICAgICAgIGNhbnZhc0V2dEluICYmIHRoaXMuZmlyZShjYW52YXNFdnRJbiwgaW5PcHQpO1xuICAgICAgICB0YXJnZXQuZmlyZShjb25maWcuZXZ0SW4sIGluT3B0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyBhY3Rpb25zIHdoZW4gYW4gRXZlbnQgTW91c2UgV2hlZWxcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX19vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3doZWVsJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX3RyYW5zZm9ybU9iamVjdDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcblxuICAgICAgdHJhbnNmb3JtLnJlc2V0ID0gZmFsc2U7XG4gICAgICB0cmFuc2Zvcm0uc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICAgICAgdHJhbnNmb3JtLmFsdEtleSA9IGVbdGhpcy5jZW50ZXJlZEtleV07XG5cbiAgICAgIHRoaXMuX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb24oZSwgdHJhbnNmb3JtLCBwb2ludGVyKTtcbiAgICAgIHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb246IGZ1bmN0aW9uKGUsIHRyYW5zZm9ybSwgcG9pbnRlcikge1xuICAgICAgdmFyIHggPSBwb2ludGVyLngsXG4gICAgICAgICAgeSA9IHBvaW50ZXIueSxcbiAgICAgICAgICBhY3Rpb24gPSB0cmFuc2Zvcm0uYWN0aW9uLFxuICAgICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IGZhbHNlLFxuICAgICAgICAgIGFjdGlvbkhhbmRsZXIgPSB0cmFuc2Zvcm0uYWN0aW9uSGFuZGxlcjtcbiAgICAgICAgICAvLyB0aGlzIG9iamVjdCBjb3VsZCBiZSBjcmVhdGVkIGZyb20gdGhlIGZ1bmN0aW9uIGluIHRoZSBjb250cm9sIGhhbmRsZXJzXG5cblxuICAgICAgaWYgKGFjdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgYWN0aW9uUGVyZm9ybWVkID0gYWN0aW9uSGFuZGxlcihlLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ2RyYWcnICYmIGFjdGlvblBlcmZvcm1lZCkge1xuICAgICAgICB0cmFuc2Zvcm0udGFyZ2V0LmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodHJhbnNmb3JtLnRhcmdldC5tb3ZlQ3Vyc29yIHx8IHRoaXMubW92ZUN1cnNvcik7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkID0gdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCB8fCBhY3Rpb25QZXJmb3JtZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmU6IGZhYnJpYy5jb250cm9sc1V0aWxzLmZpcmVFdmVudCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnNvciBkZXBlbmRpbmcgb24gd2hlcmUgdGhlIGNhbnZhcyBpcyBiZWluZyBob3ZlcmVkLlxuICAgICAqIE5vdGU6IHZlcnkgYnVnZ3kgaW4gT3BlcmFcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRoYXQgdGhlIG1vdXNlIGlzIGhvdmVyaW5nLCBpZiBzby5cbiAgICAgKi9cbiAgICBfc2V0Q3Vyc29yRnJvbUV2ZW50OiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaG92ZXJDdXJzb3IgPSB0YXJnZXQuaG92ZXJDdXJzb3IgfHwgdGhpcy5ob3ZlckN1cnNvcixcbiAgICAgICAgICBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGhpcy5fYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nID9cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA6IG51bGwsXG4gICAgICAgICAgLy8gb25seSBzaG93IHByb3BlciBjb3JuZXIgd2hlbiBncm91cCBzZWxlY3Rpb24gaXMgbm90IGFjdGl2ZVxuICAgICAgICAgIGNvcm5lciA9ICghYWN0aXZlU2VsZWN0aW9uIHx8ICFhY3RpdmVTZWxlY3Rpb24uY29udGFpbnModGFyZ2V0KSlcbiAgICAgICAgICAvLyBoZXJlIHdlIGNhbGwgZmluZFRhcmdldENvcm5lciBhbHdheXMgd2l0aCB1bmRlZmluZWQgZm9yIHRoZSB0b3VjaCBwYXJhbWV0ZXIuXG4gICAgICAgICAgLy8gd2UgYXNzdW1lIHRoYXQgaWYgeW91IGFyZSB1c2luZyBhIGN1cnNvciB5b3UgZG8gbm90IG5lZWQgdG8gaW50ZXJhY3Qgd2l0aFxuICAgICAgICAgIC8vIHRoZSBiaWdnZXIgdG91Y2ggYXJlYS5cbiAgICAgICAgICAgICAgICAgICAgJiYgdGFyZ2V0Ll9maW5kVGFyZ2V0Q29ybmVyKHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKSk7XG5cbiAgICAgIGlmICghY29ybmVyKSB7XG4gICAgICAgIGlmICh0YXJnZXQuc3ViVGFyZ2V0Q2hlY2spe1xuICAgICAgICAgIC8vIGhvdmVyQ3Vyc29yIHNob3VsZCBjb21lIGZyb20gdG9wLW1vc3Qgc3ViVGFyZ2V0LFxuICAgICAgICAgIC8vIHNvIHdlIHdhbGsgdGhlIGFycmF5IGJhY2t3YXJkc1xuICAgICAgICAgIHRoaXMudGFyZ2V0cy5jb25jYXQoKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uKF90YXJnZXQpe1xuICAgICAgICAgICAgaG92ZXJDdXJzb3IgPSBfdGFyZ2V0LmhvdmVyQ3Vyc29yIHx8IGhvdmVyQ3Vyc29yO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKGhvdmVyQ3Vyc29yKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmdldENvcm5lckN1cnNvcihjb3JuZXIsIHRhcmdldCwgZSkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldENvcm5lckN1cnNvcjogZnVuY3Rpb24oY29ybmVyLCB0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl07XG4gICAgICByZXR1cm4gY29udHJvbC5jdXJzb3JTdHlsZUhhbmRsZXIoZSwgY29udHJvbCwgdGFyZ2V0KTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIG1pbiA9IE1hdGgubWluLFxuICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIF9zaG91bGRHcm91cDogZnVuY3Rpb24oZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdCAmJiB0aGlzLl9pc1NlbGVjdGlvbktleVByZXNzZWQoZSkgJiYgdGFyZ2V0ICYmIHRhcmdldC5zZWxlY3RhYmxlICYmIHRoaXMuc2VsZWN0aW9uICYmXG4gICAgICAgICAgICAoYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQgfHwgYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSAmJiAhdGFyZ2V0Lm9uU2VsZWN0KHsgZTogZSB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX2hhbmRsZUdyb3VwaW5nOiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgLy8gYXZvaWQgbXVsdGkgc2VsZWN0IHdoZW4gc2hpZnQgY2xpY2sgb24gYSBjb3JuZXJcbiAgICAgIGlmIChhY3RpdmVPYmplY3QuX19jb3JuZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldCA9PT0gYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIC8vIGlmIGl0J3MgYSBncm91cCwgZmluZCB0YXJnZXQgYWdhaW4sIHVzaW5nIGFjdGl2ZUdyb3VwIG9iamVjdHNcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUsIHRydWUpO1xuICAgICAgICAvLyBpZiBldmVuIG9iamVjdCBpcyBub3QgZm91bmQgb3Igd2UgYXJlIG9uIGFjdGl2ZU9iamVjdENvcm5lciwgYmFpbCBvdXRcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlT2JqZWN0ICYmIGFjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmVTZWxlY3Rpb24odGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jcmVhdGVBY3RpdmVTZWxlY3Rpb24odGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQWN0aXZlU2VsZWN0aW9uOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgY3VycmVudEFjdGl2ZU9iamVjdHMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHMuc2xpY2UoMCk7XG4gICAgICBpZiAoYWN0aXZlU2VsZWN0aW9uLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgYWN0aXZlU2VsZWN0aW9uLnJlbW92ZVdpdGhVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSB0aGlzLnRhcmdldHMuY29uY2F0KCk7XG4gICAgICAgIGlmIChhY3RpdmVTZWxlY3Rpb24uc2l6ZSgpID09PSAxKSB7XG4gICAgICAgICAgLy8gYWN0aXZhdGUgbGFzdCByZW1haW5pbmcgb2JqZWN0XG4gICAgICAgICAgdGhpcy5fc2V0QWN0aXZlT2JqZWN0KGFjdGl2ZVNlbGVjdGlvbi5pdGVtKDApLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFjdGl2ZVNlbGVjdGlvbi5hZGRXaXRoVXBkYXRlKHRhcmdldCk7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBhY3RpdmVTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlT2JqZWN0cywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUFjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSwgZ3JvdXAgPSB0aGlzLl9jcmVhdGVHcm91cCh0YXJnZXQpO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IGdyb3VwO1xuICAgICAgLy8gSVNTVUUgNDExNTogc2hvdWxkIHdlIGNvbnNpZGVyIHN1YlRhcmdldHMgaGVyZT9cbiAgICAgIC8vIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gW107XG4gICAgICAvLyB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cy5jb25jYXQoKTtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChncm91cCwgZSk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVzLCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX2NyZWF0ZUdyb3VwOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcbiAgICAgICAgICBpc0FjdGl2ZUxvd2VyID0gb2JqZWN0cy5pbmRleE9mKHRoaXMuX2FjdGl2ZU9iamVjdCkgPCBvYmplY3RzLmluZGV4T2YodGFyZ2V0KSxcbiAgICAgICAgICBncm91cE9iamVjdHMgPSBpc0FjdGl2ZUxvd2VyXG4gICAgICAgICAgICA/IFt0aGlzLl9hY3RpdmVPYmplY3QsIHRhcmdldF1cbiAgICAgICAgICAgIDogW3RhcmdldCwgdGhpcy5fYWN0aXZlT2JqZWN0XTtcbiAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5pc0VkaXRpbmcgJiYgdGhpcy5fYWN0aXZlT2JqZWN0LmV4aXRFZGl0aW5nKCk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oZ3JvdXBPYmplY3RzLCB7XG4gICAgICAgIGNhbnZhczogdGhpc1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqL1xuICAgIF9ncm91cFNlbGVjdGVkT2JqZWN0czogZnVuY3Rpb24gKGUpIHtcblxuICAgICAgdmFyIGdyb3VwID0gdGhpcy5fY29sbGVjdE9iamVjdHMoZSksXG4gICAgICAgICAgYUdyb3VwO1xuXG4gICAgICAvLyBkbyBub3QgY3JlYXRlIGdyb3VwIGZvciAxIGVsZW1lbnQgb25seVxuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdChncm91cFswXSwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChncm91cC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFHcm91cCA9IG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGdyb3VwLnJldmVyc2UoKSwge1xuICAgICAgICAgIGNhbnZhczogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QoYUdyb3VwLCBlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29sbGVjdE9iamVjdHM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBncm91cCA9IFtdLFxuICAgICAgICAgIGN1cnJlbnRPYmplY3QsXG4gICAgICAgICAgeDEgPSB0aGlzLl9ncm91cFNlbGVjdG9yLmV4LFxuICAgICAgICAgIHkxID0gdGhpcy5fZ3JvdXBTZWxlY3Rvci5leSxcbiAgICAgICAgICB4MiA9IHgxICsgdGhpcy5fZ3JvdXBTZWxlY3Rvci5sZWZ0LFxuICAgICAgICAgIHkyID0geTEgKyB0aGlzLl9ncm91cFNlbGVjdG9yLnRvcCxcbiAgICAgICAgICBzZWxlY3Rpb25YMVkxID0gbmV3IGZhYnJpYy5Qb2ludChtaW4oeDEsIHgyKSwgbWluKHkxLCB5MikpLFxuICAgICAgICAgIHNlbGVjdGlvblgyWTIgPSBuZXcgZmFicmljLlBvaW50KG1heCh4MSwgeDIpLCBtYXgoeTEsIHkyKSksXG4gICAgICAgICAgYWxsb3dJbnRlcnNlY3QgPSAhdGhpcy5zZWxlY3Rpb25GdWxseUNvbnRhaW5lZCxcbiAgICAgICAgICBpc0NsaWNrID0geDEgPT09IHgyICYmIHkxID09PSB5MjtcbiAgICAgIC8vIHdlIGl0ZXJhdGUgcmV2ZXJzZSBvcmRlciB0byBjb2xsZWN0IHRvcCBmaXJzdCBpbiBjYXNlIG9mIGNsaWNrLlxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICBjdXJyZW50T2JqZWN0ID0gdGhpcy5fb2JqZWN0c1tpXTtcblxuICAgICAgICBpZiAoIWN1cnJlbnRPYmplY3QgfHwgIWN1cnJlbnRPYmplY3Quc2VsZWN0YWJsZSB8fCAhY3VycmVudE9iamVjdC52aXNpYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGFsbG93SW50ZXJzZWN0ICYmIGN1cnJlbnRPYmplY3QuaW50ZXJzZWN0c1dpdGhSZWN0KHNlbGVjdGlvblgxWTEsIHNlbGVjdGlvblgyWTIsIHRydWUpKSB8fFxuICAgICAgICAgICAgY3VycmVudE9iamVjdC5pc0NvbnRhaW5lZFdpdGhpblJlY3Qoc2VsZWN0aW9uWDFZMSwgc2VsZWN0aW9uWDJZMiwgdHJ1ZSkgfHxcbiAgICAgICAgICAgIChhbGxvd0ludGVyc2VjdCAmJiBjdXJyZW50T2JqZWN0LmNvbnRhaW5zUG9pbnQoc2VsZWN0aW9uWDFZMSwgbnVsbCwgdHJ1ZSkpIHx8XG4gICAgICAgICAgICAoYWxsb3dJbnRlcnNlY3QgJiYgY3VycmVudE9iamVjdC5jb250YWluc1BvaW50KHNlbGVjdGlvblgyWTIsIG51bGwsIHRydWUpKVxuICAgICAgICApIHtcbiAgICAgICAgICBncm91cC5wdXNoKGN1cnJlbnRPYmplY3QpO1xuICAgICAgICAgIC8vIG9ubHkgYWRkIG9uZSBvYmplY3QgaWYgaXQncyBhIGNsaWNrXG4gICAgICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMSkge1xuICAgICAgICBncm91cCA9IGdyb3VwLmZpbHRlcihmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gIW9iamVjdC5vblNlbGVjdCh7IGU6IGUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21heWJlR3JvdXBPYmplY3RzOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5fZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9ncm91cFNlbGVjdGVkT2JqZWN0cyhlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZGVmYXVsdEN1cnNvcik7XG4gICAgICAvLyBjbGVhciBzZWxlY3Rpb24gYW5kIGN1cnJlbnQgdHJhbnNmb3JtYXRpb25cbiAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgIH1cbiAgfSk7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIGNhbnZhcyBlbGVtZW50IHRvIGEgZGF0YXVybCBpbWFnZS4gTm90ZSB0aGF0IHdoZW4gbXVsdGlwbGllciBpcyB1c2VkLCBjcm9wcGluZyBpcyBzY2FsZWQgYXBwcm9wcmlhdGVseVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieSwgdG8gaGF2ZSBjb25zaXN0ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdIENyb3BwaW5nIHdpZHRoLiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZ10gRW5hYmxlIHJldGluYSBzY2FsaW5nIGZvciBjbG9uZSBpbWFnZS4gSW50cm9kdWNlIGluIDIuMC4wXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIGEgZGF0YTogVVJMIGNvbnRhaW5pbmcgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IG9wdGlvbnMuZm9ybWF0XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9OZlpWYi98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBqcGVnIGRhdGFVUkwgd2l0aCBsb3dlciBxdWFsaXR5PC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdqcGVnJyxcbiAgICAgKiAgIHF1YWxpdHk6IDAuOFxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGNyb3BwZWQgcG5nIGRhdGFVUkwgKGNsaXBwaW5nIG9mIGNhbnZhcyk8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ3BuZycsXG4gICAgICogICBsZWZ0OiAxMDAsXG4gICAgICogICB0b3A6IDEwMCxcbiAgICAgKiAgIHdpZHRoOiAyMDAsXG4gICAgICogICBoZWlnaHQ6IDIwMFxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGRvdWJsZSBzY2FsZWQgcG5nIGRhdGFVUkw8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ3BuZycsXG4gICAgICogICBtdWx0aXBsaWVyOiAyXG4gICAgICogfSk7XG4gICAgICovXG4gICAgdG9EYXRhVVJMOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCAncG5nJyxcbiAgICAgICAgICBxdWFsaXR5ID0gb3B0aW9ucy5xdWFsaXR5IHx8IDEsXG4gICAgICAgICAgbXVsdGlwbGllciA9IChvcHRpb25zLm11bHRpcGxpZXIgfHwgMSkgKiAob3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nID8gdGhpcy5nZXRSZXRpbmFTY2FsaW5nKCkgOiAxKSxcbiAgICAgICAgICBjYW52YXNFbCA9IHRoaXMudG9DYW52YXNFbGVtZW50KG11bHRpcGxpZXIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRvRGF0YVVSTChjYW52YXNFbCwgZm9ybWF0LCBxdWFsaXR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEhUTUxDYW52YXMgZWxlbWVudCBwYWludGVkIHdpdGggdGhlIGN1cnJlbnQgY2FudmFzIGNvbnRlbnQuXG4gICAgICogTm8gbmVlZCB0byByZXNpemUgdGhlIGFjdHVhbCBvbmUgb3IgcmVwYWludCBpdC5cbiAgICAgKiBXaWxsIHRyYW5zZmVyIG9iamVjdCBvd25lcnNoaXAgdG8gYSBuZXcgY2FudmFzLCBwYWludCBpdCwgYW5kIHNldCBldmVyeXRoaW5nIGJhY2suXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCB1c2VkIHRvIGdldCB0byBhIGRhdGFVcmwgYnV0IGFsc28gaXQgaXMgdXNlZnVsIHRvXG4gICAgICogY3JlYXRlIHF1aWNrIGltYWdlIGNvcGllcyBvZiBhIGNhbnZhcyB3aXRob3V0IHBhc3NpbmcgZm9yIHRoZSBkYXRhVXJsIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbXVsdGlwbGllcl0gYSB6b29tIGZhY3Rvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2Nyb3BwaW5nXSBDcm9wcGluZyBpbmZvcm1hdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY3JvcHBpbmcudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY3JvcHBpbmcud2lkdGhdIENyb3BwaW5nIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY3JvcHBpbmcuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuXG4gICAgICovXG4gICAgdG9DYW52YXNFbGVtZW50OiBmdW5jdGlvbihtdWx0aXBsaWVyLCBjcm9wcGluZykge1xuICAgICAgbXVsdGlwbGllciA9IG11bHRpcGxpZXIgfHwgMTtcbiAgICAgIGNyb3BwaW5nID0gY3JvcHBpbmcgfHwgeyB9O1xuICAgICAgdmFyIHNjYWxlZFdpZHRoID0gKGNyb3BwaW5nLndpZHRoIHx8IHRoaXMud2lkdGgpICogbXVsdGlwbGllcixcbiAgICAgICAgICBzY2FsZWRIZWlnaHQgPSAoY3JvcHBpbmcuaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0KSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgIG9yaWdpbmFsV2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICAgIG9yaWdpbmFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgICAgbmV3Wm9vbSA9IHpvb20gKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHZwID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSxcbiAgICAgICAgICB0cmFuc2xhdGVYID0gKHZwWzRdIC0gKGNyb3BwaW5nLmxlZnQgfHwgMCkpICogbXVsdGlwbGllcixcbiAgICAgICAgICB0cmFuc2xhdGVZID0gKHZwWzVdIC0gKGNyb3BwaW5nLnRvcCB8fCAwKSkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIG9yaWdpbmFsSW50ZXJhY3RpdmUgPSB0aGlzLmludGVyYWN0aXZlLFxuICAgICAgICAgIG5ld1ZwID0gW25ld1pvb20sIDAsIDAsIG5ld1pvb20sIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldLFxuICAgICAgICAgIG9yaWdpbmFsUmV0aW5hID0gdGhpcy5lbmFibGVSZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIG9yaWdpbmFsQ29udGV4dFRvcCA9IHRoaXMuY29udGV4dFRvcDtcbiAgICAgIGNhbnZhc0VsLndpZHRoID0gc2NhbGVkV2lkdGg7XG4gICAgICBjYW52YXNFbC5oZWlnaHQgPSBzY2FsZWRIZWlnaHQ7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSBudWxsO1xuICAgICAgdGhpcy5lbmFibGVSZXRpbmFTY2FsaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gbmV3VnA7XG4gICAgICB0aGlzLndpZHRoID0gc2NhbGVkV2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHNjYWxlZEhlaWdodDtcbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSwgdGhpcy5fb2JqZWN0cyk7XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdnA7XG4gICAgICB0aGlzLndpZHRoID0gb3JpZ2luYWxXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBvcmlnaW5hbEludGVyYWN0aXZlO1xuICAgICAgdGhpcy5lbmFibGVSZXRpbmFTY2FsaW5nID0gb3JpZ2luYWxSZXRpbmE7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSBvcmlnaW5hbENvbnRleHRUb3A7XG4gICAgICByZXR1cm4gY2FudmFzRWw7XG4gICAgfSxcbiAgfSk7XG5cbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgY2FudmFzIHdpdGggZGF0YSBmcm9tIHRoZSBzcGVjaWZpZWQgSlNPTi5cbiAgICogSlNPTiBmb3JtYXQgbXVzdCBjb25mb3JtIHRvIHRoZSBvbmUgb2Yge0BsaW5rIGZhYnJpYy5DYW52YXMjdG9KU09OfVxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGpzb24gSlNPTiBzdHJpbmcgb3Igb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrLCBpbnZva2VkIHdoZW4ganNvbiBpcyBwYXJzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGNvcnJlc3BvbmRpbmcgb2JqZWN0cyAoZS5nOiB7QGxpbmsgZmFicmljLkltYWdlfSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIGluaXRpYWxpemVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBKU09OIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZGVzZXJpYWxpemF0aW9ufVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2ZtZ1h0L3xqc0ZpZGRsZSBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5sb2FkRnJvbUpTT048L2NhcHRpb24+XG4gICAqIGNhbnZhcy5sb2FkRnJvbUpTT04oanNvbiwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5sb2FkRnJvbUpTT04gd2l0aCByZXZpdmVyPC9jYXB0aW9uPlxuICAgKiBjYW52YXMubG9hZEZyb21KU09OKGpzb24sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCBmdW5jdGlvbihvLCBvYmplY3QpIHtcbiAgICogICAvLyBgb2AgPSBqc29uIG9iamVjdFxuICAgKiAgIC8vIGBvYmplY3RgID0gZmFicmljLk9iamVjdCBpbnN0YW5jZVxuICAgKiAgIC8vIC4uLiBkbyBzb21lIHN0dWZmIC4uLlxuICAgKiB9KTtcbiAgICovXG4gIGxvYWRGcm9tSlNPTjogZnVuY3Rpb24gKGpzb24sIGNhbGxiYWNrLCByZXZpdmVyKSB7XG4gICAgaWYgKCFqc29uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2VyaWFsaXplIGlmIGl0IHdhc24ndCBhbHJlYWR5XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKVxuICAgICAgPyBKU09OLnBhcnNlKGpzb24pXG4gICAgICA6IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShqc29uKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGNsaXBQYXRoID0gc2VyaWFsaXplZC5jbGlwUGF0aCxcbiAgICAgICAgcmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlO1xuXG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQuY2xpcFBhdGg7XG5cbiAgICB0aGlzLl9lbmxpdmVuT2JqZWN0cyhzZXJpYWxpemVkLm9iamVjdHMsIGZ1bmN0aW9uIChlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBfdGhpcy5jbGVhcigpO1xuICAgICAgX3RoaXMuX3NldEJnT3ZlcmxheShzZXJpYWxpemVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICAgIF90aGlzLl9lbmxpdmVuT2JqZWN0cyhbY2xpcFBhdGhdLCBmdW5jdGlvbiAoZW5saXZlbmVkQ2FudmFzQ2xpcCkge1xuICAgICAgICAgICAgX3RoaXMuY2xpcFBhdGggPSBlbmxpdmVuZWRDYW52YXNDbGlwWzBdO1xuICAgICAgICAgICAgX3RoaXMuX19zZXR1cENhbnZhcy5jYWxsKF90aGlzLCBzZXJpYWxpemVkLCBlbmxpdmVuZWRPYmplY3RzLCByZW5kZXJPbkFkZFJlbW92ZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9fc2V0dXBDYW52YXMuY2FsbChfdGhpcywgc2VyaWFsaXplZCwgZW5saXZlbmVkT2JqZWN0cywgcmVuZGVyT25BZGRSZW1vdmUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgcmV2aXZlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpYWxpemVkIE9iamVjdCB3aXRoIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtBcnJheX0gcmVzdG9yZWQgY2FudmFzIG9iamVjdHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FjaGVkIHJlbmRlck9uQWRkUmVtb3ZlIGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgYWZ0ZXIgYWxsIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW1hZ2VzL3BhdHRlcm5zIGxvYWRlZFxuICAgKi9cbiAgX19zZXR1cENhbnZhczogZnVuY3Rpb24oc2VyaWFsaXplZCwgZW5saXZlbmVkT2JqZWN0cywgcmVuZGVyT25BZGRSZW1vdmUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBlbmxpdmVuZWRPYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqLCBpbmRleCkge1xuICAgICAgLy8gd2Ugc3BsaWNlIHRoZSBhcnJheSBqdXN0IGluIGNhc2Ugc29tZSBjdXN0b20gY2xhc3NlcyByZXN0b3JlZCBmcm9tIEpTT05cbiAgICAgIC8vIHdpbGwgYWRkIG1vcmUgb2JqZWN0IHRvIGNhbnZhcyBhdCBjYW52YXMgaW5pdC5cbiAgICAgIF90aGlzLmluc2VydEF0KG9iaiwgaW5kZXgpO1xuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgPSByZW5kZXJPbkFkZFJlbW92ZTtcbiAgICAvLyByZW1vdmUgcGFydHMgaSBjYW5ub3Qgc2V0IGFzIG9wdGlvbnNcbiAgICBkZWxldGUgc2VyaWFsaXplZC5vYmplY3RzO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZTtcbiAgICBkZWxldGUgc2VyaWFsaXplZC5vdmVybGF5SW1hZ2U7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQuYmFja2dyb3VuZDtcbiAgICBkZWxldGUgc2VyaWFsaXplZC5vdmVybGF5O1xuICAgIC8vIHRoaXMuX2luaXRPcHRpb25zIGRvZXMgdG9vIG1hbnkgdGhpbmdzIHRvIGp1c3RcbiAgICAvLyBjYWxsIGl0LiBOb3JtYWxseSBsb2FkaW5nIGFuIE9iamVjdCBmcm9tIEpTT05cbiAgICAvLyBjcmVhdGUgdGhlIE9iamVjdCBpbnN0YW5jZS4gSGVyZSB0aGUgQ2FudmFzIGlzXG4gICAgLy8gYWxyZWFkeSBhbiBpbnN0YW5jZSBhbmQgd2UgYXJlIGp1c3QgbG9hZGluZyB0aGluZ3Mgb3ZlciBpdFxuICAgIHRoaXMuX3NldE9wdGlvbnMoc2VyaWFsaXplZCk7XG4gICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXplZCBPYmplY3Qgd2l0aCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgYWZ0ZXIgYWxsIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW1hZ2VzL3BhdHRlcm5zIGxvYWRlZFxuICAgKi9cbiAgX3NldEJnT3ZlcmxheTogZnVuY3Rpb24oc2VyaWFsaXplZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgbG9hZGVkID0ge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBmYWxzZSxcbiAgICAgIG92ZXJsYXlDb2xvcjogZmFsc2UsXG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGZhbHNlLFxuICAgICAgb3ZlcmxheUltYWdlOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoIXNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlICYmICFzZXJpYWxpemVkLm92ZXJsYXlJbWFnZSAmJiAhc2VyaWFsaXplZC5iYWNrZ3JvdW5kICYmICFzZXJpYWxpemVkLm92ZXJsYXkpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNiSWZMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobG9hZGVkLmJhY2tncm91bmRJbWFnZSAmJiBsb2FkZWQub3ZlcmxheUltYWdlICYmIGxvYWRlZC5iYWNrZ3JvdW5kQ29sb3IgJiYgbG9hZGVkLm92ZXJsYXlDb2xvcikge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdiYWNrZ3JvdW5kSW1hZ2UnLCBzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZSwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdvdmVybGF5SW1hZ2UnLCBzZXJpYWxpemVkLm92ZXJsYXlJbWFnZSwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdiYWNrZ3JvdW5kQ29sb3InLCBzZXJpYWxpemVkLmJhY2tncm91bmQsIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnb3ZlcmxheUNvbG9yJywgc2VyaWFsaXplZC5vdmVybGF5LCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0IChiYWNrZ3JvdW5kSW1hZ2UsIG92ZXJsYXlJbWFnZSwgYmFja2dyb3VuZENvbG9yLCBvdmVybGF5Q29sb3IpXG4gICAqIEBwYXJhbSB7KE9iamVjdHxTdHJpbmcpfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGxvYWRlZCBTZXQgbG9hZGVkIHByb3BlcnR5IHRvIHRydWUgaWYgcHJvcGVydHkgaXMgc2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgcHJvcGVydHkgaXMgc2V0XG4gICAqL1xuICBfX3NldEJnT3ZlcmxheTogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlLCBsb2FkZWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHkgPT09ICdiYWNrZ3JvdW5kSW1hZ2UnIHx8IHByb3BlcnR5ID09PSAnb3ZlcmxheUltYWdlJykge1xuICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoW3ZhbHVlXSwgZnVuY3Rpb24oZW5saXZlZE9iamVjdCl7XG4gICAgICAgIF90aGlzW3Byb3BlcnR5XSA9IGVubGl2ZWRPYmplY3RbMF07XG4gICAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1snc2V0JyArIGZhYnJpYy51dGlsLnN0cmluZy5jYXBpdGFsaXplKHByb3BlcnR5LCB0cnVlKV0odmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkZWRbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl1cbiAgICovXG4gIF9lbmxpdmVuT2JqZWN0czogZnVuY3Rpb24gKG9iamVjdHMsIGNhbGxiYWNrLCByZXZpdmVyKSB7XG4gICAgaWYgKCFvYmplY3RzIHx8IG9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0cywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkT2JqZWN0cyk7XG4gICAgfSwgbnVsbCwgcmV2aXZlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF90b0RhdGFVUkw6IGZ1bmN0aW9uIChmb3JtYXQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jbG9uZShmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgIGNhbGxiYWNrKGNsb25lLnRvRGF0YVVSTChmb3JtYXQpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICAgKiBAcGFyYW0ge051bWJlcn0gbXVsdGlwbGllclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX3RvRGF0YVVSTFdpdGhNdWx0aXBsaWVyOiBmdW5jdGlvbiAoZm9ybWF0LCBtdWx0aXBsaWVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuY2xvbmUoZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICBjYWxsYmFjayhjbG9uZS50b0RhdGFVUkxXaXRoTXVsdGlwbGllcihmb3JtYXQsIG11bHRpcGxpZXIpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVzIGNhbnZhcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrXSBSZWNlaXZlcyBjbG9uZWQgaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc10gQXJyYXkgb2YgcHJvcGVydGllcyB0byBpbmNsdWRlIGluIHRoZSBjbG9uZWQgY2FudmFzIGFuZCBjaGlsZHJlblxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uIChjYWxsYmFjaywgcHJvcGVydGllcykge1xuICAgIHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04ocHJvcGVydGllcykpO1xuICAgIHRoaXMuY2xvbmVXaXRob3V0RGF0YShmdW5jdGlvbihjbG9uZSkge1xuICAgICAgY2xvbmUubG9hZEZyb21KU09OKGRhdGEsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhjbG9uZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVzIGNhbnZhcyBpbnN0YW5jZSB3aXRob3V0IGNsb25pbmcgZXhpc3RpbmcgZGF0YS5cbiAgICogVGhpcyBlc3NlbnRpYWxseSBjb3BpZXMgY2FudmFzIGRpbWVuc2lvbnMsIGNsaXBwaW5nIHByb3BlcnRpZXMsIGV0Yy5cbiAgICogYnV0IGxlYXZlcyBkYXRhIGVtcHR5IChzbyB0aGF0IHlvdSBjYW4gcG9wdWxhdGUgaXQgd2l0aCB5b3VyIG93bilcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja10gUmVjZWl2ZXMgY2xvbmVkIGluc3RhbmNlIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICovXG4gIGNsb25lV2l0aG91dERhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGVsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuXG4gICAgZWwud2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGVsLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgdmFyIGNsb25lID0gbmV3IGZhYnJpYy5DYW52YXMoZWwpO1xuICAgIGlmICh0aGlzLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgY2xvbmUuc2V0QmFja2dyb3VuZEltYWdlKHRoaXMuYmFja2dyb3VuZEltYWdlLnNyYywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsb25lLnJlbmRlckFsbCgpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhjbG9uZSk7XG4gICAgICB9KTtcbiAgICAgIGNsb25lLmJhY2tncm91bmRJbWFnZU9wYWNpdHkgPSB0aGlzLmJhY2tncm91bmRJbWFnZU9wYWNpdHk7XG4gICAgICBjbG9uZS5iYWNrZ3JvdW5kSW1hZ2VTdHJldGNoID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2VTdHJldGNoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBjYXBpdGFsaXplID0gZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUsXG4gICAgICBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIG9iamVjdENhY2hpbmcgPSAhZmFicmljLmlzTGlrZWx5Tm9kZSxcbiAgICAgIEFMSUFTSU5HX0xJTUlUID0gMjtcblxuICBpZiAoZmFicmljLk9iamVjdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb290IG9iamVjdCBjbGFzcyBmcm9tIHdoaWNoIGFsbCAyZCBzaGFwZSBjbGFzc2VzIGluaGVyaXQgZnJvbVxuICAgKiBAY2xhc3MgZmFicmljLk9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNvYmplY3RzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuT2JqZWN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBmaXJlcyBhZGRlZFxuICAgKiBAZmlyZXMgcmVtb3ZlZFxuICAgKlxuICAgKiBAZmlyZXMgc2VsZWN0ZWRcbiAgICogQGZpcmVzIGRlc2VsZWN0ZWRcbiAgICogQGZpcmVzIG1vZGlmaWVkXG4gICAqIEBmaXJlcyBtb2RpZmllZFxuICAgKiBAZmlyZXMgbW92ZWRcbiAgICogQGZpcmVzIHNjYWxlZFxuICAgKiBAZmlyZXMgcm90YXRlZFxuICAgKiBAZmlyZXMgc2tld2VkXG4gICAqXG4gICAqIEBmaXJlcyByb3RhdGluZ1xuICAgKiBAZmlyZXMgc2NhbGluZ1xuICAgKiBAZmlyZXMgbW92aW5nXG4gICAqIEBmaXJlcyBza2V3aW5nXG4gICAqXG4gICAqIEBmaXJlcyBtb3VzZWRvd25cbiAgICogQGZpcmVzIG1vdXNldXBcbiAgICogQGZpcmVzIG1vdXNlb3ZlclxuICAgKiBAZmlyZXMgbW91c2VvdXRcbiAgICogQGZpcmVzIG1vdXNld2hlZWxcbiAgICogQGZpcmVzIG1vdXNlZGJsY2xpY2tcbiAgICpcbiAgICogQGZpcmVzIGRyYWdvdmVyXG4gICAqIEBmaXJlcyBkcmFnZW50ZXJcbiAgICogQGZpcmVzIGRyYWdsZWF2ZVxuICAgKiBAZmlyZXMgZHJvcFxuICAgKi9cbiAgZmFicmljLk9iamVjdCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Db21tb25NZXRob2RzLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0IChyZWN0LCBjaXJjbGUsIHBhdGgsIGV0Yy4pLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIG1lYW50IHRvIGJlIHJlYWQtb25seSBhbmQgbm90IG1lYW50IHRvIGJlIG1vZGlmaWVkLlxuICAgICAqIElmIHlvdSBtb2RpZnksIGNlcnRhaW4gcGFydHMgb2YgRmFicmljIChzdWNoIGFzIEpTT04gbG9hZGluZykgd29uJ3Qgd29yayBjb3JyZWN0bHkuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAgICAgICAgICAgICAgICAgICAgICdvYmplY3QnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gb2YgYW4gb2JqZWN0IChvbmUgb2YgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJjZW50ZXJcIilcbiAgICAgKiBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC8xb3cwMmdlYS8yNDQvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5YOiAgICAgICAgICAgICAgICAgICdsZWZ0JyxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbiBvZiBhbiBvYmplY3QgKG9uZSBvZiBcInRvcFwiLCBcImJvdHRvbVwiLCBcImNlbnRlclwiKVxuICAgICAqIFNlZSBodHRwOi8vanNmaWRkbGUubmV0LzFvdzAyZ2VhLzI0NC8gb24gaG93IG9yaWdpblgvb3JpZ2luWSBhZmZlY3Qgb2JqZWN0cyBpbiBncm91cHNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9yaWdpblk6ICAgICAgICAgICAgICAgICAgJ3RvcCcsXG5cbiAgICAvKipcbiAgICAgKiBUb3AgcG9zaXRpb24gb2YgYW4gb2JqZWN0LiBOb3RlIHRoYXQgYnkgZGVmYXVsdCBpdCdzIHJlbGF0aXZlIHRvIG9iamVjdCB0b3AuIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgc2V0dGluZyBvcmlnaW5ZPXt0b3AvY2VudGVyL2JvdHRvbX1cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRvcDogICAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIExlZnQgcG9zaXRpb24gb2YgYW4gb2JqZWN0LiBOb3RlIHRoYXQgYnkgZGVmYXVsdCBpdCdzIHJlbGF0aXZlIHRvIG9iamVjdCBsZWZ0LiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgb3JpZ2luWD17bGVmdC9jZW50ZXIvcmlnaHR9XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsZWZ0OiAgICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBzY2FsZSBmYWN0b3IgKGhvcml6b250YWwpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVg6ICAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgc2NhbGUgZmFjdG9yICh2ZXJ0aWNhbClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWTogICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIGFzIGZsaXBwZWQgaG9yaXpvbnRhbGx5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmxpcFg6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIGFzIGZsaXBwZWQgdmVydGljYWxseVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZsaXBZOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBPcGFjaXR5IG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3BhY2l0eTogICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgb2Ygcm90YXRpb24gb2YgYW4gb2JqZWN0IChpbiBkZWdyZWVzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYW5nbGU6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgb2Ygc2tldyBvbiB4IGF4ZXMgb2YgYW4gb2JqZWN0IChpbiBkZWdyZWVzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tld1g6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgb2Ygc2tldyBvbiB5IGF4ZXMgb2YgYW4gb2JqZWN0IChpbiBkZWdyZWVzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tld1k6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiBvYmplY3QncyBjb250cm9sbGluZyBjb3JuZXJzIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJTaXplOiAgICAgICAgICAgICAgIDEzLFxuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiBvYmplY3QncyBjb250cm9sbGluZyBjb3JuZXJzIHdoZW4gdG91Y2ggaW50ZXJhY3Rpb24gaXMgZGV0ZWN0ZWRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRvdWNoQ29ybmVyU2l6ZTogICAgICAgICAgICAgICAyNCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyBhcmUgcmVuZGVyZWQgYXMgdHJhbnNwYXJlbnQgaW5zaWRlIChpLmUuIHN0cm9rZSBpbnN0ZWFkIG9mIGZpbGwpXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHJhbnNwYXJlbnRDb3JuZXJzOiAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgdGhpcyBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBob3ZlckN1cnNvcjogICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gbW92aW5nIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUGFkZGluZyBiZXR3ZWVuIG9iamVjdCBhbmQgaXRzIGNvbnRyb2xsaW5nIGJvcmRlcnMgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhZGRpbmc6ICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGJvcmRlcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyQ29sb3I6ICAgICAgICAgICAgICAncmdiKDE3OCwyMDQsMjU1KScsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBib3JkZXJzIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgYm9yZGVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgY29ybmVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJDb2xvcjogICAgICAgICAgICAgICdyZ2IoMTc4LDIwNCwyNTUpJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGNvcm5lcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlIGFuZCB0cmFuc3BhcmVudENvcm5lcnMgZmFsc2UpXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJTdHJva2VDb2xvcjogICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHN0eWxlIG9mIGNvbnRyb2wsICdyZWN0JyBvciAnY2lyY2xlJ1xuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGNvcm5lclN0eWxlOiAgICAgICAgICAncmVjdCcsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBjb250cm9sIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY29ybmVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGlzIG9iamVjdCB3aWxsIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvblxuICAgICAqIHdoZW4gYmVpbmcgc2NhbGVkIHZpYSB0aGUgY29udHJvbHMuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFNjYWxpbmc6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGlzIG9iamVjdCB3aWxsIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvblxuICAgICAqIHdoZW4gYmVpbmcgcm90YXRlZCB2aWEgdGhlIGNvbnRyb2xzLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRSb3RhdGlvbjogICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2Ygb2JqZWN0J3MgZmlsbFxuICAgICAqIHRha2VzIGNzcyBjb2xvcnMgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci0zL1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlsbDogICAgICAgICAgICAgICAgICAgICAncmdiKDAsMCwwKScsXG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHJ1bGUgdXNlZCB0byBmaWxsIGFuIG9iamVjdFxuICAgICAqIGFjY2VwdGVkIHZhbHVlcyBhcmUgbm9uemVybywgZXZlbm9kZFxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIHVzZWQgZm9yIHNldHRpbmcgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHVudGlsIHYxLjQuMTIgKHVzZSBgZmFicmljLk9iamVjdCNnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25gIGluc3RlYWQpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaWxsUnVsZTogICAgICAgICAgICAgICAgICdub256ZXJvJyxcblxuICAgIC8qKlxuICAgICAqIENvbXBvc2l0ZSBydWxlIHVzZWQgZm9yIGNhbnZhcyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjogJ3NvdXJjZS1vdmVyJyxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3Igb2YgYW4gb2JqZWN0LlxuICAgICAqIHRha2VzIGNzcyBjb2xvcnMgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci0zL1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOiAgICAgICAgICAnJyxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdGlvbiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGFuIG9iamVjdC4gY29sb3JlZCBsYXllciBiZWhpbmQgdGhlIG9iamVjdCB3aGVuIGl0IGlzIGFjdGl2ZS5cbiAgICAgKiBkb2VzIG5vdCBtaXggZ29vZCB3aXRoIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBtZXRob2RzLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yOiAgICAgICAgICAnJyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGVmaW5lZCwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIHZpYSBzdHJva2UgYW5kIHRoaXMgcHJvcGVydHkgc3BlY2lmaWVzIGl0cyBjb2xvclxuICAgICAqIHRha2VzIGNzcyBjb2xvcnMgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci0zL1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgYSBzdHJva2UgdXNlZCB0byByZW5kZXIgdGhpcyBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZVdpZHRoOiAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHNwZWNpZnlpbmcgZGFzaCBwYXR0ZXJuIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAoc3Ryb2tlIG11c3QgYmUgZGVmaW5lZClcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0cm9rZURhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIExpbmUgb2Zmc2V0IG9mIGFuIG9iamVjdCdzIHN0cm9rZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogMCxcblxuICAgIC8qKlxuICAgICAqIExpbmUgZW5kaW5ncyBzdHlsZSBvZiBhbiBvYmplY3QncyBzdHJva2UgKG9uZSBvZiBcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTGluZUNhcDogICAgICAgICAgICAnYnV0dCcsXG5cbiAgICAvKipcbiAgICAgKiBDb3JuZXIgc3R5bGUgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChvbmUgb2YgXCJiZXZlbFwiLCBcInJvdW5kXCIsIFwibWl0ZXJcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgJ21pdGVyJyxcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gbWl0ZXIgbGVuZ3RoICh1c2VkIGZvciBzdHJva2VMaW5lSm9pbiA9IFwibWl0ZXJcIikgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VNaXRlckxpbWl0OiAgICAgICAgIDQsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZVxuICAgICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNoYWRvdzogICAgICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE9wYWNpdHkgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVycyB3aGVuIG9iamVjdCBpcyBhY3RpdmUgYW5kIG1vdmluZ1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyT3BhY2l0eVdoZW5Nb3Zpbmc6ICAwLjQsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3Igb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVyc1xuICAgICAqIGJpZ2dlciBudW1iZXIgd2lsbCBtYWtlIGEgdGhpY2tlciBib3JkZXJcbiAgICAgKiBib3JkZXIgaXMgMSwgc28gdGhpcyBpcyBiYXNpY2FsbHkgYSBib3JkZXIgdGhpY2tuZXNzXG4gICAgICogc2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIGNoYW5nZSB0aGUgYm9yZGVyIGl0c2VsZi5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlclNjYWxlRmFjdG9yOiAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gYWxsb3dlZCBzY2FsZSB2YWx1ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pblNjYWxlTGltaXQ6ICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBjYW4gbm90IGJlIHNlbGVjdGVkIGZvciBtb2RpZmljYXRpb24gKHVzaW5nIGVpdGhlciBwb2ludC1jbGljay1iYXNlZCBvciBncm91cC1iYXNlZCBzZWxlY3Rpb24pLlxuICAgICAqIEJ1dCBldmVudHMgc3RpbGwgZmlyZSBvbiBpdC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3RhYmxlOiAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgY2FuIG5vdCBiZSBhIHRhcmdldCBvZiBldmVudHMuIEFsbCBldmVudHMgcHJvcGFnYXRlIHRocm91Z2ggaXQuIEludHJvZHVjZWQgaW4gdjEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZXZlbnRlZDogICAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGlzIG5vdCByZW5kZXJlZCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB2aXNpYmxlOiAgICAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBvYmplY3QncyBjb250cm9scyBhcmUgbm90IGRpc3BsYXllZCBhbmQgY2FuIG5vdCBiZSB1c2VkIHRvIG1hbmlwdWxhdGUgb2JqZWN0XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGFzQ29udHJvbHM6ICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVycyBhcmUgbm90IHJlbmRlcmVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGFzQm9yZGVyczogICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBvYmplY3RzIGFyZSBcImZvdW5kXCIgb24gY2FudmFzIG9uIHBlci1waXhlbCBiYXNpcyByYXRoZXIgdGhhbiBhY2NvcmRpbmcgdG8gYm91bmRpbmcgYm94XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGVyUGl4ZWxUYXJnZXRGaW5kOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYGZhbHNlYCwgZGVmYXVsdCBvYmplY3QncyB2YWx1ZXMgYXJlIG5vdCBpbmNsdWRlZCBpbiBpdHMgc2VyaWFsaXphdGlvblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBtb3ZlbWVudCBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrTW92ZW1lbnRYOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCB2ZXJ0aWNhbCBtb3ZlbWVudCBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrTW92ZW1lbnRZOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCByb3RhdGlvbiBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrUm90YXRpb246ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2NhbGluZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNrZXdpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NrZXdpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2tld2luZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2tld2luZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBjYW5ub3QgYmUgZmxpcHBlZCBieSBzY2FsaW5nIGludG8gbmVnYXRpdmUgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgbm90IGV4cG9ydGVkIGluIE9CSkVDVC9KU09OXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZXhjbHVkZUZyb21FeHBvcnQ6ICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgY2FjaGVkIG9uIGFuIGFkZGl0aW9uYWwgY2FudmFzLlxuICAgICAqIFdoZW4gYGZhbHNlYCwgb2JqZWN0IGlzIG5vdCBjYWNoZWQgdW5sZXNzIG5lY2Vzc2FyeSAoIGNsaXBQYXRoIClcbiAgICAgKiBkZWZhdWx0IHRvIHRydWVcbiAgICAgKiBAc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG9iamVjdENhY2hpbmc6ICAgICAgICAgICAgb2JqZWN0Q2FjaGluZyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBmb3IgY2FjaGUgaW52YWxpZGF0aW9uLiBJbiBzb21lIHBhcnRpY3VsYXJcbiAgICAgKiBzaXR1YXRpb24geW91IG1heSB3YW50IHRoaXMgdG8gYmUgZGlzYWJsZWQgKCBzcHJheSBicnVzaCwgdmVyeSBiaWcsIGdyb3VwcylcbiAgICAgKiBvciBpZiB5b3VyIGFwcGxpY2F0aW9uIGRvZXMgbm90IGFsbG93IHlvdSB0byBtb2RpZnkgcHJvcGVydGllcyBmb3IgZ3JvdXBzIGNoaWxkIHlvdSB3YW50XG4gICAgICogdG8gZGlzYWJsZSBpdCBmb3IgZ3JvdXBzLlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHN0YXRlZnVsbENhY2hlOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIGNhY2hlIGRvZXMgbm90IGdldCB1cGRhdGVkIGR1cmluZyBzY2FsaW5nLiBUaGUgcGljdHVyZSB3aWxsIGdldCBibG9ja3kgaWYgc2NhbGVkXG4gICAgICogdG9vIG11Y2ggYW5kIHdpbGwgYmUgcmVkcmF3biB3aXRoIGNvcnJlY3QgZGV0YWlscyBhdCB0aGUgZW5kIG9mIHNjYWxpbmcuXG4gICAgICogdGhpcyBzZXR0aW5nIGlzIHBlcmZvcm1hbmNlIGFuZCBhcHBsaWNhdGlvbiBkZXBlbmRhbnQuXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIHRoZSBzdG9rZSB3aWR0aCB3aWxsIHNjYWxlIHdpdGggdGhlIG9iamVjdC5cbiAgICAgKiBXaGVuIGB0cnVlYCwgdGhlIHN0cm9rZSB3aWxsIGFsd2F5cyBtYXRjaCB0aGUgZXhhY3QgcGl4ZWwgc2l6ZSBlbnRlcmVkIGZvciBzdHJva2Ugd2lkdGguXG4gICAgICogdGhpcyBQcm9wZXJ0eSBkb2VzIG5vdCB3b3JrIG9uIFRleHQgY2xhc3NlcyBvciBkcmF3aW5nIGNhbGwgdGhhdCB1c2VzIHN0cm9rZVRleHQsZmlsbFRleHQgbWV0aG9kc1xuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBAc2luY2UgMi42LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzdHJva2VVbmlmb3JtOiAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIG9iamVjdCdzIGNhY2hlIHdpbGwgYmUgcmVyZW5kZXJlZCBuZXh0IHJlbmRlciBjYWxsLlxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBkaXJ0eTogICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGtlZXBzIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBob3ZlcmVkIGNvcm5lciBkdXJpbmcgbW91c2UgbW92ZS5cbiAgICAgKiAwIGlzIG5vIGNvcm5lciwgb3IgJ210JywgJ21sJywgJ210cicgZXRjLi5cbiAgICAgKiBJdCBzaG91bGQgYmUgcHJpdmF0ZSwgYnV0IHRoZXJlIGlzIG5vIGhhcm0gaW4gdXNpbmcgaXQgYXNcbiAgICAgKiBhIHJlYWQtb25seSBwcm9wZXJ0eS5cbiAgICAgKiBAdHlwZSBudW1iZXJ8c3RyaW5nfGFueVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBfX2Nvcm5lcjogMCxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGZpbGwgb3IgdGhlIHN0cm9rZSBpcyBkcmF3biBmaXJzdCAob25lIG9mIFwiZmlsbFwiIG9yIFwic3Ryb2tlXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYWludEZpcnN0OiAgICAgICAgICAgJ2ZpbGwnLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiAnZG93bicsIG9iamVjdCBpcyBzZXQgdG8gYWN0aXZlIG9uIG1vdXNlZG93bi90b3VjaHN0YXJ0XG4gICAgICogV2hlbiAndXAnLCBvYmplY3QgaXMgc2V0IHRvIGFjdGl2ZSBvbiBtb3VzZXVwL3RvdWNoZW5kXG4gICAgICogRXhwZXJpbWVudGFsLiBMZXQncyBzZWUgaWYgdGhpcyBicmVha3MgYW55dGhpbmcgYmVmb3JlIHN1cHBvcnRpbmcgb2ZmaWNpYWxseVxuICAgICAqIEBwcml2YXRlXG4gICAgICogc2luY2UgNC40LjBcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAnZG93bidcbiAgICAgKi9cbiAgICBhY3RpdmVPbjogICAgICAgICAgICdkb3duJyxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIHN0YXRlXG4gICAgICogb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkKVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogKFxuICAgICAgJ3RvcCBsZWZ0IHdpZHRoIGhlaWdodCBzY2FsZVggc2NhbGVZIGZsaXBYIGZsaXBZIG9yaWdpblggb3JpZ2luWSB0cmFuc2Zvcm1NYXRyaXggJyArXG4gICAgICAnc3Ryb2tlIHN0cm9rZVdpZHRoIHN0cm9rZURhc2hBcnJheSBzdHJva2VMaW5lQ2FwIHN0cm9rZURhc2hPZmZzZXQgc3Ryb2tlTGluZUpvaW4gc3Ryb2tlTWl0ZXJMaW1pdCAnICtcbiAgICAgICdhbmdsZSBvcGFjaXR5IGZpbGwgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHNoYWRvdyB2aXNpYmxlIGJhY2tncm91bmRDb2xvciAnICtcbiAgICAgICdza2V3WCBza2V3WSBmaWxsUnVsZSBwYWludEZpcnN0IGNsaXBQYXRoIHN0cm9rZVVuaWZvcm0nXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgY2FjaGUgbmVlZHMgcmVmcmVzaFxuICAgICAqIFRob3NlIHByb3BlcnRpZXMgYXJlIGNoZWNrZWQgYnkgc3RhdGVmdWxsQ2FjaGUgT04gKCBvciBsYXp5IG1vZGUgaWYgd2Ugd2FudCApIG9yIGZyb20gc2luZ2xlXG4gICAgICogY2FsbHMgdG8gT2JqZWN0LnNldChrZXksIHZhbHVlKS4gSWYgdGhlIGtleSBpcyBpbiB0aGlzIGxpc3QsIHRoZSBvYmplY3QgaXMgbWFya2VkIGFzIGRpcnR5XG4gICAgICogYW5kIHJlZnJlc2hlZCBhdCB0aGUgbmV4dCByZW5kZXJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGNhY2hlUHJvcGVydGllczogKFxuICAgICAgJ2ZpbGwgc3Ryb2tlIHN0cm9rZVdpZHRoIHN0cm9rZURhc2hBcnJheSB3aWR0aCBoZWlnaHQgcGFpbnRGaXJzdCBzdHJva2VVbmlmb3JtJyArXG4gICAgICAnIHN0cm9rZUxpbmVDYXAgc3Ryb2tlRGFzaE9mZnNldCBzdHJva2VMaW5lSm9pbiBzdHJva2VNaXRlckxpbWl0IGJhY2tncm91bmRDb2xvciBjbGlwUGF0aCdcbiAgICApLnNwbGl0KCcgJyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgZm9yIGFuaW1hdGluZyBjb2xvcnMuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjb2xvclByb3BlcnRpZXM6IChcbiAgICAgICdmaWxsIHN0cm9rZSBiYWNrZ3JvdW5kQ29sb3InXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogYSBmYWJyaWNPYmplY3QgdGhhdCwgd2l0aG91dCBzdHJva2UgZGVmaW5lIGEgY2xpcHBpbmcgYXJlYSB3aXRoIHRoZWlyIHNoYXBlLiBmaWxsZWQgaW4gYmxhY2tcbiAgICAgKiB0aGUgY2xpcFBhdGggb2JqZWN0IGdldHMgdXNlZCB3aGVuIHRoZSBvYmplY3QgaGFzIHJlbmRlcmVkLCBhbmQgdGhlIGNvbnRleHQgaXMgcGxhY2VkIGluIHRoZSBjZW50ZXJcbiAgICAgKiBvZiB0aGUgb2JqZWN0IGNhY2hlQ2FudmFzLlxuICAgICAqIElmIHlvdSB3YW50IDAsMCBvZiBhIGNsaXBQYXRoIHRvIGFsaWduIHdpdGggYW4gb2JqZWN0IGNlbnRlciwgdXNlIGNsaXBQYXRoLm9yaWdpblgvWSB0byAnY2VudGVyJ1xuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RcbiAgICAgKi9cbiAgICBjbGlwUGF0aDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogTWVhbmluZ2Z1bCBPTkxZIHdoZW4gdGhlIG9iamVjdCBpcyB1c2VkIGFzIGNsaXBQYXRoLlxuICAgICAqIGlmIHRydWUsIHRoZSBjbGlwUGF0aCB3aWxsIG1ha2UgdGhlIG9iamVjdCBjbGlwIHRvIHRoZSBvdXRzaWRlIG9mIHRoZSBjbGlwUGF0aFxuICAgICAqIHNpbmNlIDIuNC4wXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgaW52ZXJ0ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTWVhbmluZ2Z1bCBPTkxZIHdoZW4gdGhlIG9iamVjdCBpcyB1c2VkIGFzIGNsaXBQYXRoLlxuICAgICAqIGlmIHRydWUsIHRoZSBjbGlwUGF0aCB3aWxsIGhhdmUgaXRzIHRvcCBhbmQgbGVmdCByZWxhdGl2ZSB0byBjYW52YXMsIGFuZCB3aWxsXG4gICAgICogbm90IGJlIGluZmx1ZW5jZWQgYnkgdGhlIG9iamVjdCB0cmFuc2Zvcm0uIFRoaXMgd2lsbCBtYWtlIHRoZSBjbGlwUGF0aCByZWxhdGl2ZVxuICAgICAqIHRvIHRoZSBjYW52YXMsIGJ1dCBjbGlwcGluZyBqdXN0IGEgcGFydGljdWxhciBvYmplY3QuXG4gICAgICogV0FSTklORyB0aGlzIGlzIGJldGEsIHRoaXMgZmVhdHVyZSBtYXkgY2hhbmdlIG9yIGJlIHJlbmFtZWQuXG4gICAgICogc2luY2UgMi40LjBcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBhYnNvbHV0ZVBvc2l0aW9uZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aGUgY2FudmFzIHVzZWQgdG8ga2VlcCB0aGUgY2FjaGVkIGNvcHkgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NhY2hlUHJvcGVydGllcyA9IHt9O1xuICAgICAgdGhpcy5fY2FjaGVDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB0aGlzLl9jYWNoZUNvbnRleHQgPSB0aGlzLl9jYWNoZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdGhpcy5fdXBkYXRlQ2FjaGVDYW52YXMoKTtcbiAgICAgIC8vIGlmIGNhbnZhcyBnZXRzIGNyZWF0ZWQsIGlzIGVtcHR5LCBzbyBkaXJ0eS5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaW1pdCB0aGUgY2FjaGUgZGltZW5zaW9ucyBzbyB0aGF0IFggKiBZIGRvIG5vdCBjcm9zcyBmYWJyaWMucGVyZkxpbWl0U2l6ZVRvdGFsXG4gICAgICogYW5kIGVhY2ggc2lkZSBkbyBub3QgY3Jvc3MgZmFicmljLmNhY2hlU2lkZUxpbWl0XG4gICAgICogdGhvc2UgbnVtYmVycyBhcmUgY29uZmlndXJhYmxlIHNvIHRoYXQgeW91IGNhbiBnZXQgYXMgbXVjaCBkZXRhaWwgYXMgeW91IHdhbnRcbiAgICAgKiBtYWtpbmcgYmFyZ2FpbiB3aXRoIHBlcmZvcm1hbmNlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMuem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2xpbWl0Q2FjaGVTaXplOiBmdW5jdGlvbihkaW1zKSB7XG4gICAgICB2YXIgcGVyZkxpbWl0U2l6ZVRvdGFsID0gZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbCxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGgsIGhlaWdodCA9IGRpbXMuaGVpZ2h0LFxuICAgICAgICAgIG1heCA9IGZhYnJpYy5tYXhDYWNoZVNpZGVMaW1pdCwgbWluID0gZmFicmljLm1pbkNhY2hlU2lkZUxpbWl0O1xuICAgICAgaWYgKHdpZHRoIDw9IG1heCAmJiBoZWlnaHQgPD0gbWF4ICYmIHdpZHRoICogaGVpZ2h0IDw9IHBlcmZMaW1pdFNpemVUb3RhbCkge1xuICAgICAgICBpZiAod2lkdGggPCBtaW4pIHtcbiAgICAgICAgICBkaW1zLndpZHRoID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgPCBtaW4pIHtcbiAgICAgICAgICBkaW1zLmhlaWdodCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGltcztcbiAgICAgIH1cbiAgICAgIHZhciBhciA9IHdpZHRoIC8gaGVpZ2h0LCBsaW1pdGVkRGltcyA9IGZhYnJpYy51dGlsLmxpbWl0RGltc0J5QXJlYShhciwgcGVyZkxpbWl0U2l6ZVRvdGFsKSxcbiAgICAgICAgICBjYXBWYWx1ZSA9IGZhYnJpYy51dGlsLmNhcFZhbHVlLFxuICAgICAgICAgIHggPSBjYXBWYWx1ZShtaW4sIGxpbWl0ZWREaW1zLngsIG1heCksXG4gICAgICAgICAgeSA9IGNhcFZhbHVlKG1pbiwgbGltaXRlZERpbXMueSwgbWF4KTtcbiAgICAgIGlmICh3aWR0aCA+IHgpIHtcbiAgICAgICAgZGltcy56b29tWCAvPSB3aWR0aCAvIHg7XG4gICAgICAgIGRpbXMud2lkdGggPSB4O1xuICAgICAgICBkaW1zLmNhcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0ID4geSkge1xuICAgICAgICBkaW1zLnpvb21ZIC89IGhlaWdodCAvIHk7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0geTtcbiAgICAgICAgZGltcy5jYXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGltZW5zaW9uIGFuZCB0aGUgem9vbSBsZXZlbCBuZWVkZWQgdG8gY3JlYXRlIGEgY2FjaGUgY2FudmFzXG4gICAgICogYmlnIGVub3VnaCB0byBob3N0IHRoZSBvYmplY3QgdG8gYmUgY2FjaGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS54IHdpZHRoIG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LnkgaGVpZ2h0IG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iamVjdFNjYWxlID0gdGhpcy5nZXRUb3RhbE9iamVjdFNjYWxpbmcoKSxcbiAgICAgICAgICAvLyBjYWN1bGF0ZSBkaW1lbnNpb25zIHdpdGhvdXQgc2tld2luZ1xuICAgICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygwLCAwKSxcbiAgICAgICAgICBuZWVkZWRYID0gZGltLnggKiBvYmplY3RTY2FsZS5zY2FsZVggLyB0aGlzLnNjYWxlWCxcbiAgICAgICAgICBuZWVkZWRZID0gZGltLnkgKiBvYmplY3RTY2FsZS5zY2FsZVkgLyB0aGlzLnNjYWxlWTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIGZvciBzdXJlIHRoaXMgQUxJQVNJTkdfTElNSVQgaXMgc2xpZ2h0bHkgY3JlYXRpbmcgcHJvYmxlbVxuICAgICAgICAvLyBpbiBzaXR1YXRpb24gaW4gd2hpY2ggdGhlIGNhY2hlIGNhbnZhcyBnZXRzIGFuIHVwcGVyIGxpbWl0XG4gICAgICAgIC8vIGFsc28gb2JqZWN0U2NhbGUgY29udGFpbnMgYWxyZWFkeSBzY2FsZVggYW5kIHNjYWxlWVxuICAgICAgICB3aWR0aDogbmVlZGVkWCArIEFMSUFTSU5HX0xJTUlULFxuICAgICAgICBoZWlnaHQ6IG5lZWRlZFkgKyBBTElBU0lOR19MSU1JVCxcbiAgICAgICAgem9vbVg6IG9iamVjdFNjYWxlLnNjYWxlWCxcbiAgICAgICAgem9vbVk6IG9iamVjdFNjYWxlLnNjYWxlWSxcbiAgICAgICAgeDogbmVlZGVkWCxcbiAgICAgICAgeTogbmVlZGVkWVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGNhbnZhcyBmb3IgY2FjaGVcbiAgICAgKiByZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgY2FudmFzIG5lZWRlZCByZXNpemUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjYW52YXMgaGFzIGJlZW4gcmVzaXplZFxuICAgICAqL1xuICAgIF91cGRhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGFyZ2V0Q2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBpZiAodGhpcy5ub1NjYWxlQ2FjaGUgJiYgdGFyZ2V0Q2FudmFzICYmIHRhcmdldENhbnZhcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0Q2FudmFzLl9jdXJyZW50VHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICAgIGFjdGlvbiA9IHRhcmdldENhbnZhcy5fY3VycmVudFRyYW5zZm9ybS5hY3Rpb247XG4gICAgICAgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgYWN0aW9uLnNsaWNlICYmIGFjdGlvbi5zbGljZSgwLCA1KSA9PT0gJ3NjYWxlJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhY2hlQ2FudmFzLFxuICAgICAgICAgIGRpbXMgPSB0aGlzLl9saW1pdENhY2hlU2l6ZSh0aGlzLl9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnMoKSksXG4gICAgICAgICAgbWluQ2FjaGVTaXplID0gZmFicmljLm1pbkNhY2hlU2lkZUxpbWl0LFxuICAgICAgICAgIHdpZHRoID0gZGltcy53aWR0aCwgaGVpZ2h0ID0gZGltcy5oZWlnaHQsIGRyYXdpbmdXaWR0aCwgZHJhd2luZ0hlaWdodCxcbiAgICAgICAgICB6b29tWCA9IGRpbXMuem9vbVgsIHpvb21ZID0gZGltcy56b29tWSxcbiAgICAgICAgICBkaW1lbnNpb25zQ2hhbmdlZCA9IHdpZHRoICE9PSB0aGlzLmNhY2hlV2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLmNhY2hlSGVpZ2h0LFxuICAgICAgICAgIHpvb21DaGFuZ2VkID0gdGhpcy56b29tWCAhPT0gem9vbVggfHwgdGhpcy56b29tWSAhPT0gem9vbVksXG4gICAgICAgICAgc2hvdWxkUmVkcmF3ID0gZGltZW5zaW9uc0NoYW5nZWQgfHwgem9vbUNoYW5nZWQsXG4gICAgICAgICAgYWRkaXRpb25hbFdpZHRoID0gMCwgYWRkaXRpb25hbEhlaWdodCA9IDAsIHNob3VsZFJlc2l6ZUNhbnZhcyA9IGZhbHNlO1xuICAgICAgaWYgKGRpbWVuc2lvbnNDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBjYW52YXNXaWR0aCA9IHRoaXMuX2NhY2hlQ2FudmFzLndpZHRoLFxuICAgICAgICAgICAgY2FudmFzSGVpZ2h0ID0gdGhpcy5fY2FjaGVDYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgc2l6ZUdyb3dpbmcgPSB3aWR0aCA+IGNhbnZhc1dpZHRoIHx8IGhlaWdodCA+IGNhbnZhc0hlaWdodCxcbiAgICAgICAgICAgIHNpemVTaHJpbmtpbmcgPSAod2lkdGggPCBjYW52YXNXaWR0aCAqIDAuOSB8fCBoZWlnaHQgPCBjYW52YXNIZWlnaHQgKiAwLjkpICYmXG4gICAgICAgICAgICAgIGNhbnZhc1dpZHRoID4gbWluQ2FjaGVTaXplICYmIGNhbnZhc0hlaWdodCA+IG1pbkNhY2hlU2l6ZTtcbiAgICAgICAgc2hvdWxkUmVzaXplQ2FudmFzID0gc2l6ZUdyb3dpbmcgfHwgc2l6ZVNocmlua2luZztcbiAgICAgICAgaWYgKHNpemVHcm93aW5nICYmICFkaW1zLmNhcHBlZCAmJiAod2lkdGggPiBtaW5DYWNoZVNpemUgfHwgaGVpZ2h0ID4gbWluQ2FjaGVTaXplKSkge1xuICAgICAgICAgIGFkZGl0aW9uYWxXaWR0aCA9IHdpZHRoICogMC4xO1xuICAgICAgICAgIGFkZGl0aW9uYWxIZWlnaHQgPSBoZWlnaHQgKiAwLjE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgZmFicmljLlRleHQgJiYgdGhpcy5wYXRoKSB7XG4gICAgICAgIHNob3VsZFJlZHJhdyA9IHRydWU7XG4gICAgICAgIHNob3VsZFJlc2l6ZUNhbnZhcyA9IHRydWU7XG4gICAgICAgIGFkZGl0aW9uYWxXaWR0aCArPSB0aGlzLmdldEhlaWdodE9mTGluZSgwKSAqIHRoaXMuem9vbVg7XG4gICAgICAgIGFkZGl0aW9uYWxIZWlnaHQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoMCkgKiB0aGlzLnpvb21ZO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlZHJhdykge1xuICAgICAgICBpZiAoc2hvdWxkUmVzaXplQ2FudmFzKSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoICsgYWRkaXRpb25hbFdpZHRoKTtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCArIGFkZGl0aW9uYWxIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdpbmdXaWR0aCA9IGRpbXMueCAvIDI7XG4gICAgICAgIGRyYXdpbmdIZWlnaHQgPSBkaW1zLnkgLyAyO1xuICAgICAgICB0aGlzLmNhY2hlVHJhbnNsYXRpb25YID0gTWF0aC5yb3VuZChjYW52YXMud2lkdGggLyAyIC0gZHJhd2luZ1dpZHRoKSArIGRyYXdpbmdXaWR0aDtcbiAgICAgICAgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoY2FudmFzLmhlaWdodCAvIDIgLSBkcmF3aW5nSGVpZ2h0KSArIGRyYXdpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FjaGVXaWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQudHJhbnNsYXRlKHRoaXMuY2FjaGVUcmFuc2xhdGlvblgsIHRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuc2NhbGUoem9vbVgsIHpvb21ZKTtcbiAgICAgICAgdGhpcy56b29tWCA9IHpvb21YO1xuICAgICAgICB0aGlzLnpvb21ZID0gem9vbVk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQob3B0aW9ucy5maWxsLCAnZmlsbCcpO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KG9wdGlvbnMuc3Ryb2tlLCAnc3Ryb2tlJyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLmZpbGwsICdmaWxsJyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLnN0cm9rZSwgJ3N0cm9rZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbnRleHQgd2hlbiByZW5kZXJpbmcgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0XG4gICAgICovXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBuZWVkRnVsbFRyYW5zZm9ybSA9ICh0aGlzLmdyb3VwICYmICF0aGlzLmdyb3VwLl90cmFuc2Zvcm1Eb25lKSB8fFxuICAgICAgICAgKHRoaXMuZ3JvdXAgJiYgdGhpcy5jYW52YXMgJiYgY3R4ID09PSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHZhciBtID0gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCFuZWVkRnVsbFRyYW5zZm9ybSk7XG4gICAgICBjdHgudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcblxuICAgICAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgICAgdmVyc2lvbjogICAgICAgICAgICAgICAgICBmYWJyaWMudmVyc2lvbixcbiAgICAgICAgICAgIG9yaWdpblg6ICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5YLFxuICAgICAgICAgICAgb3JpZ2luWTogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblksXG4gICAgICAgICAgICBsZWZ0OiAgICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5sZWZ0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHRvcDogICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnRvcCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICB3aWR0aDogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBoZWlnaHQ6ICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgZmlsbDogICAgICAgICAgICAgICAgICAgICAodGhpcy5maWxsICYmIHRoaXMuZmlsbC50b09iamVjdCkgPyB0aGlzLmZpbGwudG9PYmplY3QoKSA6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgIHN0cm9rZTogICAgICAgICAgICAgICAgICAgKHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlLnRvT2JqZWN0KSA/IHRoaXMuc3Ryb2tlLnRvT2JqZWN0KCkgOiB0aGlzLnN0cm9rZSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnN0cm9rZVdpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHN0cm9rZURhc2hBcnJheTogICAgICAgICAgdGhpcy5zdHJva2VEYXNoQXJyYXkgPyB0aGlzLnN0cm9rZURhc2hBcnJheS5jb25jYXQoKSA6IHRoaXMuc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgICAgICAgc3Ryb2tlTGluZUNhcDogICAgICAgICAgICB0aGlzLnN0cm9rZUxpbmVDYXAsXG4gICAgICAgICAgICBzdHJva2VEYXNoT2Zmc2V0OiAgICAgICAgIHRoaXMuc3Ryb2tlRGFzaE9mZnNldCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgICAgIHN0cm9rZVVuaWZvcm06ICAgICAgICAgICAgdGhpcy5zdHJva2VVbmlmb3JtLFxuICAgICAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzY2FsZVg6ICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5zY2FsZVgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2NhbGVZOiAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGFuZ2xlOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmFuZ2xlLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWCxcbiAgICAgICAgICAgIGZsaXBZOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWSxcbiAgICAgICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLm9wYWNpdHksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2hhZG93OiAgICAgICAgICAgICAgICAgICAodGhpcy5zaGFkb3cgJiYgdGhpcy5zaGFkb3cudG9PYmplY3QpID8gdGhpcy5zaGFkb3cudG9PYmplY3QoKSA6IHRoaXMuc2hhZG93LFxuICAgICAgICAgICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZmlsbFJ1bGU6ICAgICAgICAgICAgICAgICB0aGlzLmZpbGxSdWxlLFxuICAgICAgICAgICAgcGFpbnRGaXJzdDogICAgICAgICAgICAgICB0aGlzLnBhaW50Rmlyc3QsXG4gICAgICAgICAgICBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246IHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLFxuICAgICAgICAgICAgc2tld1g6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2tld1gsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2tld1k6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2tld1ksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmNsaXBQYXRoICYmICF0aGlzLmNsaXBQYXRoLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgIG9iamVjdC5jbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGgudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIG9iamVjdC5jbGlwUGF0aC5pbnZlcnRlZCA9IHRoaXMuY2xpcFBhdGguaW52ZXJ0ZWQ7XG4gICAgICAgIG9iamVjdC5jbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQgPSB0aGlzLmNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZDtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuX3JlbW92ZURlZmF1bHRWYWx1ZXMob2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAoZGF0YWxlc3MpIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgc3ViY2xhc3Nlc1xuICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqL1xuICAgIF9yZW1vdmVEZWZhdWx0VmFsdWVzOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBwcm90b3R5cGUgPSBmYWJyaWMudXRpbC5nZXRLbGFzcyhvYmplY3QudHlwZSkucHJvdG90eXBlLFxuICAgICAgICAgIHN0YXRlUHJvcGVydGllcyA9IHByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXM7XG4gICAgICBzdGF0ZVByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAnbGVmdCcgfHwgcHJvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdFtwcm9wXSA9PT0gcHJvdG90eXBlW3Byb3BdKSB7XG4gICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNBcnJheSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3RbcHJvcF0pID09PSAnW29iamVjdCBBcnJheV0nICYmXG4gICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb3RvdHlwZVtwcm9wXSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cbiAgICAgICAgLy8gYmFzaWNhbGx5IGEgY2hlY2sgZm9yIFtdID09PSBbXVxuICAgICAgICBpZiAoaXNBcnJheSAmJiBvYmplY3RbcHJvcF0ubGVuZ3RoID09PSAwICYmIHByb3RvdHlwZVtwcm9wXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLicgKyBjYXBpdGFsaXplKHRoaXMudHlwZSkgKyAnPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IHNjYWxlIGZhY3RvciBjb3VudGluZyBhbHNvIHRoZSBncm91cCBzY2FsaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0T2JqZWN0U2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgdG9wIGxldmVsIG9uZSwgb24gdGhlIGNhbnZhcywgd2UgZ28gZm9yIHNpbXBsZSBhcml0bWV0aWNcbiAgICAgIC8vIG90aGVyd2lzZSB0aGUgY29tcGxleCBtZXRob2Qgd2l0aCBhbmdsZXMgd2lsbCByZXR1cm4gYXBwcm94aW1hdGlvbnMgYW5kIGRlY2ltYWxzXG4gICAgICAvLyBhbmQgd2lsbCBsaWtlbHkga2lsbCB0aGUgY2FjaGUgd2hlbiBub3QgbmVlZGVkXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFicmljanMvZmFicmljLmpzL2lzc3Vlcy83MTU3XG4gICAgICBpZiAoIXRoaXMuZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBpZiB3ZSBhcmUgaW5zaWRlIGEgZ3JvdXAgdG90YWwgem9vbSBjYWxjdWxhdGlvbiBpcyBjb21wbGV4LCB3ZSBkZWZlciB0byBnZW5lcmljIG1hdHJpY2VzXG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgIHJldHVybiB7IHNjYWxlWDogTWF0aC5hYnMob3B0aW9ucy5zY2FsZVgpLCBzY2FsZVk6IE1hdGguYWJzKG9wdGlvbnMuc2NhbGVZKSB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG9iamVjdCBzY2FsZSBmYWN0b3IgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgc2NhbGluZywgem9vbSBhbmQgcmV0aW5hXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0VG90YWxPYmplY3RTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpLCBzY2FsZVggPSBzY2FsZS5zY2FsZVgsIHNjYWxlWSA9IHNjYWxlLnNjYWxlWTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB2YXIgem9vbSA9IHRoaXMuY2FudmFzLmdldFpvb20oKTtcbiAgICAgICAgdmFyIHJldGluYSA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKTtcbiAgICAgICAgc2NhbGVYICo9IHpvb20gKiByZXRpbmE7XG4gICAgICAgIHNjYWxlWSAqPSB6b29tICogcmV0aW5hO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IG9wYWNpdHkgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0T2JqZWN0T3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIG9wYWNpdHkgKj0gdGhpcy5ncm91cC5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3BhY2l0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc2hvdWxkQ29uc3RyYWluVmFsdWUgPSAoa2V5ID09PSAnc2NhbGVYJyB8fCBrZXkgPT09ICdzY2FsZVknKSxcbiAgICAgICAgICBpc0NoYW5nZWQgPSB0aGlzW2tleV0gIT09IHZhbHVlLCBncm91cE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRDb25zdHJhaW5WYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2NvbnN0cmFpblNjYWxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzY2FsZVgnICYmIHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBYID0gIXRoaXMuZmxpcFg7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc2NhbGVZJyAmJiB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhpcy5mbGlwWSA9ICF0aGlzLmZsaXBZO1xuICAgICAgICB2YWx1ZSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3NoYWRvdycgJiYgdmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIGZhYnJpYy5TaGFkb3cpKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IGZhYnJpYy5TaGFkb3codmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZGlydHknICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcblxuICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICBncm91cE5lZWRzVXBkYXRlID0gdGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgZ3JvdXBOZWVkc1VwZGF0ZSAmJiB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChncm91cE5lZWRzVXBkYXRlICYmIHRoaXMuc3RhdGVQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgcGFyZW50IGdyb3VwIG9mIGFuIG9iamVjdCBldmVyeVxuICAgICAqIHRpbWUgYSBub24tZGVsZWdhdGVkIHByb3BlcnR5IGNoYW5nZXMgb24gdGhlIGdyb3VwLiBJdCBpcyBwYXNzZWQgdGhlIGtleVxuICAgICAqIGFuZCB2YWx1ZSBhcyBwYXJhbWV0ZXJzLiBOb3QgYWRkaW5nIGluIHRoaXMgZnVuY3Rpb24ncyBzaWduYXR1cmUgdG8gYXZvaWRcbiAgICAgKiBUcmF2aXMgYnVpbGQgZXJyb3IgYWJvdXQgdW51c2VkIHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBzZXRPbkdyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB2aWV3cG9ydFRyYW5zZm9ybSBmcm9tIE9iamVjdCdzIGNhbnZhcyBpZiBwb3NzaWJsZVxuICAgICAqIEBtZXRob2QgZ2V0Vmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmV0dXJuIGlmIHRoZSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpbiByZW5kZXJpbmdcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzTm90VmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID09PSAwIHx8XG4gICAgICAgICghdGhpcy53aWR0aCAmJiAhdGhpcy5oZWlnaHQgJiYgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkgfHxcbiAgICAgICAgIXRoaXMudmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gZG8gbm90IHJlbmRlciBpZiB3aWR0aC9oZWlnaHQgYXJlIHplcm9zIG9yIG9iamVjdCBpcyBub3QgdmlzaWJsZVxuICAgICAgaWYgKHRoaXMuaXNOb3RWaXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnNraXBPZmZzY3JlZW4gJiYgIXRoaXMuZ3JvdXAgJiYgIXRoaXMuaXNPblNjcmVlbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbihjdHgpO1xuICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uQmFja2dyb3VuZChjdHgpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIHRoaXMuX3NldE9wYWNpdHkoY3R4KTtcbiAgICAgIHRoaXMuX3NldFNoYWRvdyhjdHgsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMuc2hvdWxkQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLnJlbmRlckNhY2hlKCk7XG4gICAgICAgIHRoaXMuZHJhd0NhY2hlT25DYW52YXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVDYWNoZUNhbnZhcygpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhd09iamVjdChjdHgpO1xuICAgICAgICBpZiAodGhpcy5vYmplY3RDYWNoaW5nICYmIHRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgICB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnY2FjaGVQcm9wZXJ0aWVzJyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyQ2FjaGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKCF0aGlzLl9jYWNoZUNhbnZhcykge1xuICAgICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNDYWNoZURpcnR5KCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZWZ1bGxDYWNoZSAmJiB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnY2FjaGVQcm9wZXJ0aWVzJyB9KTtcbiAgICAgICAgdGhpcy5kcmF3T2JqZWN0KHRoaXMuX2NhY2hlQ29udGV4dCwgb3B0aW9ucy5mb3JDbGlwcGluZyk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNhY2hlQ2FudmFzIGFuZCBpdHMgZGltZW5zaW9ucyBmcm9tIHRoZSBvYmplY3RzXG4gICAgICovXG4gICAgX3JlbW92ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NhY2hlQ2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY2FjaGVXaWR0aCA9IDA7XG4gICAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCB3aWxsIGRyYXcgYSBzdHJva2VcbiAgICAgKiBEb2VzIG5vdCBjb25zaWRlciB0ZXh0IHN0eWxlcy4gVGhpcyBpcyBqdXN0IGEgc2hvcnRjdXQgdXNlZCBhdCByZW5kZXJpbmcgdGltZVxuICAgICAqIFdlIHdhbnQgaXQgdG8gYmUgYW4gYXBwcm94aW1hdGlvbiBhbmQgYmUgZmFzdC5cbiAgICAgKiB3cm90ZSB0byBhdm9pZCBleHRyYSBjYWNoaW5nLCBpdCBoYXMgdG8gcmV0dXJuIHRydWUgd2hlbiBzdHJva2UgaGFwcGVucyxcbiAgICAgKiBjYW4gZ3Vlc3Mgd2hlbiBpdCB3aWxsIG5vdCBoYXBwZW4gYXQgMTAwJSBjaGFuY2UsIGRvZXMgbm90IG1hdHRlciBpZiBpdCBtaXNzZXNcbiAgICAgKiBzb21lIHVzZSBjYXNlIHdoZXJlIHRoZSBzdHJva2UgaXMgaW52aXNpYmxlLlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKi9cbiAgICBoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlICE9PSAndHJhbnNwYXJlbnQnICYmIHRoaXMuc3Ryb2tlV2lkdGggIT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZSBvYmplY3Qgd2lsbCBkcmF3IGEgZmlsbFxuICAgICAqIERvZXMgbm90IGNvbnNpZGVyIHRleHQgc3R5bGVzLiBUaGlzIGlzIGp1c3QgYSBzaG9ydGN1dCB1c2VkIGF0IHJlbmRlcmluZyB0aW1lXG4gICAgICogV2Ugd2FudCBpdCB0byBiZSBhbiBhcHByb3hpbWF0aW9uIGFuZCBiZSBmYXN0LlxuICAgICAqIHdyb3RlIHRvIGF2b2lkIGV4dHJhIGNhY2hpbmcsIGl0IGhhcyB0byByZXR1cm4gdHJ1ZSB3aGVuIGZpbGwgaGFwcGVucyxcbiAgICAgKiBjYW4gZ3Vlc3Mgd2hlbiBpdCB3aWxsIG5vdCBoYXBwZW4gYXQgMTAwJSBjaGFuY2UsIGRvZXMgbm90IG1hdHRlciBpZiBpdCBtaXNzZXNcbiAgICAgKiBzb21lIHVzZSBjYXNlIHdoZXJlIHRoZSBmaWxsIGlzIGludmlzaWJsZS5cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICovXG4gICAgaGFzRmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxsICYmIHRoaXMuZmlsbCAhPT0gJ3RyYW5zcGFyZW50JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBmb3JjZSB0aGUgb2JqZWN0IHRvIGhhdmUgaXRzIG93biBjYWNoZSwgZXZlbiBpZiBpdCBpcyBpbnNpZGUgYSBncm91cFxuICAgICAqIGl0IG1heSBiZSBuZWVkZWQgd2hlbiB5b3VyIG9iamVjdCBiZWhhdmUgaW4gYSBwYXJ0aWN1bGFyIHdheSBvbiB0aGUgY2FjaGUgYW5kIGFsd2F5cyBuZWVkc1xuICAgICAqIGl0cyBvd24gaXNvbGF0ZWQgY2FudmFzIHRvIHJlbmRlciBjb3JyZWN0bHkuXG4gICAgICogQ3JlYXRlZCB0byBiZSBvdmVycmlkZGVuXG4gICAgICogc2luY2UgMS43LjEyXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqL1xuICAgIG5lZWRzSXRzT3duQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScgJiZcbiAgICAgICAgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSAmJiB0eXBlb2YgdGhpcy5zaGFkb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogb2JqZWN0Q2FjaGluZyBpcyBhIGdsb2JhbCBmbGFnLCB3aW5zIG92ZXIgZXZlcnl0aGluZ1xuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBSZWFkIGFzOiBjYWNoZSBpZiBpcyBuZWVkZWQsIG9yIGlmIHRoZSBmZWF0dXJlIGlzIGVuYWJsZWQgYnV0IHdlIGFyZSBub3QgYWxyZWFkeSBjYWNoaW5nLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5vd25DYWNoaW5nID0gdGhpcy5uZWVkc0l0c093bkNhY2hlKCkgfHwgKFxuICAgICAgICB0aGlzLm9iamVjdENhY2hpbmcgJiZcbiAgICAgICAgKCF0aGlzLmdyb3VwIHx8ICF0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5vd25DYWNoaW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBvciBhIGNoaWxkIG9iamVjdCB3aWxsIGNhc3QgYSBzaGFkb3dcbiAgICAgKiB1c2VkIGJ5IEdyb3VwLnNob3VsZENhY2hlIHRvIGtub3cgaWYgY2hpbGQgaGFzIGEgc2hhZG93IHJlY3Vyc2l2ZWx5XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aWxsRHJhd1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnNoYWRvdyAmJiAodGhpcy5zaGFkb3cub2Zmc2V0WCAhPT0gMCB8fCB0aGlzLnNoYWRvdy5vZmZzZXRZICE9PSAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgZHJhd2luZyBvcGVyYXRpb24gZm9yIGFuIG9iamVjdCBjbGlwUGF0aFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGNsaXBQYXRoXG4gICAgICovXG4gICAgZHJhd0NsaXBQYXRoT25DYWNoZTogZnVuY3Rpb24oY3R4LCBjbGlwUGF0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vIERFQlVHOiB1bmNvbW1lbnQgdGhpcyBsaW5lLCBjb21tZW50IHRoZSBmb2xsb3dpbmdcbiAgICAgIC8vIGN0eC5nbG9iYWxBbHBoYSA9IDAuNFxuICAgICAgaWYgKGNsaXBQYXRoLmludmVydGVkKSB7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgIH1cbiAgICAgIC8vY3R4LnNjYWxlKDEgLyAyLCAxIC8gMik7XG4gICAgICBpZiAoY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkKSB7XG4gICAgICAgIHZhciBtID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgIH1cbiAgICAgIGNsaXBQYXRoLnRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnNjYWxlKDEgLyBjbGlwUGF0aC56b29tWCwgMSAvIGNsaXBQYXRoLnpvb21ZKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY2xpcFBhdGguX2NhY2hlQ2FudmFzLCAtY2xpcFBhdGguY2FjaGVUcmFuc2xhdGlvblgsIC1jbGlwUGF0aC5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd09iamVjdDogZnVuY3Rpb24oY3R4LCBmb3JDbGlwcGluZykge1xuICAgICAgdmFyIG9yaWdpbmFsRmlsbCA9IHRoaXMuZmlsbCwgb3JpZ2luYWxTdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICAgIGlmIChmb3JDbGlwcGluZykge1xuICAgICAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuICAgICAgICB0aGlzLnN0cm9rZSA9ICcnO1xuICAgICAgICB0aGlzLl9zZXRDbGlwcGluZ1Byb3BlcnRpZXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXIoY3R4KTtcbiAgICAgIHRoaXMuX2RyYXdDbGlwUGF0aChjdHgsIHRoaXMuY2xpcFBhdGgpO1xuICAgICAgdGhpcy5maWxsID0gb3JpZ2luYWxGaWxsO1xuICAgICAgdGhpcy5zdHJva2UgPSBvcmlnaW5hbFN0cm9rZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBjbGlwUGF0aCBzdGF0ZSBhbmQgY2FjaGUgYW5kIGRyYXcgaXQgb24gaW5zdGFuY2UncyBjYWNoZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGNsaXBQYXRoXG4gICAgICovXG4gICAgX2RyYXdDbGlwUGF0aDogZnVuY3Rpb24gKGN0eCwgY2xpcFBhdGgpIHtcbiAgICAgIGlmICghY2xpcFBhdGgpIHsgcmV0dXJuOyB9XG4gICAgICAvLyBuZWVkZWQgdG8gc2V0dXAgYSBjb3VwbGUgb2YgdmFyaWFibGVzXG4gICAgICAvLyBwYXRoIGNhbnZhcyBnZXRzIG92ZXJyaWRkZW4gd2l0aCB0aGlzIG9uZS5cbiAgICAgIC8vIFRPRE8gZmluZCBhIGJldHRlciBzb2x1dGlvbj9cbiAgICAgIGNsaXBQYXRoLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgY2xpcFBhdGguc2hvdWxkQ2FjaGUoKTtcbiAgICAgIGNsaXBQYXRoLl90cmFuc2Zvcm1Eb25lID0gdHJ1ZTtcbiAgICAgIGNsaXBQYXRoLnJlbmRlckNhY2hlKHsgZm9yQ2xpcHBpbmc6IHRydWUgfSk7XG4gICAgICB0aGlzLmRyYXdDbGlwUGF0aE9uQ2FjaGUoY3R4LCBjbGlwUGF0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0IG9uIHRoZSB0YXJnZXQgY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd0NhY2hlT25DYW52YXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LnNjYWxlKDEgLyB0aGlzLnpvb21YLCAxIC8gdGhpcy56b29tWSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2NhY2hlQ2FudmFzLCAtdGhpcy5jYWNoZVRyYW5zbGF0aW9uWCwgLXRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYWNoZSBpcyBkaXJ0eVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcENhbnZhcyBza2lwIGNhbnZhcyBjaGVja3MgYmVjYXVzZSB0aGlzIG9iamVjdCBpcyBwYWludGVkXG4gICAgICogb24gcGFyZW50IGNhbnZhcy5cbiAgICAgKi9cbiAgICBpc0NhY2hlRGlydHk6IGZ1bmN0aW9uKHNraXBDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLmlzTm90VmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jYWNoZUNhbnZhcyAmJiAhc2tpcENhbnZhcyAmJiB0aGlzLl91cGRhdGVDYWNoZUNhbnZhcygpKSB7XG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgY29udGV4dCBpcyBhbHJlYWR5IGNsZWFyZWQuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5IHx8XG4gICAgICAgICAgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQpIHx8XG4gICAgICAgICAgKHRoaXMuc3RhdGVmdWxsQ2FjaGUgJiYgdGhpcy5oYXNTdGF0ZUNoYW5nZWQoJ2NhY2hlUHJvcGVydGllcycpKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2FjaGVDYW52YXMgJiYgIXNraXBDYW52YXMpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FjaGVXaWR0aCAvIHRoaXMuem9vbVg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5jYWNoZUhlaWdodCAvIHRoaXMuem9vbVk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBiYWNrZ3JvdW5kIGZvciB0aGUgb2JqZWN0IGJpZyBhcyBpdHMgdW50cmFuc2Zvcm1lZCBkaW1lbnNpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGltID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgLWRpbS54IC8gMixcbiAgICAgICAgLWRpbS55IC8gMixcbiAgICAgICAgZGltLngsXG4gICAgICAgIGRpbS55XG4gICAgICApO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgYmFja2dyb3VuZCBjb2xvciBubyBvdGhlciBzaGFkb3dzXG4gICAgICAvLyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldE9wYWNpdHk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICB2YXIgc3Ryb2tlID0gZGVjbC5zdHJva2U7XG4gICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBkZWNsLnN0cm9rZVdpZHRoO1xuICAgICAgICBjdHgubGluZUNhcCA9IGRlY2wuc3Ryb2tlTGluZUNhcDtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGVjbC5zdHJva2VEYXNoT2Zmc2V0O1xuICAgICAgICBjdHgubGluZUpvaW4gPSBkZWNsLnN0cm9rZUxpbmVKb2luO1xuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IGRlY2wuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICAgICAgaWYgKHN0cm9rZS50b0xpdmUpIHtcbiAgICAgICAgICBpZiAoc3Ryb2tlLmdyYWRpZW50VW5pdHMgPT09ICdwZXJjZW50YWdlJyB8fCBzdHJva2UuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgc3Ryb2tlLnBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhbnNmb3JtIGdyYWRpZW50IGluIGEgcGF0dGVybi5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzbG93IHByb2Nlc3MuIElmIHlvdSBhcmUgaGl0dGluZyB0aGlzIGNvZGVwYXRoLCBhbmQgdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXMgbm90IHVzaW5nIGNhY2hpbmcsIHlvdSBzaG91bGQgY29uc2lkZXIgc3dpdGNoaW5nIGl0IG9uLlxuICAgICAgICAgICAgLy8gd2UgbmVlZCBhIGNhbnZhcyBhcyBiaWcgYXMgdGhlIGN1cnJlbnQgb2JqZWN0IGNhY2hpbmcgY2FudmFzLlxuICAgICAgICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuRm9yVHJhbnNmb3JtZWRHcmFkaWVudChjdHgsIHN0cm9rZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaXMgYSBzaW1wbGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLnRvTGl2ZShjdHgsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0oY3R4LCBzdHJva2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBpcyBhIGNvbG9yXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZGVjbC5zdHJva2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldEZpbGxTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgZGVjbCkge1xuICAgICAgdmFyIGZpbGwgPSBkZWNsLmZpbGw7XG4gICAgICBpZiAoZmlsbCkge1xuICAgICAgICBpZiAoZmlsbC50b0xpdmUpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC50b0xpdmUoY3R4LCB0aGlzKTtcbiAgICAgICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIGRlY2wuZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldENsaXBwaW5nUHJvcGVydGllczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3RyYW5zcGFyZW50JztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU2V0cyBsaW5lIGRhc2hcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gc2V0IHRoZSBkYXNoIGxpbmUgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXNoQXJyYXkgYXJyYXkgcmVwcmVzZW50aW5nIGRhc2hlc1xuICAgICAqL1xuICAgIF9zZXRMaW5lRGFzaDogZnVuY3Rpb24oY3R4LCBkYXNoQXJyYXkpIHtcbiAgICAgIGlmICghZGFzaEFycmF5IHx8IGRhc2hBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3BlYyByZXF1aXJlcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0d28gY29waWVzIHRoZSBkYXNoIGxpc3Qgd2hlbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIG9kZFxuICAgICAgaWYgKDEgJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGRhc2hBcnJheS5wdXNoLmFwcGx5KGRhc2hBcnJheSwgZGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGNvbnRyb2xzIGFuZCBib3JkZXJzIGZvciB0aGUgb2JqZWN0XG4gICAgICogdGhlIGNvbnRleHQgaGVyZSBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZU92ZXJyaWRlXSBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zLCBkcmF3Qm9yZGVycywgZHJhd0NvbnRyb2xzO1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwgeyB9O1xuICAgICAgZHJhd0JvcmRlcnMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNCb3JkZXJzICE9PSAndW5kZWZpbmVkJyA/IHN0eWxlT3ZlcnJpZGUuaGFzQm9yZGVycyA6IHRoaXMuaGFzQm9yZGVycztcbiAgICAgIGRyYXdDb250cm9scyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc0NvbnRyb2xzICE9PSAndW5kZWZpbmVkJyA/IHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgOiB0aGlzLmhhc0NvbnRyb2xzO1xuICAgICAgbWF0cml4ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyh2cHQsIG1hdHJpeCk7XG4gICAgICBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UobWF0cml4KTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxICogdGhpcy5ib3JkZXJTY2FsZUZhY3RvcjtcbiAgICAgIGlmICghdGhpcy5ncm91cCkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5mbGlwWCkge1xuICAgICAgICBvcHRpb25zLmFuZ2xlIC09IDE4MDtcbiAgICAgIH1cbiAgICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyh0aGlzLmdyb3VwID8gb3B0aW9ucy5hbmdsZSA6IHRoaXMuYW5nbGUpKTtcbiAgICAgIGlmIChzdHlsZU92ZXJyaWRlLmZvckFjdGl2ZVNlbGVjdGlvbiB8fCB0aGlzLmdyb3VwKSB7XG4gICAgICAgIGRyYXdCb3JkZXJzICYmIHRoaXMuZHJhd0JvcmRlcnNJbkdyb3VwKGN0eCwgb3B0aW9ucywgc3R5bGVPdmVycmlkZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZHJhd0JvcmRlcnMgJiYgdGhpcy5kcmF3Qm9yZGVycyhjdHgsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgfVxuICAgICAgZHJhd0NvbnRyb2xzICYmIHRoaXMuZHJhd0NvbnRyb2xzKGN0eCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc2V0U2hhZG93OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zaGFkb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hhZG93ID0gdGhpcy5zaGFkb3csIGNhbnZhcyA9IHRoaXMuY2FudmFzLCBzY2FsaW5nLFxuICAgICAgICAgIG11bHRYID0gKGNhbnZhcyAmJiBjYW52YXMudmlld3BvcnRUcmFuc2Zvcm1bMF0pIHx8IDEsXG4gICAgICAgICAgbXVsdFkgPSAoY2FudmFzICYmIGNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybVszXSkgfHwgMTtcbiAgICAgIGlmIChzaGFkb3cubm9uU2NhbGluZykge1xuICAgICAgICBzY2FsaW5nID0geyBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNjYWxpbmcgPSB0aGlzLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW52YXMgJiYgY2FudmFzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgICBtdWx0WCAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgbXVsdFkgKj0gZmFicmljLmRldmljZVBpeGVsUmF0aW87XG4gICAgICB9XG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBzaGFkb3cuY29sb3I7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IHNoYWRvdy5ibHVyICogZmFicmljLmJyb3dzZXJTaGFkb3dCbHVyQ29uc3RhbnQgKlxuICAgICAgICAobXVsdFggKyBtdWx0WSkgKiAoc2NhbGluZy5zY2FsZVggKyBzY2FsaW5nLnNjYWxlWSkgLyA0O1xuICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBzaGFkb3cub2Zmc2V0WCAqIG11bHRYICogc2NhbGluZy5zY2FsZVg7XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHNoYWRvdy5vZmZzZXRZICogbXVsdFkgKiBzY2FsaW5nLnNjYWxlWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbW92ZVNoYWRvdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJyc7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IGN0eC5zaGFkb3dPZmZzZXRYID0gY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsbGVyIGZhYnJpYy5QYXR0ZXJuIG9yIGZhYnJpYy5HcmFkaWVudFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2Zmc2V0Lm9mZnNldFggb2Zmc2V0IGZvciB0ZXh0IHJlbmRlcmluZ1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2Zmc2V0Lm9mZnNldFkgb2Zmc2V0IGZvciB0ZXh0IHJlbmRlcmluZ1xuICAgICAqL1xuICAgIF9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybTogZnVuY3Rpb24oY3R4LCBmaWxsZXIpIHtcbiAgICAgIGlmICghZmlsbGVyIHx8ICFmaWxsZXIudG9MaXZlKSB7XG4gICAgICAgIHJldHVybiB7IG9mZnNldFg6IDAsIG9mZnNldFk6IDAgfTtcbiAgICAgIH1cbiAgICAgIHZhciB0ID0gZmlsbGVyLmdyYWRpZW50VHJhbnNmb3JtIHx8IGZpbGxlci5wYXR0ZXJuVHJhbnNmb3JtO1xuICAgICAgdmFyIG9mZnNldFggPSAtdGhpcy53aWR0aCAvIDIgKyBmaWxsZXIub2Zmc2V0WCB8fCAwLFxuICAgICAgICAgIG9mZnNldFkgPSAtdGhpcy5oZWlnaHQgLyAyICsgZmlsbGVyLm9mZnNldFkgfHwgMDtcblxuICAgICAgaWYgKGZpbGxlci5ncmFkaWVudFVuaXRzID09PSAncGVyY2VudGFnZScpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSh0aGlzLndpZHRoLCAwLCAwLCB0aGlzLmhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCAxLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIH1cbiAgICAgIGlmICh0KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0odFswXSwgdFsxXSwgdFsyXSwgdFszXSwgdFs0XSwgdFs1XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBvZmZzZXRYOiBvZmZzZXRYLCBvZmZzZXRZOiBvZmZzZXRZIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJQYWludEluT3JkZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGZ1bmN0aW9uIHRoYXQgYWN0dWFsbHkgcmVuZGVyIHNvbWV0aGluZyBvbiB0aGUgY29udGV4dC5cbiAgICAgKiBlbXB0eSBoZXJlIHRvIGFsbG93IE9iZWN0cyB0byB3b3JrIG9uIHRlc3RzIHRvIGJlbmNobWFyayBmYWJyaWMgZnVuY3Rpb25hbGl0ZXNcbiAgICAgKiBub3QgcmVsYXRlZCB0byByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oLyogY3R4ICovKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmZpbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0RmlsbFN0eWxlcyhjdHgsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMuZmlsbFJ1bGUgPT09ICdldmVub2RkJykge1xuICAgICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNoYWRvdyAmJiAhdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgaWYgKHRoaXMuc3Ryb2tlVW5pZm9ybSAmJiB0aGlzLmdyb3VwKSB7XG4gICAgICAgIHZhciBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGluZy5zY2FsZVgsIDEgLyBzY2FsaW5nLnNjYWxlWSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnN0cm9rZVVuaWZvcm0pIHtcbiAgICAgICAgY3R4LnNjYWxlKDEgLyB0aGlzLnNjYWxlWCwgMSAvIHRoaXMuc2NhbGVZKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgdGhpcy5fc2V0U3Ryb2tlU3R5bGVzKGN0eCwgdGhpcyk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyeSB0byBwYXRjaCB0aGUgbWlzc2luZyBncmFkaWVudFRyYW5zZm9ybSBvbiBjYW52YXMgZ3JhZGllbnRzLlxuICAgICAqIHRyYW5zZm9ybWluZyBhIGNvbnRleHQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCwgaXMgZ29pbmcgdG8gdHJhbnNmb3JtIHRoZSBzdHJva2UgdG9vLlxuICAgICAqIHdlIHdhbnQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCBidXQgbm90IHRoZSBzdHJva2Ugb3BlcmF0aW9uLCBzbyB3ZSBjcmVhdGVcbiAgICAgKiBhIHRyYW5zZm9ybWVkIGdyYWRpZW50IG9uIGEgcGF0dGVybiBhbmQgdGhlbiB3ZSB1c2UgdGhlIHBhdHRlcm4gaW5zdGVhZCBvZiB0aGUgZ3JhZGllbnQuXG4gICAgICogdGhpcyBtZXRob2QgaGFzIGRyd2FiYWNrczogaXMgc2xvdywgaXMgaW4gbG93IHJlc29sdXRpb24sIG5lZWRzIGEgcGF0Y2ggZm9yIHdoZW4gdGhlIHNpemVcbiAgICAgKiBpcyBsaW1pdGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7ZmFicmljLkdyYWRpZW50fSBmaWxsZXIgYSBmYWJyaWMgZ3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuRm9yVHJhbnNmb3JtZWRHcmFkaWVudDogZnVuY3Rpb24oY3R4LCBmaWxsZXIpIHtcbiAgICAgIHZhciBkaW1zID0gdGhpcy5fbGltaXRDYWNoZVNpemUodGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkpLFxuICAgICAgICAgIHBDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksIHBDdHgsIHJldGluYVNjYWxpbmcgPSB0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCksXG4gICAgICAgICAgd2lkdGggPSBkaW1zLnggLyB0aGlzLnNjYWxlWCAvIHJldGluYVNjYWxpbmcsIGhlaWdodCA9IGRpbXMueSAvIHRoaXMuc2NhbGVZIC8gcmV0aW5hU2NhbGluZztcbiAgICAgIHBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcEN0eCA9IHBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHBDdHguYmVnaW5QYXRoKCk7IHBDdHgubW92ZVRvKDAsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgMCk7IHBDdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcEN0eC5saW5lVG8oMCwgaGVpZ2h0KTsgcEN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHBDdHgudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICBwQ3R4LnNjYWxlKFxuICAgICAgICBkaW1zLnpvb21YIC8gdGhpcy5zY2FsZVggLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICBkaW1zLnpvb21ZIC8gdGhpcy5zY2FsZVkgLyByZXRpbmFTY2FsaW5nXG4gICAgICApO1xuICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0ocEN0eCwgZmlsbGVyKTtcbiAgICAgIHBDdHguZmlsbFN0eWxlID0gZmlsbGVyLnRvTGl2ZShjdHgpO1xuICAgICAgcEN0eC5maWxsKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKC10aGlzLndpZHRoIC8gMiAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIpO1xuICAgICAgY3R4LnNjYWxlKFxuICAgICAgICByZXRpbmFTY2FsaW5nICogdGhpcy5zY2FsZVggLyBkaW1zLnpvb21YLFxuICAgICAgICByZXRpbmFTY2FsaW5nICogdGhpcy5zY2FsZVkgLyBkaW1zLnpvb21ZXG4gICAgICApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gcEN0eC5jcmVhdGVQYXR0ZXJuKHBDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0IGluIHRoZSBzdmdcbiAgICAgKiB1bnRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBwb2ludCBmcm9tIGVsZW1lbnQgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBfZmluZENlbnRlckZyb21FbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMubGVmdCArIHRoaXMud2lkdGggLyAyLCB5OiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0IC8gMiB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgZGVjb21wb3NlIHRoZSB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBhbmQgYXNzaWduIHByb3BlcnRpZXMgdG8gb2JqZWN0LlxuICAgICAqIHVudHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfYXNzaWduVHJhbnNmb3JtTWF0cml4UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UodGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgICB0aGlzLmZsaXBYID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXQoJ3NjYWxlWCcsIG9wdGlvbnMuc2NhbGVYKTtcbiAgICAgICAgdGhpcy5zZXQoJ3NjYWxlWScsIG9wdGlvbnMuc2NhbGVZKTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICAgIHRoaXMuc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgICB0aGlzLnNrZXdZID0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJlbW92ZXMgdGhlIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBhbmQgc2V0IHRvIG9iamVjdCBwcm9wZXJ0aWVzIHRoYXQgZmFicmljanMgY2FuIGhhbmRsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zXG4gICAgICogQHJldHVybiB7dGhpc0FyZ31cbiAgICAgKi9cbiAgICBfcmVtb3ZlVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbihwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucykge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2ZpbmRDZW50ZXJGcm9tRWxlbWVudCgpO1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHRoaXMuX2Fzc2lnblRyYW5zZm9ybU1hdHJpeFByb3BzKCk7XG4gICAgICAgIGNlbnRlciA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KGNlbnRlciwgdGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBudWxsO1xuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2NhbGVYICo9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLnNjYWxlWDtcbiAgICAgICAgdGhpcy5zY2FsZVkgKj0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuc2NhbGVZO1xuICAgICAgICB0aGlzLmNyb3BYID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuY3JvcFg7XG4gICAgICAgIHRoaXMuY3JvcFkgPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5jcm9wWTtcbiAgICAgICAgY2VudGVyLnggKz0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMub2Zmc2V0TGVmdDtcbiAgICAgICAgY2VudGVyLnkgKz0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMub2Zmc2V0VG9wO1xuICAgICAgICB0aGlzLndpZHRoID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGFuIGluc3RhbmNlLCB1c2luZyBhIGNhbGxiYWNrIG1ldGhvZCB3aWxsIHdvcmsgZm9yIGV2ZXJ5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBpcyBpbnZva2VkIHdpdGggYSBjbG9uZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihjYWxsYmFjaywgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9iamVjdEZvcm0gPSB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuZnJvbU9iamVjdCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmZyb21PYmplY3Qob2JqZWN0Rm9ybSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ09iamVjdCcsIG9iamVjdEZvcm0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2Ugb3V0IG9mIGFuIG9iamVjdFxuICAgICAqIG1ha2VzIHVzZSBvZiB0b0NhbnZhc0VsZW1lbnQuXG4gICAgICogT25jZSB0aGlzIG1ldGhvZCB3YXMgYmFzZWQgb24gdG9EYXRhVXJsIGFuZCBsb2FkSW1hZ2UsIHNvIGl0IGFsc28gaGFkIGEgcXVhbGl0eVxuICAgICAqIGFuZCBmb3JtYXQgb3B0aW9uLiB0b0NhbnZhc0VsZW1lbnQgaXMgZmFzdGVyIGFuZCBwcm9kdWNlIG5vIGxvc3Mgb2YgcXVhbGl0eS5cbiAgICAgKiBJZiB5b3UgbmVlZCB0byBnZXQgYSByZWFsIEpwZWcgb3IgUG5nIGZyb20gYW4gb2JqZWN0LCB1c2luZyB0b0RhdGFVUkwgaXMgdGhlIHJpZ2h0IHdheSB0byBkbyBpdC5cbiAgICAgKiB0b0NhbnZhc0VsZW1lbnQgYW5kIHRoZW4gdG9CbG9iIGZyb20gdGhlIG9idGFpbmVkIGNhbnZhcyBpcyBhbHNvIGEgZ29vZCBvcHRpb24uXG4gICAgICogVGhpcyBtZXRob2QgaXMgc3luYyBub3csIGJ1dCBzdGlsbCBzdXBwb3J0IHRoZSBjYWxsYmFjayBiZWNhdXNlIHdlIGRpZCBub3Qgd2FudCB0byBicmVhay5cbiAgICAgKiBXaGVuIGZhYnJpY0pTIDUuMCB3aWxsIGJlIHBsYW5uZWQsIHRoaXMgd2lsbCBwcm9iYWJseSBiZSBjaGFuZ2VkIHRvIG5vdCBoYXZlIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2ssIGludm9rZWQgd2l0aCBhbiBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBmb3IgY2xvbmUgYXMgaW1hZ2UsIHBhc3NlZCB0byB0b0RhdGFVUkxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdIENyb3BwaW5nIHdpZHRoLiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZ10gRW5hYmxlIHJldGluYSBzY2FsaW5nIGZvciBjbG9uZSBpbWFnZS4gSW50cm9kdWNlIGluIDEuNi40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0VHJhbnNmb3JtXSBSZW1vdmUgY3VycmVudCBvYmplY3QgdHJhbnNmb3JtICggbm8gc2NhbGUgLCBubyBhbmdsZSwgbm8gZmxpcCwgbm8gc2tldyApLiBJbnRyb2R1Y2VkIGluIDIuMy40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0U2hhZG93XSBSZW1vdmUgY3VycmVudCBvYmplY3Qgc2hhZG93LiBJbnRyb2R1Y2VkIGluIDIuNC4yXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGNsb25lQXNJbWFnZTogZnVuY3Rpb24oY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYW52YXNFbCA9IHRoaXMudG9DYW52YXNFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuSW1hZ2UoY2FudmFzRWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEhUTUxDYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBSZXR1cm5zIERPTSBlbGVtZW50IDxjYW52YXM+IHdpdGggdGhlIGZhYnJpYy5PYmplY3RcbiAgICAgKi9cbiAgICB0b0NhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgdXRpbHMgPSBmYWJyaWMudXRpbCwgb3JpZ1BhcmFtcyA9IHV0aWxzLnNhdmVPYmplY3RUcmFuc2Zvcm0odGhpcyksXG4gICAgICAgICAgb3JpZ2luYWxHcm91cCA9IHRoaXMuZ3JvdXAsXG4gICAgICAgICAgb3JpZ2luYWxTaGFkb3cgPSB0aGlzLnNoYWRvdywgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgbXVsdGlwbGllciA9IChvcHRpb25zLm11bHRpcGxpZXIgfHwgMSkgKiAob3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nID8gZmFicmljLmRldmljZVBpeGVsUmF0aW8gOiAxKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3VwO1xuICAgICAgaWYgKG9wdGlvbnMud2l0aG91dFRyYW5zZm9ybSkge1xuICAgICAgICB1dGlscy5yZXNldE9iamVjdFRyYW5zZm9ybSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLndpdGhvdXRTaGFkb3cpIHtcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgICAgLy8gc2tpcCBjYW52YXMgem9vbSBhbmQgY2FsY3VsYXRlIHdpdGggc2V0Q29vcmRzIG5vdy5cbiAgICAgICAgICBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCh0cnVlLCB0cnVlKSxcbiAgICAgICAgICBzaGFkb3cgPSB0aGlzLnNoYWRvdywgc2NhbGluZyxcbiAgICAgICAgICBzaGFkb3dPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfSwgc2hhZG93Qmx1cixcbiAgICAgICAgICB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICBpZiAoc2hhZG93KSB7XG4gICAgICAgIHNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1cjtcbiAgICAgICAgaWYgKHNoYWRvdy5ub25TY2FsaW5nKSB7XG4gICAgICAgICAgc2NhbGluZyA9IHsgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc2lkZXIgbm9uIHNjYWxpbmcgc2hhZG93LlxuICAgICAgICBzaGFkb3dPZmZzZXQueCA9IDIgKiBNYXRoLnJvdW5kKGFicyhzaGFkb3cub2Zmc2V0WCkgKyBzaGFkb3dCbHVyKSAqIChhYnMoc2NhbGluZy5zY2FsZVgpKTtcbiAgICAgICAgc2hhZG93T2Zmc2V0LnkgPSAyICogTWF0aC5yb3VuZChhYnMoc2hhZG93Lm9mZnNldFkpICsgc2hhZG93Qmx1cikgKiAoYWJzKHNjYWxpbmcuc2NhbGVZKSk7XG4gICAgICB9XG4gICAgICB3aWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aCArIHNoYWRvd09mZnNldC54O1xuICAgICAgaGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodCArIHNoYWRvd09mZnNldC55O1xuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgd2lkdGgvaGVpZ2h0IGlzIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgaXQgc28uXG4gICAgICBlbC53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XG4gICAgICBlbC5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcbiAgICAgIHZhciBjYW52YXMgPSBuZXcgZmFicmljLlN0YXRpY0NhbnZhcyhlbCwge1xuICAgICAgICBlbmFibGVSZXRpbmFTY2FsaW5nOiBmYWxzZSxcbiAgICAgICAgcmVuZGVyT25BZGRSZW1vdmU6IGZhbHNlLFxuICAgICAgICBza2lwT2Zmc2NyZWVuOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnanBlZycpIHtcbiAgICAgICAgY2FudmFzLmJhY2tncm91bmRDb2xvciA9ICcjZmZmJztcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbihuZXcgZmFicmljLlBvaW50KGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyKSwgJ2NlbnRlcicsICdjZW50ZXInKTtcblxuICAgICAgdmFyIG9yaWdpbmFsQ2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBjYW52YXMuYWRkKHRoaXMpO1xuICAgICAgdmFyIGNhbnZhc0VsID0gY2FudmFzLnRvQ2FudmFzRWxlbWVudChtdWx0aXBsaWVyIHx8IDEsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zaGFkb3cgPSBvcmlnaW5hbFNoYWRvdztcbiAgICAgIHRoaXMuc2V0KCdjYW52YXMnLCBvcmlnaW5hbENhbnZhcyk7XG4gICAgICBpZiAob3JpZ2luYWxHcm91cCkge1xuICAgICAgICB0aGlzLmdyb3VwID0gb3JpZ2luYWxHcm91cDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0KG9yaWdQYXJhbXMpLnNldENvb3JkcygpO1xuICAgICAgLy8gY2FudmFzLmRpc3Bvc2Ugd2lsbCBjYWxsIGltYWdlLmRpc3Bvc2UgdGhhdCB3aWxsIG51bGxpZnkgdGhlIGVsZW1lbnRzXG4gICAgICAvLyBzaW5jZSB0aGlzIGNhbnZhcyBpcyBhIHNpbXBsZSBlbGVtZW50IGZvciB0aGUgcHJvY2Vzcywgd2UgcmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIC8vIHRvIG9iamVjdHMgaW4gdGhpcyB3YXkgaW4gb3JkZXIgdG8gYXZvaWQgb2JqZWN0IHRyYXNoaW5nLlxuICAgICAgY2FudmFzLl9vYmplY3RzID0gW107XG4gICAgICBjYW52YXMuZGlzcG9zZSgpO1xuICAgICAgY2FudmFzID0gbnVsbDtcblxuICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIGRhdGEtdXJsLWxpa2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudG9EYXRhVVJMKHRoaXMudG9DYW52YXNFbGVtZW50KG9wdGlvbnMpLCBvcHRpb25zLmZvcm1hdCB8fCAncG5nJywgb3B0aW9ucy5xdWFsaXR5IHx8IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3BlY2lmaWVkIHR5cGUgaXMgaWRlbnRpY2FsIHRvIHRoZSB0eXBlIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1R5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlIChpcyAxIHVubGVzcyBzdWJjbGFzc2VkKVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgXCJhbmdsZVwiIG9mIGFuIGluc3RhbmNlIHdpdGggY2VudGVyZWQgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgQW5nbGUgdmFsdWUgKGluIGRlZ3JlZXMpXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICB2YXIgc2hvdWxkQ2VudGVyT3JpZ2luID0gKHRoaXMub3JpZ2luWCAhPT0gJ2NlbnRlcicgfHwgdGhpcy5vcmlnaW5ZICE9PSAnY2VudGVyJykgJiYgdGhpcy5jZW50ZXJlZFJvdGF0aW9uO1xuXG4gICAgICBpZiAoc2hvdWxkQ2VudGVyT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX3NldE9yaWdpblRvQ2VudGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KCdhbmdsZScsIGFuZ2xlKTtcblxuICAgICAgaWYgKHNob3VsZENlbnRlck9yaWdpbikge1xuICAgICAgICB0aGlzLl9yZXNldE9yaWdpbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVySDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0SCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVySDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3RIKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgb24gY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJWOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3RWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyVjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3RWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXMgd2FzIGFkZGVkIGxhc3RcbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3QodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3Qgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnRlciByZWxhdGl2ZSB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IHRvIG9wZXJhdGUgdXBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRlcl0gUG9pbnRlciB0byBvcGVyYXRlIHVwb24gKGluc3RlYWQgb2YgZXZlbnQpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIHBvaW50ZXIgKHgsIHkpXG4gICAgICovXG4gICAgZ2V0TG9jYWxQb2ludGVyOiBmdW5jdGlvbihlLCBwb2ludGVyKSB7XG4gICAgICBwb2ludGVyID0gcG9pbnRlciB8fCB0aGlzLmNhbnZhcy5nZXRQb2ludGVyKGUpO1xuICAgICAgdmFyIHBDbGlja2VkID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSksXG4gICAgICAgICAgb2JqZWN0TGVmdFRvcCA9IHRoaXMuX2dldExlZnRUb3BDb29yZHMoKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHBDbGlja2VkID0gZmFicmljLnV0aWwucm90YXRlUG9pbnQoXG4gICAgICAgICAgcENsaWNrZWQsIG9iamVjdExlZnRUb3AsIGRlZ3JlZXNUb1JhZGlhbnMoLXRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBDbGlja2VkLnggLSBvYmplY3RMZWZ0VG9wLngsXG4gICAgICAgIHk6IHBDbGlja2VkLnkgLSBvYmplY3RMZWZ0VG9wLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY2FudmFzIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBmb3Igc3BlY2lmaWMgb2JqZWN0XG4gICAgICogY3VzdG9tIGNvbXBvc2l0aW9uIG9wZXJhdGlvbiBmb3IgdGhlIHBhcnRpY3VsYXIgb2JqZWN0IGNhbiBiZSBzcGVjaWZpZWQgdXNpbmcgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBSZW5kZXJpbmcgY2FudmFzIGNvbnRleHRcbiAgICAgKi9cbiAgICBfc2V0dXBDb21wb3NpdGVPcGVyYXRpb246IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIGlmICh0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbikge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbmNlbCBpbnN0YW5jZSdzIHJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAqIG92ZXJyaWRlIGlmIG5lY2Vzc2FyeSB0byBkaXNwb3NlIGFydGlmYWN0cyBzdWNoIGFzIGBjbGlwUGF0aGBcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZmFicmljLnJ1bm5pbmdBbmltYXRpb25zKSB7XG4gICAgICAgIGZhYnJpYy5ydW5uaW5nQW5pbWF0aW9ucy5jYW5jZWxCeVRhcmdldCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyAmJiBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMoZmFicmljLk9iamVjdCk7XG5cbiAgZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIG51bWJlciBvZiBmcmFjdGlvbiBkaWdpdHMgdG8gdXNlIHdoZW4gc2VyaWFsaXppbmcgb2JqZWN0IHZhbHVlcy5cbiAgICogWW91IGNhbiB1c2UgaXQgdG8gaW5jcmVhc2UvZGVjcmVhc2UgcHJlY2lzaW9uIG9mIHN1Y2ggdmFsdWVzIGxpa2UgbGVmdCwgdG9wLCBzY2FsZVgsIHNjYWxlWSwgZXRjLlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0XG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IDI7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgZW5saXZlbmVkIGZyb20gdGhlIG9iamVjdCBwYXNzZWQgdG8ge0BsaW5rIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3R9XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHN0cmluZ1tdXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0LkVOTElWRU5fUFJPUFMgPSBbJ2NsaXBQYXRoJ107XG5cbiAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGNsYXNzTmFtZSwgb2JqZWN0LCBjYWxsYmFjaywgZXh0cmFQYXJhbSkge1xuICAgIHZhciBrbGFzcyA9IGZhYnJpY1tjbGFzc05hbWVdO1xuICAgIG9iamVjdCA9IGNsb25lKG9iamVjdCwgdHJ1ZSk7XG4gICAgZmFicmljLnV0aWwuZW5saXZlblBhdHRlcm5zKFtvYmplY3QuZmlsbCwgb2JqZWN0LnN0cm9rZV0sIGZ1bmN0aW9uKHBhdHRlcm5zKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm5zWzBdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvYmplY3QuZmlsbCA9IHBhdHRlcm5zWzBdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuc1sxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqZWN0LnN0cm9rZSA9IHBhdHRlcm5zWzFdO1xuICAgICAgfVxuICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdEVubGl2YWJsZXMob2JqZWN0LCBvYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZXh0cmFQYXJhbSA/IG5ldyBrbGFzcyhvYmplY3RbZXh0cmFQYXJhbV0sIG9iamVjdCkgOiBuZXcga2xhc3Mob2JqZWN0KTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuaXF1ZSBpZCB1c2VkIGludGVybmFsbHkgd2hlbiBjcmVhdGluZyBTVkcgZWxlbWVudHNcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIGZhYnJpYy5PYmplY3QuX191aWQgPSAwO1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBvcmlnaW5YT2Zmc2V0ID0ge1xuICAgICAgICBsZWZ0OiAtMC41LFxuICAgICAgICBjZW50ZXI6IDAsXG4gICAgICAgIHJpZ2h0OiAwLjVcbiAgICAgIH0sXG4gICAgICBvcmlnaW5ZT2Zmc2V0ID0ge1xuICAgICAgICB0b3A6IC0wLjUsXG4gICAgICAgIGNlbnRlcjogMCxcbiAgICAgICAgYm90dG9tOiAwLjVcbiAgICAgIH07XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIGEgc2V0IG9mIG9yaWdpbiB0byBhbm90aGVyIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tT3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZyb21PcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvT3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvT3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb0dpdmVuT3JpZ2luOiBmdW5jdGlvbihwb2ludCwgZnJvbU9yaWdpblgsIGZyb21PcmlnaW5ZLCB0b09yaWdpblgsIHRvT3JpZ2luWSkge1xuICAgICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICAgIHkgPSBwb2ludC55LFxuICAgICAgICAgIG9mZnNldFgsIG9mZnNldFksIGRpbTtcblxuICAgICAgaWYgKHR5cGVvZiBmcm9tT3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJvbU9yaWdpblggPSBvcmlnaW5YT2Zmc2V0W2Zyb21PcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmcm9tT3JpZ2luWCAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9PcmlnaW5YID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b09yaWdpblggPSBvcmlnaW5YT2Zmc2V0W3RvT3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9PcmlnaW5YIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0WCA9IHRvT3JpZ2luWCAtIGZyb21PcmlnaW5YO1xuXG4gICAgICBpZiAodHlwZW9mIGZyb21PcmlnaW5ZID09PSAnc3RyaW5nJykge1xuICAgICAgICBmcm9tT3JpZ2luWSA9IG9yaWdpbllPZmZzZXRbZnJvbU9yaWdpblldO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZyb21PcmlnaW5ZIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0b09yaWdpblkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRvT3JpZ2luWSA9IG9yaWdpbllPZmZzZXRbdG9PcmlnaW5ZXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0b09yaWdpblkgLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBvZmZzZXRZID0gdG9PcmlnaW5ZIC0gZnJvbU9yaWdpblk7XG5cbiAgICAgIGlmIChvZmZzZXRYIHx8IG9mZnNldFkpIHtcbiAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICAgIHggPSBwb2ludC54ICsgb2Zmc2V0WCAqIGRpbS54O1xuICAgICAgICB5ID0gcG9pbnQueSArIG9mZnNldFkgKiBkaW0ueTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gb3JpZ2luIHRvIGNlbnRlciBjb29yZGluYXRlcyAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9DZW50ZXJQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAsIHBvaW50LCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIGNlbnRlciB0byBvcmlnaW4gY29vcmRpbmF0ZXMgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIGNlbnRlciBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQ6IGZ1bmN0aW9uKGNlbnRlciwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAsIGNlbnRlciwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVhbCBjZW50ZXIgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVmdFRvcCA9IG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb0NlbnRlclBvaW50KGxlZnRUb3AsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBiYXNlZCBvbiBjZW50ZXIgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICAvLyBnZXRPcmlnaW5Qb2ludDogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGFzIGlmIGl0IGhhcyBhIGRpZmZlcmVudCBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZ2V0UG9pbnRCeU9yaWdpbjogZnVuY3Rpb24ob3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgaW4gbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdG9Mb2NhbFBvaW50OiBmdW5jdGlvbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICBwLCBwMjtcblxuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5YICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3JpZ2luWSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHAgPSBuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgfVxuXG4gICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICBwMiA9IGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAyLCBjZW50ZXIsIC1kZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwMi5zdWJ0cmFjdEVxdWFscyhwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgLy8gdG9HbG9iYWxQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAvLyAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwb2ludCwgdGhpcy5nZXRDZW50ZXJQb2ludCgpLCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKS5hZGRFcXVhbHMobmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKSk7XG4gICAgLy8gfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QgdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgb2JqZWN0J3Mgb3JpZ2luXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvcyBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uQnlPcmlnaW46IGZ1bmN0aW9uKHBvcywgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMudHJhbnNsYXRlVG9DZW50ZXJQb2ludChwb3MsIG9yaWdpblgsIG9yaWdpblkpLFxuICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgICAgdGhpcy5zZXQoJ2xlZnQnLCBwb3NpdGlvbi54KTtcbiAgICAgIHRoaXMuc2V0KCd0b3AnLCBwb3NpdGlvbi55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvIE9uZSBvZiAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXG4gICAgICovXG4gICAgYWRqdXN0UG9zaXRpb246IGZ1bmN0aW9uKHRvKSB7XG4gICAgICB2YXIgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIGh5cG90RnVsbCA9IHRoaXMuZ2V0U2NhbGVkV2lkdGgoKSxcbiAgICAgICAgICB4RnVsbCA9IGZhYnJpYy51dGlsLmNvcyhhbmdsZSkgKiBoeXBvdEZ1bGwsXG4gICAgICAgICAgeUZ1bGwgPSBmYWJyaWMudXRpbC5zaW4oYW5nbGUpICogaHlwb3RGdWxsLFxuICAgICAgICAgIG9mZnNldEZyb20sIG9mZnNldFRvO1xuXG4gICAgICAvL1RPRE86IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29uc2lkZXIgbWl4ZWQgc2l0dWF0aW9uIGxpa2UgdG9wLCBjZW50ZXIuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2Zmc2V0RnJvbSA9IG9yaWdpblhPZmZzZXRbdGhpcy5vcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRGcm9tID0gdGhpcy5vcmlnaW5YIC0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2Zmc2V0VG8gPSBvcmlnaW5YT2Zmc2V0W3RvXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRUbyA9IHRvIC0gMC41O1xuICAgICAgfVxuICAgICAgdGhpcy5sZWZ0ICs9IHhGdWxsICogKG9mZnNldFRvIC0gb2Zmc2V0RnJvbSk7XG4gICAgICB0aGlzLnRvcCArPSB5RnVsbCAqIChvZmZzZXRUbyAtIG9mZnNldEZyb20pO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMub3JpZ2luWCA9IHRvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcmlnaW4vcG9zaXRpb24gb2YgdGhlIG9iamVjdCB0byBpdCdzIGNlbnRlciBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfc2V0T3JpZ2luVG9DZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YID0gdGhpcy5vcmlnaW5YO1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5ZID0gdGhpcy5vcmlnaW5ZO1xuXG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuXG4gICAgICB0aGlzLm9yaWdpblggPSAnY2VudGVyJztcbiAgICAgIHRoaXMub3JpZ2luWSA9ICdjZW50ZXInO1xuXG4gICAgICB0aGlzLmxlZnQgPSBjZW50ZXIueDtcbiAgICAgIHRoaXMudG9wID0gY2VudGVyLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgb3JpZ2luL3Bvc2l0aW9uIG9mIHRoZSBvYmplY3QgdG8gaXQncyBvcmlnaW5hbCBvcmlnaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3Jlc2V0T3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcmlnaW5Qb2ludCA9IHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChcbiAgICAgICAgdGhpcy5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblgsXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSk7XG5cbiAgICAgIHRoaXMub3JpZ2luWCA9IHRoaXMuX29yaWdpbmFsT3JpZ2luWDtcbiAgICAgIHRoaXMub3JpZ2luWSA9IHRoaXMuX29yaWdpbmFsT3JpZ2luWTtcblxuICAgICAgdGhpcy5sZWZ0ID0gb3JpZ2luUG9pbnQueDtcbiAgICAgIHRoaXMudG9wID0gb3JpZ2luUG9pbnQueTtcblxuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YID0gbnVsbDtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExlZnRUb3BDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludCh0aGlzLmdldENlbnRlclBvaW50KCksICdsZWZ0JywgJ3RvcCcpO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBhcnJheUZyb21Db29yZHMoY29vcmRzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnRsLngsIGNvb3Jkcy50bC55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnRyLngsIGNvb3Jkcy50ci55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLmJyLngsIGNvb3Jkcy5ici55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLmJsLngsIGNvb3Jkcy5ibC55KVxuICAgIF07XG4gIH1cblxuICB2YXIgdXRpbCA9IGZhYnJpYy51dGlsLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IHV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIG11bHRpcGx5TWF0cmljZXMgPSB1dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMsXG4gICAgICB0cmFuc2Zvcm1Qb2ludCA9IHV0aWwudHJhbnNmb3JtUG9pbnQ7XG5cbiAgdXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIG9iamVjdCdzIGNvcm5lciBwb3NpdGlvbiBpbiBjYW52YXMgZWxlbWVudCBjb29yZGluYXRlcy5cbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSBkZXBlbmRpbmcgb24gY29udHJvbCBrZXlzIGFuZCBwYWRkaW5nIHRoZSBtYWluIGNvbnRyb2xzLlxuICAgICAqIGVhY2ggcHJvcGVydHkgaXMgYW4gb2JqZWN0IHdpdGggeCwgeSBhbmQgY29ybmVyLlxuICAgICAqIFRoZSBgY29ybmVyYCBwcm9wZXJ0eSBjb250YWlucyBpbiBhIHNpbWlsYXIgbWFubmVyIHRoZSA0IHBvaW50cyBvZiB0aGVcbiAgICAgKiBpbnRlcmFjdGl2ZSBhcmVhIG9mIHRoZSBjb3JuZXIuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGRlcGVuZHMgZnJvbSB0aGUgY29udHJvbHMgcG9zaXRpb25IYW5kbGVyIGFuZCBhcmUgdXNlZFxuICAgICAqIHRvIGRyYXcgYW5kIGxvY2F0ZSBjb250cm9sc1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIG9Db29yZHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBvYmplY3QncyBjb3JuZXIgcG9zaXRpb24gaW4gY2FudmFzIG9iamVjdCBhYnNvbHV0ZSBjb29yZGluYXRlc1xuICAgICAqIHByb3BlcnRpZXMgYXJlIHRsLHRyLGJsLGJyIGFuZCBkZXNjcmliZSB0aGUgZm91ciBtYWluIGNvcm5lci5cbiAgICAgKiBlYWNoIHByb3BlcnR5IGlzIGFuIG9iamVjdCB3aXRoIHgsIHksIGluc3RhbmNlIG9mIEZhYnJpYy5Qb2ludC5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZGVwZW5kcyBmcm9tIHRoaXMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodCwgc2NhbGVYLCBzY2FsZVlcbiAgICAgKiBza2V3WCwgc2tld1ksIGFuZ2xlLCBzdHJva2VXaWR0aCwgdG9wLCBsZWZ0LlxuICAgICAqIFRob3NlIGNvb3JkaW5hdGVzIGFyZSB1c2VmdWwgdG8gdW5kZXJzdGFuZCB3aGVyZSBhbiBvYmplY3QgaXMuIFRoZXkgZ2V0IHVwZGF0ZWRcbiAgICAgKiB3aXRoIG9Db29yZHMgYnV0IHRoZXkgZG8gbm90IG5lZWQgdG8gYmUgdXBkYXRlZCB3aGVuIHpvb20gb3IgcGFubmluZyBjaGFuZ2UuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkIHdpdGggQG1ldGhvZCBzZXRDb29yZHMuXG4gICAgICogWW91IGNhbiBjYWxjdWxhdGUgdGhlbSB3aXRob3V0IHVwZGF0aW5nIHdpdGggQG1ldGhvZCBjYWxjQUNvb3JkcygpO1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFDb29yZHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBvYmplY3QncyBjb3JuZXIgcG9zaXRpb24gaW4gY2FudmFzIGVsZW1lbnQgY29vcmRpbmF0ZXMuXG4gICAgICogaW5jbHVkZXMgcGFkZGluZy4gVXNlZCBvZiBvYmplY3QgZGV0ZWN0aW9uLlxuICAgICAqIHNldCBhbmQgcmVmcmVzaGVkIHdpdGggc2V0Q29vcmRzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxpbmVDb29yZHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBzdG9yYWdlIGZvciBvYmplY3QgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIG93bk1hdHJpeENhY2hlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogc3RvcmFnZSBmb3Igb2JqZWN0IGZ1bGwgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIG1hdHJpeENhY2hlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogY3VzdG9tIGNvbnRyb2xzIGludGVyZmFjZVxuICAgICAqIGNvbnRyb2xzIGFyZSBhZGRlZCBieSBkZWZhdWx0X2NvbnRyb2xzLmpzXG4gICAgICovXG4gICAgY29udHJvbHM6IHsgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBjb3JyZWN0IHNldCBvZiBjb29yZGluYXRlcyBmb3IgaW50ZXJzZWN0aW9uXG4gICAgICogdGhpcyB3aWxsIHJldHVybiBlaXRoZXIgYUNvb3JkcyBvciBsaW5lQ29vcmRzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgd2lsbCByZXR1cm4gYUNvb3JkcyBpZiB0cnVlIG9yIGxpbmVDb29yZHNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHt0bCwgdHIsIGJyLCBibH0gcG9pbnRzXG4gICAgICovXG4gICAgX2dldENvb3JkczogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgaWYgKGNhbGN1bGF0ZSkge1xuICAgICAgICByZXR1cm4gKGFic29sdXRlID8gdGhpcy5jYWxjQUNvb3JkcygpIDogdGhpcy5jYWxjTGluZUNvb3JkcygpKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5hQ29vcmRzIHx8ICF0aGlzLmxpbmVDb29yZHMpIHtcbiAgICAgICAgdGhpcy5zZXRDb29yZHModHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGFic29sdXRlID8gdGhpcy5hQ29vcmRzIDogdGhpcy5saW5lQ29vcmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGNvcnJlY3Qgc2V0IG9mIGNvb3JkaW5hdGVzIGZvciBpbnRlcnNlY3Rpb25cbiAgICAgKiB0aGlzIHdpbGwgcmV0dXJuIGVpdGhlciBhQ29vcmRzIG9yIGxpbmVDb29yZHMuXG4gICAgICogVGhlIGNvb3JkcyBhcmUgcmV0dXJuZWQgaW4gYW4gYXJyYXkuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFt0bCwgdHIsIGJyLCBibF0gb2YgcG9pbnRzXG4gICAgICovXG4gICAgZ2V0Q29vcmRzOiBmdW5jdGlvbihhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICByZXR1cm4gYXJyYXlGcm9tQ29vcmRzKHRoaXMuX2dldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFuIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50VEwgdG9wLWxlZnQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEJSIGJvdHRvbS1yaWdodCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFuIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICovXG4gICAgaW50ZXJzZWN0c1dpdGhSZWN0OiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgICAgaW50ZXJzZWN0aW9uID0gZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlKFxuICAgICAgICAgICAgY29vcmRzLFxuICAgICAgICAgICAgcG9pbnRUTCxcbiAgICAgICAgICAgIHBvaW50QlJcbiAgICAgICAgICApO1xuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbi5zdGF0dXMgPT09ICdJbnRlcnNlY3Rpb24nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBPYmplY3QgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9iamVjdFxuICAgICAqL1xuICAgIGludGVyc2VjdHNXaXRoT2JqZWN0OiBmdW5jdGlvbihvdGhlciwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblBvbHlnb24oXG4gICAgICAgIHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICBvdGhlci5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uc3RhdHVzID09PSAnSW50ZXJzZWN0aW9uJ1xuICAgICAgICB8fCBvdGhlci5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKVxuICAgICAgICB8fCB0aGlzLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG90aGVyLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgT2JqZWN0IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKi9cbiAgICBpc0NvbnRhaW5lZFdpdGhpbk9iamVjdDogZnVuY3Rpb24ob3RoZXIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgICBvdGhlckNvb3JkcyA9IGFic29sdXRlID8gb3RoZXIuYUNvb3JkcyA6IG90aGVyLmxpbmVDb29yZHMsXG4gICAgICAgICAgaSA9IDAsIGxpbmVzID0gb3RoZXIuX2dldEltYWdlTGluZXMob3RoZXJDb29yZHMpO1xuICAgICAgZm9yICg7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgaWYgKCFvdGhlci5jb250YWluc1BvaW50KHBvaW50c1tpXSwgbGluZXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50VEwgdG9wLWxlZnQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEJSIGJvdHRvbS1yaWdodCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqL1xuICAgIGlzQ29udGFpbmVkV2l0aGluUmVjdDogZnVuY3Rpb24ocG9pbnRUTCwgcG9pbnRCUiwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KGFic29sdXRlLCBjYWxjdWxhdGUpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBib3VuZGluZ1JlY3QubGVmdCA+PSBwb2ludFRMLnggJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgKyBib3VuZGluZ1JlY3Qud2lkdGggPD0gcG9pbnRCUi54ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgPj0gcG9pbnRUTC55ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgKyBib3VuZGluZ1JlY3QuaGVpZ2h0IDw9IHBvaW50QlIueVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFBvaW50IHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xpbmVzXSBvYmplY3QgcmV0dXJuZWQgZnJvbSBAbWV0aG9kIF9nZXRJbWFnZUxpbmVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBsaW5lcywgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2dldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgICBsaW5lcyA9IGxpbmVzIHx8IHRoaXMuX2dldEltYWdlTGluZXMoY29vcmRzKSxcbiAgICAgICAgICB4UG9pbnRzID0gdGhpcy5fZmluZENyb3NzUG9pbnRzKHBvaW50LCBsaW5lcyk7XG4gICAgICAvLyBpZiB4UG9pbnRzIGlzIG9kZCB0aGVuIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICByZXR1cm4gKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGNhbnZhcyB3aXRoIGN1cnJlbnQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiB0aGUgY2hlY2sgaXMgZG9uZSBzdG9wcGluZyBhdCBmaXJzdCBwb2ludCB0aGF0IGFwcGVhcnMgb24gc2NyZWVuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5hQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgb3IgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gY2FudmFzXG4gICAgICovXG4gICAgaXNPblNjcmVlbjogZnVuY3Rpb24oY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludFRMID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLnRsLCBwb2ludEJSID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLmJyO1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0Q29vcmRzKHRydWUsIGNhbGN1bGF0ZSk7XG4gICAgICAvLyBpZiBzb21lIHBvaW50IGlzIG9uIHNjcmVlbiwgdGhlIG9iamVjdCBpcyBvbiBzY3JlZW4uXG4gICAgICBpZiAocG9pbnRzLnNvbWUoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPD0gcG9pbnRCUi54ICYmIHBvaW50LnggPj0gcG9pbnRUTC54ICYmXG4gICAgICAgIHBvaW50LnkgPD0gcG9pbnRCUi55ICYmIHBvaW50LnkgPj0gcG9pbnRUTC55O1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBubyBwb2ludHMgb24gc2NyZWVuLCBjaGVjayBpbnRlcnNlY3Rpb24gd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlc1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1dpdGhSZWN0KHBvaW50VEwsIHBvaW50QlIsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbnNDZW50ZXJPZkNhbnZhcyhwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG9iamVjdCBjb250YWlucyB0aGUgbWlkcG9pbnQgYmV0d2VlbiBjYW52YXMgZXh0cmVtaXRpZXNcbiAgICAgKiBEb2VzIG5vdCBtYWtlIHNlbnNlIG91dHNpZGUgdGhlIGNvbnRleHQgb2YgaXNPblNjcmVlbiBhbmQgaXNQYXJ0aWFsbHlPblNjcmVlblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGYWJyaWMuUG9pbnR9IHBvaW50VEwgVG9wIExlZnQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5Qb2ludH0gcG9pbnRCUiBUb3AgUmlnaHQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbGN1bGF0ZSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBwb2ludFxuICAgICAqL1xuICAgIF9jb250YWluc0NlbnRlck9mQ2FudmFzOiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpIHtcbiAgICAgIC8vIHdvcnN0IGNhc2Ugc2NlbmFyaW8gdGhlIG9iamVjdCBpcyBzbyBiaWcgdGhhdCBjb250YWlucyB0aGUgc2NyZWVuXG4gICAgICB2YXIgY2VudGVyUG9pbnQgPSB7IHg6IChwb2ludFRMLnggKyBwb2ludEJSLngpIC8gMiwgeTogKHBvaW50VEwueSArIHBvaW50QlIueSkgLyAyIH07XG4gICAgICBpZiAodGhpcy5jb250YWluc1BvaW50KGNlbnRlclBvaW50LCBudWxsLCB0cnVlLCBjYWxjdWxhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluIHRoZSBjYW52YXMgd2l0aCBjdXJyZW50IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gY2FudmFzXG4gICAgICovXG4gICAgaXNQYXJ0aWFsbHlPblNjcmVlbjogZnVuY3Rpb24oY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludFRMID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLnRsLCBwb2ludEJSID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLmJyO1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1dpdGhSZWN0KHBvaW50VEwsIHBvaW50QlIsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgYWxsUG9pbnRzQXJlT3V0c2lkZSA9IHRoaXMuZ2V0Q29vcmRzKHRydWUsIGNhbGN1bGF0ZSkuZXZlcnkoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChwb2ludC54ID49IHBvaW50QlIueCB8fCBwb2ludC54IDw9IHBvaW50VEwueCkgJiZcbiAgICAgICAgKHBvaW50LnkgPj0gcG9pbnRCUi55IHx8IHBvaW50LnkgPD0gcG9pbnRUTC55KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFsbFBvaW50c0FyZU91dHNpZGUgJiYgdGhpcy5fY29udGFpbnNDZW50ZXJPZkNhbnZhcyhwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBvYmplY3QgZWRnZXMgaW4gaXQsIGdpdmVuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9Db29yZHMgQ29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBjb3JuZXJzXG4gICAgICovXG4gICAgX2dldEltYWdlTGluZXM6IGZ1bmN0aW9uKG9Db29yZHMpIHtcblxuICAgICAgdmFyIGxpbmVzID0ge1xuICAgICAgICB0b3BsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy50bCxcbiAgICAgICAgICBkOiBvQ29vcmRzLnRyXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0bGluZToge1xuICAgICAgICAgIG86IG9Db29yZHMudHIsXG4gICAgICAgICAgZDogb0Nvb3Jkcy5iclxuICAgICAgICB9LFxuICAgICAgICBib3R0b21saW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy5icixcbiAgICAgICAgICBkOiBvQ29vcmRzLmJsXG4gICAgICAgIH0sXG4gICAgICAgIGxlZnRsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy5ibCxcbiAgICAgICAgICBkOiBvQ29vcmRzLnRsXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIC8vIGRlYnVnZ2luZ1xuICAgICAgLy8gaWYgKHRoaXMuY2FudmFzLmNvbnRleHRUb3ApIHtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLmQueCwgbGluZXMuYm90dG9tbGluZS5kLnksIDIsIDIpO1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmJvdHRvbWxpbmUuby54LCBsaW5lcy5ib3R0b21saW5lLm8ueSwgMiwgMik7XG4gICAgICAvL1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLmQueCwgbGluZXMubGVmdGxpbmUuZC55LCAyLCAyKTtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5vLngsIGxpbmVzLmxlZnRsaW5lLm8ueSwgMiwgMik7XG4gICAgICAvL1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuZC54LCBsaW5lcy50b3BsaW5lLmQueSwgMiwgMik7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5vLngsIGxpbmVzLnRvcGxpbmUuby55LCAyLCAyKTtcbiAgICAgIC8vXG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLmQueCwgbGluZXMucmlnaHRsaW5lLmQueSwgMiwgMik7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLm8ueCwgbGluZXMucmlnaHRsaW5lLm8ueSwgMiwgMik7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgaG93IG1hbnkgY3Jvc3MgcG9pbnRzIGFyZSBiZXR3ZWVuIHRoZSA0IG9iamVjdCBlZGdlc1xuICAgICAqIGFuZCB0aGUgaG9yaXpvbnRhbCBsaW5lIGRldGVybWluZWQgYnkgYSBwb2ludCBvbiBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaW5lcyBDb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGJlaW5nIGV2YWx1YXRlZFxuICAgICAqL1xuICAgIC8vIHJlbW92ZSB5aSwgbm90IHVzZWQgYnV0IGxlZnQgY29kZSBoZXJlIGp1c3QgaW4gY2FzZS5cbiAgICBfZmluZENyb3NzUG9pbnRzOiBmdW5jdGlvbihwb2ludCwgbGluZXMpIHtcbiAgICAgIHZhciBiMSwgYjIsIGExLCBhMiwgeGksIC8vIHlpLFxuICAgICAgICAgIHhjb3VudCA9IDAsXG4gICAgICAgICAgaUxpbmU7XG5cbiAgICAgIGZvciAodmFyIGxpbmVLZXkgaW4gbGluZXMpIHtcbiAgICAgICAgaUxpbmUgPSBsaW5lc1tsaW5lS2V5XTtcbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDE6IGxpbmUgYmVsb3cgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55IDwgcG9pbnQueSkgJiYgKGlMaW5lLmQueSA8IHBvaW50LnkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDI6IGxpbmUgYWJvdmUgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55ID49IHBvaW50LnkpICYmIChpTGluZS5kLnkgPj0gcG9pbnQueSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMzogdmVydGljYWwgbGluZSBjYXNlXG4gICAgICAgIGlmICgoaUxpbmUuby54ID09PSBpTGluZS5kLngpICYmIChpTGluZS5vLnggPj0gcG9pbnQueCkpIHtcbiAgICAgICAgICB4aSA9IGlMaW5lLm8ueDtcbiAgICAgICAgICAvLyB5aSA9IHBvaW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYjEgPSAwO1xuICAgICAgICAgIGIyID0gKGlMaW5lLmQueSAtIGlMaW5lLm8ueSkgLyAoaUxpbmUuZC54IC0gaUxpbmUuby54KTtcbiAgICAgICAgICBhMSA9IHBvaW50LnkgLSBiMSAqIHBvaW50Lng7XG4gICAgICAgICAgYTIgPSBpTGluZS5vLnkgLSBiMiAqIGlMaW5lLm8ueDtcblxuICAgICAgICAgIHhpID0gLShhMSAtIGEyKSAvIChiMSAtIGIyKTtcbiAgICAgICAgICAvLyB5aSA9IGExICsgYjEgKiB4aTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb250IGNvdW50IHhpIDwgcG9pbnQueCBjYXNlc1xuICAgICAgICBpZiAoeGkgPj0gcG9pbnQueCkge1xuICAgICAgICAgIHhjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiA0OiBzcGVjaWZpYyBmb3Igc3F1YXJlIGltYWdlc1xuICAgICAgICBpZiAoeGNvdW50ID09PSAyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB4Y291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2Ygb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpXG4gICAgICogdGhlIGJveCBpcyBpbnRlbmRlZCBhcyBhbGlnbmVkIHRvIGF4aXMgb2YgY2FudmFzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3JkcyAvIC5hQ29vcmRzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpO1xuICAgICAgcmV0dXJuIHV0aWwubWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyhjb29yZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdpZHRoIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveCBjb3VudGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBiZWZvcmUgMi4wIGl0IHdhcyBuYW1lZCBnZXRXaWR0aCgpO1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gd2lkdGggdmFsdWVcbiAgICAgKi9cbiAgICBnZXRTY2FsZWRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZWlnaHQgb2YgYW4gb2JqZWN0IGJvdW5kaW5nIGJveCBjb3VudGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBiZWZvcmUgMi4wIGl0IHdhcyBuYW1lZCBnZXRIZWlnaHQoKTtcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGhlaWdodCB2YWx1ZVxuICAgICAqL1xuICAgIGdldFNjYWxlZEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgc3VyZSB0aGUgc2NhbGUgaXMgdmFsaWQgYW5kIG1vZGlmaWVzIGl0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9jb25zdHJhaW5TY2FsZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPCB0aGlzLm1pblNjYWxlTGltaXQpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgIHJldHVybiAtdGhpcy5taW5TY2FsZUxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pblNjYWxlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwLjAwMDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbiBvYmplY3QgKGVxdWFsbHkgYnkgeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgU2NhbGUgZmFjdG9yXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldCgnc2NhbGVYJywgdmFsdWUpO1xuICAgICAgdGhpcy5fc2V0KCdzY2FsZVknLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCB0byBhIGdpdmVuIHdpZHRoLCB3aXRoIHJlc3BlY3QgdG8gYm91bmRpbmcgYm94IChzY2FsaW5nIGJ5IHgveSBlcXVhbGx5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBOZXcgd2lkdGggdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFic29sdXRlIGlnbm9yZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGVUb1dpZHRoOiBmdW5jdGlvbih2YWx1ZSwgYWJzb2x1dGUpIHtcbiAgICAgIC8vIGFkanVzdCB0byBib3VuZGluZyByZWN0IGZhY3RvciBzbyB0aGF0IHJvdGF0ZWQgc2hhcGVzIHdvdWxkIGZpdCBhcyB3ZWxsXG4gICAgICB2YXIgYm91bmRpbmdSZWN0RmFjdG9yID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUpLndpZHRoIC8gdGhpcy5nZXRTY2FsZWRXaWR0aCgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUgLyB0aGlzLndpZHRoIC8gYm91bmRpbmdSZWN0RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCB0byBhIGdpdmVuIGhlaWdodCwgd2l0aCByZXNwZWN0IHRvIGJvdW5kaW5nIGJveCAoc2NhbGluZyBieSB4L3kgZXF1YWxseSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgTmV3IGhlaWdodCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgaWdub3JlIHZpZXdwb3J0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZVRvSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgYWJzb2x1dGUpIHtcbiAgICAgIC8vIGFkanVzdCB0byBib3VuZGluZyByZWN0IGZhY3RvciBzbyB0aGF0IHJvdGF0ZWQgc2hhcGVzIHdvdWxkIGZpdCBhcyB3ZWxsXG4gICAgICB2YXIgYm91bmRpbmdSZWN0RmFjdG9yID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUpLmhlaWdodCAvIHRoaXMuZ2V0U2NhbGVkSGVpZ2h0KCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSAvIHRoaXMuaGVpZ2h0IC8gYm91bmRpbmdSZWN0RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgY2FsY0xpbmVDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBwYWRkaW5nID0gdGhpcy5wYWRkaW5nLCBhbmdsZSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksXG4gICAgICAgICAgY29zID0gdXRpbC5jb3MoYW5nbGUpLCBzaW4gPSB1dGlsLnNpbihhbmdsZSksXG4gICAgICAgICAgY29zUCA9IGNvcyAqIHBhZGRpbmcsIHNpblAgPSBzaW4gKiBwYWRkaW5nLCBjb3NQU2luUCA9IGNvc1AgKyBzaW5QLFxuICAgICAgICAgIGNvc1BNaW51c1NpblAgPSBjb3NQIC0gc2luUCwgYUNvb3JkcyA9IHRoaXMuY2FsY0FDb29yZHMoKTtcblxuICAgICAgdmFyIGxpbmVDb29yZHMgPSB7XG4gICAgICAgIHRsOiB0cmFuc2Zvcm1Qb2ludChhQ29vcmRzLnRsLCB2cHQpLFxuICAgICAgICB0cjogdHJhbnNmb3JtUG9pbnQoYUNvb3Jkcy50ciwgdnB0KSxcbiAgICAgICAgYmw6IHRyYW5zZm9ybVBvaW50KGFDb29yZHMuYmwsIHZwdCksXG4gICAgICAgIGJyOiB0cmFuc2Zvcm1Qb2ludChhQ29vcmRzLmJyLCB2cHQpLFxuICAgICAgfTtcblxuICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgbGluZUNvb3Jkcy50bC54IC09IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMudGwueSAtPSBjb3NQU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy50ci54ICs9IGNvc1BTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLnRyLnkgLT0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy5ibC54IC09IGNvc1BTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLmJsLnkgKz0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy5ici54ICs9IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMuYnIueSArPSBjb3NQU2luUDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmVDb29yZHM7XG4gICAgfSxcblxuICAgIGNhbGNPQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByb3RhdGVNYXRyaXggPSB0aGlzLl9jYWxjUm90YXRlTWF0cml4KCksXG4gICAgICAgICAgdHJhbnNsYXRlTWF0cml4ID0gdGhpcy5fY2FsY1RyYW5zbGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBzdGFydE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModnB0LCB0cmFuc2xhdGVNYXRyaXgpLFxuICAgICAgICAgIGZpbmFsTWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhzdGFydE1hdHJpeCwgcm90YXRlTWF0cml4KSxcbiAgICAgICAgICBmaW5hbE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMoZmluYWxNYXRyaXgsIFsxIC8gdnB0WzBdLCAwLCAwLCAxIC8gdnB0WzNdLCAwLCAwXSksXG4gICAgICAgICAgZGltID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBjb29yZHMgPSB7fTtcbiAgICAgIHRoaXMuZm9yRWFjaENvbnRyb2woZnVuY3Rpb24oY29udHJvbCwga2V5LCBmYWJyaWNPYmplY3QpIHtcbiAgICAgICAgY29vcmRzW2tleV0gPSBjb250cm9sLnBvc2l0aW9uSGFuZGxlcihkaW0sIGZpbmFsTWF0cml4LCBmYWJyaWNPYmplY3QpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRlYnVnIGNvZGVcbiAgICAgIC8vIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIC8vIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIGNhbnZhcy5jb250ZXh0VG9wLmNsZWFyUmVjdCgwLCAwLCA3MDAsIDcwMCk7XG4gICAgICAvLyAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxTdHlsZSA9ICdncmVlbic7XG4gICAgICAvLyAgIE9iamVjdC5rZXlzKGNvb3JkcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIC8vICAgICB2YXIgY29udHJvbCA9IGNvb3Jkc1trZXldO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGNvbnRyb2wueCwgY29udHJvbC55LCAzLCAzKTtcbiAgICAgIC8vICAgfSk7XG4gICAgICAvLyB9LCA1MCk7XG4gICAgICByZXR1cm4gY29vcmRzO1xuICAgIH0sXG5cbiAgICBjYWxjQUNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcm90YXRlTWF0cml4ID0gdGhpcy5fY2FsY1JvdGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICBmaW5hbE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModHJhbnNsYXRlTWF0cml4LCByb3RhdGVNYXRyaXgpLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIHcgPSBkaW0ueCAvIDIsIGggPSBkaW0ueSAvIDI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBjb3JuZXJzXG4gICAgICAgIHRsOiB0cmFuc2Zvcm1Qb2ludCh7IHg6IC13LCB5OiAtaCB9LCBmaW5hbE1hdHJpeCksXG4gICAgICAgIHRyOiB0cmFuc2Zvcm1Qb2ludCh7IHg6IHcsIHk6IC1oIH0sIGZpbmFsTWF0cml4KSxcbiAgICAgICAgYmw6IHRyYW5zZm9ybVBvaW50KHsgeDogLXcsIHk6IGggfSwgZmluYWxNYXRyaXgpLFxuICAgICAgICBicjogdHJhbnNmb3JtUG9pbnQoeyB4OiB3LCB5OiBoIH0sIGZpbmFsTWF0cml4KVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb3JuZXIgYW5kIGNvbnRyb2xzIHBvc2l0aW9uIGNvb3JkaW5hdGVzIGJhc2VkIG9uIGN1cnJlbnQgYW5nbGUsIHdpZHRoIGFuZCBoZWlnaHQsIGxlZnQgYW5kIHRvcC5cbiAgICAgKiBvQ29vcmRzIGFyZSB1c2VkIHRvIGZpbmQgdGhlIGNvcm5lcnNcbiAgICAgKiBhQ29vcmRzIGFyZSB1c2VkIHRvIHF1aWNrbHkgZmluZCBhbiBvYmplY3Qgb24gdGhlIGNhbnZhc1xuICAgICAqIGxpbmVDb29yZHMgYXJlIHVzZWQgdG8gcXVpY2tseSBmaW5kIG9iamVjdCBkdXJpbmcgcG9pbnRlciBldmVudHMuXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmFicmljanMvZmFicmljLmpzL3dpa2kvV2hlbi10by1jYWxsLXNldENvb3Jkc30gYW5kIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1nb3RjaGFzfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENvcm5lcnNdIHNraXAgY2FsY3VsYXRpb24gb2Ygb0Nvb3Jkcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvb3JkczogZnVuY3Rpb24oc2tpcENvcm5lcnMpIHtcbiAgICAgIHRoaXMuYUNvb3JkcyA9IHRoaXMuY2FsY0FDb29yZHMoKTtcbiAgICAgIC8vIGluIGNhc2Ugd2UgYXJlIGluIGEgZ3JvdXAsIGZvciBob3cgdGhlIGlubmVyIGdyb3VwIHRhcmdldCBjaGVjayB3b3JrcyxcbiAgICAgIC8vIGxpbmVDb29yZHMgYXJlIGV4YWN0bHkgYUNvb3Jkcy4gU2luY2UgdGhlIHZwdCBnZXRzIGFic29yYmVkIGJ5IHRoZSBub3JtYWxpemVkIHBvaW50ZXIuXG4gICAgICB0aGlzLmxpbmVDb29yZHMgPSB0aGlzLmdyb3VwID8gdGhpcy5hQ29vcmRzIDogdGhpcy5jYWxjTGluZUNvb3JkcygpO1xuICAgICAgaWYgKHNraXBDb3JuZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGNvb3JkaW5hdGVzIG9mIHRoZSBkcmFnZ2FibGUgYm94ZXMgaW4gdGhlIGNvcm5lcnMgdXNlZCB0byBzY2FsZS9yb3RhdGUgdGhlIGltYWdlXG4gICAgICB0aGlzLm9Db29yZHMgPSB0aGlzLmNhbGNPQ29vcmRzKCk7XG4gICAgICB0aGlzLl9zZXRDb3JuZXJDb29yZHMgJiYgdGhpcy5fc2V0Q29ybmVyQ29vcmRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHJvdGF0aW9uIG1hdHJpeCBvZiBhbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcm90YXRpb24gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgX2NhbGNSb3RhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHV0aWwuY2FsY1JvdGF0ZU1hdHJpeCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggZm9yIGFuIG9iamVjdCB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcm90YXRpb24gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgX2NhbGNUcmFuc2xhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHJldHVybiBbMSwgMCwgMCwgMSwgY2VudGVyLngsIGNlbnRlci55XTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtTWF0cml4S2V5OiBmdW5jdGlvbihza2lwR3JvdXApIHtcbiAgICAgIHZhciBzZXAgPSAnXycsIHByZWZpeCA9ICcnO1xuICAgICAgaWYgKCFza2lwR3JvdXAgJiYgdGhpcy5ncm91cCkge1xuICAgICAgICBwcmVmaXggPSB0aGlzLmdyb3VwLnRyYW5zZm9ybU1hdHJpeEtleShza2lwR3JvdXApICsgc2VwO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBwcmVmaXggKyB0aGlzLnRvcCArIHNlcCArIHRoaXMubGVmdCArIHNlcCArIHRoaXMuc2NhbGVYICsgc2VwICsgdGhpcy5zY2FsZVkgK1xuICAgICAgICBzZXAgKyB0aGlzLnNrZXdYICsgc2VwICsgdGhpcy5za2V3WSArIHNlcCArIHRoaXMuYW5nbGUgKyBzZXAgKyB0aGlzLm9yaWdpblggKyBzZXAgKyB0aGlzLm9yaWdpblkgK1xuICAgICAgICBzZXAgKyB0aGlzLndpZHRoICsgc2VwICsgdGhpcy5oZWlnaHQgKyBzZXAgKyB0aGlzLnN0cm9rZVdpZHRoICsgdGhpcy5mbGlwWCArIHRoaXMuZmxpcFk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0cmFuc2Zvcm0gbWF0cml4IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbnMgZnJvbSB0aGVcbiAgICAgKiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBHcm91cF0gcmV0dXJuIHRyYW5zZm9ybSBtYXRyaXggZm9yIG9iamVjdCBub3QgY291bnRpbmcgcGFyZW50IHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIFRoZXJlIGFyZSBzb21lIHNpdHVhdGlvbiBpbiB3aGljaCB0aGlzIGlzIHVzZWZ1bCB0byBhdm9pZCB0aGUgZmFrZSByb3RhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gdHJhbnNmb3JtIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHNraXBHcm91cCkge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuY2FsY093bk1hdHJpeCgpO1xuICAgICAgaWYgKHNraXBHcm91cCB8fCAhdGhpcy5ncm91cCkge1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHRoaXMudHJhbnNmb3JtTWF0cml4S2V5KHNraXBHcm91cCksIGNhY2hlID0gdGhpcy5tYXRyaXhDYWNoZSB8fCAodGhpcy5tYXRyaXhDYWNoZSA9IHt9KTtcbiAgICAgIGlmIChjYWNoZS5rZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICBtYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHRoaXMuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeChmYWxzZSksIG1hdHJpeCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IG1hdHJpeDtcbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0cmFuc2Zvcm0gbWF0cml4IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbnMgZnJvbSB0aGVcbiAgICAgKiBvYmplY3QncyBwcm9wZXJ0aWVzLCB0aGlzIG1hdHJpeCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBncm91cCB0cmFuc2Zvcm1hdGlvblxuICAgICAqIEByZXR1cm4ge0FycmF5fSB0cmFuc2Zvcm0gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY2FsY093bk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXhLZXkodHJ1ZSksIGNhY2hlID0gdGhpcy5vd25NYXRyaXhDYWNoZSB8fCAodGhpcy5vd25NYXRyaXhDYWNoZSA9IHt9KTtcbiAgICAgIGlmIChjYWNoZS5rZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgdE1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgYW5nbGU6IHRoaXMuYW5nbGUsXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiB0TWF0cml4WzRdLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogdE1hdHJpeFs1XSxcbiAgICAgICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgICAgICBzY2FsZVk6IHRoaXMuc2NhbGVZLFxuICAgICAgICAgICAgc2tld1g6IHRoaXMuc2tld1gsXG4gICAgICAgICAgICBza2V3WTogdGhpcy5za2V3WSxcbiAgICAgICAgICAgIGZsaXBYOiB0aGlzLmZsaXBYLFxuICAgICAgICAgICAgZmxpcFk6IHRoaXMuZmxpcFksXG4gICAgICAgICAgfTtcbiAgICAgIGNhY2hlLmtleSA9IGtleTtcbiAgICAgIGNhY2hlLnZhbHVlID0gdXRpbC5jb21wb3NlTWF0cml4KG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC54IHdpZHRoIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnkgaGVpZ2h0IGRpbWVuc2lvblxuICAgICAqL1xuICAgIF9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGggPSB0aGlzLmhlaWdodCArIHN0cm9rZVdpZHRoO1xuICAgICAgcmV0dXJuIHsgeDogdywgeTogaCB9O1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgYm91bmRpbmcgYm94IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllcyBzY2FsZSwgc2tldy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tld1gsIGEgdmFsdWUgdG8gb3ZlcnJpZGUgY3VycmVudCBza2V3WFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WSwgYSB2YWx1ZSB0byBvdmVycmlkZSBjdXJyZW50IHNrZXdZXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC54IHdpZHRoIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnkgaGVpZ2h0IGRpbWVuc2lvblxuICAgICAqL1xuICAgIF9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnM6IGZ1bmN0aW9uKHNrZXdYLCBza2V3WSkge1xuICAgICAgaWYgKHR5cGVvZiBza2V3WCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBza2V3WSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2tld1kgPSB0aGlzLnNrZXdZO1xuICAgICAgfVxuICAgICAgdmFyIGRpbWVuc2lvbnMsIGRpbVgsIGRpbVksXG4gICAgICAgICAgbm9Ta2V3ID0gc2tld1ggPT09IDAgJiYgc2tld1kgPT09IDA7XG5cbiAgICAgIGlmICh0aGlzLnN0cm9rZVVuaWZvcm0pIHtcbiAgICAgICAgZGltWCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGRpbVkgPSB0aGlzLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkaW1lbnNpb25zID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICAgIGRpbVggPSBkaW1lbnNpb25zLng7XG4gICAgICAgIGRpbVkgPSBkaW1lbnNpb25zLnk7XG4gICAgICB9XG4gICAgICBpZiAobm9Ta2V3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZURpbWVuc2lvbnMoZGltWCAqIHRoaXMuc2NhbGVYLCBkaW1ZICogdGhpcy5zY2FsZVkpO1xuICAgICAgfVxuICAgICAgdmFyIGJib3ggPSB1dGlsLnNpemVBZnRlclRyYW5zZm9ybShkaW1YLCBkaW1ZLCB7XG4gICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIHNrZXdYOiBza2V3WCxcbiAgICAgICAgc2tld1k6IHNrZXdZLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVEaW1lbnNpb25zKGJib3gueCwgYmJveC55KTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGJvdW5kaW5nIGJveCBkaW1lbnNpb25zIGZyb20gaXRzIHByb3BlcnRpZXMgc2NhbGUsIHNrZXcuXG4gICAgICogQHBhcmFtIE51bWJlciB3aWR0aCB3aWR0aCBvZiB0aGUgYmJveFxuICAgICAqIEBwYXJhbSBOdW1iZXIgaGVpZ2h0IGhlaWdodCBvZiB0aGUgYmJveFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCBmaW5hbGl6ZWQgd2lkdGggZGltZW5zaW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueSBmaW5hbGl6ZWQgaGVpZ2h0IGRpbWVuc2lvblxuICAgICAqL1xuICAgIF9maW5hbGl6ZURpbWVuc2lvbnM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cm9rZVVuaWZvcm0gP1xuICAgICAgICB7IHg6IHdpZHRoICsgdGhpcy5zdHJva2VXaWR0aCwgeTogaGVpZ2h0ICsgdGhpcy5zdHJva2VXaWR0aCB9XG4gICAgICAgIDpcbiAgICAgICAgeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH07XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBkaW1lbnNpb25zIGZvciBjb250cm9scyBib3gsIGluY2x1ZGluZyBwYWRkaW5nIGFuZCBjYW52YXMgem9vbS5cbiAgICAgKiBhbmQgYWN0aXZlIHNlbGVjdGlvblxuICAgICAqIHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkgIHtcbiAgICAgIHZhciB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCksXG4gICAgICAgICAgcCA9IHRyYW5zZm9ybVBvaW50KGRpbSwgdnB0LCB0cnVlKTtcbiAgICAgIHJldHVybiBwLnNjYWxhckFkZCgyICogdGhpcy5wYWRkaW5nKTtcbiAgICB9LFxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2VuZFRvQmFjazogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNlbmRUb0JhY2suY2FsbCh0aGlzLmdyb3VwLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnNlbmRUb0JhY2sodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmJyaW5nVG9Gcm9udC5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMuYnJpbmdUb0Zyb250KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kQmFja3dhcmRzLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnNlbmRCYWNrd2FyZHModGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB1cCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBpbiBmcm9udCBvZiBuZXh0IHVwcGVyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBicmluZ0ZvcndhcmQ6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5icmluZ0ZvcndhcmQuY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMuYnJpbmdGb3J3YXJkKHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gc3BlY2lmaWVkIGxldmVsIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IE5ldyBwb3NpdGlvbiBvZiBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgaWYgKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC50eXBlICE9PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUubW92ZVRvLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMubW92ZVRvKHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGdldFN2Z0NvbG9yU3RyaW5nKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnOiBub25lOyAnO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS50b0xpdmUpIHtcbiAgICAgIHJldHVybiBwcm9wICsgJzogdXJsKCNTVkdJRF8nICsgdmFsdWUuaWQgKyAnKTsgJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSxcbiAgICAgICAgICBzdHIgPSBwcm9wICsgJzogJyArIGNvbG9yLnRvUmdiKCkgKyAnOyAnLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgLy9jaGFuZ2UgdGhlIGNvbG9yIGluIHJnYiArIG9wYWNpdHlcbiAgICAgICAgc3RyICs9IHByb3AgKyAnLW9wYWNpdHk6ICcgKyBvcGFjaXR5LnRvU3RyaW5nKCkgKyAnOyAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwU2hhZG93IGEgYm9vbGVhbiB0byBza2lwIHNoYWRvdyBmaWx0ZXIgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oc2tpcFNoYWRvdykge1xuXG4gICAgICB2YXIgZmlsbFJ1bGUgPSB0aGlzLmZpbGxSdWxlID8gdGhpcy5maWxsUnVsZSA6ICdub256ZXJvJyxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGggPyB0aGlzLnN0cm9rZVdpZHRoIDogJzAnLFxuICAgICAgICAgIHN0cm9rZURhc2hBcnJheSA9IHRoaXMuc3Ryb2tlRGFzaEFycmF5ID8gdGhpcy5zdHJva2VEYXNoQXJyYXkuam9pbignICcpIDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZURhc2hPZmZzZXQgPSB0aGlzLnN0cm9rZURhc2hPZmZzZXQgPyB0aGlzLnN0cm9rZURhc2hPZmZzZXQgOiAnMCcsXG4gICAgICAgICAgc3Ryb2tlTGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcCA/IHRoaXMuc3Ryb2tlTGluZUNhcCA6ICdidXR0JyxcbiAgICAgICAgICBzdHJva2VMaW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW4gPyB0aGlzLnN0cm9rZUxpbmVKb2luIDogJ21pdGVyJyxcbiAgICAgICAgICBzdHJva2VNaXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0ID8gdGhpcy5zdHJva2VNaXRlckxpbWl0IDogJzQnLFxuICAgICAgICAgIG9wYWNpdHkgPSB0eXBlb2YgdGhpcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyA/IHRoaXMub3BhY2l0eSA6ICcxJyxcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gdGhpcy52aXNpYmxlID8gJycgOiAnIHZpc2liaWxpdHk6IGhpZGRlbjsnLFxuICAgICAgICAgIGZpbHRlciA9IHNraXBTaGFkb3cgPyAnJyA6IHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICAgZmlsbCA9IGdldFN2Z0NvbG9yU3RyaW5nKCdmaWxsJywgdGhpcy5maWxsKSxcbiAgICAgICAgICBzdHJva2UgPSBnZXRTdmdDb2xvclN0cmluZygnc3Ryb2tlJywgdGhpcy5zdHJva2UpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgICdzdHJva2Utd2lkdGg6ICcsIHN0cm9rZVdpZHRoLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheTogJywgc3Ryb2tlRGFzaEFycmF5LCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXA6ICcsIHN0cm9rZUxpbmVDYXAsICc7ICcsXG4gICAgICAgICdzdHJva2UtZGFzaG9mZnNldDogJywgc3Ryb2tlRGFzaE9mZnNldCwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lam9pbjogJywgc3Ryb2tlTGluZUpvaW4sICc7ICcsXG4gICAgICAgICdzdHJva2UtbWl0ZXJsaW1pdDogJywgc3Ryb2tlTWl0ZXJMaW1pdCwgJzsgJyxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgJ2ZpbGwtcnVsZTogJywgZmlsbFJ1bGUsICc7ICcsXG4gICAgICAgICdvcGFjaXR5OiAnLCBvcGFjaXR5LCAnOycsXG4gICAgICAgIGZpbHRlcixcbiAgICAgICAgdmlzaWJpbGl0eVxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIHRoZSBvYmplY3QgZnJvbSB3aGljaCB0byByZXRyaWV2ZSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB1c2VXaGl0ZVNwYWNlIGEgYm9vbGVhbiB0byBpbmNsdWRlIGFuIGFkZGl0aW9uYWwgYXR0cmlidXRlIGluIHRoZSBzdHlsZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3BhblN0eWxlczogZnVuY3Rpb24oc3R5bGUsIHVzZVdoaXRlU3BhY2UpIHtcbiAgICAgIHZhciB0ZXJtID0gJzsgJztcbiAgICAgIHZhciBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseSA/XG4gICAgICAgICdmb250LWZhbWlseTogJyArICgoKHN0eWxlLmZvbnRGYW1pbHkuaW5kZXhPZignXFwnJykgPT09IC0xICYmIHN0eWxlLmZvbnRGYW1pbHkuaW5kZXhPZignXCInKSA9PT0gLTEpID9cbiAgICAgICAgICAnXFwnJyArIHN0eWxlLmZvbnRGYW1pbHkgICsgJ1xcJycgOiBzdHlsZS5mb250RmFtaWx5KSkgKyB0ZXJtIDogJyc7XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSBzdHlsZS5zdHJva2VXaWR0aCA/ICdzdHJva2Utd2lkdGg6ICcgKyBzdHlsZS5zdHJva2VXaWR0aCArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250RmFtaWx5ID0gZm9udEZhbWlseSxcbiAgICAgICAgICBmb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplID8gJ2ZvbnQtc2l6ZTogJyArIHN0eWxlLmZvbnRTaXplICsgJ3B4JyArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250U3R5bGUgPSBzdHlsZS5mb250U3R5bGUgPyAnZm9udC1zdHlsZTogJyArIHN0eWxlLmZvbnRTdHlsZSArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250V2VpZ2h0ID0gc3R5bGUuZm9udFdlaWdodCA/ICdmb250LXdlaWdodDogJyArIHN0eWxlLmZvbnRXZWlnaHQgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZmlsbCA9IHN0eWxlLmZpbGwgPyBnZXRTdmdDb2xvclN0cmluZygnZmlsbCcsIHN0eWxlLmZpbGwpIDogJycsXG4gICAgICAgICAgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlID8gZ2V0U3ZnQ29sb3JTdHJpbmcoJ3N0cm9rZScsIHN0eWxlLnN0cm9rZSkgOiAnJyxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0U3ZnVGV4dERlY29yYXRpb24oc3R5bGUpLFxuICAgICAgICAgIGRlbHRhWSA9IHN0eWxlLmRlbHRhWSA/ICdiYXNlbGluZS1zaGlmdDogJyArICgtc3R5bGUuZGVsdGFZKSArICc7ICcgOiAnJztcbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbikge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9ICd0ZXh0LWRlY29yYXRpb246ICcgKyB0ZXh0RGVjb3JhdGlvbiArIHRlcm07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBmb250U3R5bGUsXG4gICAgICAgIGZvbnRXZWlnaHQsXG4gICAgICAgIHRleHREZWNvcmF0aW9uLFxuICAgICAgICBmaWxsLFxuICAgICAgICBkZWx0YVksXG4gICAgICAgIHVzZVdoaXRlU3BhY2UgPyAnd2hpdGUtc3BhY2U6IHByZTsgJyA6ICcnXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRleHQtZGVjb3JhdGlvbiBwcm9wZXJ0eSBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSB0aGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUZXh0RGVjb3JhdGlvbjogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHJldHVybiBbJ292ZXJsaW5lJywgJ3VuZGVybGluZScsICdsaW5lLXRocm91Z2gnXS5maWx0ZXIoZnVuY3Rpb24oZGVjb3JhdGlvbikge1xuICAgICAgICByZXR1cm4gc3R5bGVbZGVjb3JhdGlvbi5yZXBsYWNlKCctJywgJycpXTtcbiAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaWx0ZXIgZm9yIHN2ZyBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYWRvdyA/ICdmaWx0ZXI6IHVybCgjU1ZHSURfJyArIHRoaXMuc2hhZG93LmlkICsgJyk7JyA6ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlkIGF0dHJpYnV0ZSBmb3Igc3ZnIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdDb21tb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXMuaWQgPyAnaWQ9XCInICsgdGhpcy5pZCArICdcIiAnIDogJycsXG4gICAgICAgIHRoaXMuY2xpcFBhdGggPyAnY2xpcC1wYXRoPVwidXJsKCMnICsgdGhpcy5jbGlwUGF0aC5jbGlwUGF0aElkICsgJylcIiAnIDogJycsXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRyYW5zZm9ybS1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZSB0aGUgZnVsbCB0cmFuc2Zvcm0gb3IgdGhlIHNpbmdsZSBvYmplY3Qgb25lLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUcmFuc2Zvcm06IGZ1bmN0aW9uKGZ1bGwsIGFkZGl0aW9uYWxUcmFuc2Zvcm0pIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBmdWxsID8gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkgOiB0aGlzLmNhbGNPd25NYXRyaXgoKSxcbiAgICAgICAgICBzdmdUcmFuc2Zvcm0gPSAndHJhbnNmb3JtPVwiJyArIGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKHRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gc3ZnVHJhbnNmb3JtICtcbiAgICAgICAgKGFkZGl0aW9uYWxUcmFuc2Zvcm0gfHwgJycpICsgJ1wiICc7XG4gICAgfSxcblxuICAgIF9zZXRTVkdCZzogZnVuY3Rpb24odGV4dEJnUmVjdHMpIHtcbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgICAgdGV4dEJnUmVjdHMucHVzaChcbiAgICAgICAgICAnXFx0XFx0PHJlY3QgJyxcbiAgICAgICAgICB0aGlzLl9nZXRGaWxsQXR0cmlidXRlcyh0aGlzLmJhY2tncm91bmRDb2xvciksXG4gICAgICAgICAgJyB4PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKC10aGlzLndpZHRoIC8gMiwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiIHk9XCInLFxuICAgICAgICAgIHRvRml4ZWQoLXRoaXMuaGVpZ2h0IC8gMiwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiIHdpZHRoPVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMud2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiBoZWlnaHQ9XCInLFxuICAgICAgICAgIHRvRml4ZWQodGhpcy5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIj48L3JlY3Q+XFxuJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCh0aGlzLl90b1NWRyhyZXZpdmVyKSwgeyByZXZpdmVyOiByZXZpdmVyIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyBjbGlwUGF0aCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0NsaXBQYXRoU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICByZXR1cm4gJ1xcdCcgKyB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAodGhpcy5fdG9TVkcocmV2aXZlciksIHsgcmV2aXZlcjogcmV2aXZlciB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwOiBmdW5jdGlvbihvYmplY3RNYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHJldml2ZXIgPSBvcHRpb25zLnJldml2ZXIsXG4gICAgICAgICAgYWRkaXRpb25hbFRyYW5zZm9ybSA9IG9wdGlvbnMuYWRkaXRpb25hbFRyYW5zZm9ybSB8fCAnJyxcbiAgICAgICAgICBjb21tb25QaWVjZXMgPSBbXG4gICAgICAgICAgICB0aGlzLmdldFN2Z1RyYW5zZm9ybSh0cnVlLCBhZGRpdGlvbmFsVHJhbnNmb3JtKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0U3ZnQ29tbW9ucygpLFxuICAgICAgICAgIF0uam9pbignJyksXG4gICAgICAgICAgLy8gaW5zZXJ0IGNvbW1vbnMgaW4gdGhlIG1hcmt1cCwgc3R5bGUgYW5kIHN2Z0NvbW1vbnNcbiAgICAgICAgICBpbmRleCA9IG9iamVjdE1hcmt1cC5pbmRleE9mKCdDT01NT05fUEFSVFMnKTtcbiAgICAgIG9iamVjdE1hcmt1cFtpbmRleF0gPSBjb21tb25QaWVjZXM7XG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIob2JqZWN0TWFya3VwLmpvaW4oJycpKSA6IG9iamVjdE1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZVNWR01hcmt1cDogZnVuY3Rpb24ob2JqZWN0TWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBub1N0eWxlID0gb3B0aW9ucy5ub1N0eWxlLFxuICAgICAgICAgIHJldml2ZXIgPSBvcHRpb25zLnJldml2ZXIsXG4gICAgICAgICAgc3R5bGVJbmZvID0gbm9TdHlsZSA/ICcnIDogJ3N0eWxlPVwiJyArIHRoaXMuZ2V0U3ZnU3R5bGVzKCkgKyAnXCIgJyxcbiAgICAgICAgICBzaGFkb3dJbmZvID0gb3B0aW9ucy53aXRoU2hhZG93ID8gJ3N0eWxlPVwiJyArIHRoaXMuZ2V0U3ZnRmlsdGVyKCkgKyAnXCIgJyA6ICcnLFxuICAgICAgICAgIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aCxcbiAgICAgICAgICB2ZWN0b3JFZmZlY3QgPSB0aGlzLnN0cm9rZVVuaWZvcm0gPyAndmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiICcgOiAnJyxcbiAgICAgICAgICBhYnNvbHV0ZUNsaXBQYXRoID0gY2xpcFBhdGggJiYgY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkLFxuICAgICAgICAgIHN0cm9rZSA9IHRoaXMuc3Ryb2tlLCBmaWxsID0gdGhpcy5maWxsLCBzaGFkb3cgPSB0aGlzLnNoYWRvdyxcbiAgICAgICAgICBjb21tb25QaWVjZXMsIG1hcmt1cCA9IFtdLCBjbGlwUGF0aE1hcmt1cCxcbiAgICAgICAgICAvLyBpbnNlcnQgY29tbW9ucyBpbiB0aGUgbWFya3VwLCBzdHlsZSBhbmQgc3ZnQ29tbW9uc1xuICAgICAgICAgIGluZGV4ID0gb2JqZWN0TWFya3VwLmluZGV4T2YoJ0NPTU1PTl9QQVJUUycpLFxuICAgICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSBvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm07XG4gICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgY2xpcFBhdGguY2xpcFBhdGhJZCA9ICdDTElQUEFUSF8nICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgICBjbGlwUGF0aE1hcmt1cCA9ICc8Y2xpcFBhdGggaWQ9XCInICsgY2xpcFBhdGguY2xpcFBhdGhJZCArICdcIiA+XFxuJyArXG4gICAgICAgICAgY2xpcFBhdGgudG9DbGlwUGF0aFNWRyhyZXZpdmVyKSArXG4gICAgICAgICAgJzwvY2xpcFBhdGg+XFxuJztcbiAgICAgIH1cbiAgICAgIGlmIChhYnNvbHV0ZUNsaXBQYXRoKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8ZyAnLCBzaGFkb3dJbmZvLCB0aGlzLmdldFN2Z0NvbW1vbnMoKSwgJyA+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8ZyAnLFxuICAgICAgICB0aGlzLmdldFN2Z1RyYW5zZm9ybShmYWxzZSksXG4gICAgICAgICFhYnNvbHV0ZUNsaXBQYXRoID8gc2hhZG93SW5mbyArIHRoaXMuZ2V0U3ZnQ29tbW9ucygpIDogJycsXG4gICAgICAgICcgPlxcbidcbiAgICAgICk7XG4gICAgICBjb21tb25QaWVjZXMgPSBbXG4gICAgICAgIHN0eWxlSW5mbyxcbiAgICAgICAgdmVjdG9yRWZmZWN0LFxuICAgICAgICBub1N0eWxlID8gJycgOiB0aGlzLmFkZFBhaW50T3JkZXIoKSwgJyAnLFxuICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID8gJ3RyYW5zZm9ybT1cIicgKyBhZGRpdGlvbmFsVHJhbnNmb3JtICsgJ1wiICcgOiAnJyxcbiAgICAgIF0uam9pbignJyk7XG4gICAgICBvYmplY3RNYXJrdXBbaW5kZXhdID0gY29tbW9uUGllY2VzO1xuICAgICAgaWYgKGZpbGwgJiYgZmlsbC50b0xpdmUpIHtcbiAgICAgICAgbWFya3VwLnB1c2goZmlsbC50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3Ryb2tlICYmIHN0cm9rZS50b0xpdmUpIHtcbiAgICAgICAgbWFya3VwLnB1c2goc3Ryb2tlLnRvU1ZHKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFkb3cpIHtcbiAgICAgICAgbWFya3VwLnB1c2goc2hhZG93LnRvU1ZHKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaChjbGlwUGF0aE1hcmt1cCk7XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaChvYmplY3RNYXJrdXAuam9pbignJykpO1xuICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIGFic29sdXRlQ2xpcFBhdGggJiYgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBhZGRQYWludE9yZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJyA/ICcgcGFpbnQtb3JkZXI9XCInICsgdGhpcy5wYWludEZpcnN0ICsgJ1wiICcgOiAnJztcbiAgICB9XG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIG9yaWdpbmFsU2V0ID0gJ3N0YXRlUHJvcGVydGllcyc7XG5cbiAgLypcbiAgICBEZXBlbmRzIG9uIGBzdGF0ZVByb3BlcnRpZXNgXG4gICovXG4gIGZ1bmN0aW9uIHNhdmVQcm9wcyhvcmlnaW4sIGRlc3RpbmF0aW9uLCBwcm9wcykge1xuICAgIHZhciB0bXBPYmogPSB7IH0sIGRlZXAgPSB0cnVlO1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdG1wT2JqW3Byb3BdID0gb3JpZ2luW3Byb3BdO1xuICAgIH0pO1xuXG4gICAgZXh0ZW5kKG9yaWdpbltkZXN0aW5hdGlvbl0sIHRtcE9iaiwgZGVlcCk7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNFcXVhbChvcmlnVmFsdWUsIGN1cnJlbnRWYWx1ZSwgZmlyc3RQYXNzKSB7XG4gICAgaWYgKG9yaWdWYWx1ZSA9PT0gY3VycmVudFZhbHVlKSB7XG4gICAgICAvLyBpZiB0aGUgb2JqZWN0cyBhcmUgaWRlbnRpY2FsLCByZXR1cm5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9yaWdWYWx1ZSkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpIHx8IG9yaWdWYWx1ZS5sZW5ndGggIT09IGN1cnJlbnRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9yaWdWYWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIV9pc0VxdWFsKG9yaWdWYWx1ZVtpXSwgY3VycmVudFZhbHVlW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9yaWdWYWx1ZSAmJiB0eXBlb2Ygb3JpZ1ZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcmlnVmFsdWUpLCBrZXk7XG4gICAgICBpZiAoIWN1cnJlbnRWYWx1ZSB8fFxuICAgICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgKCFmaXJzdFBhc3MgJiYga2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKGN1cnJlbnRWYWx1ZSkubGVuZ3RoKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIC8vIHNpbmNlIGNsaXBQYXRoIGlzIGluIHRoZSBzdGF0ZWZ1bGwgY2FjaGUgbGlzdCBhbmQgdGhlIGNsaXBQYXRoIG9iamVjdHNcbiAgICAgICAgLy8gd291bGQgYmUgaXRlcmF0ZWQgYXMgYW4gb2JqZWN0LCB0aGlzIHdvdWxkIGxlYWQgdG8gcG9zc2libGUgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGNvbXBhcmUgdGhvc2UuXG4gICAgICAgIGlmIChrZXkgPT09ICdjYW52YXMnIHx8IGtleSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX2lzRXF1YWwob3JpZ1ZhbHVlW2tleV0sIGN1cnJlbnRWYWx1ZVtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3Qgc3RhdGUgKG9uZSBvZiBpdHMgc3RhdGUgcHJvcGVydGllcykgd2FzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5U2V0XSBvcHRpb25hbCBuYW1lIGZvciB0aGUgc2V0IG9mIHByb3BlcnR5IHdlIHdhbnQgdG8gc2F2ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgaW5zdGFuY2UnIHN0YXRlIGhhcyBjaGFuZ2VkIHNpbmNlIGB7QGxpbmsgZmFicmljLk9iamVjdCNzYXZlU3RhdGV9YCB3YXMgY2FsbGVkXG4gICAgICovXG4gICAgaGFzU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbihwcm9wZXJ0eVNldCkge1xuICAgICAgcHJvcGVydHlTZXQgPSBwcm9wZXJ0eVNldCB8fCBvcmlnaW5hbFNldDtcbiAgICAgIHZhciBkYXNoZWRQcm9wZXJ0eVNldCA9ICdfJyArIHByb3BlcnR5U2V0O1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXNbZGFzaGVkUHJvcGVydHlTZXRdKS5sZW5ndGggPCB0aGlzW3Byb3BlcnR5U2V0XS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gIV9pc0VxdWFsKHRoaXNbZGFzaGVkUHJvcGVydHlTZXRdLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgc3RhdGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGBzdGF0ZVByb3BlcnRpZXNgIGFycmF5IHRvIGluY2x1ZGUgd2hlbiBzYXZpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgc2F2ZVN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcGVydHlTZXQgPSBvcHRpb25zICYmIG9wdGlvbnMucHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQsXG4gICAgICAgICAgZGVzdGluYXRpb24gPSAnXycgKyBwcm9wZXJ0eVNldDtcbiAgICAgIGlmICghdGhpc1tkZXN0aW5hdGlvbl0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXBTdGF0ZShvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNhdmVQcm9wcyh0aGlzLCBkZXN0aW5hdGlvbiwgdGhpc1twcm9wZXJ0eVNldF0pO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdGF0ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgc2F2ZVByb3BzKHRoaXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zLnN0YXRlUHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXBzIHN0YXRlIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggYWRkaXRpb25hbCBgc3RhdGVQcm9wZXJ0aWVzYCBhcnJheSB0byBpbmNsdWRlIHdoZW4gc2F2aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldHVwU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcbiAgICAgIHZhciBwcm9wZXJ0eVNldCA9IG9wdGlvbnMucHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQ7XG4gICAgICBvcHRpb25zLnByb3BlcnR5U2V0ID0gcHJvcGVydHlTZXQ7XG4gICAgICB0aGlzWydfJyArIHByb3BlcnR5U2V0XSA9IHsgfTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucztcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoaWNoIGNvcm5lciBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBUaGUgcG9pbnRlciBpbmRpY2F0aW5nIHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufSBjb3JuZXIgY29kZSAodGwsIHRyLCBibCwgYnIsIGV0Yy4pLCBvciBmYWxzZSBpZiBub3RoaW5nIGlzIGZvdW5kXG4gICAgICovXG4gICAgX2ZpbmRUYXJnZXRDb3JuZXI6IGZ1bmN0aW9uKHBvaW50ZXIsIGZvclRvdWNoKSB7XG4gICAgICAvLyBvYmplY3RzIGluIGdyb3VwLCBhbnlraW5kLCBhcmUgbm90IHNlbGYgbW9kaWZpY2FibGUsXG4gICAgICAvLyBtdXN0IG5vdCByZXR1cm4gYW4gaG92ZXJlZCBjb3JuZXIuXG4gICAgICBpZiAoIXRoaXMuaGFzQ29udHJvbHMgfHwgdGhpcy5ncm91cCB8fCAoIXRoaXMuY2FudmFzIHx8IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4ID0gcG9pbnRlci54LFxuICAgICAgICAgIGV5ID0gcG9pbnRlci55LFxuICAgICAgICAgIHhQb2ludHMsXG4gICAgICAgICAgbGluZXMsIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9Db29yZHMpLFxuICAgICAgICAgIGogPSBrZXlzLmxlbmd0aCAtIDEsIGk7XG4gICAgICB0aGlzLl9fY29ybmVyID0gMDtcblxuICAgICAgLy8gY3ljbGUgaW4gcmV2ZXJzZSBvcmRlciBzbyB3ZSBwaWNrIGZpcnN0IHRoZSBvbmUgb24gdG9wXG4gICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgaSA9IGtleXNbal07XG4gICAgICAgIGlmICghdGhpcy5pc0NvbnRyb2xWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IHRoaXMuX2dldEltYWdlTGluZXMoZm9yVG91Y2ggPyB0aGlzLm9Db29yZHNbaV0udG91Y2hDb3JuZXIgOiB0aGlzLm9Db29yZHNbaV0uY29ybmVyKTtcbiAgICAgICAgLy8gLy8gZGVidWdnaW5nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5kLngsIGxpbmVzLmJvdHRvbWxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLm8ueCwgbGluZXMuYm90dG9tbGluZS5vLnksIDIsIDIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLmQueCwgbGluZXMubGVmdGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5vLngsIGxpbmVzLmxlZnRsaW5lLm8ueSwgMiwgMik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5kLngsIGxpbmVzLnRvcGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLm8ueCwgbGluZXMudG9wbGluZS5vLnksIDIsIDIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5kLngsIGxpbmVzLnJpZ2h0bGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5vLngsIGxpbmVzLnJpZ2h0bGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIHhQb2ludHMgPSB0aGlzLl9maW5kQ3Jvc3NQb2ludHMoeyB4OiBleCwgeTogZXkgfSwgbGluZXMpO1xuICAgICAgICBpZiAoeFBvaW50cyAhPT0gMCAmJiB4UG9pbnRzICUgMiA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuX19jb3JuZXIgPSBpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxzIGEgZnVuY3Rpb24gZm9yIGVhY2ggY29udHJvbC4gVGhlIGZ1bmN0aW9uIGdldHMgY2FsbGVkLFxuICAgICAqIHdpdGggdGhlIGNvbnRyb2wsIHRoZSBvYmplY3QgdGhhdCBpcyBjYWxsaW5nIHRoZSBpdGVyYXRvciBhbmQgdGhlIGNvbnRyb2wncyBrZXlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgdGhlIGNvbnRyb2xzIG92ZXJcbiAgICAgKi9cbiAgICBmb3JFYWNoQ29udHJvbDogZnVuY3Rpb24oZm4pIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jb250cm9scykge1xuICAgICAgICBmbih0aGlzLmNvbnRyb2xzW2ldLCBpLCB0aGlzKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBkcmFnZ2FibGUgYm94ZXMgaW4gdGhlIGNvcm5lcnMgb2ZcbiAgICAgKiB0aGUgaW1hZ2UgdXNlZCB0byBzY2FsZS9yb3RhdGUgaXQuXG4gICAgICogbm90ZTogaWYgd2Ugd291bGQgc3dpdGNoIHRvIFJPVU5EIGNvcm5lciBhcmVhLCBhbGwgb2YgdGhpcyB3b3VsZCBkaXNhcHBlYXIuXG4gICAgICogZXZlcnl0aGluZyB3b3VsZCByZXNvbHZlIHRvIGEgc2luZ2xlIHBvaW50IGFuZCBhIHB5dGhhZ29yZWFuIHRoZW9yZW0gZm9yIHRoZSBkaXN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldENvcm5lckNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5vQ29vcmRzO1xuXG4gICAgICBmb3IgKHZhciBjb250cm9sIGluIGNvb3Jkcykge1xuICAgICAgICB2YXIgY29udHJvbE9iamVjdCA9IHRoaXMuY29udHJvbHNbY29udHJvbF07XG4gICAgICAgIGNvb3Jkc1tjb250cm9sXS5jb3JuZXIgPSBjb250cm9sT2JqZWN0LmNhbGNDb3JuZXJDb29yZHMoXG4gICAgICAgICAgdGhpcy5hbmdsZSwgdGhpcy5jb3JuZXJTaXplLCBjb29yZHNbY29udHJvbF0ueCwgY29vcmRzW2NvbnRyb2xdLnksIGZhbHNlKTtcbiAgICAgICAgY29vcmRzW2NvbnRyb2xdLnRvdWNoQ29ybmVyID0gY29udHJvbE9iamVjdC5jYWxjQ29ybmVyQ29vcmRzKFxuICAgICAgICAgIHRoaXMuYW5nbGUsIHRoaXMudG91Y2hDb3JuZXJTaXplLCBjb29yZHNbY29udHJvbF0ueCwgY29vcmRzW2NvbnRyb2xdLnksIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGNvbG9yZWQgbGF5ZXIgYmVoaW5kIHRoZSBvYmplY3QsIGluc2lkZSBpdHMgc2VsZWN0aW9uIGJvcmRlcnMuXG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIHNlbGVjdGlvbkJhY2tncm91bmRDb2xvclxuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGNvbnRleHQgaXMgdHJhbnNmb3JtZWRcbiAgICAgKiBoYXMgY2hlY2tzIHRvIGJlIHNraXBwZWQgd2hlbiB0aGUgb2JqZWN0IGlzIG9uIGEgc3RhdGljQ2FudmFzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgfHxcbiAgICAgICAgKHRoaXMuY2FudmFzICYmICF0aGlzLmNhbnZhcy5pbnRlcmFjdGl2ZSkgfHxcbiAgICAgICAgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHZwdCA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgY3R4LnNjYWxlKDEgLyB2cHRbMF0sIDEgLyB2cHRbM10pO1xuICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgtd2gueCAvIDIsIC13aC55IC8gMiwgd2gueCwgd2gueSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94LlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0XG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIGJvcmRlckNvbG9yXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0JvcmRlcnM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICB2YXIgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gdGhpcy5ib3JkZXJTY2FsZUZhY3RvcixcbiAgICAgICAgICB3aWR0aCA9IHdoLnggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB3aC55ICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgaGFzQ29udHJvbHMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyA6IHRoaXMuaGFzQ29udHJvbHMsXG4gICAgICAgICAgc2hvdWxkU3Ryb2tlID0gZmFsc2U7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmJvcmRlckNvbG9yIHx8IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHN0eWxlT3ZlcnJpZGUuYm9yZGVyRGFzaEFycmF5IHx8IHRoaXMuYm9yZGVyRGFzaEFycmF5KTtcblxuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBpZiAoaGFzQ29udHJvbHMpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmZvckVhY2hDb250cm9sKGZ1bmN0aW9uKGNvbnRyb2wsIGtleSwgZmFicmljT2JqZWN0KSB7XG4gICAgICAgICAgLy8gaW4gdGhpcyBtb21lbnQsIHRoZSBjdHggaXMgY2VudGVyZWQgb24gdGhlIG9iamVjdC5cbiAgICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBhYm92ZSBmdW5jdGlvbiBhcmUgdGhlIHNpemUgb2YgdGhlIGJib3guXG4gICAgICAgICAgaWYgKGNvbnRyb2wud2l0aENvbm5lY3Rpb24gJiYgY29udHJvbC5nZXRWaXNpYmlsaXR5KGZhYnJpY09iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgbW92ZW1lbnQgZm9yIGVhY2ggY29udHJvbFxuICAgICAgICAgICAgc2hvdWxkU3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29udHJvbC54ICogd2lkdGgsIGNvbnRyb2wueSAqIGhlaWdodCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICBjb250cm9sLnggKiB3aWR0aCArIGNvbnRyb2wub2Zmc2V0WCxcbiAgICAgICAgICAgICAgY29udHJvbC55ICogaGVpZ2h0ICsgY29udHJvbC5vZmZzZXRZXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzaG91bGRTdHJva2UpIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYm9yZGVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3ggd2hlbiBpdCBpcyBpbnNpZGUgYSBncm91cC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb2JqZWN0IHJlcHJlc2VudGluZyBjdXJyZW50IG9iamVjdCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdCb3JkZXJzSW5Hcm91cDogZnVuY3Rpb24oY3R4LCBvcHRpb25zLCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHZhciBiYm94ID0gZmFicmljLnV0aWwuc2l6ZUFmdGVyVHJhbnNmb3JtKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBvcHRpb25zKSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgc3Ryb2tlVW5pZm9ybSA9IHRoaXMuc3Ryb2tlVW5pZm9ybSxcbiAgICAgICAgICBib3JkZXJTY2FsZUZhY3RvciA9IHRoaXMuYm9yZGVyU2NhbGVGYWN0b3IsXG4gICAgICAgICAgd2lkdGggPVxuICAgICAgICAgICAgYmJveC54ICsgc3Ryb2tlV2lkdGggKiAoc3Ryb2tlVW5pZm9ybSA/IHRoaXMuY2FudmFzLmdldFpvb20oKSA6IG9wdGlvbnMuc2NhbGVYKSArIGJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIGhlaWdodCA9XG4gICAgICAgICAgICBiYm94LnkgKyBzdHJva2VXaWR0aCAqIChzdHJva2VVbmlmb3JtID8gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpIDogb3B0aW9ucy5zY2FsZVkpICsgYm9yZGVyU2NhbGVGYWN0b3I7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCBzdHlsZU92ZXJyaWRlLmJvcmRlckRhc2hBcnJheSB8fCB0aGlzLmJvcmRlckRhc2hBcnJheSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmJvcmRlckNvbG9yIHx8IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgICAgLXdpZHRoIC8gMixcbiAgICAgICAgLWhlaWdodCAvIDIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgICk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgY29ybmVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3guXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogY29ybmVyU2l6ZSwgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgcmV0aW5hU2NhbGluZyA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKSwgbWF0cml4LCBwO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybShyZXRpbmFTY2FsaW5nLCAwLCAwLCByZXRpbmFTY2FsaW5nLCAwLCAwKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lckNvbG9yIHx8IHRoaXMuY29ybmVyQ29sb3I7XG4gICAgICBpZiAoIXRoaXMudHJhbnNwYXJlbnRDb3JuZXJzKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgdGhpcy5jb3JuZXJTdHJva2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgc3R5bGVPdmVycmlkZS5jb3JuZXJEYXNoQXJyYXkgfHwgdGhpcy5jb3JuZXJEYXNoQXJyYXkpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIC8vIGZhYnJpY0pTIGRvZXMgbm90IHJlYWxseSBzdXBwb3J0IGRyYXdpbmcgY29udHJvbHMgaW5zaWRlIGdyb3VwcyxcbiAgICAgICAgLy8gdGhpcyBwaWVjZSBvZiBjb2RlIGhlcmUgaGVscHMgaGF2aW5nIGF0IGxlYXN0IHRoZSBjb250cm9sIGluIHBsYWNlcy5cbiAgICAgICAgLy8gSWYgYW4gYXBwbGljYXRpb24gbmVlZHMgdG8gc2hvdyBzb21lIG9iamVjdHMgYXMgc2VsZWN0ZWQgYmVjYXVzZSBvZiBzb21lIFVJIHN0YXRlXG4gICAgICAgIC8vIGNhbiBzdGlsbCBjYWxsIE9iamVjdC5fcmVuZGVyQ29udHJvbHMoKSBvbiBhbnkgb2JqZWN0IHRoZXkgZGVzaXJlLCBpbmRlcGVuZGVudGx5IG9mIGdyb3Vwcy5cbiAgICAgICAgLy8gdXNpbmcgbm8gcGFkZGluZywgY2lyY3VsYXIgY29udHJvbHMgYW5kIGhpZGluZyB0aGUgcm90YXRpbmcgY3Vyc29yIGlzIGhpZ2x5IHN1Z2dlc3RlZCxcbiAgICAgICAgbWF0cml4ID0gdGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvckVhY2hDb250cm9sKGZ1bmN0aW9uKGNvbnRyb2wsIGtleSwgZmFicmljT2JqZWN0KSB7XG4gICAgICAgIHAgPSBmYWJyaWNPYmplY3Qub0Nvb3Jkc1trZXldO1xuICAgICAgICBpZiAoY29udHJvbC5nZXRWaXNpYmlsaXR5KGZhYnJpY09iamVjdCwga2V5KSkge1xuICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCBtYXRyaXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sLnJlbmRlcihjdHgsIHAueCwgcC55LCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBjb250cm9sIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbEtleSBUaGUga2V5IG9mIHRoZSBjb250cm9sLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd0bCcsICd0cicsICdicicsICdibCcsICdtbCcsICdtdCcsICdtcicsICdtYicsICdtdHInLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY29udHJvbCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc0NvbnRyb2xWaXNpYmxlOiBmdW5jdGlvbihjb250cm9sS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250cm9sc1tjb250cm9sS2V5XSAmJiB0aGlzLmNvbnRyb2xzW2NvbnRyb2xLZXldLmdldFZpc2liaWxpdHkodGhpcywgY29udHJvbEtleSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHNwZWNpZmllZCBjb250cm9sLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250cm9sS2V5IFRoZSBrZXkgb2YgdGhlIGNvbnRyb2wuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3RsJywgJ3RyJywgJ2JyJywgJ2JsJywgJ21sJywgJ210JywgJ21yJywgJ21iJywgJ210cicuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIHRydWUgdG8gc2V0IHRoZSBzcGVjaWZpZWQgY29udHJvbCB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbnRyb2xWaXNpYmxlOiBmdW5jdGlvbihjb250cm9sS2V5LCB2aXNpYmxlKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eSkge1xuICAgICAgICB0aGlzLl9jb250cm9sc1Zpc2liaWxpdHkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eVtjb250cm9sS2V5XSA9IHZpc2libGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiBvYmplY3QgY29udHJvbHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmxdIHRydWUgdG8gZW5hYmxlIHRoZSBib3R0b20tbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5icl0gdHJ1ZSB0byBlbmFibGUgdGhlIGJvdHRvbS1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1ib3R0b20gY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWxdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tcl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdF0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS10b3AgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGxdIHRydWUgdG8gZW5hYmxlIHRoZSB0b3AtbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cl0gdHJ1ZSB0byBlbmFibGUgdGhlIHRvcC1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdHJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtdG9wLXJvdGF0ZSBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb250cm9sc1Zpc2liaWxpdHk6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICBmb3IgKHZhciBwIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRDb250cm9sVmlzaWJsZShwLCBvcHRpb25zW3BdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGV2ZXJ5IHRpbWUgX2Rpc2NhcmRBY3RpdmVPYmplY3Qgb3IgX3NldEFjdGl2ZU9iamVjdFxuICAgICAqIHRyeSB0byB0byBkZXNlbGVjdCB0aGlzIG9iamVjdC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIHByb2Nlc3MgaXMgY2FuY2VsbGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHNlbnQgZnJvbSB0aGUgdXBwZXIgZnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtFdmVudH0gW29wdGlvbnMuZV0gZXZlbnQgaWYgdGhlIHByb2Nlc3MgaXMgZ2VuZXJhdGVkIGJ5IGFuIGV2ZW50XG4gICAgICovXG4gICAgb25EZXNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWItY2xhc3NlcywgYXMgbmVlZGVkLlxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGV2ZXJ5IHRpbWUgX2Rpc2NhcmRBY3RpdmVPYmplY3Qgb3IgX3NldEFjdGl2ZU9iamVjdFxuICAgICAqIHRyeSB0byB0byBzZWxlY3QgdGhpcyBvYmplY3QuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIHRoZSBwcm9jZXNzIGlzIGNhbmNlbGxlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBzZW50IGZyb20gdGhlIHVwcGVyIGZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtvcHRpb25zLmVdIGV2ZW50IGlmIHRoZSBwcm9jZXNzIGlzIGdlbmVyYXRlZCBieSBhbiBldmVudFxuICAgICAqL1xuICAgIG9uU2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEFuaW1hdGlvbiBkdXJhdGlvbiAoaW4gbXMpIGZvciBmeCogbWV0aG9kc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIEZYX0RVUkFUSU9OOiA1MDAsXG5cbiAgLyoqXG4gICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSB3aXRoIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5BbmltYXRpb25Db250ZXh0fSBjb250ZXh0XG4gICAqL1xuICBmeENlbnRlck9iamVjdEg6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0LmxlZnQsXG4gICAgICBlbmRWYWx1ZTogdGhpcy5nZXRDZW50ZXIoKS5sZWZ0LFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgb2JqZWN0LnNldCgnbGVmdCcsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSB3aXRoIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5BbmltYXRpb25Db250ZXh0fSBjb250ZXh0XG4gICAqL1xuICBmeENlbnRlck9iamVjdFY6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0LnRvcCxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLmdldENlbnRlcigpLnRvcCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ3RvcCcsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBgZmFicmljLkNhbnZhcyNyZW1vdmVgIGJ1dCBhbmltYXRlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkFuaW1hdGlvbkNvbnRleHR9IGNvbnRleHRcbiAgICovXG4gIGZ4UmVtb3ZlOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC5vcGFjaXR5LFxuICAgICAgZW5kVmFsdWU6IDAsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdvcGFjaXR5JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59KTtcblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBBbmltYXRlcyBvYmplY3QncyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcGVydHkgUHJvcGVydHkgdG8gYW5pbWF0ZSAoaWYgc3RyaW5nKSBvciBwcm9wZXJ0aWVzIHRvIGFuaW1hdGUgKGlmIG9iamVjdClcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byBhbmltYXRlIHByb3BlcnR5IHRvIChpZiBzdHJpbmcgd2FzIGdpdmVuIGZpcnN0KSBvciBvcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2FuaW1hdGlvbn1cbiAgICogQHJldHVybiB7ZmFicmljLkFuaW1hdGlvbkNvbnRleHQgfCBmYWJyaWMuQW5pbWF0aW9uQ29udGV4dFtdfSBhbmltYXRpb24gY29udGV4dCAob3IgYW4gYXJyYXkgaWYgcGFzc2VkIG11bHRpcGxlIHByb3BlcnRpZXMpXG4gICAqXG4gICAqIEFzIG9iamVjdCDigJQgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgKlxuICAgKiBvYmplY3QuYW5pbWF0ZSh7IGxlZnQ6IC4uLiwgdG9wOiAuLi4gfSk7XG4gICAqIG9iamVjdC5hbmltYXRlKHsgbGVmdDogLi4uLCB0b3A6IC4uLiB9LCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqIEFzIHN0cmluZyDigJQgb25lIHByb3BlcnR5XG4gICAqXG4gICAqIG9iamVjdC5hbmltYXRlKCdsZWZ0JywgLi4uKTtcbiAgICogb2JqZWN0LmFuaW1hdGUoJ2xlZnQnLCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHByb3BzVG9BbmltYXRlID0gW10sIHByb3AsIHNraXBDYWxsYmFja3MsIG91dCA9IFtdO1xuICAgICAgZm9yIChwcm9wIGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICBwcm9wc1RvQW5pbWF0ZS5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BzVG9BbmltYXRlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1RvQW5pbWF0ZVtpXTtcbiAgICAgICAgc2tpcENhbGxiYWNrcyA9IGkgIT09IGxlbiAtIDE7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuX2FuaW1hdGUocHJvcCwgYXJndW1lbnRzWzBdW3Byb3BdLCBhcmd1bWVudHNbMV0sIHNraXBDYWxsYmFja3MpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBhbmltYXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0byBWYWx1ZSB0byBhbmltYXRlIHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENhbGxiYWNrc10gV2hlbiB0cnVlLCBjYWxsYmFja3MgbGlrZSBvbmNoYW5nZSBhbmQgb25jb21wbGV0ZSBhcmUgbm90IGludm9rZWRcbiAgICovXG4gIF9hbmltYXRlOiBmdW5jdGlvbihwcm9wZXJ0eSwgdG8sIG9wdGlvbnMsIHNraXBDYWxsYmFja3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLCBwcm9wUGFpcjtcblxuICAgIHRvID0gdG8udG9TdHJpbmcoKTtcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZignLicpKSB7XG4gICAgICBwcm9wUGFpciA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3BJc0NvbG9yID1cbiAgICAgIF90aGlzLmNvbG9yUHJvcGVydGllcy5pbmRleE9mKHByb3BlcnR5KSA+IC0xIHx8XG4gICAgICAocHJvcFBhaXIgJiYgX3RoaXMuY29sb3JQcm9wZXJ0aWVzLmluZGV4T2YocHJvcFBhaXJbMV0pID4gLTEpO1xuXG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHByb3BQYWlyXG4gICAgICA/IHRoaXMuZ2V0KHByb3BQYWlyWzBdKVtwcm9wUGFpclsxXV1cbiAgICAgIDogdGhpcy5nZXQocHJvcGVydHkpO1xuXG4gICAgaWYgKCEoJ2Zyb20nIGluIG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zLmZyb20gPSBjdXJyZW50VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9wSXNDb2xvcikge1xuICAgICAgaWYgKH50by5pbmRleE9mKCc9JykpIHtcbiAgICAgICAgdG8gPSBjdXJyZW50VmFsdWUgKyBwYXJzZUZsb2F0KHRvLnJlcGxhY2UoJz0nLCAnJykpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRvID0gcGFyc2VGbG9hdCh0byk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0ge1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgc3RhcnRWYWx1ZTogb3B0aW9ucy5mcm9tLFxuICAgICAgZW5kVmFsdWU6IHRvLFxuICAgICAgYnlWYWx1ZTogb3B0aW9ucy5ieSxcbiAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgIGFib3J0OiBvcHRpb25zLmFib3J0ICYmIGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYWJvcnQuY2FsbChfdGhpcywgdmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcyk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uICh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKSB7XG4gICAgICAgIGlmIChwcm9wUGFpcikge1xuICAgICAgICAgIF90aGlzW3Byb3BQYWlyWzBdXVtwcm9wUGFpclsxXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5zZXQocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcENhbGxiYWNrcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLm9uQ2hhbmdlICYmIG9wdGlvbnMub25DaGFuZ2UodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcyk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHNraXBDYWxsYmFja3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlICYmIG9wdGlvbnMub25Db21wbGV0ZSh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHByb3BJc0NvbG9yKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwuYW5pbWF0ZUNvbG9yKF9vcHRpb25zLnN0YXJ0VmFsdWUsIF9vcHRpb25zLmVuZFZhbHVlLCBfb3B0aW9ucy5kdXJhdGlvbiwgX29wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKF9vcHRpb25zKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgY29vcmRQcm9wcyA9IHsgeDE6IDEsIHgyOiAxLCB5MTogMSwgeTI6IDEgfTtcblxuICBpZiAoZmFicmljLkxpbmUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkxpbmUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIExpbmUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5MaW5lXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkxpbmUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5MaW5lID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuTGluZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIHggdmFsdWUgb3IgZmlyc3QgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB4MTogMCxcblxuICAgIC8qKlxuICAgICAqIHkgdmFsdWUgb3IgZmlyc3QgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB5MTogMCxcblxuICAgIC8qKlxuICAgICAqIHggdmFsdWUgb3Igc2Vjb25kIGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeDI6IDAsXG5cbiAgICAvKipcbiAgICAgKiB5IHZhbHVlIG9yIHNlY29uZCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHkyOiAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCd4MScsICd4MicsICd5MScsICd5MicpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcG9pbnRzXSBBcnJheSBvZiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkxpbmV9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgIHBvaW50cyA9IFswLCAwLCAwLCAwXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5zZXQoJ3gxJywgcG9pbnRzWzBdKTtcbiAgICAgIHRoaXMuc2V0KCd5MScsIHBvaW50c1sxXSk7XG4gICAgICB0aGlzLnNldCgneDInLCBwb2ludHNbMl0pO1xuICAgICAgdGhpcy5zZXQoJ3kyJywgcG9pbnRzWzNdKTtcblxuICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zXG4gICAgICovXG4gICAgX3NldFdpZHRoSGVpZ2h0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdGhpcy53aWR0aCA9IE1hdGguYWJzKHRoaXMueDIgLSB0aGlzLngxKTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5hYnModGhpcy55MiAtIHRoaXMueTEpO1xuXG4gICAgICB0aGlzLmxlZnQgPSAnbGVmdCcgaW4gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMubGVmdFxuICAgICAgICA6IHRoaXMuX2dldExlZnRUb09yaWdpblgoKTtcblxuICAgICAgdGhpcy50b3AgPSAndG9wJyBpbiBvcHRpb25zXG4gICAgICAgID8gb3B0aW9ucy50b3BcbiAgICAgICAgOiB0aGlzLl9nZXRUb3BUb09yaWdpblkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAodHlwZW9mIGNvb3JkUHJvcHNba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gbGVmdFRvT3JpZ2luWCBEaXN0YW5jZSBmcm9tIGxlZnQgZWRnZSBvZiBjYW52YXMgdG8gb3JpZ2luWCBvZiBMaW5lLlxuICAgICAqL1xuICAgIF9nZXRMZWZ0VG9PcmlnaW5YOiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKFxuICAgICAgeyAvLyBwcm9wZXJ0eSBuYW1lc1xuICAgICAgICBvcmlnaW46ICdvcmlnaW5YJyxcbiAgICAgICAgYXhpczE6ICd4MScsXG4gICAgICAgIGF4aXMyOiAneDInLFxuICAgICAgICBkaW1lbnNpb246ICd3aWR0aCdcbiAgICAgIH0sXG4gICAgICB7IC8vIHBvc3NpYmxlIHZhbHVlcyBvZiBvcmlnaW5cbiAgICAgICAgbmVhcmVzdDogJ2xlZnQnLFxuICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICBmYXJ0aGVzdDogJ3JpZ2h0J1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdG9wVG9PcmlnaW5ZIERpc3RhbmNlIGZyb20gdG9wIGVkZ2Ugb2YgY2FudmFzIHRvIG9yaWdpblkgb2YgTGluZS5cbiAgICAgKi9cbiAgICBfZ2V0VG9wVG9PcmlnaW5ZOiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKFxuICAgICAgeyAvLyBwcm9wZXJ0eSBuYW1lc1xuICAgICAgICBvcmlnaW46ICdvcmlnaW5ZJyxcbiAgICAgICAgYXhpczE6ICd5MScsXG4gICAgICAgIGF4aXMyOiAneTInLFxuICAgICAgICBkaW1lbnNpb246ICdoZWlnaHQnXG4gICAgICB9LFxuICAgICAgeyAvLyBwb3NzaWJsZSB2YWx1ZXMgb2Ygb3JpZ2luXG4gICAgICAgIG5lYXJlc3Q6ICd0b3AnLFxuICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICBmYXJ0aGVzdDogJ2JvdHRvbSdcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cblxuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICBjdHgubW92ZVRvKHAueDEsIHAueTEpO1xuICAgICAgY3R4LmxpbmVUbyhwLngyLCBwLnkyKTtcblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG5cbiAgICAgIC8vIFRPRE86IHRlc3QgdGhpc1xuICAgICAgLy8gbWFrZSBzdXJlIHNldHRpbmcgXCJmaWxsXCIgY2hhbmdlcyBjb2xvciBvZiBhIGxpbmVcbiAgICAgIC8vIChieSBjb3B5aW5nIGZpbGxTdHlsZSB0byBzdHJva2VTdHlsZSwgc2luY2UgbGluZSBpcyBzdHJva2VkLCBub3QgZmlsbGVkKVxuICAgICAgdmFyIG9yaWdTdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlIHx8IGN0eC5maWxsU3R5bGU7XG4gICAgICB0aGlzLnN0cm9rZSAmJiB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9yaWdTdHJva2VTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0IGluIHRoZSBzdmdcbiAgICAgKiB1bnRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBwb2ludCBmcm9tIGVsZW1lbnQgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBfZmluZENlbnRlckZyb21FbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6ICh0aGlzLngxICsgdGhpcy54MikgLyAyLFxuICAgICAgICB5OiAodGhpcy55MSArIHRoaXMueTIpIC8gMixcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQG1ldGhvZCB0b09iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB0aGlzLmNhbGNMaW5lUG9pbnRzKCkpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaW0gPSB0aGlzLmNhbGxTdXBlcignX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucycpO1xuICAgICAgaWYgKHRoaXMuc3Ryb2tlTGluZUNhcCA9PT0gJ2J1dHQnKSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgZGltLnkgLT0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBkaW0ueCAtPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGltO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgbGluZSBwb2ludHMgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2FsY0xpbmVQb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHhNdWx0ID0gdGhpcy54MSA8PSB0aGlzLngyID8gLTEgOiAxLFxuICAgICAgICAgIHlNdWx0ID0gdGhpcy55MSA8PSB0aGlzLnkyID8gLTEgOiAxLFxuICAgICAgICAgIHgxID0gKHhNdWx0ICogdGhpcy53aWR0aCAqIDAuNSksXG4gICAgICAgICAgeTEgPSAoeU11bHQgKiB0aGlzLmhlaWdodCAqIDAuNSksXG4gICAgICAgICAgeDIgPSAoeE11bHQgKiB0aGlzLndpZHRoICogLTAuNSksXG4gICAgICAgICAgeTIgPSAoeU11bHQgKiB0aGlzLmhlaWdodCAqIC0wLjUpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPGxpbmUgJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICd4MT1cIicsIHAueDEsXG4gICAgICAgICdcIiB5MT1cIicsIHAueTEsXG4gICAgICAgICdcIiB4Mj1cIicsIHAueDIsXG4gICAgICAgICdcIiB5Mj1cIicsIHAueTIsXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuTGluZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0xpbmVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4MSB5MSB4MiB5Micuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMpLFxuICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy54MSB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueTEgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLngyIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy55MiB8fCAwXG4gICAgICAgIF07XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5MaW5lKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIF9jYWxsYmFjayhpbnN0YW5jZSkge1xuICAgICAgZGVsZXRlIGluc3RhbmNlLnBvaW50cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICB9O1xuICAgIHZhciBvcHRpb25zID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBvcHRpb25zLnBvaW50cyA9IFtvYmplY3QueDEsIG9iamVjdC55MSwgb2JqZWN0LngyLCBvYmplY3QueTJdO1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0xpbmUnLCBvcHRpb25zLCBfY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBmdW5jdGlvbiB0aGF0IGNhbGN1bGF0ZXMgZGlzdGFuY2UgZnJvbSBjYW52YXMgZWRnZSB0byBMaW5lIG9yaWdpbi5cbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIocHJvcGVydHlOYW1lcywgb3JpZ2luVmFsdWVzKSB7XG4gICAgdmFyIG9yaWdpbiA9IHByb3BlcnR5TmFtZXMub3JpZ2luLFxuICAgICAgICBheGlzMSA9IHByb3BlcnR5TmFtZXMuYXhpczEsXG4gICAgICAgIGF4aXMyID0gcHJvcGVydHlOYW1lcy5heGlzMixcbiAgICAgICAgZGltZW5zaW9uID0gcHJvcGVydHlOYW1lcy5kaW1lbnNpb24sXG4gICAgICAgIG5lYXJlc3QgPSBvcmlnaW5WYWx1ZXMubmVhcmVzdCxcbiAgICAgICAgY2VudGVyID0gb3JpZ2luVmFsdWVzLmNlbnRlcixcbiAgICAgICAgZmFydGhlc3QgPSBvcmlnaW5WYWx1ZXMuZmFydGhlc3Q7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0KG9yaWdpbikpIHtcbiAgICAgICAgY2FzZSBuZWFyZXN0OlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSk7XG4gICAgICAgIGNhc2UgY2VudGVyOlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSkgKyAoMC41ICogdGhpcy5nZXQoZGltZW5zaW9uKSk7XG4gICAgICAgIGNhc2UgZmFydGhlc3Q6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIH1cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnM7XG5cbiAgaWYgKGZhYnJpYy5DaXJjbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNpcmNsZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmNsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkNpcmNsZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5DaXJjbGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5DaXJjbGUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgIC8qKlxuICAgICAqIFJhZGl1cyBvZiB0aGlzIGNpcmNsZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmFkaXVzOiAwLFxuXG4gICAgLyoqXG4gICAgICogZGVncmVlcyBvZiBzdGFydCBvZiB0aGUgY2lyY2xlLlxuICAgICAqIHByb2JhYmx5IHdpbGwgY2hhbmdlIHRvIGRlZ3JlZXMgaW4gbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICogQHR5cGUgTnVtYmVyIDAgLSAzNTlcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc3RhcnRBbmdsZTogMCxcblxuICAgIC8qKlxuICAgICAqIEVuZCBhbmdsZSBvZiB0aGUgY2lyY2xlXG4gICAgICogcHJvYmFibHkgd2lsbCBjaGFuZ2UgdG8gZGVncmVlcyBpbiBuZXh0IG1ham9yIHZlcnNpb25cbiAgICAgKiBAdHlwZSBOdW1iZXIgMSAtIDM2MFxuICAgICAqIEBkZWZhdWx0IDM2MFxuICAgICAqL1xuICAgIGVuZEFuZ2xlOiAzNjAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJyksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChrZXkgPT09ICdyYWRpdXMnKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcsIHggPSAwLCB5ID0gMCxcbiAgICAgICAgICBhbmdsZSA9ICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSAlIDM2MDtcblxuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IFtcbiAgICAgICAgICAnPGNpcmNsZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgICAnY3g9XCInICsgeCArICdcIiBjeT1cIicgKyB5ICsgJ1wiICcsXG4gICAgICAgICAgJ3I9XCInLCB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAnXCIgLz5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLnN0YXJ0QW5nbGUpLFxuICAgICAgICAgICAgZW5kID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLmVuZEFuZ2xlKSxcbiAgICAgICAgICAgIHJhZGl1cyA9IHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgc3RhcnRYID0gZmFicmljLnV0aWwuY29zKHN0YXJ0KSAqIHJhZGl1cyxcbiAgICAgICAgICAgIHN0YXJ0WSA9IGZhYnJpYy51dGlsLnNpbihzdGFydCkgKiByYWRpdXMsXG4gICAgICAgICAgICBlbmRYID0gZmFicmljLnV0aWwuY29zKGVuZCkgKiByYWRpdXMsXG4gICAgICAgICAgICBlbmRZID0gZmFicmljLnV0aWwuc2luKGVuZCkgKiByYWRpdXMsXG4gICAgICAgICAgICBsYXJnZUZsYWcgPSBhbmdsZSA+IDE4MCA/ICcxJyA6ICcwJztcbiAgICAgICAgc3ZnU3RyaW5nID0gW1xuICAgICAgICAgICc8cGF0aCBkPVwiTSAnICsgc3RhcnRYICsgJyAnICsgc3RhcnRZLFxuICAgICAgICAgICcgQSAnICsgcmFkaXVzICsgJyAnICsgcmFkaXVzLFxuICAgICAgICAgICcgMCAnLCArbGFyZ2VGbGFnICsgJyAxJywgJyAnICsgZW5kWCArICcgJyArIGVuZFksXG4gICAgICAgICAgJ1wiICcsICdDT01NT05fUEFSVFMnLCAnIC8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN2Z1N0cmluZztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgZGVncmVlc1RvUmFkaWFucyh0aGlzLnN0YXJ0QW5nbGUpLFxuICAgICAgICBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuZW5kQW5nbGUpLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhvcml6b250YWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSYWRpdXNYOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncmFkaXVzJykgKiB0aGlzLmdldCgnc2NhbGVYJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdmVydGljYWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSYWRpdXNZOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncmFkaXVzJykgKiB0aGlzLmdldCgnc2NhbGVZJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcmFkaXVzIG9mIGFuIG9iamVjdCAoYW5kIHVwZGF0ZXMgd2lkdGggYWNjb3JkaW5nbHkpXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldFJhZGl1czogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMucmFkaXVzID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoJ3dpZHRoJywgdmFsdWUgKiAyKS5zZXQoJ2hlaWdodCcsIHZhbHVlICogMik7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuQ2lyY2xlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjQ2lyY2xlRWxlbWVudFxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCdjeCBjeSByJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkNpcmNsZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ2lyY2xlXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9ucyBjYWxsYmFjayBpbnZva2VkIGFmdGVyIHBhcnNpbmcgaXMgZmluaXNoZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdmFsdWUgb2YgYHJgIGF0dHJpYnV0ZSBpcyBtaXNzaW5nIG9yIGludmFsaWRcbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuQ2lyY2xlLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBpZiAoIWlzVmFsaWRSYWRpdXMocGFyc2VkQXR0cmlidXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgb2YgYHJgIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBhbmQgY2FuIG5vdCBiZSBuZWdhdGl2ZScpO1xuICAgIH1cblxuICAgIHBhcnNlZEF0dHJpYnV0ZXMubGVmdCA9IChwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJhZGl1cztcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCA9IChwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucmFkaXVzO1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuQ2lyY2xlKHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWRSYWRpdXMoYXR0cmlidXRlcykge1xuICAgIHJldHVybiAoKCdyYWRpdXMnIGluIGF0dHJpYnV0ZXMpICYmIChhdHRyaWJ1dGVzLnJhZGl1cyA+PSAwKSk7XG4gIH1cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkNpcmNsZX0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdDaXJjbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuVHJpYW5nbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRyaWFuZ2xlIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRyaWFuZ2xlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UcmlhbmdsZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVHJpYW5nbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndHJpYW5nbGUnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggaXMgc2V0IHRvIDEwMCB0byBjb21wZW5zYXRlIHRoZSBvbGQgaW5pdGlhbGl6ZSBjb2RlIHRoYXQgd2FzIHNldHRpbmcgaXQgdG8gMTAwXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogMTAwLFxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0IGlzIHNldCB0byAxMDAgdG8gY29tcGVuc2F0ZSB0aGUgb2xkIGluaXRpYWxpemUgY29kZSB0aGF0IHdhcyBzZXR0aW5nIGl0IHRvIDEwMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGVpZ2h0OiAxMDAsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtd2lkdGhCeTIsIGhlaWdodEJ5Mik7XG4gICAgICBjdHgubGluZVRvKDAsIC1oZWlnaHRCeTIpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aEJ5MiwgaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIC13aWR0aEJ5MiArICcgJyArIGhlaWdodEJ5MixcbiAgICAgICAgICAgICcwICcgKyAtaGVpZ2h0QnkyLFxuICAgICAgICAgICAgd2lkdGhCeTIgKyAnICcgKyBoZWlnaHRCeTJcbiAgICAgICAgICBdLmpvaW4oJywnKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8cG9seWdvbiAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3BvaW50cz1cIicsIHBvaW50cyxcbiAgICAgICAgJ1wiIC8+J1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlRyaWFuZ2xlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVHJpYW5nbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuVHJpYW5nbGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVHJpYW5nbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgcGlCeTIgICA9IE1hdGguUEkgKiAyO1xuXG4gIGlmIChmYWJyaWMuRWxsaXBzZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuRWxsaXBzZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsbGlwc2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkVsbGlwc2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuRWxsaXBzZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdlbGxpcHNlJyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeTogICAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdyeCcsICdyeScpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zZXQoJ3J4Jywgb3B0aW9ucyAmJiBvcHRpb25zLnJ4IHx8IDApO1xuICAgICAgdGhpcy5zZXQoJ3J5Jywgb3B0aW9ucyAmJiBvcHRpb25zLnJ5IHx8IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICBjYXNlICdyeCc6XG4gICAgICAgICAgdGhpcy5yeCA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncnknOlxuICAgICAgICAgIHRoaXMucnkgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNldCgnaGVpZ2h0JywgdmFsdWUgKiAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaG9yaXpvbnRhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJ4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncngnKSAqIHRoaXMuZ2V0KCdzY2FsZVgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBWZXJ0aWNhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJ5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncnknKSAqIHRoaXMuZ2V0KCdzY2FsZVknKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsncngnLCAncnknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8ZWxsaXBzZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ2N4PVwiMFwiIGN5PVwiMFwiICcsXG4gICAgICAgICdyeD1cIicsIHRoaXMucngsXG4gICAgICAgICdcIiByeT1cIicsIHRoaXMucnksXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgdGhpcy5yeSAvIHRoaXMucngsIDAsIDApO1xuICAgICAgY3R4LmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5yeCxcbiAgICAgICAgMCxcbiAgICAgICAgcGlCeTIsXG4gICAgICAgIGZhbHNlKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5FbGxpcHNlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkVsbGlwc2VcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjRWxsaXBzZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ2N4IGN5IHJ4IHJ5Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkVsbGlwc2V9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkVsbGlwc2VcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25zIGNhbGxiYWNrIGludm9rZWQgYWZ0ZXIgcGFyc2luZyBpcyBmaW5pc2hlZFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuRWxsaXBzZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gKHBhcnNlZEF0dHJpYnV0ZXMubGVmdCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucng7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSAocGFyc2VkQXR0cmlidXRlcy50b3AgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJ5O1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuRWxsaXBzZShwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5FbGxpcHNlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnRWxsaXBzZScsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xuXG4gIGlmIChmYWJyaWMuUmVjdCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUmVjdCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUmVjdGFuZ2xlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUmVjdFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5SZWN0fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5SZWN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUmVjdCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlJlY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncmVjdCcsXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIGJvcmRlciByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ4OiAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBib3JkZXIgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeTogICAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdyeCcsICdyeScpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRSeFJ5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHJ4L3J5IGF0dHJpYnV0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0UnhSeTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yeCAmJiAhdGhpcy5yeSkge1xuICAgICAgICB0aGlzLnJ5ID0gdGhpcy5yeDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucnkgJiYgIXRoaXMucngpIHtcbiAgICAgICAgdGhpcy5yeCA9IHRoaXMucnk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAvLyAxeDEgY2FzZSAodXNlZCBpbiBzcHJheSBicnVzaCkgb3B0aW1pemF0aW9uIHdhcyByZW1vdmVkIGJlY2F1c2VcbiAgICAgIC8vIHdpdGggY2FjaGluZyBhbmQgaGlnaGVyIHpvb20gbGV2ZWwgdGhpcyBtYWtlcyBtb3JlIGRhbWFnZSB0aGFuIGhlbHBcblxuICAgICAgdmFyIHJ4ID0gdGhpcy5yeCA/IE1hdGgubWluKHRoaXMucngsIHRoaXMud2lkdGggLyAyKSA6IDAsXG4gICAgICAgICAgcnkgPSB0aGlzLnJ5ID8gTWF0aC5taW4odGhpcy5yeSwgdGhpcy5oZWlnaHQgLyAyKSA6IDAsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHggPSAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgeSA9IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgaXNSb3VuZGVkID0gcnggIT09IDAgfHwgcnkgIT09IDAsXG4gICAgICAgICAgLyogXCJtYWdpYyBudW1iZXJcIiBmb3IgYmV6aWVyIGFwcHJveGltYXRpb25zIG9mIGFyY3MgKGh0dHA6Ly9pdGMua3R1Lmx0L2l0YzM1NC9SaXNrdXMzNTQucGRmKSAqL1xuICAgICAgICAgIGsgPSAxIC0gMC41NTIyODQ3NDk4O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBjdHgubW92ZVRvKHggKyByeCwgeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHcgLSByeCwgeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcgLSBrICogcngsIHksIHggKyB3LCB5ICsgayAqIHJ5LCB4ICsgdywgeSArIHJ5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gayAqIHJ5LCB4ICsgdyAtIGsgKiByeCwgeSArIGgsIHggKyB3IC0gcngsIHkgKyBoKTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgcngsIHkgKyBoKTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgayAqIHJ4LCB5ICsgaCwgeCwgeSArIGggLSBrICogcnksIHgsIHkgKyBoIC0gcnkpO1xuXG4gICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIGsgKiByeSwgeCArIGsgKiByeCwgeSwgeCArIHJ4LCB5KTtcblxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsncngnLCAncnknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8cmVjdCAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3g9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICdcIiByeD1cIicsIHRoaXMucngsICdcIiByeT1cIicsIHRoaXMucnksXG4gICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5SZWN0LmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1JlY3RFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUmVjdC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4IHkgcnggcnkgd2lkdGggaGVpZ2h0Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5SZWN0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyk7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gcGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgID0gcGFyc2VkQXR0cmlidXRlcy50b3AgIHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5oZWlnaHQgID0gcGFyc2VkQXR0cmlidXRlcy5oZWlnaHQgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLndpZHRoICA9IHBhcnNlZEF0dHJpYnV0ZXMud2lkdGggfHwgMDtcbiAgICB2YXIgcmVjdCA9IG5ldyBmYWJyaWMuUmVjdChleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gICAgcmVjdC52aXNpYmxlID0gcmVjdC52aXNpYmxlICYmIHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgICBjYWxsYmFjayhyZWN0KTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5SZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlJlY3QgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlJlY3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUmVjdCcsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBwcm9qZWN0U3Ryb2tlT25Qb2ludHMgPSBmYWJyaWMudXRpbC5wcm9qZWN0U3Ryb2tlT25Qb2ludHM7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5bGluZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9seWxpbmUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlsaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWxpbmUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlsaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIFBvaW50cyBhcnJheVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwb2ludHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXQVJOSU5HOiBGZWF0dXJlIGluIHByb2dyZXNzXG4gICAgICogQ2FsY3VsYXRlIHRoZSBleGFjdCBib3VuZGluZyBib3ggdGFraW5nIGluIGFjY291bnQgc3Ryb2tlV2lkdGggb24gYWN1dGUgYW5nbGVzXG4gICAgICogdGhpcyB3aWxsIGJlIHR1cm5lZCB0byB0cnVlIGJ5IGRlZmF1bHQgb24gZmFicmljIDYuMFxuICAgICAqIG1heWJlIHdpbGwgYmUgbGVmdCBpbiBhcyBhbiBvcHRpbWl6YXRpb24gc2luY2UgY2FsY3VsYXRpb25zIG1heSBiZSBzbG93XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBleGFjdEJvdW5kaW5nQm94OiBmYWxzZSxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncG9pbnRzJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHMgKHdoZXJlIGVhY2ggcG9pbnQgaXMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvbHlsaW5lfSB0aGlzQXJnXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IG5ldyBmYWJyaWMuUG9seWxpbmUoW1xuICAgICAqICAgICB7IHg6IDEwLCB5OiAxMCB9LFxuICAgICAqICAgICB7IHg6IDUwLCB5OiAzMCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiA3MCB9LFxuICAgICAqICAgICB7IHg6IDYwLCB5OiA1MCB9LFxuICAgICAqICAgICB7IHg6IDEwMCwgeTogMTUwIH0sXG4gICAgICogICAgIHsgeDogNDAsIHk6IDEwMCB9XG4gICAgICogICBdLCB7XG4gICAgICogICBzdHJva2U6ICdyZWQnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0UG9zaXRpb25EaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9qZWN0U3Ryb2tlT25Qb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0U3Ryb2tlT25Qb2ludHModGhpcy5wb2ludHMsIHRoaXMsIHRydWUpO1xuICAgIH0sXG5cbiAgICBfc2V0UG9zaXRpb25EaW1lbnNpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FsY0RpbSA9IHRoaXMuX2NhbGNEaW1lbnNpb25zKG9wdGlvbnMpLCBjb3JyZWN0TGVmdFRvcCxcbiAgICAgICAgICBjb3JyZWN0U2l6ZSA9IHRoaXMuZXhhY3RCb3VuZGluZ0JveCA/IHRoaXMuc3Ryb2tlV2lkdGggOiAwO1xuICAgICAgdGhpcy53aWR0aCA9IGNhbGNEaW0ud2lkdGggLSBjb3JyZWN0U2l6ZTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gY2FsY0RpbS5oZWlnaHQgLSBjb3JyZWN0U2l6ZTtcbiAgICAgIGlmICghb3B0aW9ucy5mcm9tU1ZHKSB7XG4gICAgICAgIGNvcnJlY3RMZWZ0VG9wID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbG9va3MgYmFkLCBidXQgaXMgb25lIHdheSB0byBrZWVwIGl0IG9wdGlvbmFsIGZvciBub3cuXG4gICAgICAgICAgICB4OiBjYWxjRGltLmxlZnQgLSB0aGlzLnN0cm9rZVdpZHRoIC8gMiArIGNvcnJlY3RTaXplIC8gMixcbiAgICAgICAgICAgIHk6IGNhbGNEaW0udG9wIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIgKyBjb3JyZWN0U2l6ZSAvIDJcbiAgICAgICAgICB9LFxuICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAndG9wJyxcbiAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgdGhpcy5vcmlnaW5ZXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gb3B0aW9ucy5mcm9tU1ZHID8gY2FsY0RpbS5sZWZ0IDogY29ycmVjdExlZnRUb3AueDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMudG9wID0gb3B0aW9ucy5mcm9tU1ZHID8gY2FsY0RpbS50b3AgOiBjb3JyZWN0TGVmdFRvcC55O1xuICAgICAgfVxuICAgICAgdGhpcy5wYXRoT2Zmc2V0ID0ge1xuICAgICAgICB4OiBjYWxjRGltLmxlZnQgKyB0aGlzLndpZHRoIC8gMiArIGNvcnJlY3RTaXplIC8gMixcbiAgICAgICAgeTogY2FsY0RpbS50b3AgKyB0aGlzLmhlaWdodCAvIDIgKyBjb3JyZWN0U2l6ZSAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9seWdvbiBtaW4gYW5kIG1heCBwb2ludCBmcm9tIHBvaW50cyBhcnJheSxcbiAgICAgKiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHRvIG1lYXN1cmUgdGhlXG4gICAgICogcG9seWdvbiBzaXplXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QubGVmdCBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb24gbGVmdG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC50b3AgWSBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uIHRvcG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aCBkaXN0YW5jZSBiZXR3ZWVuIFggY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24gbGVmdG1vc3QgYW5kIHJpZ2h0bW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LmhlaWdodCBkaXN0YW5jZSBiZXR3ZWVuIFkgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24gdG9wbW9zdCBhbmQgYm90dG9tbW9zdCBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZXhhY3RCb3VuZGluZ0JveCA/IHRoaXMuX3Byb2plY3RTdHJva2VPblBvaW50cygpIDogdGhpcy5wb2ludHMsXG4gICAgICAgICAgbWluWCA9IG1pbihwb2ludHMsICd4JykgfHwgMCxcbiAgICAgICAgICBtaW5ZID0gbWluKHBvaW50cywgJ3knKSB8fCAwLFxuICAgICAgICAgIG1heFggPSBtYXgocG9pbnRzLCAneCcpIHx8IDAsXG4gICAgICAgICAgbWF4WSA9IG1heChwb2ludHMsICd5JykgfHwgMCxcbiAgICAgICAgICB3aWR0aCA9IChtYXhYIC0gbWluWCksXG4gICAgICAgICAgaGVpZ2h0ID0gKG1heFkgLSBtaW5ZKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLmNvbmNhdCgpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW10sIGRpZmZYID0gdGhpcy5wYXRoT2Zmc2V0LngsIGRpZmZZID0gdGhpcy5wYXRoT2Zmc2V0LnksXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFxuICAgICAgICAgIHRvRml4ZWQodGhpcy5wb2ludHNbaV0ueCAtIGRpZmZYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJywnLFxuICAgICAgICAgIHRvRml4ZWQodGhpcy5wb2ludHNbaV0ueSAtIGRpZmZZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJyAnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPCcgKyB0aGlzLnR5cGUgKyAnICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAncG9pbnRzPVwiJywgcG9pbnRzLmpvaW4oJycpLFxuICAgICAgICAnXCIgLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGNvbW1vblJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgcG9pbnQsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICB4ID0gdGhpcy5wYXRoT2Zmc2V0LngsXG4gICAgICAgICAgeSA9IHRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBpZiAoIWxlbiB8fCBpc05hTih0aGlzLnBvaW50c1tsZW4gLSAxXS55KSkge1xuICAgICAgICAvLyBkbyBub3QgZHJhdyBpZiBubyBwb2ludHMgb3Igb2RkIHBvaW50c1xuICAgICAgICAvLyBOYU4gY29tZXMgZnJvbSBwYXJzZUZsb2F0IG9mIGEgZW1wdHkgc3RyaW5nIGluIHBhcnNlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMucG9pbnRzWzBdLnggLSB4LCB0aGlzLnBvaW50c1swXS55IC0geSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCAtIHgsIHBvaW50LnkgLSB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5jb21tb25SZW5kZXIoY3R4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncG9pbnRzJykubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlsaW5lRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnRHZW5lcmF0b3IgPSBmdW5jdGlvbihfY2xhc3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHBvaW50cyA9IGZhYnJpYy5wYXJzZVBvaW50c0F0dHJpYnV0ZShlbGVtZW50LmdldEF0dHJpYnV0ZSgncG9pbnRzJykpLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpY1tfY2xhc3NdLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgICBwYXJzZWRBdHRyaWJ1dGVzLmZyb21TVkcgPSB0cnVlO1xuICAgICAgY2FsbGJhY2sobmV3IGZhYnJpY1tfY2xhc3NdKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gICAgfTtcbiAgfTtcblxuICBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnQgPSBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnRHZW5lcmF0b3IoJ1BvbHlsaW5lJyk7XG5cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BvbHlsaW5lJywgb2JqZWN0LCBjYWxsYmFjaywgJ3BvaW50cycpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHt9KSxcbiAgICAgIHByb2plY3RTdHJva2VPblBvaW50cyA9IGZhYnJpYy51dGlsLnByb2plY3RTdHJva2VPblBvaW50cztcblxuICBpZiAoZmFicmljLlBvbHlnb24pIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBvbHlnb24gaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlnb24gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBleHRlbmRzIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWdvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBvbHlnb24gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuUG9seWxpbmUsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlnb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncG9seWdvbicsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9qZWN0U3Ryb2tlT25Qb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0U3Ryb2tlT25Qb2ludHModGhpcy5wb2ludHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5jb21tb25SZW5kZXIoY3R4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBvbHlnb24uZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWdvblxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUG9seWdvbkVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlBvbHlnb259IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLmZyb21FbGVtZW50ID0gZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50R2VuZXJhdG9yKCdQb2x5Z29uJyk7XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlnb24gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BvbHlnb24nLCBvYmplY3QsIGNhbGxiYWNrLCAncG9pbnRzJyk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbixcbiAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICBpZiAoZmFicmljLlBhdGgpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBhdGggaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGggY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXRoXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjcGF0aF9hbmRfcGF0aGdyb3VwfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUGF0aCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBhdGggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5QYXRoLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BhdGgnLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGF0aCBwb2ludHNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aDogbnVsbCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncGF0aCcsICdmaWxsUnVsZScpLFxuXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdwYXRoJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBwYXRoIFBhdGggZGF0YSAoc2VxdWVuY2Ugb2YgY29vcmRpbmF0ZXMgYW5kIGNvcnJlc3BvbmRpbmcgXCJjb21tYW5kXCIgdG9rZW5zKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0aH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gY2xvbmUob3B0aW9ucyB8fCB7fSk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5wYXRoO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldFBhdGgocGF0aCB8fCBbXSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBwYXRoIFBhdGggZGF0YSAoc2VxdWVuY2Ugb2YgY29vcmRpbmF0ZXMgYW5kIGNvcnJlc3BvbmRpbmcgXCJjb21tYW5kXCIgdG9rZW5zKVxuICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICovXG4gICAgX3NldFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZnJvbUFycmF5ID0gX3RvU3RyaW5nLmNhbGwocGF0aCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cbiAgICAgIHRoaXMucGF0aCA9IGZhYnJpYy51dGlsLm1ha2VQYXRoU2ltcGxlcihcbiAgICAgICAgZnJvbUFycmF5ID8gcGF0aCA6IGZhYnJpYy51dGlsLnBhcnNlUGF0aChwYXRoKVxuICAgICAgKTtcblxuICAgICAgZmFicmljLlBvbHlsaW5lLnByb3RvdHlwZS5fc2V0UG9zaXRpb25EaW1lbnNpb25zLmNhbGwodGhpcywgb3B0aW9ucyB8fCB7fSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhdGhDb21tYW5kczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHN1YnBhdGhTdGFydFggPSAwLFxuICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSAwLFxuICAgICAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICAgICAgY29udHJvbFggPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeFxuICAgICAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgICAgICBsID0gLXRoaXMucGF0aE9mZnNldC54LFxuICAgICAgICAgIHQgPSAtdGhpcy5wYXRoT2Zmc2V0Lnk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucGF0aC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLnBhdGhbaV07XG5cbiAgICAgICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuXG4gICAgICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHggKyBsLFxuICAgICAgICAgICAgICB5ICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICBjdXJyZW50WzNdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFs0XSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHggPSBzdWJwYXRoU3RhcnRYO1xuICAgICAgICAgICAgeSA9IHN1YnBhdGhTdGFydFk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgcGF0aCBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyUGF0aENvbW1hbmRzKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuUGF0aCAoJyArIHRoaXMuY29tcGxleGl0eSgpICtcbiAgICAgICAgJyk6IHsgXCJ0b3BcIjogJyArIHRoaXMudG9wICsgJywgXCJsZWZ0XCI6ICcgKyB0aGlzLmxlZnQgKyAnIH0+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwYXRoOiB0aGlzLnBhdGgubWFwKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uc2xpY2UoKTsgfSksXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRhbGVzcyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgbyA9IHRoaXMudG9PYmplY3QoWydzb3VyY2VQYXRoJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICAgIGlmIChvLnNvdXJjZVBhdGgpIHtcbiAgICAgICAgZGVsZXRlIG8ucGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gZmFicmljLnV0aWwuam9pblBhdGgodGhpcy5wYXRoKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8cGF0aCAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ2Q9XCInLCBwYXRoLFxuICAgICAgICAnXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiICcsXG4gICAgICAgICcvPlxcbidcbiAgICAgIF07XG4gICAgfSxcblxuICAgIF9nZXRPZmZzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpZ2l0cyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgIHJldHVybiAnIHRyYW5zbGF0ZSgnICsgdG9GaXhlZCgtdGhpcy5wYXRoT2Zmc2V0LngsIGRpZ2l0cykgKyAnLCAnICtcbiAgICAgICAgICB0b0ZpeGVkKC10aGlzLnBhdGhPZmZzZXQueSwgZGlnaXRzKSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgY2xpcFBhdGggcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9DbGlwUGF0aFNWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSB0aGlzLl9nZXRPZmZzZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiAnXFx0JyArIHRoaXMuX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cChcbiAgICAgICAgdGhpcy5fdG9TVkcoKSwgeyByZXZpdmVyOiByZXZpdmVyLCBhZGRpdGlvbmFsVHJhbnNmb3JtOiBhZGRpdGlvbmFsVHJhbnNmb3JtIH1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgYWRkaXRpb25hbFRyYW5zZm9ybSA9IHRoaXMuX2dldE9mZnNldFRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAodGhpcy5fdG9TVkcoKSwgeyByZXZpdmVyOiByZXZpdmVyLCBhZGRpdGlvbmFsVHJhbnNmb3JtOiBhZGRpdGlvbmFsVHJhbnNmb3JtICB9KTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2UgY29tcGxleGl0eVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYVggPSBbXSxcbiAgICAgICAgICBhWSA9IFtdLFxuICAgICAgICAgIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGJvdW5kcztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucGF0aC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLnBhdGhbaV07XG5cbiAgICAgICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuXG4gICAgICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgICBjdXJyZW50WzZdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHggPSBzdWJwYXRoU3RhcnRYO1xuICAgICAgICAgICAgeSA9IHN1YnBhdGhTdGFydFk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBib3VuZHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICBhWC5wdXNoKHBvaW50LngpO1xuICAgICAgICAgIGFZLnB1c2gocG9pbnQueSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhWC5wdXNoKHgpO1xuICAgICAgICBhWS5wdXNoKHkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluWCA9IG1pbihhWCkgfHwgMCxcbiAgICAgICAgICBtaW5ZID0gbWluKGFZKSB8fCAwLFxuICAgICAgICAgIG1heFggPSBtYXgoYVgpIHx8IDAsXG4gICAgICAgICAgbWF4WSA9IG1heChhWSkgfHwgMCxcbiAgICAgICAgICBkZWx0YVggPSBtYXhYIC0gbWluWCxcbiAgICAgICAgICBkZWx0YVkgPSBtYXhZIC0gbWluWTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogZGVsdGFYLFxuICAgICAgICBoZWlnaHQ6IGRlbHRhWVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5QYXRoIGZyb20gYW4gb2JqZWN0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5QYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUGF0aC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNvdXJjZVBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcGF0aFVybCA9IG9iamVjdC5zb3VyY2VQYXRoO1xuICAgICAgZmFicmljLmxvYWRTVkdGcm9tVVJMKHBhdGhVcmwsIGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICB2YXIgcGF0aCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICBwYXRoLnNldE9wdGlvbnMob2JqZWN0KTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socGF0aCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdQYXRoJywgb2JqZWN0LCBjYWxsYmFjaywgJ3BhdGgnKTtcbiAgICB9XG4gIH07XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IGBmYWJyaWMuUGF0aC5mcm9tRWxlbWVudGApXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5QYXRoXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aEVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5QYXRoLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoWydkJ10pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5QYXRoIGZyb20gYW4gU1ZHIDxwYXRoPiBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5QYXRoXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25zIGNhbGxiYWNrIGludm9rZWQgYWZ0ZXIgcGFyc2luZyBpcyBmaW5pc2hlZFxuICAgKi9cbiAgZmFicmljLlBhdGguZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuUGF0aC5BVFRSSUJVVEVfTkFNRVMpO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMuZnJvbVNWRyA9IHRydWU7XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5QYXRoKHBhcnNlZEF0dHJpYnV0ZXMuZCwgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbixcbiAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heDtcblxuICBpZiAoZmFicmljLkdyb3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyb3VwIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuR3JvdXBcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAbWl4ZXMgZmFicmljLkNvbGxlY3Rpb25cbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZ3JvdXBzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuR3JvdXAjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Hcm91cCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIGZhYnJpYy5Db2xsZWN0aW9uLCAvKiogQGxlbmRzIGZhYnJpYy5Hcm91cC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdncm91cCcsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZVdpZHRoOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGNsaWNrLCBtb3VzZW92ZXIsIG1vdXNlb3V0IGV2ZW50cyAmIGhvdmVyQ3Vyc29yIHNob3VsZCBhbHNvIGNoZWNrIGZvciBzdWJ0YXJnZXRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3ViVGFyZ2V0Q2hlY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogR3JvdXBzIGFyZSBjb250YWluZXIsIGRvIG5vdCByZW5kZXIgYW55dGhpbmcgb24gdGhleXIgb3duLCBlbmNlIG5vIGNhY2hlIHByb3BlcnRpZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIHNldE9uR3JvdXAgaXMgYSBtZXRob2QgdXNlZCBmb3IgVGV4dEJveCB0aGF0IGlzIG5vIG1vcmUgdXNlZCBzaW5jZSAyLjAuMCBUaGUgYmVoYXZpb3IgaXMgc3RpbGxcbiAgICAgKiBhdmFpbGFibGUgc2V0dGluZyB0aGlzIGJvb2xlYW4gdG8gdHJ1ZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1c2VTZXRPbkdyb3VwOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdHMgR3JvdXAgb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0FscmVhZHlHcm91cGVkXSBpZiB0cnVlLCBvYmplY3RzIGhhdmUgYmVlbiBncm91cGVkIGFscmVhZHkuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob2JqZWN0cywgb3B0aW9ucywgaXNBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICAvLyBpZiBvYmplY3RzIGVuY2xvc2VkIGluIGEgZ3JvdXAgaGF2ZSBiZWVuIGdyb3VwZWQgYWxyZWFkeSxcbiAgICAgIC8vIHdlIGNhbm5vdCBjaGFuZ2UgcHJvcGVydGllcyBvZiBvYmplY3RzLlxuICAgICAgLy8gVGh1cyB3ZSBuZWVkIHRvIHNldCBvcHRpb25zIHRvIGdyb3VwIHdpdGhvdXQgb2JqZWN0cyxcbiAgICAgIGlzQWxyZWFkeUdyb3VwZWQgJiYgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmdyb3VwID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0FscmVhZHlHcm91cGVkKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuY2VudGVyUG9pbnQ7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gc2V0IG9yaWdpbnMgYmVmb3JlIGNhbGN1bGF0aW5nIHRoZSBib3VuZGluZyBib3guXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIHRvcGxlZnQgY2FuIGJlIHNldCB3aXRoIHRoYXQgaW4gbWluZC5cbiAgICAgICAgLy8gaWYgc3BlY2lmaWMgdG9wIGFuZCBsZWZ0IGFyZSBwYXNzZWQsIGFyZSBvdmVyd3JpdHRlbiBsYXRlclxuICAgICAgICAvLyB3aXRoIHRoZSBjYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKVxuICAgICAgICBpZiAob3B0aW9ucy5vcmlnaW5YICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpblggPSBvcHRpb25zLm9yaWdpblg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5ZID0gb3B0aW9ucy5vcmlnaW5ZO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGNvbWluZyBmcm9tIHN2ZyBpIGRvIG5vdCB3YW50IHRvIGNhbGMgYm91bmRzLlxuICAgICAgICAvLyBpIGFzc3VtZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBwYXNzZWQgYWxvbmcgb3B0aW9uc1xuICAgICAgICBjZW50ZXIgfHwgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKGNlbnRlcik7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmNlbnRlclBvaW50O1xuICAgICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNBQ29vcmRzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdHNBQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBza2lwQ29udHJvbHMgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICl7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uc2V0Q29vcmRzKHNraXBDb250cm9scyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENvb3Jkc0NoYW5nZV0gaWYgdHJ1ZSwgY29vcmRpbmF0ZXMgb2Ygb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwIGRvIG5vdCBjaGFuZ2VcbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0c0Nvb3JkczogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgICB2YXIgY2VudGVyID0gY2VudGVyIHx8IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApe1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RDb29yZHModGhpcy5fb2JqZWN0c1tpXSwgY2VudGVyKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciwgY3VycmVudCBjZW50ZXIgb2YgZ3JvdXAuXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdENvb3JkczogZnVuY3Rpb24ob2JqZWN0LCBjZW50ZXIpIHtcbiAgICAgIHZhciBvYmplY3RMZWZ0ID0gb2JqZWN0LmxlZnQsXG4gICAgICAgICAgb2JqZWN0VG9wID0gb2JqZWN0LnRvcCxcbiAgICAgICAgICBza2lwQ29udHJvbHMgPSB0cnVlO1xuXG4gICAgICBvYmplY3Quc2V0KHtcbiAgICAgICAgbGVmdDogb2JqZWN0TGVmdCAtIGNlbnRlci54LFxuICAgICAgICB0b3A6IG9iamVjdFRvcCAtIGNlbnRlci55XG4gICAgICB9KTtcbiAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICBvYmplY3Quc2V0Q29vcmRzKHNraXBDb250cm9scyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VuYXRpb24gb2YgYSBncm91cFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkdyb3VwOiAoJyArIHRoaXMuY29tcGxleGl0eSgpICsgJyk+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBvYmplY3QgdG8gYSBncm91cDsgVGhlbiByZWNhbGN1bGF0ZXMgZ3JvdXAncyBkaW1lbnNpb24sIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYWRkV2l0aFVwZGF0ZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgbmVzdGVkID0gISF0aGlzLmdyb3VwO1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIGdyb3VwIGlzIGluc2lkZSBhbm90aGVyIGdyb3VwLCB3ZSBuZWVkIHRvIHByZSB0cmFuc2Zvcm0gdGhlIG9iamVjdFxuICAgICAgICAgIGZhYnJpYy51dGlsLnJlbW92ZVRyYW5zZm9ybUZyb21PYmplY3Qob2JqZWN0LCB0aGlzLmdyb3VwLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICAgIG9iamVjdC5fc2V0KCdjYW52YXMnLCB0aGlzLmNhbnZhcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgdGhpcy5ncm91cC5hZGRXaXRoVXBkYXRlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIG9iamVjdCBmcm9tIGEgZ3JvdXA7IFRoZW4gcmVjYWxjdWxhdGVzIGdyb3VwJ3MgZGltZW5zaW9uLCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbW92ZVdpdGhVcGRhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG5cbiAgICAgIHRoaXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25PYmplY3RBZGRlZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICBkZWxldGUgb2JqZWN0Lmdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy51c2VTZXRPbkdyb3VwKSB7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldE9uR3JvdXAoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLl9zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLl9zZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIF9pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICB2YXIgb2Jqc1RvT2JqZWN0ID0gdGhpcy5fb2JqZWN0c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gIW9iai5leGNsdWRlRnJvbUV4cG9ydDtcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsRGVmYXVsdHMgPSBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gX2luY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICAgIHZhciBfb2JqID0gb2JqLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgICAgcmV0dXJuIF9vYmo7XG4gICAgICAgIH0pO1xuICAgICAgdmFyIG9iaiA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBvYmoub2JqZWN0cyA9IG9ianNUb09iamVjdDtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlLCBpbiBkYXRhbGVzcyBtb2RlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmpzVG9PYmplY3QsIHNvdXJjZVBhdGggPSB0aGlzLnNvdXJjZVBhdGg7XG4gICAgICBpZiAoc291cmNlUGF0aCkge1xuICAgICAgICBvYmpzVG9PYmplY3QgPSBzb3VyY2VQYXRoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBfaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSB0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICBvYmpzVG9PYmplY3QgPSB0aGlzLl9vYmplY3RzLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxEZWZhdWx0cyA9IG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBfaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgdmFyIF9vYmogPSBvYmoudG9EYXRhbGVzc09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbERlZmF1bHRzO1xuICAgICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS50b0RhdGFsZXNzT2JqZWN0LmNhbGwodGhpcywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBvYmoub2JqZWN0cyA9IG9ianNUb09iamVjdDtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgaW5zdGFuY2Ugb24gYSBnaXZlbiBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBpbnN0YW5jZSBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdyZW5kZXInLCBjdHgpO1xuICAgICAgdGhpcy5fdHJhbnNmb3JtRG9uZSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBpcyBhbHJlYWR5IGNhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvd25DYWNoZSA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnNob3VsZENhY2hlLmNhbGwodGhpcyk7XG4gICAgICBpZiAob3duQ2FjaGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fb2JqZWN0c1tpXS53aWxsRHJhd1NoYWRvdygpKSB7XG4gICAgICAgICAgICB0aGlzLm93bkNhY2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvd25DYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3Qgb3IgYSBjaGlsZCBvYmplY3Qgd2lsbCBjYXN0IGEgc2hhZG93XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aWxsRHJhd1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZmFicmljLk9iamVjdC5wcm90b3R5cGUud2lsbERyYXdTaGFkb3cuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLndpbGxEcmF3U2hhZG93KCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGdyb3VwIG9yIGl0cyBwYXJlbnQgZ3JvdXAgYXJlIGNhY2hpbmcsIHJlY3Vyc2l2ZWx5IHVwXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09uQUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bkNhY2hpbmcgfHwgKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC5pc09uQUNhY2hlKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd09iamVjdDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnJlbmRlcihjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZHJhd0NsaXBQYXRoKGN0eCwgdGhpcy5jbGlwUGF0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNhY2hlIGlzIGRpcnR5XG4gICAgICovXG4gICAgaXNDYWNoZURpcnR5OiBmdW5jdGlvbihza2lwQ2FudmFzKSB7XG4gICAgICBpZiAodGhpcy5jYWxsU3VwZXIoJ2lzQ2FjaGVEaXJ0eScsIHNraXBDYW52YXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlZnVsbENhY2hlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLmlzQ2FjaGVEaXJ0eSh0cnVlKSkge1xuICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUNhbnZhcykge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBncm91cCBoYXMgbm90IGEgY2FjaGUgY2FudmFzIHRoZXJlIGlzIG5vdGhpbmcgdG8gY2xlYW5cbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5jYWNoZVdpZHRoIC8gdGhpcy56b29tWCwgeSA9IHRoaXMuY2FjaGVIZWlnaHQgLyB0aGlzLnpvb21ZO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LmNsZWFyUmVjdCgteCAvIDIsIC15IC8gMiwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIHN0YXRlIG9mIGVhY2ggb2YgZ3JvdXAgb2JqZWN0cyAob3JpZ2luYWwgc3RhdGUgaXMgdGhhdCB3aGljaCB3YXMgYmVmb3JlIGdyb3VwIHdhcyBjcmVhdGVkKS5cbiAgICAgKiBpZiB0aGUgbmVzdGVkIGJvb2xlYW4gaXMgdHJ1ZSwgdGhlIG9yaWdpbmFsIHN0YXRlIHdpbGwgYmUgcmVzdG9yZWQganVzdCBmb3IgdGhlXG4gICAgICogZmlyc3QgZ3JvdXAgYW5kIG5vdCBmb3IgYWxsIHRoZSBncm91cCBjaGFpblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBuZXN0ZWQgdGVsbCB0aGUgZnVuY3Rpb24gdG8gcmVzdG9yZSBvYmplY3Qgc3RhdGUgdXAgdG8gdGhlIHBhcmVudCBncm91cCBhbmQgbm90IG1vcmVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3Jlc3RvcmVPYmplY3RzU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGdyb3VwTWF0cml4ID0gdGhpcy5jYWxjT3duTWF0cml4KCk7XG4gICAgICB0aGlzLl9vYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgX3RoaXMgPSB0aGlzO1xuICAgICAgICBmYWJyaWMudXRpbC5hZGRUcmFuc2Zvcm1Ub09iamVjdChvYmplY3QsIGdyb3VwTWF0cml4KTtcbiAgICAgICAgZGVsZXRlIG9iamVjdC5ncm91cDtcbiAgICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBncm91cCAocmVzdG9yaW5nIHN0YXRlIG9mIGl0cyBvYmplY3RzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHdoZW4gZ3JvdXAgaXMgZGVzdHJveWVkIG9iamVjdHMgbmVlZHMgdG8gZ2V0IGEgcmVwYWludCB0byBiZSBldmVudHVhbGx5XG4gICAgICAvLyBkaXNwbGF5ZWQgb24gY2FudmFzLlxuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignZGlzcG9zZScpO1xuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LmRpc3Bvc2UgJiYgb2JqZWN0LmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgZ3JvdXAgYW4gYWN0aXZlIHNlbGVjdGlvbiwgcmVtb3ZlIHRoZSBncm91cCBmcm9tIGNhbnZhc1xuICAgICAqIHRoZSBncm91cCBoYXMgdG8gYmUgb24gY2FudmFzIGZvciB0aGlzIHRvIHdvcmsuXG4gICAgICogQHJldHVybiB7ZmFicmljLkFjdGl2ZVNlbGVjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB0b0FjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cywgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9iamVjdHM7XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gbmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oW10pO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnNldChvcHRpb25zKTtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi50eXBlID0gJ2FjdGl2ZVNlbGVjdGlvbic7XG4gICAgICBjYW52YXMucmVtb3ZlKHRoaXMpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSBhY3RpdmVTZWxlY3Rpb247XG4gICAgICAgIG9iamVjdC5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGNhbnZhcy5hZGQob2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cyA9IG9iamVjdHM7XG4gICAgICBjYW52YXMuX2FjdGl2ZU9iamVjdCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5zZXRDb29yZHMoKTtcbiAgICAgIHJldHVybiBhY3RpdmVTZWxlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGEgZ3JvdXAgKHJlc3RvcmluZyBzdGF0ZSBvZiBpdHMgb2JqZWN0cylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdW5ncm91cE9uQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29vcmRpbmF0ZXMgb2YgYWxsIG9iamVjdHMgaW5zaWRlIGdyb3VwXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldE9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNraXBDb250cm9scyA9IHRydWU7XG4gICAgICB0aGlzLmZvckVhY2hPYmplY3QoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5zZXRDb29yZHMoc2tpcENvbnRyb2xzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNCb3VuZHM6IGZ1bmN0aW9uKG9ubHlXaWR0aEhlaWdodCkge1xuICAgICAgdmFyIGFYID0gW10sXG4gICAgICAgICAgYVkgPSBbXSxcbiAgICAgICAgICBvLCBwcm9wLCBjb29yZHMsXG4gICAgICAgICAgcHJvcHMgPSBbJ3RyJywgJ2JyJywgJ2JsJywgJ3RsJ10sXG4gICAgICAgICAgaSA9IDAsIGlMZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aCxcbiAgICAgICAgICBqLCBqTGVuID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKCA7IGkgPCBpTGVuOyArK2kpIHtcbiAgICAgICAgbyA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgIGNvb3JkcyA9IG8uY2FsY0FDb29yZHMoKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgICBhWC5wdXNoKGNvb3Jkc1twcm9wXS54KTtcbiAgICAgICAgICBhWS5wdXNoKGNvb3Jkc1twcm9wXS55KTtcbiAgICAgICAgfVxuICAgICAgICBvLmFDb29yZHMgPSBjb29yZHM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2dldEJvdW5kcyhhWCwgYVksIG9ubHlXaWR0aEhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24oYVgsIGFZLCBvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBtaW5YWSA9IG5ldyBmYWJyaWMuUG9pbnQobWluKGFYKSwgbWluKGFZKSksXG4gICAgICAgICAgbWF4WFkgPSBuZXcgZmFicmljLlBvaW50KG1heChhWCksIG1heChhWSkpLFxuICAgICAgICAgIHRvcCA9IG1pblhZLnkgfHwgMCwgbGVmdCA9IG1pblhZLnggfHwgMCxcbiAgICAgICAgICB3aWR0aCA9IChtYXhYWS54IC0gbWluWFkueCkgfHwgMCxcbiAgICAgICAgICBoZWlnaHQgPSAobWF4WFkueSAtIG1pblhZLnkpIHx8IDA7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGlmICghb25seVdpZHRoSGVpZ2h0KSB7XG4gICAgICAgIC8vIHRoZSBib3VuZGluZyBib3ggYWx3YXlzIGZpbmRzIHRoZSB0b3BsZWZ0IG1vc3QgY29ybmVyLlxuICAgICAgICAvLyB3aGF0ZXZlciBpcyB0aGUgZ3JvdXAgb3JpZ2luLCB3ZSBzZXQgdXAgaGVyZSB0aGUgbGVmdC90b3AgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbih7IHg6IGxlZnQsIHk6IHRvcCB9LCAnbGVmdCcsICd0b3AnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcgPSBbJzxnICcsICdDT01NT05fUEFSVFMnLCAnID5cXG4nXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3ZnU3RyaW5nLnB1c2goJ1xcdFxcdCcsIHRoaXMuX29iamVjdHNbaV0udG9TVkcocmV2aXZlcikpO1xuICAgICAgfVxuICAgICAgc3ZnU3RyaW5nLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIHJldHVybiBzdmdTdHJpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydCwgc3BlY2lmaWMgdmVyc2lvbiBmb3IgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcGFjaXR5ID0gdHlwZW9mIHRoaXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5vcGFjaXR5ICE9PSAxID9cbiAgICAgICAgICAgICdvcGFjaXR5OiAnICsgdGhpcy5vcGFjaXR5ICsgJzsnIDogJycsXG4gICAgICAgICAgdmlzaWJpbGl0eSA9IHRoaXMudmlzaWJsZSA/ICcnIDogJyB2aXNpYmlsaXR5OiBoaWRkZW47JztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgIHZpc2liaWxpdHlcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIGNsaXBQYXRoIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvQ2xpcFBhdGhTVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3ZnU3RyaW5nLnB1c2goJ1xcdCcsIHRoaXMuX29iamVjdHNbaV0udG9DbGlwUGF0aFNWRyhyZXZpdmVyKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAoc3ZnU3RyaW5nLCB7IHJldml2ZXI6IHJldml2ZXIgfSk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5Hcm91cH0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkdyb3VwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyb3VwIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBncm91cCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuR3JvdXAuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2JqZWN0cyA9IG9iamVjdC5vYmplY3RzLFxuICAgICAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9iamVjdCwgdHJ1ZSk7XG4gICAgZGVsZXRlIG9wdGlvbnMub2JqZWN0cztcbiAgICBpZiAodHlwZW9mIG9iamVjdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBpdCBoYXMgdG8gYmUgYW4gdXJsIG9yIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgZmFicmljLmxvYWRTVkdGcm9tVVJMKG9iamVjdHMsIGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBmYWJyaWMudXRpbC5ncm91cFNWR0VsZW1lbnRzKGVsZW1lbnRzLCBvYmplY3QsIG9iamVjdHMpO1xuICAgICAgICBncm91cC5zZXQob3B0aW9ucyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGdyb3VwKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhvYmplY3RzLCBmdW5jdGlvbiAoZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9iamVjdHM7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0RW5saXZhYmxlcyhvYmplY3QsIG9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5Hcm91cChlbmxpdmVuZWRPYmplY3RzLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyb3VwIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uXG4gICAqIEBleHRlbmRzIGZhYnJpYy5Hcm91cFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNncm91cHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuR3JvdXAsIC8qKiBAbGVuZHMgZmFicmljLkFjdGl2ZVNlbGVjdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdhY3RpdmVTZWxlY3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0cyBBY3RpdmVTZWxlY3Rpb24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvYmplY3RzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmdyb3VwID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWCkge1xuICAgICAgICB0aGlzLm9yaWdpblggPSBvcHRpb25zLm9yaWdpblg7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vcmlnaW5ZKSB7XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IG9wdGlvbnMub3JpZ2luWTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0ZSBhY3RpdmVTZWxlY3Rpb24gdG8gYSBub3JtYWwgZ3JvdXAsXG4gICAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0aGF0IGF1dG9tYXRpY2FsbHkgYWRkcyBpdCB0byBjYW52YXMgYXNcbiAgICAgKiBhY3RpdmUgb2JqZWN0LiBubyBldmVudHMgZmlyZWQuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfVxuICAgICAqL1xuICAgIHRvR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLmNvbmNhdCgpO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuICAgICAgdmFyIG5ld0dyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChbXSk7XG4gICAgICBkZWxldGUgb3B0aW9ucy50eXBlO1xuICAgICAgbmV3R3JvdXAuc2V0KG9wdGlvbnMpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuY2FudmFzLnJlbW92ZShvYmplY3QpO1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSBuZXdHcm91cDtcbiAgICAgIH0pO1xuICAgICAgbmV3R3JvdXAuX29iamVjdHMgPSBvYmplY3RzO1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gbmV3R3JvdXA7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBjYW52YXMuYWRkKG5ld0dyb3VwKTtcbiAgICAgIGNhbnZhcy5fYWN0aXZlT2JqZWN0ID0gbmV3R3JvdXA7XG4gICAgICBuZXdHcm91cC5zZXRDb29yZHMoKTtcbiAgICAgIHJldHVybiBuZXdHcm91cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgcmV0dXJucyB0cnVlLCBkZXNlbGVjdGlvbiBpcyBjYW5jZWxsZWQuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gW2NhbmNlbF1cbiAgICAgKi9cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuQWN0aXZlU2VsZWN0aW9uOiAoJyArIHRoaXMuY29tcGxleGl0eSgpICsgJyk+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBvYmplY3RDYWNoaW5nIGlzIGEgZ2xvYmFsIGZsYWcsIHdpbnMgb3ZlciBldmVyeXRoaW5nXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGdyb3VwIG9yIGl0cyBwYXJlbnQgZ3JvdXAgYXJlIGNhY2hpbmcsIHJlY3Vyc2l2ZWx5IHVwXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09uQUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2hpbGRyZW5PdmVycmlkZV0gcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgY2hpbGRyZW4gb3ZlcnJpZGVzXG4gICAgICovXG4gICAgX3JlbmRlckNvbnRyb2xzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUsIGNoaWxkcmVuT3ZlcnJpZGUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlckNvbnRyb2xzJywgY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGNoaWxkcmVuT3ZlcnJpZGUgPSBjaGlsZHJlbk92ZXJyaWRlIHx8IHsgfTtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW5PdmVycmlkZS5oYXNDb250cm9scyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2hpbGRyZW5PdmVycmlkZS5oYXNDb250cm9scyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW5PdmVycmlkZS5mb3JBY3RpdmVTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5fcmVuZGVyQ29udHJvbHMoY3R4LCBjaGlsZHJlbk92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb259IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JvdXAgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIEFjdGl2ZVNlbGVjdGlvbiBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0Lm9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3Qub2JqZWN0cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGVubGl2ZW5lZE9iamVjdHMsIG9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoIWdsb2JhbC5mYWJyaWMpIHtcbiAgICBnbG9iYWwuZmFicmljID0geyB9O1xuICB9XG5cbiAgaWYgKGdsb2JhbC5mYWJyaWMuSW1hZ2UpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkltYWdlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW1hZ2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI2ltYWdlc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZS5cbiAgICAgKiBGb3IgaW1hZ2UgcXVhbGl0eSBhIHN0cm9rZSBtdWx0aXBsZSBvZiAyIGdpdmVzIGJldHRlciByZXN1bHRzLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNhbGxpbmcge0BsaW5rIGZhYnJpYy5JbWFnZS5nZXRTcmN9LCByZXR1cm4gdmFsdWUgZnJvbSBlbGVtZW50IHNyYyB3aXRoIGBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJylgLlxuICAgICAqIFRoaXMgYWxsb3dzIGZvciByZWxhdGl2ZSB1cmxzIGFzIGltYWdlIHNyYy5cbiAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzcmNGcm9tQXR0cmlidXRlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxlWCB0byBkZXRlY3RcbiAgICAgKiBpZiB0aGUgSW1hZ2UgZ290IHJlc2l6ZWQgYWZ0ZXIgdGhlIGxhc3QgUmVuZGVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2xhc3RTY2FsZVg6IDEsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsZVkgdG8gZGV0ZWN0XG4gICAgICogaWYgdGhlIEltYWdlIGdvdCByZXNpemVkIGFmdGVyIHRoZSBsYXN0IFJlbmRlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9sYXN0U2NhbGVZOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGluZyBhcHBsaWVkIGJ5IHRoZSBhcHBseSBmaWx0ZXIgY2hhaW5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfZmlsdGVyU2NhbGluZ1g6IDEsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsaW5nIGFwcGxpZWQgYnkgdGhlIGFwcGx5IGZpbHRlciBjaGFpblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9maWx0ZXJTY2FsaW5nWTogMSxcblxuICAgIC8qKlxuICAgICAqIG1pbmltdW0gc2NhbGUgZmFjdG9yIHVuZGVyIHdoaWNoIGFueSByZXNpemVGaWx0ZXIgaXMgdHJpZ2dlcmVkIHRvIHJlc2l6ZSB0aGUgaW1hZ2VcbiAgICAgKiAwIHdpbGwgZGlzYWJsZSB0aGUgYXV0b21hdGljIHJlc2l6ZS4gMSB3aWxsIHRyaWdnZXIgYXV0b21hdGljYWxseSBhbHdheXMuXG4gICAgICogbnVtYmVyIGJpZ2dlciB0aGFuIDEgYXJlIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgbWluaW11bVNjYWxlVHJpZ2dlcjogMC41LFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWZcbiAgICAgKiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ2Nyb3BYJywgJ2Nyb3BZJyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBjYWNoZSBuZWVkcyByZWZyZXNoXG4gICAgICogVGhvc2UgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBieSBzdGF0ZWZ1bGxDYWNoZSBPTiAoIG9yIGxhenkgbW9kZSBpZiB3ZSB3YW50ICkgb3IgZnJvbSBzaW5nbGVcbiAgICAgKiBjYWxscyB0byBPYmplY3Quc2V0KGtleSwgdmFsdWUpLiBJZiB0aGUga2V5IGlzIGluIHRoaXMgbGlzdCwgdGhlIG9iamVjdCBpcyBtYXJrZWQgYXMgZGlydHlcbiAgICAgKiBhbmQgcmVmcmVzaGVkIGF0IHRoZSBuZXh0IHJlbmRlclxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdjcm9wWCcsICdjcm9wWScpLFxuXG4gICAgLyoqXG4gICAgICoga2V5IHVzZWQgdG8gcmV0cmlldmUgdGhlIHRleHR1cmUgcmVwcmVzZW50aW5nIHRoaXMgaW1hZ2VcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hlS2V5OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNyb3AgaW4gcGl4ZWxzIGZyb20gb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3BYOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgY3JvcCBpbiBwaXhlbHMgZnJvbSBvcmlnaW5hbCBpbWFnZSBzaXplLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3JvcFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNhbnZhcyB3aWxsIHVzZSBpbWFnZSBzbW9vdGhpbmcgd2hlbiBwYWludGluZyB0aGlzIGltYWdlLlxuICAgICAqIEFsc28gaW5mbHVlbmNlIGlmIHRoZSBjYWNoZUNhbnZhcyBmb3IgdGhpcyBpbWFnZSB1c2VzIGltYWdlU21vb3RoaW5nXG4gICAgICogQHNpbmNlIDQuMC4wLWJldGEuMTFcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbWFnZVNtb290aGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogSW1hZ2UgY2FuIGJlIGluaXRpYWxpemVkIHdpdGggYW55IGNhbnZhcyBkcmF3YWJsZSBvciBhIHN0cmluZy5cbiAgICAgKiBUaGUgc3RyaW5nIHNob3VsZCBiZSBhIHVybCBhbmQgd2lsbCBiZSBsb2FkZWQgYXMgYW4gaW1hZ2UuXG4gICAgICogQ2FudmFzIGFuZCBJbWFnZSBlbGVtZW50IHdvcmsgb3V0IG9mIHRoZSBib3gsIHdoaWxlIHZpZGVvcyByZXF1aXJlIGV4dHJhIGNvZGUgdG8gd29yay5cbiAgICAgKiBQbGVhc2UgY2hlY2sgdmlkZW8gZWxlbWVudCBldmVudHMgZm9yIHNlZWtpbmcuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50IHwgU3RyaW5nfSBlbGVtZW50IEltYWdlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIGV2ZW50dWFsIGZpbHRlcnMgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgICAgdGhpcy5jYWNoZUtleSA9ICd0ZXh0dXJlJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0RWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbWFnZSBlbGVtZW50IHdoaWNoIHRoaXMgaW5zdGFuY2UgaWYgYmFzZWQgb25cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBJbWFnZSBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudCB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpbWFnZSBlbGVtZW50IGZvciB0aGlzIGluc3RhbmNlIHRvIGEgc3BlY2lmaWVkIG9uZS5cbiAgICAgKiBJZiBmaWx0ZXJzIGRlZmluZWQgdGhleSBhcmUgYXBwbGllZCB0byBuZXcgaW1hZ2UuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgY2FudmFzLnJlbmRlckFsbGAgYW5kIGBvYmplY3Quc2V0Q29vcmRzYCBhZnRlciByZXBsYWNpbmcsIHRvIHJlbmRlciBuZXcgaW1hZ2UgYW5kIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkpO1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9pbml0Q29uZmlnKG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMuZmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlcnMoKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlc2l6ZUZpbHRlcnMgd29yayBvbiB0aGUgYWxyZWFkeSBmaWx0ZXJlZCBjb3B5LlxuICAgICAgLy8gd2UgbmVlZCB0byBhcHBseSByZXNpemVGaWx0ZXJzIEFGVEVSIG5vcm1hbCBmaWx0ZXJzLlxuICAgICAgLy8gYXBwbHlSZXNpemVGaWx0ZXJzIGlzIHJ1biBtb3JlIG9mdGVuIHRoYW4gbm9ybWFsIGZpbHRlcnNcbiAgICAgIC8vIGFuZCBpcyB0cmlnZ2VyZWQgYnkgdXNlciBpbnRlcmFjdGlvbnMgcmF0aGVyIHRoYW4gZGV2IGNvZGVcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICB0aGlzLmFwcGx5UmVzaXplRmlsdGVycygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHNpbmdsZSB0ZXh0dXJlIGlmIGluIHdlYmdsIG1vZGVcbiAgICAgKi9cbiAgICByZW1vdmVUZXh0dXJlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBiYWNrZW5kID0gZmFicmljLmZpbHRlckJhY2tlbmQ7XG4gICAgICBpZiAoYmFja2VuZCAmJiBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KSB7XG4gICAgICAgIGJhY2tlbmQuZXZpY3RDYWNoZXNGb3JLZXkoa2V5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRleHR1cmVzLCByZWZlcmVuY2UgdG8gZWxlbWVudHMgYW5kIGV2ZW50dWFsbHkgSlNET00gY2xlYW51cFxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdkaXNwb3NlJyk7XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSk7XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKTtcbiAgICAgIHRoaXMuX2NhY2hlQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIFsnX29yaWdpbmFsRWxlbWVudCcsICdfZWxlbWVudCcsICdfZmlsdGVyZWRFbCcsICdfY2FjaGVDYW52YXMnXS5mb3JFYWNoKChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpc1tlbGVtZW50XSk7XG4gICAgICAgIHRoaXNbZWxlbWVudF0gPSB1bmRlZmluZWQ7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjcm9zc09yaWdpbiB2YWx1ZSAob2YgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZWxlbWVudClcbiAgICAgKi9cbiAgICBnZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxFbGVtZW50ICYmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnQuY3Jvc3NPcmlnaW4gfHwgbnVsbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb3JpZ2luYWwgc2l6ZSBvZiBhbiBpbWFnZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggXCJ3aWR0aFwiIGFuZCBcImhlaWdodFwiIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRPcmlnaW5hbFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBlbGVtZW50Lm5hdHVyYWxXaWR0aCB8fCBlbGVtZW50LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGVsZW1lbnQubmF0dXJhbEhlaWdodCB8fCBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3N0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHcgPSB0aGlzLndpZHRoIC8gMiwgaCA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oLXcsIC1oKTtcbiAgICAgIGN0eC5saW5lVG8odywgLWgpO1xuICAgICAgY3R4LmxpbmVUbyh3LCBoKTtcbiAgICAgIGN0eC5saW5lVG8oLXcsIGgpO1xuICAgICAgY3R4LmxpbmVUbygtdywgLWgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgZmlsdGVycyA9IFtdO1xuXG4gICAgICB0aGlzLmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXJPYmopIHtcbiAgICAgICAgaWYgKGZpbHRlck9iaikge1xuICAgICAgICAgIGZpbHRlcnMucHVzaChmaWx0ZXJPYmoudG9PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9iamVjdCA9IGV4dGVuZChcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoXG4gICAgICAgICAgJ3RvT2JqZWN0JyxcbiAgICAgICAgICBbJ2Nyb3BYJywgJ2Nyb3BZJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICksIHtcbiAgICAgICAgICBzcmM6IHRoaXMuZ2V0U3JjKCksXG4gICAgICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuZ2V0Q3Jvc3NPcmlnaW4oKSxcbiAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICBvYmplY3QucmVzaXplRmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIudG9PYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbWFnZSBoYXMgY3JvcCBhcHBsaWVkLCBpbnNwZWN0aW5nIHZhbHVlcyBvZiBjcm9wWCxjcm9wWSx3aWR0aCxoZWlnaHQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDcm9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyb3BYIHx8IHRoaXMuY3JvcFkgfHwgdGhpcy53aWR0aCA8IHRoaXMuX2VsZW1lbnQud2lkdGggfHwgdGhpcy5oZWlnaHQgPCB0aGlzLl9lbGVtZW50LmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gW10sIGltYWdlTWFya3VwID0gW10sIHN0cm9rZVN2ZywgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgeCA9IC10aGlzLndpZHRoIC8gMiwgeSA9IC10aGlzLmhlaWdodCAvIDIsIGNsaXBQYXRoID0gJycsIGltYWdlUmVuZGVyaW5nID0gJyc7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzQ3JvcCgpKSB7XG4gICAgICAgIHZhciBjbGlwUGF0aElkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgICBzdmdTdHJpbmcucHVzaChcbiAgICAgICAgICAnPGNsaXBQYXRoIGlkPVwiaW1hZ2VDcm9wXycgKyBjbGlwUGF0aElkICsgJ1wiPlxcbicsXG4gICAgICAgICAgJ1xcdDxyZWN0IHg9XCInICsgeCArICdcIiB5PVwiJyArIHkgKyAnXCIgd2lkdGg9XCInICsgdGhpcy53aWR0aCArICdcIiBoZWlnaHQ9XCInICsgdGhpcy5oZWlnaHQgKyAnXCIgLz5cXG4nLFxuICAgICAgICAgICc8L2NsaXBQYXRoPlxcbidcbiAgICAgICAgKTtcbiAgICAgICAgY2xpcFBhdGggPSAnIGNsaXAtcGF0aD1cInVybCgjaW1hZ2VDcm9wXycgKyBjbGlwUGF0aElkICsgJylcIiAnO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmltYWdlU21vb3RoaW5nKSB7XG4gICAgICAgIGltYWdlUmVuZGVyaW5nID0gJ1wiIGltYWdlLXJlbmRlcmluZz1cIm9wdGltaXplU3BlZWQnO1xuICAgICAgfVxuICAgICAgaW1hZ2VNYXJrdXAucHVzaCgnXFx0PGltYWdlICcsICdDT01NT05fUEFSVFMnLCAneGxpbms6aHJlZj1cIicsIHRoaXMuZ2V0U3ZnU3JjKHRydWUpLFxuICAgICAgICAnXCIgeD1cIicsIHggLSB0aGlzLmNyb3BYLCAnXCIgeT1cIicsIHkgLSB0aGlzLmNyb3BZLFxuICAgICAgICAvLyB3ZSdyZSBlc3NlbnRpYWxseSBtb3Zpbmcgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIGZyb20gdG9wL2xlZnQgY29ybmVyIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlXG4gICAgICAgIC8vIGJ5IHdyYXBwaW5nIGl0IGluIGNvbnRhaW5lciA8Zz4gZWxlbWVudCB3aXRoIGFjdHVhbCB0cmFuc2Zvcm1hdGlvbiwgdGhlbiBvZmZzZXR0aW5nIG9iamVjdCB0byB0aGUgdG9wL2xlZnRcbiAgICAgICAgLy8gc28gdGhhdCBvYmplY3QncyBjZW50ZXIgYWxpZ25zIHdpdGggY29udGFpbmVyJ3MgbGVmdC90b3BcbiAgICAgICAgJ1wiIHdpZHRoPVwiJywgZWxlbWVudC53aWR0aCB8fCBlbGVtZW50Lm5hdHVyYWxXaWR0aCxcbiAgICAgICAgJ1wiIGhlaWdodD1cIicsIGVsZW1lbnQuaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBpbWFnZVJlbmRlcmluZyxcbiAgICAgICAgJ1wiJywgY2xpcFBhdGgsXG4gICAgICAgICc+PC9pbWFnZT5cXG4nKTtcblxuICAgICAgaWYgKHRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlRGFzaEFycmF5KSB7XG4gICAgICAgIHZhciBvcmlnRmlsbCA9IHRoaXMuZmlsbDtcbiAgICAgICAgdGhpcy5maWxsID0gbnVsbDtcbiAgICAgICAgc3Ryb2tlU3ZnID0gW1xuICAgICAgICAgICdcXHQ8cmVjdCAnLFxuICAgICAgICAgICd4PVwiJywgeCwgJ1wiIHk9XCInLCB5LFxuICAgICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgICB0aGlzLmZpbGwgPSBvcmlnRmlsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJykge1xuICAgICAgICBzdmdTdHJpbmcgPSBzdmdTdHJpbmcuY29uY2F0KHN0cm9rZVN2ZywgaW1hZ2VNYXJrdXApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IHN2Z1N0cmluZy5jb25jYXQoaW1hZ2VNYXJrdXAsIHN0cm9rZVN2Zyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ZnU3RyaW5nO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmlsdGVyZWQgaW5kaWNhdGVzIGlmIHRoZSBzcmMgaXMgbmVlZGVkIGZvciBzdmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqL1xuICAgIGdldFNyYzogZnVuY3Rpb24oZmlsdGVyZWQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZmlsdGVyZWQgPyB0aGlzLl9lbGVtZW50IDogdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudG9EYXRhVVJMKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQudG9EYXRhVVJMKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zcmNGcm9tQXR0cmlidXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5zcmM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zcmMgfHwgJyc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc291cmNlIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBTb3VyY2Ugc3RyaW5nIChVUkwpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gaW1hZ2UgaGFzIGJlZW4gbG9hZGVkIChhbmQgYWxsIGZpbHRlcnMgaGF2ZSBiZWVuIGFwcGxpZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gdmFsdWUgKG9uZSBvZiBcIlwiLCBcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiKVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTcmM6IGZ1bmN0aW9uKHNyYywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShzcmMsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQoaW1nLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQoKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcywgaXNFcnJvcik7XG4gICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkltYWdlOiB7IHNyYzogXCInICsgdGhpcy5nZXRTcmMoKSArICdcIiB9Pic7XG4gICAgfSxcblxuICAgIGFwcGx5UmVzaXplRmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIsXG4gICAgICAgICAgbWluaW11bVNjYWxlID0gdGhpcy5taW5pbXVtU2NhbGVUcmlnZ2VyLFxuICAgICAgICAgIG9iamVjdFNjYWxlID0gdGhpcy5nZXRUb3RhbE9iamVjdFNjYWxpbmcoKSxcbiAgICAgICAgICBzY2FsZVggPSBvYmplY3RTY2FsZS5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gb2JqZWN0U2NhbGUuc2NhbGVZLFxuICAgICAgICAgIGVsZW1lbnRUb0ZpbHRlciA9IHRoaXMuX2ZpbHRlcmVkRWwgfHwgdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZpbHRlciB8fCAoc2NhbGVYID4gbWluaW11bVNjYWxlICYmIHNjYWxlWSA+IG1pbmltdW1TY2FsZSkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRUb0ZpbHRlcjtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDE7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVggPSBzY2FsZVg7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZmFicmljLmZpbHRlckJhY2tlbmQpIHtcbiAgICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQgPSBmYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXNFbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICBjYWNoZUtleSA9IHRoaXMuX2ZpbHRlcmVkRWwgPyAodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKSA6IHRoaXMuY2FjaGVLZXksXG4gICAgICAgICAgc291cmNlV2lkdGggPSBlbGVtZW50VG9GaWx0ZXIud2lkdGgsIHNvdXJjZUhlaWdodCA9IGVsZW1lbnRUb0ZpbHRlci5oZWlnaHQ7XG4gICAgICBjYW52YXNFbC53aWR0aCA9IHNvdXJjZVdpZHRoO1xuICAgICAgY2FudmFzRWwuaGVpZ2h0ID0gc291cmNlSGVpZ2h0O1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGNhbnZhc0VsO1xuICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IGZpbHRlci5zY2FsZVggPSBzY2FsZVg7XG4gICAgICB0aGlzLl9sYXN0U2NhbGVZID0gZmlsdGVyLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kLmFwcGx5RmlsdGVycyhcbiAgICAgICAgW2ZpbHRlcl0sIGVsZW1lbnRUb0ZpbHRlciwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGhpcy5fZWxlbWVudCwgY2FjaGVLZXkpO1xuICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSBjYW52YXNFbC53aWR0aCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aDtcbiAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gY2FudmFzRWwuaGVpZ2h0IC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXJzIGFzc2lnbmVkIHRvIHRoaXMgaW1hZ2UgKGZyb20gXCJmaWx0ZXJzXCIgYXJyYXkpIG9yIGZyb20gZmlsdGVyIHBhcmFtXG4gICAgICogQG1ldGhvZCBhcHBseUZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIHRvIGJlIGFwcGxpZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvclJlc2l6aW5nIHNwZWNpZnkgaWYgdGhlIGZpbHRlciBvcGVyYXRpb24gaXMgYSByZXNpemUgb3BlcmF0aW9uXG4gICAgICogQHJldHVybiB7dGhpc0FyZ30gcmV0dXJuIHRoZSBmYWJyaWMuSW1hZ2Ugb2JqZWN0XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycykge1xuXG4gICAgICBmaWx0ZXJzID0gZmlsdGVycyB8fCB0aGlzLmZpbHRlcnMgfHwgW107XG4gICAgICBmaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoZnVuY3Rpb24oZmlsdGVyKSB7IHJldHVybiBmaWx0ZXIgJiYgIWZpbHRlci5pc05ldXRyYWxTdGF0ZSgpOyB9KTtcbiAgICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuXG4gICAgICAvLyBuZWVkcyB0byBjbGVhciBvdXQgb3IgV0VCR0wgd2lsbCBub3QgcmVzaXplIGNvcnJlY3RseVxuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG5cbiAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nRWxlbWVudCA9IHRoaXMuX29yaWdpbmFsRWxlbWVudCxcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGltZ0VsZW1lbnQubmF0dXJhbFdpZHRoIHx8IGltZ0VsZW1lbnQud2lkdGgsXG4gICAgICAgICAgc291cmNlSGVpZ2h0ID0gaW1nRWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IGltZ0VsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gdGhpcy5fb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICBjYW52YXNFbC53aWR0aCA9IHNvdXJjZVdpZHRoO1xuICAgICAgICBjYW52YXNFbC5oZWlnaHQgPSBzb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBjYW52YXNFbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGNsZWFyIHRoZSBleGlzdGluZyBlbGVtZW50IHRvIGdldCBuZXcgZmlsdGVyIGRhdGFcbiAgICAgICAgLy8gYWxzbyBkZXJlZmVyZW5jZSB0aGUgZXZlbnR1YWwgcmVzaXplZCBfZWxlbWVudFxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fZmlsdGVyZWRFbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbC5nZXRDb250ZXh0KCcyZCcpLmNsZWFyUmVjdCgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgICAgLy8gd2UgYWxzbyBuZWVkIHRvIHJlc2l6ZSBhZ2FpbiBhdCBuZXh0IHJlbmRlckFsbCwgc28gcmVtb3ZlIHNhdmVkIF9sYXN0U2NhbGVYL1lcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKCFmYWJyaWMuZmlsdGVyQmFja2VuZCkge1xuICAgICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZCA9IGZhYnJpYy5pbml0RmlsdGVyQmFja2VuZCgpO1xuICAgICAgfVxuICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQuYXBwbHlGaWx0ZXJzKFxuICAgICAgICBmaWx0ZXJzLCB0aGlzLl9vcmlnaW5hbEVsZW1lbnQsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRoaXMuX2VsZW1lbnQsIHRoaXMuY2FjaGVLZXkpO1xuICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aCAhPT0gdGhpcy5fZWxlbWVudC53aWR0aCB8fFxuICAgICAgICB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0ICE9PSB0aGlzLl9lbGVtZW50LmhlaWdodCkge1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IHRoaXMuX2VsZW1lbnQud2lkdGggLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQud2lkdGg7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gdGhpcy5fZWxlbWVudC5oZWlnaHQgLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgZmFicmljLnV0aWwuc2V0SW1hZ2VTbW9vdGhpbmcoY3R4LCB0aGlzLmltYWdlU21vb3RoaW5nKTtcbiAgICAgIGlmICh0aGlzLmlzTW92aW5nICE9PSB0cnVlICYmIHRoaXMucmVzaXplRmlsdGVyICYmIHRoaXMuX25lZWRzUmVzaXplKCkpIHtcbiAgICAgICAgdGhpcy5hcHBseVJlc2l6ZUZpbHRlcnMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0cm9rZShjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0IG9uIHRoZSB0YXJnZXQgY29udGV4dC5cbiAgICAgKiBpdCB3aWxsIHNldCB0aGUgaW1hZ2VTbW9vdGhpbmcgZm9yIHRoZSBkcmF3IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2FjaGVPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyhjdHgsIHRoaXMuaW1hZ2VTbW9vdGhpbmcpO1xuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuZHJhd0NhY2hlT25DYW52YXMuY2FsbCh0aGlzLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBUaGlzIGlzIHRoZSBzcGVjaWFsIGltYWdlIHZlcnNpb24gd2hlcmUgd2Ugd291bGQgbGlrZSB0byBhdm9pZCBjYWNoaW5nIHdoZXJlIHBvc3NpYmxlLlxuICAgICAqIEVzc2VudGlhbGx5IGltYWdlcyBkbyBub3QgYmVuZWZpdCBmcm9tIGNhY2hpbmcuIFRoZXkgbWF5IHJlcXVpcmUgY2FjaGluZywgYW5kIGluIHRoYXRcbiAgICAgKiBjYXNlIHdlIGRvIGl0LiBBbHNvIGNhY2hpbmcgYW4gaW1hZ2UgdXN1YWxseSBlbmRzIGluIGEgbG9zcyBvZiBkZXRhaWxzLlxuICAgICAqIEEgZnVsbCBwZXJmb3JtYW5jZSBhdWRpdCBzaG91bGQgYmUgZG9uZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5lZWRzSXRzT3duQ2FjaGUoKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlckZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGVsZW1lbnRUb0RyYXcgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgaWYgKCFlbGVtZW50VG9EcmF3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLl9maWx0ZXJTY2FsaW5nWCwgc2NhbGVZID0gdGhpcy5fZmlsdGVyU2NhbGluZ1ksXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodCwgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LFxuICAgICAgICAgIC8vIGNyb3AgdmFsdWVzIGNhbm5vdCBiZSBsZXNzZXIgdGhhbiAwLlxuICAgICAgICAgIGNyb3BYID0gbWF4KHRoaXMuY3JvcFgsIDApLCBjcm9wWSA9IG1heCh0aGlzLmNyb3BZLCAwKSxcbiAgICAgICAgICBlbFdpZHRoID0gZWxlbWVudFRvRHJhdy5uYXR1cmFsV2lkdGggfHwgZWxlbWVudFRvRHJhdy53aWR0aCxcbiAgICAgICAgICBlbEhlaWdodCA9IGVsZW1lbnRUb0RyYXcubmF0dXJhbEhlaWdodCB8fCBlbGVtZW50VG9EcmF3LmhlaWdodCxcbiAgICAgICAgICBzWCA9IGNyb3BYICogc2NhbGVYLFxuICAgICAgICAgIHNZID0gY3JvcFkgKiBzY2FsZVksXG4gICAgICAgICAgLy8gdGhlIHdpZHRoIGhlaWdodCBjYW5ub3QgZXhjZWVkIGVsZW1lbnQgd2lkdGgvaGVpZ2h0LCBzdGFydGluZyBmcm9tIHRoZSBjcm9wIG9mZnNldC5cbiAgICAgICAgICBzVyA9IG1pbih3ICogc2NhbGVYLCBlbFdpZHRoIC0gc1gpLFxuICAgICAgICAgIHNIID0gbWluKGggKiBzY2FsZVksIGVsSGVpZ2h0IC0gc1kpLFxuICAgICAgICAgIHggPSAtdyAvIDIsIHkgPSAtaCAvIDIsXG4gICAgICAgICAgbWF4RGVzdFcgPSBtaW4odywgZWxXaWR0aCAvIHNjYWxlWCAtIGNyb3BYKSxcbiAgICAgICAgICBtYXhEZXN0SCA9IG1pbihoLCBlbEhlaWdodCAvIHNjYWxlWSAtIGNyb3BZKTtcblxuICAgICAgZWxlbWVudFRvRHJhdyAmJiBjdHguZHJhd0ltYWdlKGVsZW1lbnRUb0RyYXcsIHNYLCBzWSwgc1csIHNILCB4LCB5LCBtYXhEZXN0VywgbWF4RGVzdEgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBuZWVkZWQgdG8gY2hlY2sgaWYgaW1hZ2UgbmVlZHMgcmVzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmVlZHNSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRUb3RhbE9iamVjdFNjYWxpbmcoKTtcbiAgICAgIHJldHVybiAoc2NhbGUuc2NhbGVYICE9PSB0aGlzLl9sYXN0U2NhbGVYIHx8IHNjYWxlLnNjYWxlWSAhPT0gdGhpcy5fbGFzdFNjYWxlWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXQodGhpcy5nZXRPcmlnaW5hbFNpemUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBJbWFnZSBjbGFzcydzIGluaXRpYWxpemF0aW9uIG1ldGhvZC4gVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseVxuICAgICAqIGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8U3RyaW5nfSBlbGVtZW50IFRoZSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldEVsZW1lbnQoZmFicmljLnV0aWwuZ2V0QnlJZChlbGVtZW50KSwgb3B0aW9ucyk7XG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh0aGlzLmdldEVsZW1lbnQoKSwgZmFicmljLkltYWdlLkNTU19DQU5WQVMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdENvbmZpZzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodChvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIGZhYnJpYy5JbWFnZS5maWx0ZXJzIGluc3RhbmNlcyBhcmUgY3JlYXRlZFxuICAgICAqL1xuICAgIF9pbml0RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChmaWx0ZXJzICYmIGZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKGZpbHRlcnMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgfSwgJ2ZhYnJpYy5JbWFnZS5maWx0ZXJzJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTZXQgdGhlIHdpZHRoIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBvYmplY3QsIHVzaW5nIHRoZSBlbGVtZW50IG9yIHRoZVxuICAgICAqIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB3aWR0aC9oZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIF9zZXRXaWR0aEhlaWdodDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB2YXIgZWwgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IGVsLm5hdHVyYWxXaWR0aCB8fCBlbC53aWR0aCB8fCAwO1xuICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBlbC5uYXR1cmFsSGVpZ2h0IHx8IGVsLmhlaWdodCB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb2Zmc2V0IGZvciBjZW50ZXIgYW5kIHNjYWxlIGZhY3RvciBmb3IgdGhlIGltYWdlIGluIG9yZGVyIHRvIHJlc3BlY3RcbiAgICAgKiB0aGUgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBBUiA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZSh0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJycpLFxuICAgICAgICAgIHJXaWR0aCA9IHRoaXMuX2VsZW1lbnQud2lkdGgsIHJIZWlnaHQgPSB0aGlzLl9lbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCBvZmZzZXRMZWZ0ID0gMCwgb2Zmc2V0VG9wID0gMCwgY3JvcFggPSAwLCBjcm9wWSA9IDAsXG4gICAgICAgICAgb2Zmc2V0LCBwV2lkdGggPSB0aGlzLndpZHRoLCBwSGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHBhcnNlZEF0dHJpYnV0ZXMgPSB7IHdpZHRoOiBwV2lkdGgsIGhlaWdodDogcEhlaWdodCB9O1xuICAgICAgaWYgKHBBUiAmJiAocEFSLmFsaWduWCAhPT0gJ25vbmUnIHx8IHBBUi5hbGlnblkgIT09ICdub25lJykpIHtcbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gZmFicmljLnV0aWwuZmluZFNjYWxlVG9GaXQodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gKHBXaWR0aCAtIHJXaWR0aCAqIHNjYWxlWCkgLyAyO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWluJykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IC1vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWF4Jykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ID0gKHBIZWlnaHQgLSBySGVpZ2h0ICogc2NhbGVZKSAvIDI7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgPSAtb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IGZhYnJpYy51dGlsLmZpbmRTY2FsZVRvQ292ZXIodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gcldpZHRoIC0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWlkJykge1xuICAgICAgICAgICAgY3JvcFggPSBvZmZzZXQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWCA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIGNyb3BYID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgPSBySGVpZ2h0IC0gcEhlaWdodCAvIHNjYWxlWTtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01pZCcpIHtcbiAgICAgICAgICAgIGNyb3BZID0gb2Zmc2V0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBjcm9wWSA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcldpZHRoID0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIHJIZWlnaHQgPSBwSGVpZ2h0IC8gc2NhbGVZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gcFdpZHRoIC8gcldpZHRoO1xuICAgICAgICBzY2FsZVkgPSBwSGVpZ2h0IC8gckhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByV2lkdGgsXG4gICAgICAgIGhlaWdodDogckhlaWdodCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICBvZmZzZXRUb3A6IG9mZnNldFRvcCxcbiAgICAgICAgY3JvcFg6IGNyb3BYLFxuICAgICAgICBjcm9wWTogY3JvcFlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVmYXVsdCBDU1MgY2xhc3MgbmFtZSBmb3IgY2FudmFzXG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyA9ICdjYW52YXMtaW1nJztcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGdldFNyY1xuICAgKiBAc3RhdGljXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLmdldFN2Z1NyYyA9IGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3JjO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBpbWFnZSBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKF9vYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdCA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShfb2JqZWN0KTtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob2JqZWN0LnNyYywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIG9iamVjdC5maWx0ZXJzLCBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgICAgIG9iamVjdC5maWx0ZXJzID0gZmlsdGVycyB8fCBbXTtcbiAgICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIFtvYmplY3QucmVzaXplRmlsdGVyXSwgZnVuY3Rpb24ocmVzaXplRmlsdGVycykge1xuICAgICAgICAgIG9iamVjdC5yZXNpemVGaWx0ZXIgPSByZXNpemVGaWx0ZXJzWzBdO1xuICAgICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RFbmxpdmFibGVzKG9iamVjdCwgb2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgZmFicmljLkltYWdlKGltZywgb2JqZWN0KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGltYWdlLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgbnVsbCwgb2JqZWN0LmNyb3NzT3JpZ2luKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UgZnJvbSBhbiBVUkwgc3RyaW5nXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gY3JlYXRlIGFuIGltYWdlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBjcmVhdGVkIChuZXdseSBjcmVhdGVkIGltYWdlIGlzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50KS4gU2Vjb25kIGFyZ3VtZW50IGlzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIG5vdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtpbWdPcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZyb21VUkwgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCBpbWdPcHRpb25zKSB7XG4gICAgZmFicmljLnV0aWwubG9hZEltYWdlKHVybCwgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlKGltZywgaW1nT3B0aW9ucyksIGlzRXJyb3IpO1xuICAgIH0sIG51bGwsIGltZ09wdGlvbnMgJiYgaW1nT3B0aW9ucy5jcm9zc09yaWdpbik7XG4gIH07XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuSW1hZ2UuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNJbWFnZUVsZW1lbnR9XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQVRUUklCVVRFX05BTUVTID1cbiAgICBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFxuICAgICAgJ3ggeSB3aWR0aCBoZWlnaHQgcHJlc2VydmVBc3BlY3RSYXRpbyB4bGluazpocmVmIGNyb3NzT3JpZ2luIGltYWdlLXJlbmRlcmluZycuc3BsaXQoJyAnKVxuICAgICk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5JbWFnZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGZhYnJpYy5JbWFnZSBvYmplY3QgaXMgY3JlYXRlZFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkltYWdlLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgZmFicmljLkltYWdlLmZyb21VUkwocGFyc2VkQXR0cmlidXRlc1sneGxpbms6aHJlZiddLCBjYWxsYmFjayxcbiAgICAgIGV4dGVuZCgob3B0aW9ucyA/IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKSA6IHsgfSksIHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlIHZhbHVlXG4gICAqL1xuICBfZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhbmdsZSA9IHRoaXMuYW5nbGUgJSAzNjA7XG4gICAgaWYgKGFuZ2xlID4gMCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGFuZ2xlIC0gMSkgLyA5MCkgKiA5MDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYW5nbGUgLyA5MCkgKiA5MDtcbiAgfSxcblxuICAvKipcbiAgICogU3RyYWlnaHRlbnMgYW4gb2JqZWN0IChyb3RhdGluZyBpdCBmcm9tIGN1cnJlbnQgYW5nbGUgdG8gb25lIG9mIDAsIDkwLCAxODAsIDI3MCwgZXRjLiBkZXBlbmRpbmcgb24gd2hpY2ggaXMgY2xvc2VyKVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHN0cmFpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0ZSh0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RyYWlnaHRlbn0gYnV0IHdpdGggYW5pbWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFja3MgT2JqZWN0IHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKi9cbiAgZnhTdHJhaWdodGVuOiBmdW5jdGlvbihjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHN0YXJ0VmFsdWU6IHRoaXMuZ2V0KCdhbmdsZScpLFxuICAgICAgZW5kVmFsdWU6IHRoaXMuX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuKCksXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfdGhpcy5yb3RhdGUodmFsdWUpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufSk7XG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBTdHJhaWdodGVucyBvYmplY3QsIHRoZW4gcmVyZW5kZXJzIGNhbnZhc1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc3RyYWlnaHRlblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHN0cmFpZ2h0ZW5PYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBvYmplY3Quc3RyYWlnaHRlbigpO1xuICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5zdHJhaWdodGVuT2JqZWN0fSwgYnV0IGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzdHJhaWdodGVuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICovXG4gIGZ4U3RyYWlnaHRlbk9iamVjdDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QuZnhTdHJhaWdodGVuKHtcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLnJlcXVlc3RSZW5kZXJBbGxCb3VuZFxuICAgIH0pO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB3ZWJnbCBzdXBwb3J0cyBjZXJ0YWluIHByZWNpc2lvblxuICAgKiBAcGFyYW0ge1dlYkdMfSBDYW52YXMgV2ViR0wgY29udGV4dCB0byB0ZXN0IG9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBQcmVjaXNpb24gdG8gdGVzdCBjYW4gYmUgYW55IG9mIGZvbGxvd2luZzogJ2xvd3AnLCAnbWVkaXVtcCcsICdoaWdocCdcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIFdlYkdMIHN1cHBvcnRzIGdpdmVuIHByZWNpc2lvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHRlc3RQcmVjaXNpb24oZ2wsIHByZWNpc2lvbil7XG4gICAgdmFyIGZyYWdtZW50U291cmNlID0gJ3ByZWNpc2lvbiAnICsgcHJlY2lzaW9uICsgJyBmbG9hdDtcXG52b2lkIG1haW4oKXt9JztcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgdGhpcyBmaWx0ZXJpbmcgYmFja2VuZCBpcyBzdXBwb3J0ZWQgYnkgdGhlIHVzZXIncyBicm93c2VyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGlsZVNpemUgY2hlY2sgaWYgdGhlIHRpbGVTaXplIGlzIHN1cHBvcnRlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgc3VwcG9ydHMgV2ViR0wuXG4gICAqL1xuICBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZCA9IGZ1bmN0aW9uKHRpbGVTaXplKSB7XG4gICAgaWYgKGZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGlsZVNpemUgPSB0aWxlU2l6ZSB8fCBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZS50aWxlU2l6ZTtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuICAgIHZhciBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmIChnbCkge1xuICAgICAgZmFicmljLm1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpO1xuICAgICAgaXNTdXBwb3J0ZWQgPSBmYWJyaWMubWF4VGV4dHVyZVNpemUgPj0gdGlsZVNpemU7XG4gICAgICB2YXIgcHJlY2lzaW9ucyA9IFsnaGlnaHAnLCAnbWVkaXVtcCcsICdsb3dwJ107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKyl7XG4gICAgICAgIGlmICh0ZXN0UHJlY2lzaW9uKGdsLCBwcmVjaXNpb25zW2ldKSl7XG4gICAgICAgICAgZmFicmljLndlYkdsUHJlY2lzaW9uID0gcHJlY2lzaW9uc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkO1xuICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgfTtcblxuICBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kID0gV2ViZ2xGaWx0ZXJCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBXZWJHTCBmaWx0ZXIgYmFja2VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIFdlYmdsRmlsdGVyQmFja2VuZChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aWxlU2l6ZSkge1xuICAgICAgdGhpcy50aWxlU2l6ZSA9IG9wdGlvbnMudGlsZVNpemU7XG4gICAgfVxuICAgIHRoaXMuc2V0dXBHTENvbnRleHQodGhpcy50aWxlU2l6ZSwgdGhpcy50aWxlU2l6ZSk7XG4gICAgdGhpcy5jYXB0dXJlR1BVSW5mbygpO1xuICB9O1xuXG4gIFdlYmdsRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQucHJvdG90eXBlICovIHtcblxuICAgIHRpbGVTaXplOiAyMDQ4LFxuXG4gICAgLyoqXG4gICAgICogRXhwZXJpbWVudGFsLiBUaGlzIG9iamVjdCBpcyBhIHNvcnQgb2YgcmVwb3NpdG9yeSBvZiBoZWxwIGxheWVycyB1c2VkIHRvIGF2b2lkXG4gICAgICogb2YgcmVjcmVhdGluZyB0aGVtIGR1cmluZyBmcmVxdWVudCBmaWx0ZXJpbmcuIElmIHlvdSBhcmUgcHJldmlld2luZyBhIGZpbHRlciB3aXRoXG4gICAgICogYSBzbGlkZXIgeW91IHByb2JhYmx5IGRvIG5vdCB3YW50IHRvIGNyZWF0ZSBoZWxwIGxheWVycyBldmVyeSBmaWx0ZXIgc3RlcC5cbiAgICAgKiBpbiB0aGlzIG9iamVjdCB0aGVyZSB3aWxsIGJlIGFwcGVuZGVkIHNvbWUgY2FudmFzZXMsIGNyZWF0ZWQgb25jZSwgcmVzaXplZCBzb21ldGltZXNcbiAgICAgKiBjbGVhcmVkIG5ldmVyLiBDbGVhcmluZyBpcyBsZWZ0IHRvIHRoZSBkZXZlbG9wZXIuXG4gICAgICoqL1xuICAgIHJlc291cmNlczoge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwIGEgV2ViR0wgY29udGV4dCBzdWl0YWJsZSBmb3IgZmlsdGVyaW5nLCBhbmQgYmluZCBhbnkgbmVlZGVkIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqL1xuICAgIHNldHVwR0xDb250ZXh0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuY3JlYXRlV2ViR0xDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHRoaXMuYVBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0pO1xuICAgICAgdGhpcy5jaG9vc2VGYXN0ZXN0Q29weUdMVG8yRE1ldGhvZCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGljayBhIG1ldGhvZCB0byBjb3B5IGRhdGEgZnJvbSBHTCBjb250ZXh0IHRvIDJkIGNhbnZhcy4gIEluIHNvbWUgYnJvd3NlcnMgdXNpbmdcbiAgICAgKiBwdXRJbWFnZURhdGEgaXMgZmFzdGVyIHRoYW4gZHJhd0ltYWdlIGZvciB0aGF0IHNwZWNpZmljIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBjaG9vc2VGYXN0ZXN0Q29weUdMVG8yRE1ldGhvZDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGNhbk1lYXN1cmVQZXJmID0gdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcsIGNhblVzZUltYWdlRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBJbWFnZURhdGEoMSwgMSk7XG4gICAgICAgIGNhblVzZUltYWdlRGF0YSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBjYW5Vc2VJbWFnZURhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhblVzZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhblVzZVVpbnQ4Q2xhbXBlZCA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgIGlmICghKGNhbk1lYXN1cmVQZXJmICYmIGNhblVzZUltYWdlRGF0YSAmJiBjYW5Vc2VBcnJheUJ1ZmZlciAmJiBjYW5Vc2VVaW50OENsYW1wZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldENhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGltYWdlQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICBpZiAoZmFicmljLmZvcmNlR0xQdXRJbWFnZURhdGEpIHtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlciA9IGltYWdlQnVmZmVyO1xuICAgICAgICB0aGlzLmNvcHlHTFRvMkQgPSBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdGVzdENvbnRleHQgPSB7XG4gICAgICAgIGltYWdlQnVmZmVyOiBpbWFnZUJ1ZmZlcixcbiAgICAgICAgZGVzdGluYXRpb25XaWR0aDogd2lkdGgsXG4gICAgICAgIGRlc3RpbmF0aW9uSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHRhcmdldENhbnZhczogdGFyZ2V0Q2FudmFzXG4gICAgICB9O1xuICAgICAgdmFyIHN0YXJ0VGltZSwgZHJhd0ltYWdlVGltZSwgcHV0SW1hZ2VEYXRhVGltZTtcbiAgICAgIHRhcmdldENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29weUdMVG8yRERyYXdJbWFnZS5jYWxsKHRlc3RDb250ZXh0LCB0aGlzLmdsLCB0ZXN0Q29udGV4dCk7XG4gICAgICBkcmF3SW1hZ2VUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBzdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhLmNhbGwodGVzdENvbnRleHQsIHRoaXMuZ2wsIHRlc3RDb250ZXh0KTtcbiAgICAgIHB1dEltYWdlRGF0YVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIGlmIChkcmF3SW1hZ2VUaW1lID4gcHV0SW1hZ2VEYXRhVGltZSkge1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gaW1hZ2VCdWZmZXI7XG4gICAgICAgIHRoaXMuY29weUdMVG8yRCA9IGNvcHlHTFRvMkRQdXRJbWFnZURhdGE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3B5R0xUbzJEID0gY29weUdMVG8yRERyYXdJbWFnZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2FudmFzIGVsZW1lbnQgYW5kIGFzc29jaWF0ZWQgV2ViR0wgY29udGV4dCBhbmQgYXR0YWNoZXMgdGhlbSBhc1xuICAgICAqIGNsYXNzIHByb3BlcnRpZXMgdG8gdGhlIEdMRmlsdGVyQmFja2VuZCBjbGFzcy5cbiAgICAgKi9cbiAgICBjcmVhdGVXZWJHTENhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHZhciBnbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgICAgICAgICBkZXB0aDogZmFsc2UsXG4gICAgICAgICAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICAgICAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgZ2xPcHRpb25zKTtcbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgZ2xPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgIC8vIHRoaXMgY2FudmFzIGNhbiBmaXJlIHdlYmdsY29udGV4dGxvc3QgYW5kIHdlYmdsY29udGV4dHJlc3RvcmVkXG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gYXBwbHkgdGhlIHJlcXVlc3RlZCBmaWx0ZXJzIHRvIHRoZSBzb3VyY2UgcHJvdmlkZWQsIGRyYXdpbmcgdGhlIGZpbHRlcmVkIG91dHB1dFxuICAgICAqIHRvIHRoZSBwcm92aWRlZCB0YXJnZXQgY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyBUaGUgZmlsdGVycyB0byBhcHBseS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSBUaGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIGRlc3RpbmF0aW9uIGZvciBmaWx0ZXJlZCBvdXRwdXQgdG8gYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8dW5kZWZpbmVkfSBjYWNoZUtleSBBIGtleSB1c2VkIHRvIGNhY2hlIHJlc291cmNlcyByZWxhdGVkIHRvIHRoZSBzb3VyY2UuIElmXG4gICAgICogb21pdHRlZCwgY2FjaGluZyB3aWxsIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBzb3VyY2UsIHdpZHRoLCBoZWlnaHQsIHRhcmdldENhbnZhcywgY2FjaGVLZXkpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICB2YXIgY2FjaGVkVGV4dHVyZTtcbiAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICBjYWNoZWRUZXh0dXJlID0gdGhpcy5nZXRDYWNoZWRUZXh0dXJlKGNhY2hlS2V5LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIHBpcGVsaW5lU3RhdGUgPSB7XG4gICAgICAgIG9yaWdpbmFsV2lkdGg6IHNvdXJjZS53aWR0aCB8fCBzb3VyY2Uub3JpZ2luYWxXaWR0aCxcbiAgICAgICAgb3JpZ2luYWxIZWlnaHQ6IHNvdXJjZS5oZWlnaHQgfHwgc291cmNlLm9yaWdpbmFsSGVpZ2h0LFxuICAgICAgICBzb3VyY2VXaWR0aDogd2lkdGgsXG4gICAgICAgIHNvdXJjZUhlaWdodDogaGVpZ2h0LFxuICAgICAgICBkZXN0aW5hdGlvbldpZHRoOiB3aWR0aCxcbiAgICAgICAgZGVzdGluYXRpb25IZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgY29udGV4dDogZ2wsXG4gICAgICAgIHNvdXJjZVRleHR1cmU6IHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgIWNhY2hlZFRleHR1cmUgJiYgc291cmNlKSxcbiAgICAgICAgdGFyZ2V0VGV4dHVyZTogdGhpcy5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0KSxcbiAgICAgICAgb3JpZ2luYWxUZXh0dXJlOiBjYWNoZWRUZXh0dXJlIHx8XG4gICAgICAgICAgdGhpcy5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCAhY2FjaGVkVGV4dHVyZSAmJiBzb3VyY2UpLFxuICAgICAgICBwYXNzZXM6IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgICB3ZWJnbDogdHJ1ZSxcbiAgICAgICAgYVBvc2l0aW9uOiB0aGlzLmFQb3NpdGlvbixcbiAgICAgICAgcHJvZ3JhbUNhY2hlOiB0aGlzLnByb2dyYW1DYWNoZSxcbiAgICAgICAgcGFzczogMCxcbiAgICAgICAgZmlsdGVyQmFja2VuZDogdGhpcyxcbiAgICAgICAgdGFyZ2V0Q2FudmFzOiB0YXJnZXRDYW52YXNcbiAgICAgIH07XG4gICAgICB2YXIgdGVtcEZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRlbXBGYm8pO1xuICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikgeyBmaWx0ZXIgJiYgZmlsdGVyLmFwcGx5VG8ocGlwZWxpbmVTdGF0ZSk7IH0pO1xuICAgICAgcmVzaXplQ2FudmFzSWZOZWVkZWQocGlwZWxpbmVTdGF0ZSk7XG4gICAgICB0aGlzLmNvcHlHTFRvMkQoZ2wsIHBpcGVsaW5lU3RhdGUpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHBpcGVsaW5lU3RhdGUuc291cmNlVGV4dHVyZSk7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHBpcGVsaW5lU3RhdGUudGFyZ2V0VGV4dHVyZSk7XG4gICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcih0ZW1wRmJvKTtcbiAgICAgIHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHJldHVybiBwaXBlbGluZVN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggZXZlbnQgbGlzdGVuZXJzLCByZW1vdmUgcmVmZXJlbmNlcywgYW5kIGNsZWFuIHVwIGNhY2hlcy5cbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhcldlYkdMQ2FjaGVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdpcGUgb3V0IFdlYkdMLXJlbGF0ZWQgY2FjaGVzLlxuICAgICAqL1xuICAgIGNsZWFyV2ViR0xDYWNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wcm9ncmFtQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFdlYkdMIHRleHR1cmUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQWNjZXB0cyBzcGVjaWZpYyBkaW1lbnNpb25zIHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUgdG8gb3IgYSBzb3VyY2UgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNvbnRleHQgdG8gdXNlIGZvciBjcmVhdGluZyB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUgYXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSB0ZXh0dXJlSW1hZ2VTb3VyY2UgQSBzb3VyY2UgZm9yIHRoZSB0ZXh0dXJlIGRhdGEuXG4gICAgICogQHJldHVybnMge1dlYkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodCwgdGV4dHVyZUltYWdlU291cmNlKSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGlmICh0ZXh0dXJlSW1hZ2VTb3VyY2UpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlSW1hZ2VTb3VyY2UpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIG9wdGlvbmFsbHkgdXNlZCB0byBnZXQgYSB0ZXh0dXJlIGZyb20gdGhlIGNhY2hlIGFycmF5XG4gICAgICpcbiAgICAgKiBJZiBhbiBleGlzdGluZyB0ZXh0dXJlIGlzIG5vdCBmb3VuZCwgYSBuZXcgdGV4dHVyZSBpcyBjcmVhdGVkIGFuZCBjYWNoZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdW5pcXVlSWQgQSBjYWNoZSBrZXkgdG8gdXNlIHRvIGZpbmQgYW4gZXhpc3RpbmcgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHRleHR1cmVJbWFnZVNvdXJjZSBBIHNvdXJjZSB0byB1c2UgdG8gY3JlYXRlIHRoZVxuICAgICAqIHRleHR1cmUgY2FjaGUgZW50cnkgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkVGV4dHVyZTogZnVuY3Rpb24odW5pcXVlSWQsIHRleHR1cmVJbWFnZVNvdXJjZSkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW3VuaXF1ZUlkXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKFxuICAgICAgICAgIHRoaXMuZ2wsIHRleHR1cmVJbWFnZVNvdXJjZS53aWR0aCwgdGV4dHVyZUltYWdlU291cmNlLmhlaWdodCwgdGV4dHVyZUltYWdlU291cmNlKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdID0gdGV4dHVyZTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIG91dCBjYWNoZWQgcmVzb3VyY2VzIHJlbGF0ZWQgdG8gYSBzb3VyY2UgaW1hZ2UgdGhhdCBoYXMgYmVlblxuICAgICAqIGZpbHRlcmVkIHByZXZpb3VzbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2FjaGVLZXkgVGhlIGNhY2hlIGtleSBwcm92aWRlZCB3aGVuIHRoZSBzb3VyY2UgaW1hZ2Ugd2FzIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGV2aWN0Q2FjaGVzRm9yS2V5OiBmdW5jdGlvbihjYWNoZUtleSkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKTtcbiAgICAgICAgZGVsZXRlIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weUdMVG8yRDogY29weUdMVG8yRERyYXdJbWFnZSxcblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gZXh0cmFjdCBHUFUgaW5mb3JtYXRpb24gc3RyaW5ncyBmcm9tIGEgV2ViR0wgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCBpbmZvcm1hdGlvbiB3aGVuIGRlYnVnZ2luZyBvciBibGFja2xpc3Rpbmcgc3BlY2lmaWMgR1BVcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgR1BVIGluZm8gb2JqZWN0IHdpdGggcmVuZGVyZXIgYW5kIHZlbmRvciBzdHJpbmdzLlxuICAgICAqL1xuICAgIGNhcHR1cmVHUFVJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmdwdUluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3B1SW5mbztcbiAgICAgIH1cbiAgICAgIHZhciBnbCA9IHRoaXMuZ2wsIGdwdUluZm8gPSB7IHJlbmRlcmVyOiAnJywgdmVuZG9yOiAnJyB9O1xuICAgICAgaWYgKCFnbCkge1xuICAgICAgICByZXR1cm4gZ3B1SW5mbztcbiAgICAgIH1cbiAgICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8nKTtcbiAgICAgIGlmIChleHQpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCk7XG4gICAgICAgIHZhciB2ZW5kb3IgPSBnbC5nZXRQYXJhbWV0ZXIoZXh0LlVOTUFTS0VEX1ZFTkRPUl9XRUJHTCk7XG4gICAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICAgIGdwdUluZm8ucmVuZGVyZXIgPSByZW5kZXJlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZW5kb3IpIHtcbiAgICAgICAgICBncHVJbmZvLnZlbmRvciA9IHZlbmRvci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmdwdUluZm8gPSBncHVJbmZvO1xuICAgICAgcmV0dXJuIGdwdUluZm87XG4gICAgfSxcbiAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIHJlc2l6ZUNhbnZhc0lmTmVlZGVkKHBpcGVsaW5lU3RhdGUpIHtcbiAgdmFyIHRhcmdldENhbnZhcyA9IHBpcGVsaW5lU3RhdGUudGFyZ2V0Q2FudmFzLFxuICAgICAgd2lkdGggPSB0YXJnZXRDYW52YXMud2lkdGgsIGhlaWdodCA9IHRhcmdldENhbnZhcy5oZWlnaHQsXG4gICAgICBkV2lkdGggPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uV2lkdGgsXG4gICAgICBkSGVpZ2h0ID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbkhlaWdodDtcblxuICBpZiAod2lkdGggIT09IGRXaWR0aCB8fCBoZWlnaHQgIT09IGRIZWlnaHQpIHtcbiAgICB0YXJnZXRDYW52YXMud2lkdGggPSBkV2lkdGg7XG4gICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IGRIZWlnaHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5IGFuIGlucHV0IFdlYkdMIGNhbnZhcyBvbiB0byBhbiBvdXRwdXQgMkQgY2FudmFzLlxuICpcbiAqIFRoZSBXZWJHTCBjYW52YXMgaXMgYXNzdW1lZCB0byBiZSB1cHNpZGUgZG93biwgd2l0aCB0aGUgdG9wLWxlZnQgcGl4ZWwgb2YgdGhlXG4gKiBkZXNpcmVkIG91dHB1dCBpbWFnZSBhcHBlYXJpbmcgaW4gdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0aGUgV2ViR0wgY2FudmFzLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBzb3VyY2VDb250ZXh0IFRoZSBXZWJHTCBjb250ZXh0IHRvIGNvcHkgZnJvbS5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IHBpcGVsaW5lU3RhdGUgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqL1xuZnVuY3Rpb24gY29weUdMVG8yRERyYXdJbWFnZShnbCwgcGlwZWxpbmVTdGF0ZSkge1xuICB2YXIgZ2xDYW52YXMgPSBnbC5jYW52YXMsIHRhcmdldENhbnZhcyA9IHBpcGVsaW5lU3RhdGUudGFyZ2V0Q2FudmFzLFxuICAgICAgY3R4ID0gdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eC50cmFuc2xhdGUoMCwgdGFyZ2V0Q2FudmFzLmhlaWdodCk7IC8vIG1vdmUgaXQgZG93biBhZ2FpblxuICBjdHguc2NhbGUoMSwgLTEpOyAvLyB2ZXJ0aWNhbCBmbGlwXG4gIC8vIHdoZXJlIGlzIG15IGltYWdlIG9uIHRoZSBiaWcgZ2xjYW52YXM/XG4gIHZhciBzb3VyY2VZID0gZ2xDYW52YXMuaGVpZ2h0IC0gdGFyZ2V0Q2FudmFzLmhlaWdodDtcbiAgY3R4LmRyYXdJbWFnZShnbENhbnZhcywgMCwgc291cmNlWSwgdGFyZ2V0Q2FudmFzLndpZHRoLCB0YXJnZXRDYW52YXMuaGVpZ2h0LCAwLCAwLFxuICAgIHRhcmdldENhbnZhcy53aWR0aCwgdGFyZ2V0Q2FudmFzLmhlaWdodCk7XG59XG5cbi8qKlxuICogQ29weSBhbiBpbnB1dCBXZWJHTCBjYW52YXMgb24gdG8gYW4gb3V0cHV0IDJEIGNhbnZhcyB1c2luZyAyZCBjYW52YXMnIHB1dEltYWdlRGF0YVxuICogQVBJLiBNZWFzdXJhYmx5IGZhc3RlciB0aGFuIHVzaW5nIGN0eC5kcmF3SW1hZ2UgaW4gRmlyZWZveCAodmVyc2lvbiA1NCBvbiBPU1ggU2llcnJhKS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gc291cmNlQ29udGV4dCBUaGUgV2ViR0wgY29udGV4dCB0byBjb3B5IGZyb20uXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwaXBlbGluZVN0YXRlIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKi9cbmZ1bmN0aW9uIGNvcHlHTFRvMkRQdXRJbWFnZURhdGEoZ2wsIHBpcGVsaW5lU3RhdGUpIHtcbiAgdmFyIHRhcmdldENhbnZhcyA9IHBpcGVsaW5lU3RhdGUudGFyZ2V0Q2FudmFzLCBjdHggPSB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIGRXaWR0aCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25XaWR0aCxcbiAgICAgIGRIZWlnaHQgPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uSGVpZ2h0LFxuICAgICAgbnVtQnl0ZXMgPSBkV2lkdGggKiBkSGVpZ2h0ICogNDtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIHU4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5pbWFnZUJ1ZmZlciwgMCwgbnVtQnl0ZXMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIHU4Q2xhbXBlZCA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLmltYWdlQnVmZmVyLCAwLCBudW1CeXRlcyk7XG5cbiAgZ2wucmVhZFBpeGVscygwLCAwLCBkV2lkdGgsIGRIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHU4KTtcbiAgdmFyIGltZ0RhdGEgPSBuZXcgSW1hZ2VEYXRhKHU4Q2xhbXBlZCwgZFdpZHRoLCBkSGVpZ2h0KTtcbiAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuICBmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kID0gQ2FudmFzMmRGaWx0ZXJCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBDYW52YXMgMkQgZmlsdGVyIGJhY2tlbmQuXG4gICAqL1xuICBmdW5jdGlvbiBDYW52YXMyZEZpbHRlckJhY2tlbmQoKSB7fTtcblxuICBDYW52YXMyZEZpbHRlckJhY2tlbmQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgZXZpY3RDYWNoZXNGb3JLZXk6IG5vb3AsXG4gICAgZGlzcG9zZTogbm9vcCxcbiAgICBjbGVhcldlYkdMQ2FjaGVzOiBub29wLFxuXG4gICAgLyoqXG4gICAgICogRXhwZXJpbWVudGFsLiBUaGlzIG9iamVjdCBpcyBhIHNvcnQgb2YgcmVwb3NpdG9yeSBvZiBoZWxwIGxheWVycyB1c2VkIHRvIGF2b2lkXG4gICAgICogb2YgcmVjcmVhdGluZyB0aGVtIGR1cmluZyBmcmVxdWVudCBmaWx0ZXJpbmcuIElmIHlvdSBhcmUgcHJldmlld2luZyBhIGZpbHRlciB3aXRoXG4gICAgICogYSBzbGlkZXIgeW91IHByb2JhYmx5IGRvIG5vdCB3YW50IHRvIGNyZWF0ZSBoZWxwIGxheWVycyBldmVyeSBmaWx0ZXIgc3RlcC5cbiAgICAgKiBpbiB0aGlzIG9iamVjdCB0aGVyZSB3aWxsIGJlIGFwcGVuZGVkIHNvbWUgY2FudmFzZXMsIGNyZWF0ZWQgb25jZSwgcmVzaXplZCBzb21ldGltZXNcbiAgICAgKiBjbGVhcmVkIG5ldmVyLiBDbGVhcmluZyBpcyBsZWZ0IHRvIHRoZSBkZXZlbG9wZXIuXG4gICAgICoqL1xuICAgIHJlc291cmNlczoge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgc2V0IG9mIGZpbHRlcnMgYWdhaW5zdCBhIHNvdXJjZSBpbWFnZSBhbmQgZHJhdyB0aGUgZmlsdGVyZWQgb3V0cHV0XG4gICAgICogdG8gdGhlIHByb3ZpZGVkIGRlc3RpbmF0aW9uIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5oYW5jZWRGaWx0ZXJ9IGZpbHRlcnMgVGhlIGZpbHRlciB0byBhcHBseS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZUVsZW1lbnQgVGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZUhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSBkZXN0aW5hdGlvbiBmb3IgZmlsdGVyZWQgb3V0cHV0IHRvIGJlIGRyYXduLlxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgc291cmNlRWxlbWVudCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGFyZ2V0Q2FudmFzKSB7XG4gICAgICB2YXIgY3R4ID0gdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZHJhd0ltYWdlKHNvdXJjZUVsZW1lbnQsIDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgICB2YXIgb3JpZ2luYWxJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgdmFyIHBpcGVsaW5lU3RhdGUgPSB7XG4gICAgICAgIHNvdXJjZVdpZHRoOiBzb3VyY2VXaWR0aCxcbiAgICAgICAgc291cmNlSGVpZ2h0OiBzb3VyY2VIZWlnaHQsXG4gICAgICAgIGltYWdlRGF0YTogaW1hZ2VEYXRhLFxuICAgICAgICBvcmlnaW5hbEVsOiBzb3VyY2VFbGVtZW50LFxuICAgICAgICBvcmlnaW5hbEltYWdlRGF0YTogb3JpZ2luYWxJbWFnZURhdGEsXG4gICAgICAgIGNhbnZhc0VsOiB0YXJnZXRDYW52YXMsXG4gICAgICAgIGN0eDogY3R4LFxuICAgICAgICBmaWx0ZXJCYWNrZW5kOiB0aGlzLFxuICAgICAgfTtcbiAgICAgIGZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHsgZmlsdGVyLmFwcGx5VG8ocGlwZWxpbmVTdGF0ZSk7IH0pO1xuICAgICAgaWYgKHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLndpZHRoICE9PSBzb3VyY2VXaWR0aCB8fCBwaXBlbGluZVN0YXRlLmltYWdlRGF0YS5oZWlnaHQgIT09IHNvdXJjZUhlaWdodCkge1xuICAgICAgICB0YXJnZXRDYW52YXMud2lkdGggPSBwaXBlbGluZVN0YXRlLmltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEocGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgcmV0dXJuIHBpcGVsaW5lU3RhdGU7XG4gICAgfSxcblxuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZmFicmljLkltYWdlLmZpbHRlcnNcbiAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2VcbiAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2ltYWdlX2ZpbHRlcnN9XG4gKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gKi9cbmZhYnJpYy5JbWFnZSA9IGZhYnJpYy5JbWFnZSB8fCB7IH07XG5mYWJyaWMuSW1hZ2UuZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzIHx8IHsgfTtcblxuLyoqXG4gKiBSb290IGZpbHRlciBjbGFzcyBmcm9tIHdoaWNoIGFsbCBmaWx0ZXIgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAqL1xuZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlciA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgdHlwZTogJ0Jhc2VGaWx0ZXInLFxuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHNlbmQgd2l0aCBidWZmZXJzLiBkbyBub3QgbW9kaWZ5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZlcnRleFNvdXJjZTogJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcXG4nICtcbiAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgJ3ZUZXhDb29yZCA9IGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XFxuJyArXG4gICAgJ30nLFxuXG4gIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgJ2dsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAnfScsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBmaWx0ZXIncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIgcHJvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB0byB1c2UgZm9yIHNoYWRlciBjb21waWxhdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyYWdtZW50U291cmNlIGZyYWdtZW50U2hhZGVyIHNvdXJjZSBmb3IgY29tcGlsYXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnRleFNvdXJjZSB2ZXJ0ZXhTaGFkZXIgc291cmNlIGZvciBjb21waWxhdGlvblxuICAgKi9cbiAgY3JlYXRlUHJvZ3JhbTogZnVuY3Rpb24oZ2wsIGZyYWdtZW50U291cmNlLCB2ZXJ0ZXhTb3VyY2UpIHtcbiAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlIHx8IHRoaXMuZnJhZ21lbnRTb3VyY2U7XG4gICAgdmVydGV4U291cmNlID0gdmVydGV4U291cmNlIHx8IHRoaXMudmVydGV4U291cmNlO1xuICAgIGlmIChmYWJyaWMud2ViR2xQcmVjaXNpb24gIT09ICdoaWdocCcpe1xuICAgICAgZnJhZ21lbnRTb3VyY2UgPSBmcmFnbWVudFNvdXJjZS5yZXBsYWNlKFxuICAgICAgICAvcHJlY2lzaW9uIGhpZ2hwIGZsb2F0L2csXG4gICAgICAgICdwcmVjaXNpb24gJyArIGZhYnJpYy53ZWJHbFByZWNpc2lvbiArICcgZmxvYXQnXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgJ1ZlcnRleCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgJyArIHRoaXMudHlwZSArICc6ICcgK1xuICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICdGcmFnbWVudCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgJyArIHRoaXMudHlwZSArICc6ICcgK1xuICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgICAgICAnU2hhZGVyIGxpbmsgZXJyb3IgZm9yIFwiJHt0aGlzLnR5cGV9XCIgJyArXG4gICAgICAgIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbnMgPSB0aGlzLmdldEF0dHJpYnV0ZUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSk7XG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMoZ2wsIHByb2dyYW0pIHx8IHsgfTtcbiAgICB1bmlmb3JtTG9jYXRpb25zLnVTdGVwVyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBXJyk7XG4gICAgdW5pZm9ybUxvY2F0aW9ucy51U3RlcEggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwSCcpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgYXR0cmlidXRlTG9jYXRpb25zOiBhdHRyaWJ1dGVMb2NhdGlvbnMsXG4gICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwIG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBXZWJHTEF0dHJpYnV0ZUxvY2F0aW9uIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhlIHNoYWRlciBwcm9ncmFtIGZyb20gd2hpY2ggdG8gdGFrZSBhdHRyaWJ1dGUgbG9jYXRpb25zLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG1hcCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYXR0cmlidXRlIGxvY2F0aW9ucy5cbiAgICovXG4gIGdldEF0dHJpYnV0ZUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgYVBvc2l0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVBvc2l0aW9uJyksXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0cy5cbiAgICpcbiAgICogSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoZSBzaGFkZXIgcHJvZ3JhbSBmcm9tIHdoaWNoIHRvIHRha2UgdW5pZm9ybSBsb2NhdGlvbnMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gdW5pZm9ybSBsb2NhdGlvbnMuXG4gICAqL1xuICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbiAoLyogZ2wsIHByb2dyYW0gKi8pIHtcbiAgICAvLyBpbiBjYXNlIGkgZG8gbm90IG5lZWQgYW55IHNwZWNpYWwgdW5pZm9ybSBpIG5lZWQgdG8gcmV0dXJuIGFuIGVtcHR5IG9iamVjdFxuICAgIHJldHVybiB7IH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgYXR0cmlidXRlIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0gb24gdGhlIEdQVS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlTG9jYXRpb25zIEEgbWFwIG9mIHNoYWRlciBhdHRyaWJ1dGUgbmFtZXMgdG8gdGhlaXIgbG9jYXRpb25zLlxuICAgKi9cbiAgc2VuZEF0dHJpYnV0ZURhdGE6IGZ1bmN0aW9uKGdsLCBhdHRyaWJ1dGVMb2NhdGlvbnMsIGFQb3NpdGlvbkRhdGEpIHtcbiAgICB2YXIgYXR0cmlidXRlTG9jYXRpb24gPSBhdHRyaWJ1dGVMb2NhdGlvbnMuYVBvc2l0aW9uO1xuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGVMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYVBvc2l0aW9uRGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuICB9LFxuXG4gIF9zZXR1cEZyYW1lQnVmZmVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0LCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChvcHRpb25zLnBhc3NlcyA+IDEpIHtcbiAgICAgIHdpZHRoID0gb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoO1xuICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodDtcbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVdpZHRoICE9PSB3aWR0aCB8fCBvcHRpb25zLnNvdXJjZUhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUob3B0aW9ucy50YXJnZXRUZXh0dXJlKTtcbiAgICAgICAgb3B0aW9ucy50YXJnZXRUZXh0dXJlID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELFxuICAgICAgICBvcHRpb25zLnRhcmdldFRleHR1cmUsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGRyYXcgbGFzdCBmaWx0ZXIgb24gY2FudmFzIGFuZCBub3QgdG8gZnJhbWVidWZmZXIuXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgZ2wuZmluaXNoKCk7XG4gICAgfVxuICB9LFxuXG4gIF9zd2FwVGV4dHVyZXM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnBhc3Nlcy0tO1xuICAgIG9wdGlvbnMucGFzcysrO1xuICAgIHZhciB0ZW1wID0gb3B0aW9ucy50YXJnZXRUZXh0dXJlO1xuICAgIG9wdGlvbnMudGFyZ2V0VGV4dHVyZSA9IG9wdGlvbnMuc291cmNlVGV4dHVyZTtcbiAgICBvcHRpb25zLnNvdXJjZVRleHR1cmUgPSB0ZW1wO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmljIGlzTmV1dHJhbCBpbXBsZW1lbnRhdGlvbiBmb3Igb25lIHBhcmFtZXRlciBiYXNlZCBmaWx0ZXJzLlxuICAgKiBVc2VkIG9ubHkgaW4gaW1hZ2UgYXBwbHlGaWx0ZXJzIHRvIGRpc2NhcmQgZmlsdGVycyB0aGF0IHdpbGwgbm90IGhhdmUgYW4gZWZmZWN0XG4gICAqIG9uIHRoZSBpbWFnZVxuICAgKiBPdGhlciBmaWx0ZXJzIG1heSBuZWVkIHRoZWlyIG93biB2ZXJzaW9uICggQ29sb3JNYXRyaXgsIEh1ZVJvdGF0aW9uLCBnYW1tYSwgQ29tcG9zZWRGaWx0ZXIgKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiovXG4gIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigvKiBvcHRpb25zICovKSB7XG4gICAgdmFyIG1haW4gPSB0aGlzLm1haW5QYXJhbWV0ZXIsXG4gICAgICAgIF9jbGFzcyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzW3RoaXMudHlwZV0ucHJvdG90eXBlO1xuICAgIGlmIChtYWluKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShfY2xhc3NbbWFpbl0pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBfY2xhc3NbbWFpbl0ubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgaWYgKHRoaXNbbWFpbl1baV0gIT09IF9jbGFzc1ttYWluXVtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX2NsYXNzW21haW5dID09PSB0aGlzW21haW5dO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoaXMgZmlsdGVyIHRvIHRoZSBpbnB1dCBpbWFnZSBkYXRhIHByb3ZpZGVkLlxuICAgKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIFdlYkdMIG9yIENhbnZhczJEIGJhc2VkIG9uIHRoZSBvcHRpb25zLndlYmdsIGZsYWcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICovXG4gIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbHlUbzJkKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAqL1xuICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkodGhpcy50eXBlKSkge1xuICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbdGhpcy50eXBlXSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbdGhpcy50eXBlXTtcbiAgfSxcblxuICAvKipcbiAgICogQXBwbHkgdGhpcyBmaWx0ZXIgdXNpbmcgd2ViZ2wuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMub3JpZ2luYWxUZXh0dXJlIFRoZSB0ZXh0dXJlIG9mIHRoZSBvcmlnaW5hbCBpbnB1dCBpbWFnZS5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICovXG4gIGFwcGx5VG9XZWJHTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBnbCA9IG9wdGlvbnMuY29udGV4dDtcbiAgICB2YXIgc2hhZGVyID0gdGhpcy5yZXRyaWV2ZVNoYWRlcihvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5wYXNzID09PSAwICYmIG9wdGlvbnMub3JpZ2luYWxUZXh0dXJlKSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgb3B0aW9ucy5zb3VyY2VUZXh0dXJlKTtcbiAgICB9XG4gICAgZ2wudXNlUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XG4gICAgdGhpcy5zZW5kQXR0cmlidXRlRGF0YShnbCwgc2hhZGVyLmF0dHJpYnV0ZUxvY2F0aW9ucywgb3B0aW9ucy5hUG9zaXRpb24pO1xuXG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51bmlmb3JtTG9jYXRpb25zLnVTdGVwVywgMSAvIG9wdGlvbnMuc291cmNlV2lkdGgpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybUxvY2F0aW9ucy51U3RlcEgsIDEgLyBvcHRpb25zLnNvdXJjZUhlaWdodCk7XG5cbiAgICB0aGlzLnNlbmRVbmlmb3JtRGF0YShnbCwgc2hhZGVyLnVuaWZvcm1Mb2NhdGlvbnMpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aCwgb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gIH0sXG5cbiAgYmluZEFkZGl0aW9uYWxUZXh0dXJlOiBmdW5jdGlvbihnbCwgdGV4dHVyZSwgdGV4dHVyZVVuaXQpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVVbml0KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAvLyByZXNldCBhY3RpdmUgdGV4dHVyZSB0byAwIGFzIHVzdWFsXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gIH0sXG5cbiAgdW5iaW5kQWRkaXRpb25hbFRleHR1cmU6IGZ1bmN0aW9uKGdsLCB0ZXh0dXJlVW5pdCkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZVVuaXQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICB9LFxuXG4gIGdldE1haW5QYXJhbWV0ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzW3RoaXMubWFpblBhcmFtZXRlcl07XG4gIH0sXG5cbiAgc2V0TWFpblBhcmFtZXRlcjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzW3RoaXMubWFpblBhcmFtZXRlcl0gPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU2VuZCB1bmlmb3JtIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0gb24gdGhlIEdQVS5cbiAgICpcbiAgICogSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHNoYWRlciB1bmlmb3JtIG5hbWVzIHRvIHRoZWlyIGxvY2F0aW9ucy5cbiAgICovXG4gIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oLyogZ2wsIHVuaWZvcm1Mb2NhdGlvbnMgKi8pIHtcbiAgICAvLyBJbnRlbnRpb25hbGx5IGxlZnQgYmxhbmsuICBPdmVycmlkZSBtZSBpbiBzdWJjbGFzc2VzLlxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBuZWVkZWQgYnkgYSAyZCBmaWx0ZXIsIHRoaXMgZnVuY3Rpb25zIGNhbiBjcmVhdGUgYW4gaGVscGVyIGNhbnZhcyB0byBiZSB1c2VkXG4gICAqIHJlbWVtYmVyIHRoYXQgb3B0aW9ucy50YXJnZXRDYW52YXMgaXMgYXZhaWxhYmxlIGZvciB1c2UgdGlsbCBlbmQgb2YgY2hhaW4uXG4gICAqL1xuICBjcmVhdGVIZWxwTGF5ZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuaGVscExheWVyKSB7XG4gICAgICB2YXIgaGVscExheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBoZWxwTGF5ZXIud2lkdGggPSBvcHRpb25zLnNvdXJjZVdpZHRoO1xuICAgICAgaGVscExheWVyLmhlaWdodCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgb3B0aW9ucy5oZWxwTGF5ZXIgPSBoZWxwTGF5ZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKi9cbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmplY3QgPSB7IHR5cGU6IHRoaXMudHlwZSB9LCBtYWluUCA9IHRoaXMubWFpblBhcmFtZXRlcjtcbiAgICBpZiAobWFpblApIHtcbiAgICAgIG9iamVjdFttYWluUF0gPSB0aGlzW21haW5QXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBKU09OXG4gICAqL1xuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIC8vIGRlbGVnYXRlLCBub3QgYWxpYXNcbiAgICByZXR1cm4gdGhpcy50b09iamVjdCgpO1xuICB9XG59KTtcblxuZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzW29iamVjdC50eXBlXShvYmplY3QpO1xuICBjYWxsYmFjayAmJiBjYWxsYmFjayhmaWx0ZXIpO1xuICByZXR1cm4gZmlsdGVyO1xufTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBDb2xvciBNYXRyaXggZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBzZWUge0BMaW5rIGh0dHA6Ly93d3cud2Vid2FzcC5jby51ay90dXRvcmlhbHMvMjE5L0NvbG9yX01hdHJpeF9GaWx0ZXIucGhwfVxuICAgKiBAc2VlIHtATGluayBodHRwOi8vcGhvYm9zbGFiLm9yZy9sb2cvMjAxMy8xMS9mYXN0LWltYWdlLWZpbHRlcnMtd2l0aC13ZWJnbH1cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+S29kYWNocm9tZSBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgoe1xuICAgKiAgbWF0cml4OiBbXG4gICAgICAgMS4xMjg1NTgyMzk2NTkzNTI1LCAtMC4zOTY3MzgyMjgzNjAxMzQ4LCAtMC4wMzk5MjU1OTE3MjkyMTc5MywgMCwgNjMuNzI5NTg3NjIxOTY1MDIsXG4gICAgICAgLTAuMTY0MDQzMzk5NjIyNDQ2MTYsIDEuMDgzNTI1MTU2NjI5MTMwNCwgLTAuMDU0OTg4MDUxMTU2MzMxMzIsIDAsIDI0LjczMjQwNzg5NjcwNjIwMyxcbiAgICAgICAtMC4xNjc4NjAxMDcwNjE1NTc2MywgLTAuNTYwMzQxNjI3NzY5NTI0OCwgMS42MDE0ODUwNzYxOTY0OTQzLCAwLCAzNS42Mjk4MjgwNzQ2MDk0NixcbiAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuQ29sb3JNYXRyaXggPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb2xvck1hdHJpeCcsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gbWF0NCB1Q29sb3JNYXRyaXg7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWM0IHVDb25zdGFudHM7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yICo9IHVDb2xvck1hdHJpeDtcXG4nICtcbiAgICAgICAgJ2NvbG9yICs9IHVDb25zdGFudHM7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIENvbG9ybWF0cml4IGZvciBwaXhlbHMuXG4gICAgICogYXJyYXkgb2YgMjAgZmxvYXRzLiBOdW1iZXJzIGluIHBvc2l0aW9ucyA0LCA5LCAxNCwgMTkgbG9vc2UgbWVhbmluZ1xuICAgICAqIG91dHNpZGUgdGhlIC0xLCAxIHJhbmdlLlxuICAgICAqIDAuMDAzOTIxNTY4NiBpcyB0aGUgcGFydCBvZiAxIHRoYXQgZ2V0IHRyYW5zbGF0ZWQgdG8gMSBpbiAyZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBhcnJheSBvZiAyMCBudW1iZXJzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWF0cml4OiBbXG4gICAgICAxLCAwLCAwLCAwLCAwLFxuICAgICAgMCwgMSwgMCwgMCwgMCxcbiAgICAgIDAsIDAsIDEsIDAsIDAsXG4gICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXSxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdtYXRyaXgnLFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgY29sb3JtYXRyaXggb24gdGhlIGNvbG9yIHBhcnQsIHNraXBwaW5nIGFscGhhLCBtYWlubHkgZm9yIG5vbiB3ZWJnbCBzY2VuYXJpb1xuICAgICAqIHRvIHNhdmUgc29tZSBjYWxjdWxhdGlvblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgY29sb3JzT25seTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgaW5zdGVhZCBtdXRhdGluZyB0aGUgcHJvdG90eXBlIHdpdGggcHVzaFxuICAgICAgdGhpcy5tYXRyaXggPSB0aGlzLm1hdHJpeC5zbGljZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIENvbG9yTWF0cml4IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIG0gPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICByLCBnLCBiLCBhLCBpLCBjb2xvcnNPbmx5ID0gdGhpcy5jb2xvcnNPbmx5O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgaWYgKGNvbG9yc09ubHkpIHtcbiAgICAgICAgICBkYXRhW2ldID0gciAqIG1bMF0gKyBnICogbVsxXSArIGIgKiBtWzJdICsgbVs0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IHIgKiBtWzVdICsgZyAqIG1bNl0gKyBiICogbVs3XSArIG1bOV0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMl0gPSByICogbVsxMF0gKyBnICogbVsxMV0gKyBiICogbVsxMl0gKyBtWzE0XSAqIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhID0gZGF0YVtpICsgM107XG4gICAgICAgICAgZGF0YVtpXSA9IHIgKiBtWzBdICsgZyAqIG1bMV0gKyBiICogbVsyXSArIGEgKiBtWzNdICsgbVs0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IHIgKiBtWzVdICsgZyAqIG1bNl0gKyBiICogbVs3XSArIGEgKiBtWzhdICsgbVs5XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9IHIgKiBtWzEwXSArIGcgKiBtWzExXSArIGIgKiBtWzEyXSArIGEgKiBtWzEzXSArIG1bMTRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDNdID0gciAqIG1bMTVdICsgZyAqIG1bMTZdICsgYiAqIG1bMTddICsgYSAqIG1bMThdICsgbVsxOV0gKiAyNTU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb2xvck1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29sb3JNYXRyaXgnKSxcbiAgICAgICAgdUNvbnN0YW50czogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29uc3RhbnRzJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sXG4gICAgICAgICAgICBtWzVdLCBtWzZdLCBtWzddLCBtWzhdLFxuICAgICAgICAgICAgbVsxMF0sIG1bMTFdLCBtWzEyXSwgbVsxM10sXG4gICAgICAgICAgICBtWzE1XSwgbVsxNl0sIG1bMTddLCBtWzE4XVxuICAgICAgICAgIF0sXG4gICAgICAgICAgY29uc3RhbnRzID0gW21bNF0sIG1bOV0sIG1bMTRdLCBtWzE5XV07XG4gICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUNvbG9yTWF0cml4LCBmYWxzZSwgbWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29uc3RhbnRzLCBjb25zdGFudHMpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQnJpZ2h0bmVzcyBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3NcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcyh7XG4gICAqICAgYnJpZ2h0bmVzczogMC4wNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkJyaWdodG5lc3MgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1QnJpZ2h0bmVzcztcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgKz0gdUJyaWdodG5lc3M7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEJyaWdodG5lc3MgdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiB0cmFuc2xhdGVkIHRvIC0yNTUgdG8gMjU1IGZvciAyZFxuICAgICAqIDAuMDAzOTIxNTY4NiBpcyB0aGUgcGFydCBvZiAxIHRoYXQgZ2V0IHRyYW5zbGF0ZWQgdG8gMSBpbiAyZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBicmlnaHRuZXNzOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ2JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgKiBBcHBseSB0aGUgQnJpZ2h0bmVzcyBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAqXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuYnJpZ2h0bmVzcyA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBicmlnaHRuZXNzID0gTWF0aC5yb3VuZCh0aGlzLmJyaWdodG5lc3MgKiAyNTUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldICsgYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMV0gPSBkYXRhW2kgKyAxXSArIGJyaWdodG5lc3M7XG4gICAgICAgIGRhdGFbaSArIDJdID0gZGF0YVtpICsgMl0gKyBicmlnaHRuZXNzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUJyaWdodG5lc3M6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUJyaWdodG5lc3MnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVCcmlnaHRuZXNzLCB0aGlzLmJyaWdodG5lc3MpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc30gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2ltYWdlZmlsdGVycy9cIj5odG1sNXJvY2tzIGFydGljbGU8L2E+XG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+U2hhcnBlbiBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMCwgLTEsICAwLFxuICAgKiAgICAgICAgICAgIC0xLCAgNSwgLTEsXG4gICAqICAgICAgICAgICAgIDAsIC0xLCAgMCBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5CbHVyIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85IF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtYm9zcyBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWJvc3MgZmlsdGVyIHdpdGggb3BhcXVlbmVzczwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG9wYXF1ZTogdHJ1ZSxcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5Db252b2x1dGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29udm9sdXRlJyxcblxuICAgIC8qXG4gICAgICogT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqL1xuICAgIG9wYXF1ZTogZmFsc2UsXG5cbiAgICAvKlxuICAgICAqIG1hdHJpeCBmb3IgdGhlIGZpbHRlciwgbWF4IDl4OVxuICAgICAqL1xuICAgIG1hdHJpeDogWzAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDBdLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIENvbnZvbHV0ZV8zXzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCAzLjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMSksIHVTdGVwSCAqIChoIC0gMSkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV8zXzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCAzLjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMS4wKSwgdVN0ZXBIICogKGggLSAxLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV81XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFsyNV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDUuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDIuMCksIHVTdGVwSCAqIChoIC0gMi4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogNS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzVfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzI1XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA1LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMi4wKSwgdVN0ZXBIICogKGggLSAyLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDUuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV83XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs0OV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDcuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDMuMCksIHVTdGVwSCAqIChoIC0gMy4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogNy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzdfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzQ5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA3LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMy4wKSwgdVN0ZXBIICogKGggLSAzLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDcuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV85XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs4MV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDkuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgOS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDQuMCksIHVTdGVwSCAqIChoIC0gNC4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogOS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzlfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzgxXTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgOS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA5LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gNC4wKSwgdVN0ZXBIICogKGggLSA0LjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDkuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9wYXF1ZT1mYWxzZV0gT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1hdHJpeF0gRmlsdGVyIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KHRoaXMubWF0cml4Lmxlbmd0aCk7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyBzaXplICsgJ18nICsgKHRoaXMub3BhcXVlID8gMSA6IDApO1xuICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbY2FjaGVLZXldO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICB3ZWlnaHRzID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSksXG4gICAgICAgICAgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKSxcbiAgICAgICAgICBzdyA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBzaCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgb3V0cHV0ID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKHN3LCBzaCksXG4gICAgICAgICAgZHN0ID0gb3V0cHV0LmRhdGEsXG4gICAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgcGl4ZWxzXG4gICAgICAgICAgYWxwaGFGYWMgPSB0aGlzLm9wYXF1ZSA/IDEgOiAwLFxuICAgICAgICAgIHIsIGcsIGIsIGEsIGRzdE9mZixcbiAgICAgICAgICBzY3gsIHNjeSwgc3JjT2ZmLCB3dCxcbiAgICAgICAgICB4LCB5LCBjeCwgY3k7XG5cbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBzdzsgeCsrKSB7XG4gICAgICAgICAgZHN0T2ZmID0gKHkgKiBzdyArIHgpICogNDtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcbiAgICAgICAgICAvLyBmYWxsIHVuZGVyIHRoZSBjb252b2x1dGlvbiBtYXRyaXhcbiAgICAgICAgICByID0gMDsgZyA9IDA7IGIgPSAwOyBhID0gMDtcblxuICAgICAgICAgIGZvciAoY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcbiAgICAgICAgICAgIGZvciAoY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcbiAgICAgICAgICAgICAgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICAgIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgaWYgKHNjeSA8IDAgfHwgc2N5ID49IHNoIHx8IHNjeCA8IDAgfHwgc2N4ID49IHN3KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzcmNPZmYgPSAoc2N5ICogc3cgKyBzY3gpICogNDtcbiAgICAgICAgICAgICAgd3QgPSB3ZWlnaHRzW2N5ICogc2lkZSArIGN4XTtcblxuICAgICAgICAgICAgICByICs9IGRhdGFbc3JjT2ZmXSAqIHd0O1xuICAgICAgICAgICAgICBnICs9IGRhdGFbc3JjT2ZmICsgMV0gKiB3dDtcbiAgICAgICAgICAgICAgYiArPSBkYXRhW3NyY09mZiArIDJdICogd3Q7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgaWYgKCFhbHBoYUZhYykge1xuICAgICAgICAgICAgICAgIGEgKz0gZGF0YVtzcmNPZmYgKyAzXSAqIHd0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRzdFtkc3RPZmZdID0gcjtcbiAgICAgICAgICBkc3RbZHN0T2ZmICsgMV0gPSBnO1xuICAgICAgICAgIGRzdFtkc3RPZmYgKyAyXSA9IGI7XG4gICAgICAgICAgaWYgKCFhbHBoYUZhYykge1xuICAgICAgICAgICAgZHN0W2RzdE9mZiArIDNdID0gYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkc3RbZHN0T2ZmICsgM10gPSBkYXRhW2RzdE9mZiArIDNdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0aW9ucy5pbWFnZURhdGEgPSBvdXRwdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1TWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VNYXRyaXgnKSxcbiAgICAgICAgdU9wYXF1ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1T3BhcXVlJyksXG4gICAgICAgIHVIYWxmU2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SGFsZlNpemUnKSxcbiAgICAgICAgdVNpemU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNpemUnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZnYodW5pZm9ybUxvY2F0aW9ucy51TWF0cml4LCB0aGlzLm1hdHJpeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIG9wYXF1ZTogdGhpcy5vcGFxdWUsXG4gICAgICAgIG1hdHJpeDogdGhpcy5tYXRyaXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBHcmF5c2NhbGUgaW1hZ2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZSgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuR3JheXNjYWxlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0dyYXlzY2FsZScsXG5cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgYXZlcmFnZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAnZmxvYXQgYXZlcmFnZSA9IChjb2xvci5yICsgY29sb3IuYiArIGNvbG9yLmcpIC8gMy4wO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KGF2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGNvbG9yLmEpO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBsaWdodG5lc3M6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gaW50IHVNb2RlO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2wgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAobWF4KG1heChjb2wuciwgY29sLmcpLGNvbC5iKSArIG1pbihtaW4oY29sLnIsIGNvbC5nKSxjb2wuYikpIC8gMi4wO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KGF2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGNvbC5hKTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgbHVtaW5vc2l0eTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBpbnQgdU1vZGU7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbCA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAnZmxvYXQgYXZlcmFnZSA9IDAuMjEgKiBjb2wuciArIDAuNzIgKiBjb2wuZyArIDAuMDcgKiBjb2wuYjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2wuYSk7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHcmF5c2NhbGUgbW9kZSwgYmV0d2VlbiAnYXZlcmFnZScsICdsaWdodG5lc3MnLCAnbHVtaW5vc2l0eSdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW9kZTogJ2F2ZXJhZ2UnLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ21vZGUnLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEdyYXlzY2FsZSBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLFxuICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLCB2YWx1ZSxcbiAgICAgICAgICBtb2RlID0gdGhpcy5tb2RlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGlmIChtb2RlID09PSAnYXZlcmFnZScpIHtcbiAgICAgICAgICB2YWx1ZSA9IChkYXRhW2ldICsgZGF0YVtpICsgMV0gKyBkYXRhW2kgKyAyXSkgLyAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdsaWdodG5lc3MnKSB7XG4gICAgICAgICAgdmFsdWUgPSAoTWF0aC5taW4oZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKSArXG4gICAgICAgICAgICBNYXRoLm1heChkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2x1bWlub3NpdHknKSB7XG4gICAgICAgICAgdmFsdWUgPSAwLjIxICogZGF0YVtpXSArIDAuNzIgKiBkYXRhW2kgKyAxXSArIDAuMDcgKiBkYXRhW2kgKyAyXTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2ldID0gdmFsdWU7XG4gICAgICAgIGRhdGFbaSArIDFdID0gdmFsdWU7XG4gICAgICAgIGRhdGFbaSArIDJdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyB0aGlzLm1vZGU7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICB2YXIgc2hhZGVyU291cmNlID0gdGhpcy5mcmFnbWVudFNvdXJjZVt0aGlzLm1vZGVdO1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVNb2RlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VNb2RlJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICAvLyBkZWZhdWx0IGF2ZXJhZ2UgbW9kZS5cbiAgICAgIHZhciBtb2RlID0gMTtcbiAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb25zLnVNb2RlLCBtb2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR3JheXNjYWxlIGZpbHRlciBpc05ldXRyYWxTdGF0ZSBpbXBsZW1lbnRhdGlvblxuICAgICAqIFRoZSBmaWx0ZXIgaXMgbmV2ZXIgbmV1dHJhbFxuICAgICAqIG9uIHRoZSBpbWFnZVxuICAgICAqKi9cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBJbnZlcnQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydCgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5JbnZlcnQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnSW52ZXJ0JyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gaW50IHVJbnZlcnQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnaWYgKHVJbnZlcnQgPT0gMSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCAtIGNvbG9yLnIsMS4wIC1jb2xvci5nLDEuMCAtY29sb3IuYixjb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIGludmVydC4gaWYgZmFsc2UsIGRvZXMgbm90aGluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52ZXJ0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnZlcnQ6IHRydWUsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnaW52ZXJ0JyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBJbnZlcnQgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gMjU1IC0gZGF0YVtpXTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSBkYXRhW2kgKyAxXTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSAyNTUgLSBkYXRhW2kgKyAyXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52ZXJ0IGZpbHRlciBpc05ldXRyYWxTdGF0ZSBpbXBsZW1lbnRhdGlvblxuICAgICAqIFVzZWQgb25seSBpbiBpbWFnZSBhcHBseUZpbHRlcnMgdG8gZGlzY2FyZCBmaWx0ZXJzIHRoYXQgd2lsbCBub3QgaGF2ZSBhbiBlZmZlY3RcbiAgICAgKiBvbiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqKi9cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaW52ZXJ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUludmVydDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SW52ZXJ0JyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51SW52ZXJ0LCB0aGlzLmludmVydCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnR9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBOb2lzZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZSh7XG4gICAqICAgbm9pc2U6IDcwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuTm9pc2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdOb2lzZScsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBub2lzZSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1Tm9pc2U7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U2VlZDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ2Zsb2F0IHJhbmQodmVjMiBjbywgZmxvYXQgc2VlZCwgZmxvYXQgdlNjYWxlKSB7XFxuJyArXG4gICAgICAgICdyZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSAqIHZTY2FsZSAsdmVjMigxMi45ODk4ICwgNzguMjMzKSkpICogNDM3NTguNTQ1MyAqIChzZWVkICsgMC4wMSkgLyAyLjApO1xcbicgK1xuICAgICAgJ31cXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnY29sb3IucmdiICs9ICgwLjUgLSByYW5kKHZUZXhDb29yZCwgdVNlZWQsIDAuMSAvIHVTdGVwSCkpICogdU5vaXNlO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAnbm9pc2UnLFxuXG4gICAgLyoqXG4gICAgICogTm9pc2UgdmFsdWUsIGZyb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbm9pc2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG5vaXNlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJyaWdodG5lc3Mgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5ub2lzZSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBub2lzZSA9IHRoaXMubm9pc2UsIHJhbmQ7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcblxuICAgICAgICByYW5kID0gKDAuNSAtIE1hdGgucmFuZG9tKCkpICogbm9pc2U7XG5cbiAgICAgICAgZGF0YVtpXSArPSByYW5kO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSByYW5kO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSByYW5kO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU5vaXNlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VOb2lzZScpLFxuICAgICAgICB1U2VlZDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2VlZCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudU5vaXNlLCB0aGlzLm5vaXNlIC8gMjU1KTtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVTZWVkLCBNYXRoLnJhbmRvbSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgbm9pc2U6IHRoaXMubm9pc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBQaXhlbGF0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZSh7XG4gICAqICAgYmxvY2tzaXplOiA4XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuUGl4ZWxhdGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdQaXhlbGF0ZScsXG5cbiAgICBibG9ja3NpemU6IDQsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnYmxvY2tzaXplJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIFBpeGVsYXRlIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVCbG9ja3NpemU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICdmbG9hdCBibG9ja1cgPSB1QmxvY2tzaXplICogdVN0ZXBXO1xcbicgK1xuICAgICAgICAnZmxvYXQgYmxvY2tIID0gdUJsb2Nrc2l6ZSAqIHVTdGVwVztcXG4nICtcbiAgICAgICAgJ2ludCBwb3NYID0gaW50KHZUZXhDb29yZC54IC8gYmxvY2tXKTtcXG4nICtcbiAgICAgICAgJ2ludCBwb3NZID0gaW50KHZUZXhDb29yZC55IC8gYmxvY2tIKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGZwb3NYID0gZmxvYXQocG9zWCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBmcG9zWSA9IGZsb2F0KHBvc1kpO1xcbicgK1xuICAgICAgICAndmVjMiBzcXVhcmVDb29yZHMgPSB2ZWMyKGZwb3NYICogYmxvY2tXLCBmcG9zWSAqIGJsb2NrSCk7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCBzcXVhcmVDb29yZHMpO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgUGl4ZWxhdGUgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGlMZW4gPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIGpMZW4gPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgaW5kZXgsIGksIGosIHIsIGcsIGIsIGEsXG4gICAgICAgICAgX2ksIF9qLCBfaUxlbiwgX2pMZW47XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpTGVuOyBpICs9IHRoaXMuYmxvY2tzaXplKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IHRoaXMuYmxvY2tzaXplKSB7XG5cbiAgICAgICAgICBpbmRleCA9IChpICogNCkgKiBqTGVuICsgKGogKiA0KTtcblxuICAgICAgICAgIHIgPSBkYXRhW2luZGV4XTtcbiAgICAgICAgICBnID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgIGIgPSBkYXRhW2luZGV4ICsgMl07XG4gICAgICAgICAgYSA9IGRhdGFbaW5kZXggKyAzXTtcblxuICAgICAgICAgIF9pTGVuID0gTWF0aC5taW4oaSArIHRoaXMuYmxvY2tzaXplLCBpTGVuKTtcbiAgICAgICAgICBfakxlbiA9IE1hdGgubWluKGogKyB0aGlzLmJsb2Nrc2l6ZSwgakxlbik7XG4gICAgICAgICAgZm9yIChfaSA9IGk7IF9pIDwgX2lMZW47IF9pKyspIHtcbiAgICAgICAgICAgIGZvciAoX2ogPSBqOyBfaiA8IF9qTGVuOyBfaisrKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gKF9pICogNCkgKiBqTGVuICsgKF9qICogNCk7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gcjtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDFdID0gZztcbiAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDJdID0gYjtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDNdID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgd2hlbiB0aGUgZmlsdGVyIGlzIG5vdCBnb25uYSBhcHBseSBjaGFuZ2VzIHRvIHRoZSBpbWFnZVxuICAgICAqKi9cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ibG9ja3NpemUgPT09IDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1QmxvY2tzaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VCbG9ja3NpemUnKSxcbiAgICAgICAgdVN0ZXBXOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwVycpLFxuICAgICAgICB1U3RlcEg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBIJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51QmxvY2tzaXplLCB0aGlzLmJsb2Nrc2l6ZSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUmVtb3ZlIHdoaXRlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3JcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3IjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yKHtcbiAgICogICB0aHJlc2hvbGQ6IDAuMixcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLlJlbW92ZUNvbG9yID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnUmVtb3ZlQ29sb3InLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3IgdG8gcmVtb3ZlLCBpbiBhbnkgZm9ybWF0IHVuZGVyc3Rvb2QgYnkgZmFicmljLkNvbG9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb2xvcjogJyNGRkZGRkYnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWM0IHVMb3c7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWM0IHVIaWdoO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnaWYoYWxsKGdyZWF0ZXJUaGFuKGdsX0ZyYWdDb2xvci5yZ2IsdUxvdy5yZ2IpKSAmJiBhbGwoZ3JlYXRlclRoYW4odUhpZ2gucmdiLGdsX0ZyYWdDb2xvci5yZ2IpKSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYSA9IDAuMDtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIGRpc3RhbmNlIHRvIGFjdHVhbCBjb2xvciwgYXMgdmFsdWUgdXAgb3IgZG93biBmcm9tIGVhY2ggcixnLGJcbiAgICAgKiBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiovXG4gICAgZGlzdGFuY2U6IDAuMDIsXG5cbiAgICAvKipcbiAgICAgKiBGb3IgY29sb3IgdG8gcmVtb3ZlIGluc2lkZSBkaXN0YW5jZSwgdXNlIGFscGhhIGNoYW5uZWwgZm9yIGEgc21vb3RoZXIgZGVsZXRpb25cbiAgICAgKiBOT1QgSU1QTEVNRU5URUQgWUVUXG4gICAgICoqL1xuICAgIHVzZUFscGhhOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29sb3I9I1JSR0dCQl0gVGhyZXNob2xkIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlPTEwXSBEaXN0YW5jZSB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLFxuICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSAqIDI1NSxcbiAgICAgICAgICByLCBnLCBiLFxuICAgICAgICAgIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCksXG4gICAgICAgICAgbG93QyA9IFtcbiAgICAgICAgICAgIHNvdXJjZVswXSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzFdIC0gZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMl0gLSBkaXN0YW5jZSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIGhpZ2hDID0gW1xuICAgICAgICAgICAgc291cmNlWzBdICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMV0gKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsyXSArIGRpc3RhbmNlLFxuICAgICAgICAgIF07XG5cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgIGlmIChyID4gbG93Q1swXSAmJlxuICAgICAgICAgICAgZyA+IGxvd0NbMV0gJiZcbiAgICAgICAgICAgIGIgPiBsb3dDWzJdICYmXG4gICAgICAgICAgICByIDwgaGlnaENbMF0gJiZcbiAgICAgICAgICAgIGcgPCBoaWdoQ1sxXSAmJlxuICAgICAgICAgICAgYiA8IGhpZ2hDWzJdKSB7XG4gICAgICAgICAgZGF0YVtpICsgM10gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1TG93OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VMb3cnKSxcbiAgICAgICAgdUhpZ2g6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUhpZ2gnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGRpc3RhbmNlID0gcGFyc2VGbG9hdCh0aGlzLmRpc3RhbmNlKSxcbiAgICAgICAgICBsb3dDID0gW1xuICAgICAgICAgICAgMCArIHNvdXJjZVswXSAvIDI1NSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgMCArIHNvdXJjZVsxXSAvIDI1NSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgMCArIHNvdXJjZVsyXSAvIDI1NSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIF0sXG4gICAgICAgICAgaGlnaEMgPSBbXG4gICAgICAgICAgICBzb3VyY2VbMF0gLyAyNTUgKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsxXSAvIDI1NSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzJdIC8gMjU1ICsgZGlzdGFuY2UsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgXTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51TG93LCBsb3dDKTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51SGlnaCwgaGlnaEMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgZGlzdGFuY2U6IHRoaXMuZGlzdGFuY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvcn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIHZhciBtYXRyaWNlcyA9IHtcbiAgICBCcm93bmllOiBbXG4gICAgICAwLjU5OTcwLDAuMzQ1NTMsLTAuMjcwODIsMCwwLjE4NixcbiAgICAgIC0wLjAzNzcwLDAuODYwOTUsMC4xNTA1OSwwLC0wLjE0NDksXG4gICAgICAwLjI0MTEzLC0wLjA3NDQxLDAuNDQ5NzIsMCwtMC4wMjk2NSxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgVmludGFnZTogW1xuICAgICAgMC42Mjc5MywwLjMyMDIxLC0wLjAzOTY1LDAsMC4wMzc4NCxcbiAgICAgIDAuMDI1NzgsMC42NDQxMSwwLjAzMjU5LDAsMC4wMjkyNixcbiAgICAgIDAuMDQ2NjAsLTAuMDg1MTIsMC41MjQxNiwwLDAuMDIwMjMsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIEtvZGFjaHJvbWU6IFtcbiAgICAgIDEuMTI4NTUsLTAuMzk2NzMsLTAuMDM5OTIsMCwwLjI0OTkxLFxuICAgICAgLTAuMTY0MDQsMS4wODM1MiwtMC4wNTQ5OCwwLDAuMDk2OTgsXG4gICAgICAtMC4xNjc4NiwtMC41NjAzNCwxLjYwMTQ4LDAsMC4xMzk3MixcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgVGVjaG5pY29sb3I6IFtcbiAgICAgIDEuOTEyNTIsLTAuODU0NTMsLTAuMDkxNTUsMCwwLjA0NjI0LFxuICAgICAgLTAuMzA4NzgsMS43NjU4OSwtMC4xMDYwMSwwLC0wLjI3NTg5LFxuICAgICAgLTAuMjMxMTAsLTAuNzUwMTgsMS44NDc1OSwwLDAuMTIxMzcsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFBvbGFyb2lkOiBbXG4gICAgICAxLjQzOCwtMC4wNjIsLTAuMDYyLDAsMCxcbiAgICAgIC0wLjEyMiwxLjM3OCwtMC4xMjIsMCwwLFxuICAgICAgLTAuMDE2LC0wLjAxNiwxLjQ4MywwLDAsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFNlcGlhOiBbXG4gICAgICAwLjM5MywgMC43NjksIDAuMTg5LCAwLCAwLFxuICAgICAgMC4zNDksIDAuNjg2LCAwLjE2OCwgMCwgMCxcbiAgICAgIDAuMjcyLCAwLjUzNCwgMC4xMzEsIDAsIDAsXG4gICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXSxcbiAgICBCbGFja1doaXRlOiBbXG4gICAgICAxLjUsIDEuNSwgMS41LCAwLCAtMSxcbiAgICAgIDEuNSwgMS41LCAxLjUsIDAsIC0xLFxuICAgICAgMS41LCAxLjUsIDEuNSwgMCwgLTEsXG4gICAgICAwLCAwLCAwLCAxLCAwLFxuICAgIF1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gbWF0cmljZXMpIHtcbiAgICBmaWx0ZXJzW2tleV0gPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkNvbG9yTWF0cml4LCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhLnByb3RvdHlwZSAqLyB7XG5cbiAgICAgIC8qKlxuICAgICAgICogRmlsdGVyIHR5cGVcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgKiBAZGVmYXVsdFxuICAgICAgICovXG4gICAgICB0eXBlOiBrZXksXG5cbiAgICAgIC8qKlxuICAgICAgICogQ29sb3JtYXRyaXggZm9yIHRoZSBlZmZlY3RcbiAgICAgICAqIGFycmF5IG9mIDIwIGZsb2F0cy4gTnVtYmVycyBpbiBwb3NpdGlvbnMgNCwgOSwgMTQsIDE5IGxvb3NlIG1lYW5pbmdcbiAgICAgICAqIG91dHNpZGUgdGhlIC0xLCAxIHJhbmdlLlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gbWF0cml4IGFycmF5IG9mIDIwIG51bWJlcnMuXG4gICAgICAgKiBAZGVmYXVsdFxuICAgICAgICovXG4gICAgICBtYXRyaXg6IG1hdHJpY2VzW2tleV0sXG5cbiAgICAgIC8qKlxuICAgICAgICogTG9jayB0aGUgbWF0cml4IGV4cG9ydCBmb3IgdGhpcyBraW5kIG9mIHN0YXRpYywgcGFyYW1ldGVyIGxlc3MgZmlsdGVycy5cbiAgICAgICAqL1xuICAgICAgbWFpblBhcmFtZXRlcjogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIExvY2sgdGhlIGNvbG9ybWF0cml4IG9uIHRoZSBjb2xvciBwYXJ0LCBza2lwcGluZyBhbHBoYVxuICAgICAgICovXG4gICAgICBjb2xvcnNPbmx5OiB0cnVlLFxuXG4gICAgfSk7XG4gICAgZmFicmljLkltYWdlLmZpbHRlcnNba2V5XS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuICB9XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBDb2xvciBCbGVuZCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXIuQmxlbmRDb2xvclxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3Ioe1xuICAgKiAgY29sb3I6ICcjMDAwJyxcbiAgICogIG1vZGU6ICdtdWx0aXBseSdcbiAgICogfSk7XG4gICAqXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZSh7XG4gICAqICBpbWFnZTogZmFicmljSW1hZ2VPYmplY3QsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknLFxuICAgKiAgYWxwaGE6IDAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG5cbiAgZmlsdGVycy5CbGVuZENvbG9yID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgdHlwZTogJ0JsZW5kQ29sb3InLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3IgdG8gbWFrZSB0aGUgYmxlbmQgb3BlcmF0aW9uIHdpdGguIGRlZmF1bHQgdG8gYSByZWRkaXNoIGNvbG9yIHNpbmNlIGJsYWNrIG9yIHdoaXRlXG4gICAgICogZ2l2ZXMgYWx3YXlzIHN0cm9uZyByZXN1bHQuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiovXG4gICAgY29sb3I6ICcjRjk1QzYzJyxcblxuICAgIC8qKlxuICAgICAqIEJsZW5kIG1vZGUgZm9yIHRoZSBmaWx0ZXI6IG9uZSBvZiBtdWx0aXBseSwgYWRkLCBkaWZmLCBzY3JlZW4sIHN1YnRyYWN0LFxuICAgICAqIGRhcmtlbiwgbGlnaHRlbiwgb3ZlcmxheSwgZXhjbHVzaW9uLCB0aW50LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICoqL1xuICAgIG1vZGU6ICdtdWx0aXBseScsXG5cbiAgICAvKipcbiAgICAgKiBhbHBoYSB2YWx1ZS4gcmVwcmVzZW50IHRoZSBzdHJlbmd0aCBvZiB0aGUgYmxlbmQgY29sb3Igb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICoqL1xuICAgIGFscGhhOiAxLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgTXVsdGlwbHkgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBtdWx0aXBseTogJ2dsX0ZyYWdDb2xvci5yZ2IgKj0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgc2NyZWVuOiAnZ2xfRnJhZ0NvbG9yLnJnYiA9IDEuMCAtICgxLjAgLSBnbF9GcmFnQ29sb3IucmdiKSAqICgxLjAgLSB1Q29sb3IucmdiKTtcXG4nLFxuICAgICAgYWRkOiAnZ2xfRnJhZ0NvbG9yLnJnYiArPSB1Q29sb3IucmdiO1xcbicsXG4gICAgICBkaWZmOiAnZ2xfRnJhZ0NvbG9yLnJnYiA9IGFicyhnbF9GcmFnQ29sb3IucmdiIC0gdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIHN1YnRyYWN0OiAnZ2xfRnJhZ0NvbG9yLnJnYiAtPSB1Q29sb3IucmdiO1xcbicsXG4gICAgICBsaWdodGVuOiAnZ2xfRnJhZ0NvbG9yLnJnYiA9IG1heChnbF9GcmFnQ29sb3IucmdiLCB1Q29sb3IucmdiKTtcXG4nLFxuICAgICAgZGFya2VuOiAnZ2xfRnJhZ0NvbG9yLnJnYiA9IG1pbihnbF9GcmFnQ29sb3IucmdiLCB1Q29sb3IucmdiKTtcXG4nLFxuICAgICAgZXhjbHVzaW9uOiAnZ2xfRnJhZ0NvbG9yLnJnYiArPSB1Q29sb3IucmdiIC0gMi4wICogKHVDb2xvci5yZ2IgKiBnbF9GcmFnQ29sb3IucmdiKTtcXG4nLFxuICAgICAgb3ZlcmxheTogJ2lmICh1Q29sb3IuciA8IDAuNSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuciAqPSAyLjAgKiB1Q29sb3IucjtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5yID0gMS4wIC0gMi4wICogKDEuMCAtIGdsX0ZyYWdDb2xvci5yKSAqICgxLjAgLSB1Q29sb3Iucik7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAgICdpZiAodUNvbG9yLmcgPCAwLjUpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmcgKj0gMi4wICogdUNvbG9yLmc7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuZyA9IDEuMCAtIDIuMCAqICgxLjAgLSBnbF9GcmFnQ29sb3IuZykgKiAoMS4wIC0gdUNvbG9yLmcpO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnaWYgKHVDb2xvci5iIDwgMC41KSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5iICo9IDIuMCAqIHVDb2xvci5iO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmIgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLmIpICogKDEuMCAtIHVDb2xvci5iKTtcXG4nICtcbiAgICAgICAgJ31cXG4nLFxuICAgICAgdGludDogJ2dsX0ZyYWdDb2xvci5yZ2IgKj0gKDEuMCAtIHVDb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYjtcXG4nLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBidWlsZCB0aGUgZnJhZ21lbnQgc291cmNlIGZvciB0aGUgZmlsdGVycywgam9pbmluZyB0aGUgY29tbW9uIHBhcnQgd2l0aFxuICAgICAqIHRoZSBzcGVjaWZpYyBvbmUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgdGhlIG1vZGUgb2YgdGhlIGZpbHRlciwgYSBrZXkgb2YgdGhpcy5mcmFnbWVudFNvdXJjZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHNvdXJjZSB0byBiZSBjb21waWxlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGRTb3VyY2U6IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgIHJldHVybiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHZlYzQgdUNvbG9yO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2lmIChjb2xvci5hID4gMC4wKSB7XFxuJyArXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50U291cmNlW21vZGVdICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAnfSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyB0aGlzLm1vZGUsIHNoYWRlclNvdXJjZTtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIHNoYWRlclNvdXJjZSA9IHRoaXMuYnVpbGRTb3VyY2UodGhpcy5tb2RlKTtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCbGVuZCBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGlMZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICB0ciwgdGcsIHRiLFxuICAgICAgICAgIHIsIGcsIGIsXG4gICAgICAgICAgc291cmNlLCBhbHBoYTEgPSAxIC0gdGhpcy5hbHBoYTtcblxuICAgICAgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcbiAgICAgIHRyID0gc291cmNlWzBdICogdGhpcy5hbHBoYTtcbiAgICAgIHRnID0gc291cmNlWzFdICogdGhpcy5hbHBoYTtcbiAgICAgIHRiID0gc291cmNlWzJdICogdGhpcy5hbHBoYTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcblxuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgICAgICBjYXNlICdtdWx0aXBseSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gciAqIHRyIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBnICogdGcgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGIgKiB0YiAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NjcmVlbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gMjU1IC0gKDI1NSAtIHIpICogKDI1NSAtIHRyKSAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gMjU1IC0gKDI1NSAtIGcpICogKDI1NSAtIHRnKSAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gMjU1IC0gKDI1NSAtIGIpICogKDI1NSAtIHRiKSAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICBkYXRhW2ldID0gciArIHRyO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBnICsgdGc7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGIgKyB0YjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RpZmYnOlxuICAgICAgICAgIGNhc2UgJ2RpZmZlcmVuY2UnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGguYWJzKHIgLSB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGguYWJzKGcgLSB0Zyk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IE1hdGguYWJzKGIgLSB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzdWJ0cmFjdCc6XG4gICAgICAgICAgICBkYXRhW2ldID0gciAtIHRyO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBnIC0gdGc7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGIgLSB0YjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Rhcmtlbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5taW4ociwgdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLm1pbihnLCB0Zyk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWluKGIsIHRiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2xpZ2h0ZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgubWF4KHIsIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5tYXgoZywgdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLm1heChiLCB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdvdmVybGF5JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSB0ciA8IDEyOCA/ICgyICogciAqIHRyIC8gMjU1KSA6ICgyNTUgLSAyICogKDI1NSAtIHIpICogKDI1NSAtIHRyKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHRnIDwgMTI4ID8gKDIgKiBnICogdGcgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gZykgKiAoMjU1IC0gdGcpIC8gMjU1KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gdGIgPCAxMjggPyAoMiAqIGIgKiB0YiAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSBiKSAqICgyNTUgLSB0YikgLyAyNTUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZXhjbHVzaW9uJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSB0ciArIHIgLSAoKDIgKiB0ciAqIHIpIC8gMjU1KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gdGcgKyBnIC0gKCgyICogdGcgKiBnKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHRiICsgYiAtICgoMiAqIHRiICogYikgLyAyNTUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGludCc6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgKyByICogYWxwaGExO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSB0ZyArIGcgKiBhbHBoYTE7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHRiICsgYiAqIGFscGhhMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUNvbG9yOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb2xvcicpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCk7XG4gICAgICBzb3VyY2VbMF0gPSB0aGlzLmFscGhhICogc291cmNlWzBdIC8gMjU1O1xuICAgICAgc291cmNlWzFdID0gdGhpcy5hbHBoYSAqIHNvdXJjZVsxXSAvIDI1NTtcbiAgICAgIHNvdXJjZVsyXSA9IHRoaXMuYWxwaGEgKiBzb3VyY2VbMl0gLyAyNTU7XG4gICAgICBzb3VyY2VbM10gPSB0aGlzLmFscGhhO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVDb2xvciwgc291cmNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgYWxwaGE6IHRoaXMuYWxwaGFcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3J9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3JcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3IuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogSW1hZ2UgQmxlbmQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVyLkJsZW5kSW1hZ2VcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yKHtcbiAgICogIGNvbG9yOiAnIzAwMCcsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknXG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uoe1xuICAgKiAgaW1hZ2U6IGZhYnJpY0ltYWdlT2JqZWN0LFxuICAgKiAgbW9kZTogJ211bHRpcGx5JyxcbiAgICogIGFscGhhOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuXG4gIGZpbHRlcnMuQmxlbmRJbWFnZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlLnByb3RvdHlwZSAqLyB7XG4gICAgdHlwZTogJ0JsZW5kSW1hZ2UnLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3IgdG8gbWFrZSB0aGUgYmxlbmQgb3BlcmF0aW9uIHdpdGguIGRlZmF1bHQgdG8gYSByZWRkaXNoIGNvbG9yIHNpbmNlIGJsYWNrIG9yIHdoaXRlXG4gICAgICogZ2l2ZXMgYWx3YXlzIHN0cm9uZyByZXN1bHQuXG4gICAgICoqL1xuICAgIGltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQmxlbmQgbW9kZSBmb3IgdGhlIGZpbHRlciAob25lIG9mIFwibXVsdGlwbHlcIiwgXCJtYXNrXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiovXG4gICAgbW9kZTogJ211bHRpcGx5JyxcblxuICAgIC8qKlxuICAgICAqIGFscGhhIHZhbHVlLiByZXByZXNlbnQgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibGVuZCBpbWFnZSBvcGVyYXRpb24uXG4gICAgICogbm90IGltcGxlbWVudGVkLlxuICAgICAqKi9cbiAgICBhbHBoYTogMSxcblxuICAgIHZlcnRleFNvdXJjZTogJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQyO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gbWF0MyB1VHJhbnNmb3JtTWF0cml4O1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZUZXhDb29yZCA9IGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICAgJ3ZUZXhDb29yZDIgPSAodVRyYW5zZm9ybU1hdHJpeCAqIHZlYzMoYVBvc2l0aW9uLCAxLjApKS54eTtcXG4nICtcbiAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChhUG9zaXRpb24gKiAyLjAgLSAxLjAsIDAuMCwgMS4wKTtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIE11bHRpcGx5IHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgbXVsdGlwbHk6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVJbWFnZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29sb3I7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVJbWFnZSwgdlRleENvb3JkMik7XFxuJyArXG4gICAgICAgICAgJ2NvbG9yLnJnYmEgKj0gY29sb3IyLnJnYmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBtYXNrOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1SW1hZ2U7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHZlYzQgdUNvbG9yO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQyO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1SW1hZ2UsIHZUZXhDb29yZDIpO1xcbicgK1xuICAgICAgICAgICdjb2xvci5hID0gY29sb3IyLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyB0aGlzLm1vZGU7XG4gICAgICB2YXIgc2hhZGVyU291cmNlID0gdGhpcy5mcmFnbWVudFNvdXJjZVt0aGlzLm1vZGVdO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIGFwcGx5VG9XZWJHTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgLy8gbG9hZCB0ZXh0dXJlIHRvIGJsZW5kLlxuICAgICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICAgIHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUob3B0aW9ucy5maWx0ZXJCYWNrZW5kLCB0aGlzLmltYWdlKTtcbiAgICAgIHRoaXMuYmluZEFkZGl0aW9uYWxUZXh0dXJlKGdsLCB0ZXh0dXJlLCBnbC5URVhUVVJFMSk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignYXBwbHlUb1dlYkdMJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnVuYmluZEFkZGl0aW9uYWxUZXh0dXJlKGdsLCBnbC5URVhUVVJFMSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVRleHR1cmU6IGZ1bmN0aW9uKGJhY2tlbmQsIGltYWdlKSB7XG4gICAgICByZXR1cm4gYmFja2VuZC5nZXRDYWNoZWRUZXh0dXJlKGltYWdlLmNhY2hlS2V5LCBpbWFnZS5fZWxlbWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhIHRyYW5zZm9ybU1hdHJpeCB0byBhZGFwdCB0aGUgaW1hZ2UgdG8gYmxlbmQgb3ZlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgY2FsY3VsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICAgICAgd2lkdGggPSBpbWFnZS5fZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBpbWFnZS5fZWxlbWVudC5oZWlnaHQ7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAxIC8gaW1hZ2Uuc2NhbGVYLCAwLCAwLFxuICAgICAgICAwLCAxIC8gaW1hZ2Uuc2NhbGVZLCAwLFxuICAgICAgICAtaW1hZ2UubGVmdCAvIHdpZHRoLCAtaW1hZ2UudG9wIC8gaGVpZ2h0LCAxXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQmxlbmQgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgcmVzb3VyY2VzID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcyxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGlMZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICB3aWR0aCA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIHRyLCB0ZywgdGIsIHRhLFxuICAgICAgICAgIHIsIGcsIGIsIGEsXG4gICAgICAgICAgY2FudmFzMSwgY29udGV4dCwgaW1hZ2UgPSB0aGlzLmltYWdlLCBibGVuZERhdGE7XG5cbiAgICAgIGlmICghcmVzb3VyY2VzLmJsZW5kSW1hZ2UpIHtcbiAgICAgICAgcmVzb3VyY2VzLmJsZW5kSW1hZ2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB9XG4gICAgICBjYW52YXMxID0gcmVzb3VyY2VzLmJsZW5kSW1hZ2U7XG4gICAgICBjb250ZXh0ID0gY2FudmFzMS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKGNhbnZhczEud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhczEuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgY2FudmFzMS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMxLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKGltYWdlLnNjYWxlWCwgMCwgMCwgaW1hZ2Uuc2NhbGVZLCBpbWFnZS5sZWZ0LCBpbWFnZS50b3ApO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UuX2VsZW1lbnQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgYmxlbmREYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICBhID0gZGF0YVtpICsgM107XG5cbiAgICAgICAgdHIgPSBibGVuZERhdGFbaV07XG4gICAgICAgIHRnID0gYmxlbmREYXRhW2kgKyAxXTtcbiAgICAgICAgdGIgPSBibGVuZERhdGFbaSArIDJdO1xuICAgICAgICB0YSA9IGJsZW5kRGF0YVtpICsgM107XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgICAgICBjYXNlICdtdWx0aXBseSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gciAqIHRyIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBnICogdGcgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGIgKiB0YiAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gYSAqIHRhIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWFzayc6XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IHRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVUcmFuc2Zvcm1NYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVRyYW5zZm9ybU1hdHJpeCcpLFxuICAgICAgICB1SW1hZ2U6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUltYWdlJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5jYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb25zLnVJbWFnZSwgMSk7IC8vIHRleHR1cmUgdW5pdCAxLlxuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1bmlmb3JtTG9jYXRpb25zLnVUcmFuc2Zvcm1NYXRyaXgsIGZhbHNlLCBtYXRyaXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBpbWFnZTogdGhpcy5pbWFnZSAmJiB0aGlzLmltYWdlLnRvT2JqZWN0KCksXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgYWxwaGE6IHRoaXMuYWxwaGFcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLkltYWdlLmZyb21PYmplY3Qob2JqZWN0LmltYWdlLCBmdW5jdGlvbihpbWFnZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob2JqZWN0KTtcbiAgICAgIG9wdGlvbnMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKG9wdGlvbnMpKTtcbiAgICB9KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSwgcG93ID0gTWF0aC5wb3csIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgIHNxcnQgPSBNYXRoLnNxcnQsIGFicyA9IE1hdGguYWJzLCByb3VuZCA9IE1hdGgucm91bmQsIHNpbiA9IE1hdGguc2luLFxuICAgICAgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBpbWFnZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplKCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLlJlc2l6ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdSZXNpemUnLFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHR5cGVcbiAgICAgKiBmb3Igd2ViZ2wgcmVzaXplVHlwZSBpcyBqdXN0IGxhbmN6b3MsIGZvciBjYW52YXMyZCBjYW4gYmU6XG4gICAgICogYmlsaW5lYXIsIGhlcm1pdGUsIHNsaWNlSGFjaywgbGFuY3pvcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVzaXplVHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVzaXplVHlwZTogJ2hlcm1pdGUnLFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIGZvciByZXNpemluZywgeCBheGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVYOiAxLFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIGZvciByZXNpemluZywgeSBheGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVZOiAxLFxuXG4gICAgLyoqXG4gICAgICogTGFuY3pvc0xvYmVzIHBhcmFtZXRlciBmb3IgbGFuY3pvcyBmaWx0ZXIsIHZhbGlkIGZvciByZXNpemVUeXBlIGxhbmN6b3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGFuY3pvc0xvYmVzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsYW5jem9zTG9iZXM6IDMsXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1RGVsdGE6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndURlbHRhJyksXG4gICAgICAgIHVUYXBzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VUYXBzJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMmZ2KHVuaWZvcm1Mb2NhdGlvbnMudURlbHRhLCB0aGlzLmhvcml6b250YWwgPyBbMSAvIHRoaXMud2lkdGgsIDBdIDogWzAsIDEgLyB0aGlzLmhlaWdodF0pO1xuICAgICAgZ2wudW5pZm9ybTFmdih1bmlmb3JtTG9jYXRpb25zLnVUYXBzLCB0aGlzLnRhcHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGZpbHRlcldpbmRvdyA9IHRoaXMuZ2V0RmlsdGVyV2luZG93KCksIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgZmlsdGVyV2luZG93O1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gdGhpcy5nZW5lcmF0ZVNoYWRlcihmaWx0ZXJXaW5kb3cpO1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBmcmFnbWVudFNoYWRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICBnZXRGaWx0ZXJXaW5kb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy50ZW1wU2NhbGU7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMubGFuY3pvc0xvYmVzIC8gc2NhbGUpO1xuICAgIH0sXG5cbiAgICBnZXRUYXBzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsb2JlRnVuY3Rpb24gPSB0aGlzLmxhbmN6b3NDcmVhdGUodGhpcy5sYW5jem9zTG9iZXMpLCBzY2FsZSA9IHRoaXMudGVtcFNjYWxlLFxuICAgICAgICAgIGZpbHRlcldpbmRvdyA9IHRoaXMuZ2V0RmlsdGVyV2luZG93KCksIHRhcHMgPSBuZXcgQXJyYXkoZmlsdGVyV2luZG93KTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGZpbHRlcldpbmRvdzsgaSsrKSB7XG4gICAgICAgIHRhcHNbaSAtIDFdID0gbG9iZUZ1bmN0aW9uKGkgKiBzY2FsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFwcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdmVydGV4IGFuZCBzaGFkZXIgc291cmNlcyBmcm9tIHRoZSBuZWNlc3Nhcnkgc3RlcHMgbnVtYmVyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmaWx0ZXJXaW5kb3dcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVNoYWRlcjogZnVuY3Rpb24oZmlsdGVyV2luZG93KSB7XG4gICAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShmaWx0ZXJXaW5kb3cpLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNvdXJjZVRPUCwgZmlsdGVyV2luZG93O1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBmaWx0ZXJXaW5kb3c7IGkrKykge1xuICAgICAgICBvZmZzZXRzW2kgLSAxXSA9IGkgKyAnLjAgKiB1RGVsdGEnO1xuICAgICAgfVxuXG4gICAgICBmcmFnbWVudFNoYWRlciArPSAndW5pZm9ybSBmbG9hdCB1VGFwc1snICsgZmlsdGVyV2luZG93ICsgJ107XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICd2b2lkIG1haW4oKSB7XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGZsb2F0IHN1bSA9IDEuMDtcXG4nO1xuXG4gICAgICBvZmZzZXRzLmZvckVhY2goZnVuY3Rpb24ob2Zmc2V0LCBpKSB7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGNvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgJyArIG9mZnNldCArICcpICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgICBmcmFnbWVudFNoYWRlciArPSAnICBjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCAtICcgKyBvZmZzZXQgKyAnKSAqIHVUYXBzWycgKyBpICsgJ107XFxuJztcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgc3VtICs9IDIuMCAqIHVUYXBzWycgKyBpICsgJ107XFxuJztcbiAgICAgIH0pO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyBzdW07XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICd9JztcbiAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICB9LFxuXG4gICAgZnJhZ21lbnRTb3VyY2VUT1A6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWMyIHVEZWx0YTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgcmVzaXplIGZpbHRlciB0byB0aGUgaW1hZ2VcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIFdlYkdMIG9yIENhbnZhczJEIGJhc2VkIG9uIHRoZSBvcHRpb25zLndlYmdsIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICAgICAgb3B0aW9ucy5wYXNzZXMrKztcbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdGlvbnMuc291cmNlV2lkdGg7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuZFcgPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiB0aGlzLnNjYWxlWCk7XG4gICAgICAgIHRoaXMuZEggPSBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgICAgdGhpcy50ZW1wU2NhbGUgPSB0aGlzLmRXIC8gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy50YXBzID0gdGhpcy5nZXRUYXBzKCk7XG4gICAgICAgIG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aCA9IHRoaXMuZFc7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuc291cmNlV2lkdGggPSBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGg7XG5cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZEggPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogdGhpcy5zY2FsZVkpO1xuICAgICAgICB0aGlzLnRlbXBTY2FsZSA9IHRoaXMuZEggLyB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy50YXBzID0gdGhpcy5nZXRUYXBzKCk7XG4gICAgICAgIG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQgPSB0aGlzLmRIO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnNvdXJjZUhlaWdodCA9IG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBseVRvMmQob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlWCA9PT0gMSAmJiB0aGlzLnNjYWxlWSA9PT0gMTtcbiAgICB9LFxuXG4gICAgbGFuY3pvc0NyZWF0ZTogZnVuY3Rpb24obG9iZXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID49IGxvYmVzIHx8IHggPD0gLWxvYmVzKSB7XG4gICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA8IDEuMTkyMDkyOTBFLTA3ICYmIHggPiAtMS4xOTIwOTI5MEUtMDcpIHtcbiAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICAgIHggKj0gTWF0aC5QSTtcbiAgICAgICAgdmFyIHh4ID0geCAvIGxvYmVzO1xuICAgICAgICByZXR1cm4gKHNpbih4KSAvIHgpICogc2luKHh4KSAvIHh4O1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHNjYWxlWCA9IHRoaXMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuXG4gICAgICB0aGlzLnJjcFNjYWxlWCA9IDEgLyBzY2FsZVg7XG4gICAgICB0aGlzLnJjcFNjYWxlWSA9IDEgLyBzY2FsZVk7XG5cbiAgICAgIHZhciBvVyA9IGltYWdlRGF0YS53aWR0aCwgb0ggPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIGRXID0gcm91bmQob1cgKiBzY2FsZVgpLCBkSCA9IHJvdW5kKG9IICogc2NhbGVZKSxcbiAgICAgICAgICBuZXdEYXRhO1xuXG4gICAgICBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnc2xpY2VIYWNrJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5zbGljZUJ5VHdvKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2hlcm1pdGUnKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmhlcm1pdGVGYXN0UmVzaXplKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2JpbGluZWFyJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5iaWxpbmVhckZpbHRlcmluZyhvcHRpb25zLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdsYW5jem9zJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5sYW5jem9zUmVzaXplKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gbmV3RGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHNsaWNlQnlUd29cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIHNsaWNlQnlUd286IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgbXVsdCA9IDAuNSwgZG9uZVcgPSBmYWxzZSwgZG9uZUggPSBmYWxzZSwgc3RlcFcgPSBvVyAqIG11bHQsXG4gICAgICAgICAgc3RlcEggPSBvSCAqIG11bHQsIHJlc291cmNlcyA9IGZhYnJpYy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcyxcbiAgICAgICAgICB0bXBDYW52YXMsIGN0eCwgc1ggPSAwLCBzWSA9IDAsIGRYID0gb1csIGRZID0gMDtcbiAgICAgIGlmICghcmVzb3VyY2VzLnNsaWNlQnlUd28pIHtcbiAgICAgICAgcmVzb3VyY2VzLnNsaWNlQnlUd28gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHJlc291cmNlcy5zbGljZUJ5VHdvO1xuICAgICAgaWYgKHRtcENhbnZhcy53aWR0aCA8IG9XICogMS41IHx8IHRtcENhbnZhcy5oZWlnaHQgPCBvSCkge1xuICAgICAgICB0bXBDYW52YXMud2lkdGggPSBvVyAqIDEuNTtcbiAgICAgICAgdG1wQ2FudmFzLmhlaWdodCA9IG9IO1xuICAgICAgfVxuICAgICAgY3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIG9XICogMS41LCBvSCk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgIGRXID0gZmxvb3IoZFcpO1xuICAgICAgZEggPSBmbG9vcihkSCk7XG5cbiAgICAgIHdoaWxlICghZG9uZVcgfHwgIWRvbmVIKSB7XG4gICAgICAgIG9XID0gc3RlcFc7XG4gICAgICAgIG9IID0gc3RlcEg7XG4gICAgICAgIGlmIChkVyA8IGZsb29yKHN0ZXBXICogbXVsdCkpIHtcbiAgICAgICAgICBzdGVwVyA9IGZsb29yKHN0ZXBXICogbXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3RlcFcgPSBkVztcbiAgICAgICAgICBkb25lVyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRIIDwgZmxvb3Ioc3RlcEggKiBtdWx0KSkge1xuICAgICAgICAgIHN0ZXBIID0gZmxvb3Ioc3RlcEggKiBtdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwSCA9IGRIO1xuICAgICAgICAgIGRvbmVIID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRtcENhbnZhcywgc1gsIHNZLCBvVywgb0gsIGRYLCBkWSwgc3RlcFcsIHN0ZXBIKTtcbiAgICAgICAgc1ggPSBkWDtcbiAgICAgICAgc1kgPSBkWTtcbiAgICAgICAgZFkgKz0gc3RlcEg7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LmdldEltYWdlRGF0YShzWCwgc1ksIGRXLCBkSCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBsYW5jem9zUmVzaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBsYW5jem9zUmVzaXplOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzKHUpIHtcbiAgICAgICAgdmFyIHYsIGksIHdlaWdodCwgaWR4LCBhLCByZWQsIGdyZWVuLFxuICAgICAgICAgICAgYmx1ZSwgYWxwaGEsIGZYLCBmWTtcbiAgICAgICAgY2VudGVyLnggPSAodSArIDAuNSkgKiByYXRpb1g7XG4gICAgICAgIGljZW50ZXIueCA9IGZsb29yKGNlbnRlci54KTtcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IGRIOyB2KyspIHtcbiAgICAgICAgICBjZW50ZXIueSA9ICh2ICsgMC41KSAqIHJhdGlvWTtcbiAgICAgICAgICBpY2VudGVyLnkgPSBmbG9vcihjZW50ZXIueSk7XG4gICAgICAgICAgYSA9IDA7IHJlZCA9IDA7IGdyZWVuID0gMDsgYmx1ZSA9IDA7IGFscGhhID0gMDtcbiAgICAgICAgICBmb3IgKGkgPSBpY2VudGVyLnggLSByYW5nZTJYOyBpIDw9IGljZW50ZXIueCArIHJhbmdlMlg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gb1cpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmWCA9IGZsb29yKDEwMDAgKiBhYnMoaSAtIGNlbnRlci54KSk7XG4gICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF0pIHtcbiAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXSA9IHsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpY2VudGVyLnkgLSByYW5nZTJZOyBqIDw9IGljZW50ZXIueSArIHJhbmdlMlk7IGorKykge1xuICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBvSCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZZID0gZmxvb3IoMTAwMCAqIGFicyhqIC0gY2VudGVyLnkpKTtcbiAgICAgICAgICAgICAgaWYgKCFjYWNoZUxhbmNbZlhdW2ZZXSkge1xuICAgICAgICAgICAgICAgIGNhY2hlTGFuY1tmWF1bZlldID0gbGFuY3pvcyhzcXJ0KHBvdyhmWCAqIHJjcFJhdGlvWCwgMikgKyBwb3coZlkgKiByY3BSYXRpb1ksIDIpKSAvIDEwMDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdlaWdodCA9IGNhY2hlTGFuY1tmWF1bZlldO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlkeCA9IChqICogb1cgKyBpKSAqIDQ7XG4gICAgICAgICAgICAgICAgYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmVkICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4XTtcbiAgICAgICAgICAgICAgICBncmVlbiArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDFdO1xuICAgICAgICAgICAgICAgIGJsdWUgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHggKyAyXTtcbiAgICAgICAgICAgICAgICBhbHBoYSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDNdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkeCA9ICh2ICogZFcgKyB1KSAqIDQ7XG4gICAgICAgICAgZGVzdERhdGFbaWR4XSA9IHJlZCAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMV0gPSBncmVlbiAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMl0gPSBibHVlIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAzXSA9IGFscGhhIC8gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK3UgPCBkVykge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzKHUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0SW1nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzcmNEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBkZXN0SW1nID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksXG4gICAgICAgICAgZGVzdERhdGEgPSBkZXN0SW1nLmRhdGEsXG4gICAgICAgICAgbGFuY3pvcyA9IHRoaXMubGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksXG4gICAgICAgICAgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJjcFJhdGlvWCA9IDIgLyB0aGlzLnJjcFNjYWxlWCwgcmNwUmF0aW9ZID0gMiAvIHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhbmdlMlggPSBjZWlsKHJhdGlvWCAqIHRoaXMubGFuY3pvc0xvYmVzIC8gMiksXG4gICAgICAgICAgcmFuZ2UyWSA9IGNlaWwocmF0aW9ZICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSxcbiAgICAgICAgICBjYWNoZUxhbmMgPSB7IH0sIGNlbnRlciA9IHsgfSwgaWNlbnRlciA9IHsgfTtcblxuICAgICAgcmV0dXJuIHByb2Nlc3MoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbGluZWFyRmlsdGVyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBiaWxpbmVhckZpbHRlcmluZzogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciBhLCBiLCBjLCBkLCB4LCB5LCBpLCBqLCB4RGlmZiwgeURpZmYsIGNobmwsXG4gICAgICAgICAgY29sb3IsIG9mZnNldCA9IDAsIG9yaWdQaXgsIHJhdGlvWCA9IHRoaXMucmNwU2NhbGVYLFxuICAgICAgICAgIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHc0ID0gNCAqIChvVyAtIDEpLCBpbWcgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBwaXhlbHMgPSBpbWcuZGF0YSwgZGVzdEltYWdlID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksXG4gICAgICAgICAgZGVzdFBpeGVscyA9IGRlc3RJbWFnZS5kYXRhO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGRIOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGRXOyBqKyspIHtcbiAgICAgICAgICB4ID0gZmxvb3IocmF0aW9YICogaik7XG4gICAgICAgICAgeSA9IGZsb29yKHJhdGlvWSAqIGkpO1xuICAgICAgICAgIHhEaWZmID0gcmF0aW9YICogaiAtIHg7XG4gICAgICAgICAgeURpZmYgPSByYXRpb1kgKiBpIC0geTtcbiAgICAgICAgICBvcmlnUGl4ID0gNCAqICh5ICogb1cgKyB4KTtcblxuICAgICAgICAgIGZvciAoY2hubCA9IDA7IGNobmwgPCA0OyBjaG5sKyspIHtcbiAgICAgICAgICAgIGEgPSBwaXhlbHNbb3JpZ1BpeCArIGNobmxdO1xuICAgICAgICAgICAgYiA9IHBpeGVsc1tvcmlnUGl4ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgYyA9IHBpeGVsc1tvcmlnUGl4ICsgdzQgKyBjaG5sXTtcbiAgICAgICAgICAgIGQgPSBwaXhlbHNbb3JpZ1BpeCArIHc0ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgY29sb3IgPSBhICogKDEgLSB4RGlmZikgKiAoMSAtIHlEaWZmKSArIGIgKiB4RGlmZiAqICgxIC0geURpZmYpICtcbiAgICAgICAgICAgICAgICAgICAgYyAqIHlEaWZmICogKDEgLSB4RGlmZikgKyBkICogeERpZmYgKiB5RGlmZjtcbiAgICAgICAgICAgIGRlc3RQaXhlbHNbb2Zmc2V0KytdID0gY29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdEltYWdlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoZXJtaXRlRmFzdFJlc2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgaGVybWl0ZUZhc3RSZXNpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgcmF0aW9XID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvSCA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhdGlvV0hhbGYgPSBjZWlsKHJhdGlvVyAvIDIpLFxuICAgICAgICAgIHJhdGlvSEhhbGYgPSBjZWlsKHJhdGlvSCAvIDIpLFxuICAgICAgICAgIGltZyA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBkYXRhID0gaW1nLmRhdGEsXG4gICAgICAgICAgaW1nMiA9IG9wdGlvbnMuY3R4LmNyZWF0ZUltYWdlRGF0YShkVywgZEgpLCBkYXRhMiA9IGltZzIuZGF0YTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZEg7IGorKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRXOyBpKyspIHtcbiAgICAgICAgICB2YXIgeDIgPSAoaSArIGogKiBkVykgKiA0LCB3ZWlnaHQgPSAwLCB3ZWlnaHRzID0gMCwgd2VpZ2h0c0FscGhhID0gMCxcbiAgICAgICAgICAgICAgZ3hSID0gMCwgZ3hHID0gMCwgZ3hCID0gMCwgZ3hBID0gMCwgY2VudGVyWSA9IChqICsgMC41KSAqIHJhdGlvSDtcbiAgICAgICAgICBmb3IgKHZhciB5eSA9IGZsb29yKGogKiByYXRpb0gpOyB5eSA8IChqICsgMSkgKiByYXRpb0g7IHl5KyspIHtcbiAgICAgICAgICAgIHZhciBkeSA9IGFicyhjZW50ZXJZIC0gKHl5ICsgMC41KSkgLyByYXRpb0hIYWxmLFxuICAgICAgICAgICAgICAgIGNlbnRlclggPSAoaSArIDAuNSkgKiByYXRpb1csIHcwID0gZHkgKiBkeTtcbiAgICAgICAgICAgIGZvciAodmFyIHh4ID0gZmxvb3IoaSAqIHJhdGlvVyk7IHh4IDwgKGkgKyAxKSAqIHJhdGlvVzsgeHgrKykge1xuICAgICAgICAgICAgICB2YXIgZHggPSBhYnMoY2VudGVyWCAtICh4eCArIDAuNSkpIC8gcmF0aW9XSGFsZixcbiAgICAgICAgICAgICAgICAgIHcgPSBzcXJ0KHcwICsgZHggKiBkeCk7XG4gICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuICAgICAgICAgICAgICBpZiAodyA+IDEgJiYgdyA8IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9oZXJtaXRlIGZpbHRlclxuICAgICAgICAgICAgICB3ZWlnaHQgPSAyICogdyAqIHcgKiB3IC0gMyAqIHcgKiB3ICsgMTtcbiAgICAgICAgICAgICAgaWYgKHdlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBkeCA9IDQgKiAoeHggKyB5eSAqIG9XKTtcbiAgICAgICAgICAgICAgICAvL2FscGhhXG4gICAgICAgICAgICAgICAgZ3hBICs9IHdlaWdodCAqIGRhdGFbZHggKyAzXTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzQWxwaGEgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICAgIC8vY29sb3JzXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbZHggKyAzXSA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0ICogZGF0YVtkeCArIDNdIC8gMjUwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBneFIgKz0gd2VpZ2h0ICogZGF0YVtkeF07XG4gICAgICAgICAgICAgICAgZ3hHICs9IHdlaWdodCAqIGRhdGFbZHggKyAxXTtcbiAgICAgICAgICAgICAgICBneEIgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDJdO1xuICAgICAgICAgICAgICAgIHdlaWdodHMgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEyW3gyXSA9IGd4UiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAxXSA9IGd4RyAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAyXSA9IGd4QiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAzXSA9IGd4QSAvIHdlaWdodHNBbHBoYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGltZzI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIHJlc2l6ZVR5cGU6IHRoaXMucmVzaXplVHlwZSxcbiAgICAgICAgbGFuY3pvc0xvYmVzOiB0aGlzLmxhbmN6b3NMb2Jlc1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29udHJhc3QgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3Qoe1xuICAgKiAgIGNvbnRyYXN0OiAwLjI1XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuQ29udHJhc3QgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb250cmFzdCcsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVDb250cmFzdDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBjb250cmFzdEYgPSAxLjAxNSAqICh1Q29udHJhc3QgKyAxLjApIC8gKDEuMCAqICgxLjAxNSAtIHVDb250cmFzdCkpO1xcbicgK1xuICAgICAgICAnY29sb3IucmdiID0gY29udHJhc3RGICogKGNvbG9yLnJnYiAtIDAuNSkgKyAwLjU7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIGNvbnRyYXN0IHZhbHVlLCByYW5nZSBmcm9tIC0xIHRvIDEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGNvbnRyYXN0OiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2NvbnRyYXN0JyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29udHJhc3Q9MF0gVmFsdWUgdG8gY29udHJhc3QgdGhlIGltYWdlIHVwICgtMS4uLjEpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgICogQXBwbHkgdGhlIENvbnRyYXN0IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5jb250cmFzdCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsIGksIGxlbixcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGNvbnRyYXN0ID0gTWF0aC5mbG9vcih0aGlzLmNvbnRyYXN0ICogMjU1KSxcbiAgICAgICAgICBjb250cmFzdEYgPSAyNTkgKiAoY29udHJhc3QgKyAyNTUpIC8gKDI1NSAqICgyNTkgLSBjb250cmFzdCkpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IGNvbnRyYXN0RiAqIChkYXRhW2ldIC0gMTI4KSArIDEyODtcbiAgICAgICAgZGF0YVtpICsgMV0gPSBjb250cmFzdEYgKiAoZGF0YVtpICsgMV0gLSAxMjgpICsgMTI4O1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGNvbnRyYXN0RiAqIChkYXRhW2kgKyAyXSAtIDEyOCkgKyAxMjg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Q29udHJhc3Q6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbnRyYXN0JyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51Q29udHJhc3QsIHRoaXMuY29udHJhc3QpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3R9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogU2F0dXJhdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24oe1xuICAgKiAgIHNhdHVyYXRpb246IDFcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5TYXR1cmF0aW9uID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdTYXR1cmF0aW9uJyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVNhdHVyYXRpb247XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnZmxvYXQgcmdNYXggPSBtYXgoY29sb3IuciwgY29sb3IuZyk7XFxuJyArXG4gICAgICAgICdmbG9hdCByZ2JNYXggPSBtYXgocmdNYXgsIGNvbG9yLmIpO1xcbicgK1xuICAgICAgICAnY29sb3IuciArPSByZ2JNYXggIT0gY29sb3IuciA/IChyZ2JNYXggLSBjb2xvci5yKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmcgKz0gcmdiTWF4ICE9IGNvbG9yLmcgPyAocmdiTWF4IC0gY29sb3IuZykgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XFxuJyArXG4gICAgICAgICdjb2xvci5iICs9IHJnYk1heCAhPSBjb2xvci5iID8gKHJnYk1heCAtIGNvbG9yLmIpICogdVNhdHVyYXRpb24gOiAwLjAwO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBTYXR1cmF0aW9uIHZhbHVlLCBmcm9tIC0xIHRvIDEuXG4gICAgICogSW5jcmVhc2VzL2RlY3JlYXNlcyB0aGUgY29sb3Igc2F0dXJhdGlvbi5cbiAgICAgKiBBIHZhbHVlIG9mIDAgaGFzIG5vIGVmZmVjdC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2F0dXJhdGlvbjogMCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdzYXR1cmF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2F0dXJhdGU9MF0gVmFsdWUgdG8gc2F0dXJhdGUgdGhlIGltYWdlICgtMS4uLjEpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgU2F0dXJhdGlvbiBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLnNhdHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgYWRqdXN0ID0gLXRoaXMuc2F0dXJhdGlvbiwgaSwgbWF4O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKTtcbiAgICAgICAgZGF0YVtpXSArPSBtYXggIT09IGRhdGFbaV0gPyAobWF4IC0gZGF0YVtpXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSBtYXggIT09IGRhdGFbaSArIDFdID8gKG1heCAtIGRhdGFbaSArIDFdKSAqIGFkanVzdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IG1heCAhPT0gZGF0YVtpICsgMl0gPyAobWF4IC0gZGF0YVtpICsgMl0pICogYWRqdXN0IDogMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVTYXR1cmF0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTYXR1cmF0aW9uJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51U2F0dXJhdGlvbiwgLXRoaXMuc2F0dXJhdGlvbik7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9ufSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbi5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogVmlicmFuY2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2Uoe1xuICAgKiAgIHZpYnJhbmNlOiAxXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuVmlicmFuY2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdWaWJyYW5jZScsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVWaWJyYW5jZTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBtYXggPSBtYXgoY29sb3IuciwgbWF4KGNvbG9yLmcsIGNvbG9yLmIpKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGF2ZyA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xcbicgK1xuICAgICAgICAnZmxvYXQgYW10ID0gKGFicyhtYXggLSBhdmcpICogMi4wKSAqIHVWaWJyYW5jZTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnIgKz0gbWF4ICE9IGNvbG9yLnIgPyAobWF4IC0gY29sb3IucikgKiBhbXQgOiAwLjAwO1xcbicgK1xuICAgICAgICAnY29sb3IuZyArPSBtYXggIT0gY29sb3IuZyA/IChtYXggLSBjb2xvci5nKSAqIGFtdCA6IDAuMDA7XFxuJyArXG4gICAgICAgICdjb2xvci5iICs9IG1heCAhPSBjb2xvci5iID8gKG1heCAtIGNvbG9yLmIpICogYW10IDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogVmlicmFuY2UgdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiBJbmNyZWFzZXMvZGVjcmVhc2VzIHRoZSBzYXR1cmF0aW9uIG9mIG1vcmUgbXV0ZWQgY29sb3JzIHdpdGggbGVzcyBlZmZlY3Qgb24gc2F0dXJhdGVkIGNvbG9ycy5cbiAgICAgKiBBIHZhbHVlIG9mIDAgaGFzIG5vIGVmZmVjdC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmlicmFuY2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHZpYnJhbmNlOiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ3ZpYnJhbmNlJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlicmFuY2U9MF0gVmlicmFuY2UgdmFsdWUgZm9yIHRoZSBpbWFnZSAoYmV0d2VlbiAtMSBhbmQgMSlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBWaWJyYW5jZSBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLnZpYnJhbmNlID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGFkanVzdCA9IC10aGlzLnZpYnJhbmNlLCBpLCBtYXgsIGF2ZywgYW10O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKTtcbiAgICAgICAgYXZnID0gKGRhdGFbaV0gKyBkYXRhW2kgKyAxXSArIGRhdGFbaSArIDJdKSAvIDM7XG4gICAgICAgIGFtdCA9ICgoTWF0aC5hYnMobWF4IC0gYXZnKSAqIDIgLyAyNTUpICogYWRqdXN0KTtcbiAgICAgICAgZGF0YVtpXSArPSBtYXggIT09IGRhdGFbaV0gPyAobWF4IC0gZGF0YVtpXSkgKiBhbXQgOiAwO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSBtYXggIT09IGRhdGFbaSArIDFdID8gKG1heCAtIGRhdGFbaSArIDFdKSAqIGFtdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IG1heCAhPT0gZGF0YVtpICsgMl0gPyAobWF4IC0gZGF0YVtpICsgMl0pICogYW10IDogMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVWaWJyYW5jZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1VmlicmFuY2UnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVWaWJyYW5jZSwgLXRoaXMudmlicmFuY2UpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQmx1ciBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXJcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1ciNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1cih7XG4gICAqICAgYmx1cjogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5CbHVyID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXIucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdCbHVyJyxcblxuICAgIC8qXG4nZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNyAqIHVEZWx0YSkqMC4wMDQ0Mjk5MTIxMDU1MTEzMjY1OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNiAqIHVEZWx0YSkqMC4wMDg5NTc4MTIxMTc5NDsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTUgKiB1RGVsdGEpKjAuMDIxNTk2Mzg2NjA1MzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTQgKiB1RGVsdGEpKjAuMDQ0MzY4MzMzODcxODsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTMgKiB1RGVsdGEpKjAuMDc3Njc0NDIxOTkzMzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTIgKiB1RGVsdGEpKjAuMTE1ODc2NjIxMTA1OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMSAqIHVEZWx0YSkqMC4xNDczMDgwNTYxMjE7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCAgICAgICAgICAgICAgKSowLjE1OTU3NjkxMjE2MTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgMSAqIHVEZWx0YSkqMC4xNDczMDgwNTYxMjE7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDIgKiB1RGVsdGEpKjAuMTE1ODc2NjIxMTA1OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAzICogdURlbHRhKSowLjA3NzY3NDQyMTk5MzM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDQgKiB1RGVsdGEpKjAuMDQ0MzY4MzMzODcxODsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNSAqIHVEZWx0YSkqMC4wMjE1OTYzODY2MDUzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA2ICogdURlbHRhKSowLjAwODk1NzgxMjExNzk0OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA3ICogdURlbHRhKSowLjAwNDQyOTkxMjEwNTUxMTMyNjU7JyxcbiovXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWMyIHVEZWx0YTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ2NvbnN0IGZsb2F0IG5TYW1wbGVzID0gMTUuMDtcXG4nICtcbiAgICAgICd2ZWMzIHYzb2Zmc2V0ID0gdmVjMygxMi45ODk4LCA3OC4yMzMsIDE1MS43MTgyKTtcXG4nICtcbiAgICAgICdmbG9hdCByYW5kb20odmVjMyBzY2FsZSkge1xcbicgK1xuICAgICAgICAvKiB1c2UgdGhlIGZyYWdtZW50IHBvc2l0aW9uIGZvciBhIGRpZmZlcmVudCBzZWVkIHBlci1waXhlbCAqL1xuICAgICAgICAncmV0dXJuIGZyYWN0KHNpbihkb3QoZ2xfRnJhZ0Nvb3JkLnh5eiwgc2NhbGUpKSAqIDQzNzU4LjU0NTMpO1xcbicgK1xuICAgICAgJ31cXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcbicgK1xuICAgICAgICAnZmxvYXQgdG90YWwgPSAwLjA7XFxuJyArXG4gICAgICAgICdmbG9hdCBvZmZzZXQgPSByYW5kb20odjNvZmZzZXQpO1xcbicgK1xuICAgICAgICAnZm9yIChmbG9hdCB0ID0gLW5TYW1wbGVzOyB0IDw9IG5TYW1wbGVzOyB0KyspIHtcXG4nICtcbiAgICAgICAgICAnZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIG5TYW1wbGVzO1xcbicgK1xuICAgICAgICAgICdmbG9hdCB3ZWlnaHQgPSAxLjAgLSBhYnMocGVyY2VudCk7XFxuJyArXG4gICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgdURlbHRhICogcGVyY2VudCkgKiB3ZWlnaHQ7XFxuJyArXG4gICAgICAgICAgJ3RvdGFsICs9IHdlaWdodDtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yIC8gdG90YWw7XFxuJyArXG4gICAgICAnfScsXG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbiAgICAvKipcbiAgICAgKiBibHVyIHZhbHVlLCBpbiBwZXJjZW50YWdlIG9mIGltYWdlIGRpbWVuc2lvbnMuXG4gICAgICogc3BlY2lmaWMgdG8ga2VlcCB0aGUgaW1hZ2UgYmx1ciBjb25zdGFudCBhdCBkaWZmZXJlbnQgcmVzb2x1dGlvbnNcbiAgICAgKiByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBibHVyOiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2JsdXInLFxuXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICAgICAgLy8gdGhpcyBhc3BlY3RSYXRpbyBpcyB1c2VkIHRvIGdpdmUgdGhlIHNhbWUgYmx1ciB0byB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbFxuICAgICAgICB0aGlzLmFzcGVjdFJhdGlvID0gb3B0aW9ucy5zb3VyY2VXaWR0aCAvIG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICBvcHRpb25zLnBhc3NlcysrO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBwYWludCBjYW52YXNFbCB3aXRoIGN1cnJlbnQgaW1hZ2UgZGF0YS5cbiAgICAgIC8vb3B0aW9ucy5jdHgucHV0SW1hZ2VEYXRhKG9wdGlvbnMuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gdGhpcy5zaW1wbGVCbHVyKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBzaW1wbGVCbHVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzb3VyY2VzID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcywgY2FudmFzMSwgY2FudmFzMixcbiAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMuaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgICAgaWYgKCFyZXNvdXJjZXMuYmx1ckxheWVyMSkge1xuICAgICAgICByZXNvdXJjZXMuYmx1ckxheWVyMSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgcmVzb3VyY2VzLmJsdXJMYXllcjIgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB9XG4gICAgICBjYW52YXMxID0gcmVzb3VyY2VzLmJsdXJMYXllcjE7XG4gICAgICBjYW52YXMyID0gcmVzb3VyY2VzLmJsdXJMYXllcjI7XG4gICAgICBpZiAoY2FudmFzMS53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzMS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBjYW52YXMyLndpZHRoID0gY2FudmFzMS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMyLmhlaWdodCA9IGNhbnZhczEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdmFyIGN0eDEgPSBjYW52YXMxLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgY3R4MiA9IGNhbnZhczIuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBuU2FtcGxlcyA9IDE1LFxuICAgICAgICAgIHJhbmRvbSwgcGVyY2VudCwgaiwgaSxcbiAgICAgICAgICBibHVyID0gdGhpcy5ibHVyICogMC4wNiAqIDAuNTtcblxuICAgICAgLy8gbG9hZCBmaXJzdCBjYW52YXNcbiAgICAgIGN0eDEucHV0SW1hZ2VEYXRhKG9wdGlvbnMuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBmb3IgKGkgPSAtblNhbXBsZXM7IGkgPD0gblNhbXBsZXM7IGkrKykge1xuICAgICAgICByYW5kb20gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA0O1xuICAgICAgICBwZXJjZW50ID0gaSAvIG5TYW1wbGVzO1xuICAgICAgICBqID0gYmx1ciAqIHBlcmNlbnQgKiB3aWR0aCArIHJhbmRvbTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDEgLSBNYXRoLmFicyhwZXJjZW50KTtcbiAgICAgICAgY3R4Mi5kcmF3SW1hZ2UoY2FudmFzMSwgaiwgcmFuZG9tKTtcbiAgICAgICAgY3R4MS5kcmF3SW1hZ2UoY2FudmFzMiwgMCwgMCk7XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgyLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMyLndpZHRoLCBjYW52YXMyLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAtblNhbXBsZXM7IGkgPD0gblNhbXBsZXM7IGkrKykge1xuICAgICAgICByYW5kb20gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA0O1xuICAgICAgICBwZXJjZW50ID0gaSAvIG5TYW1wbGVzO1xuICAgICAgICBqID0gYmx1ciAqIHBlcmNlbnQgKiBoZWlnaHQgKyByYW5kb207XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxIC0gTWF0aC5hYnMocGVyY2VudCk7XG4gICAgICAgIGN0eDIuZHJhd0ltYWdlKGNhbnZhczEsIHJhbmRvbSwgaik7XG4gICAgICAgIGN0eDEuZHJhd0ltYWdlKGNhbnZhczIsIDAsIDApO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4Mi5jbGVhclJlY3QoMCwgMCwgY2FudmFzMi53aWR0aCwgY2FudmFzMi5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5jdHguZHJhd0ltYWdlKGNhbnZhczEsIDAsIDApO1xuICAgICAgdmFyIG5ld0ltYWdlRGF0YSA9IG9wdGlvbnMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMxLndpZHRoLCBjYW52YXMxLmhlaWdodCk7XG4gICAgICBjdHgxLmdsb2JhbEFscGhhID0gMTtcbiAgICAgIGN0eDEuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczEud2lkdGgsIGNhbnZhczEuaGVpZ2h0KTtcbiAgICAgIHJldHVybiBuZXdJbWFnZURhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWx0YTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1RGVsdGEnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMuY2hvb3NlUmlnaHREZWx0YSgpO1xuICAgICAgZ2wudW5pZm9ybTJmdih1bmlmb3JtTG9jYXRpb25zLmRlbHRhLCBkZWx0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNob29zZSByaWdodCB2YWx1ZSBvZiBpbWFnZSBwZXJjZW50YWdlIHRvIGJsdXIgd2l0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYSBudW1lcmljIGFycmF5IHdpdGggZGVsdGEgdmFsdWVzXG4gICAgICovXG4gICAgY2hvb3NlUmlnaHREZWx0YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmx1clNjYWxlID0gMSwgZGVsdGEgPSBbMCwgMF0sIGJsdXI7XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvID4gMSkge1xuICAgICAgICAgIC8vIGltYWdlIGlzIHdpZGUsIGkgd2FudCB0byBzaHJpbmsgcmFkaXVzIGhvcml6b250YWxcbiAgICAgICAgICBibHVyU2NhbGUgPSAxIC8gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvIDwgMSkge1xuICAgICAgICAgIC8vIGltYWdlIGlzIHRhbGwsIGkgd2FudCB0byBzaHJpbmsgcmFkaXVzIHZlcnRpY2FsXG4gICAgICAgICAgYmx1clNjYWxlID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmx1ciA9IGJsdXJTY2FsZSAqIHRoaXMuYmx1ciAqIDAuMTI7XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIGRlbHRhWzBdID0gYmx1cjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWx0YVsxXSA9IGJsdXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgSlNPTiBkZWZpbml0aW9uIG9mIGEgQmx1ckZpbHRlciBpbnRvIGEgY29uY3JldGUgaW5zdGFuY2UuXG4gICAqL1xuICBmaWx0ZXJzLkJsdXIuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEdhbW1hIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWFcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hKHtcbiAgICogICBnYW1tYTogWzEsIDAuNSwgMi4xXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkdhbW1hID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnR2FtbWEnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWMzIHVHYW1tYTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICd2ZWMzIGNvcnJlY3Rpb24gPSAoMS4wIC8gdUdhbW1hKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnIgPSBwb3coY29sb3IuciwgY29ycmVjdGlvbi5yKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmcgPSBwb3coY29sb3IuZywgY29ycmVjdGlvbi5nKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmIgPSBwb3coY29sb3IuYiwgY29ycmVjdGlvbi5iKTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvci5hO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogR2FtbWEgYXJyYXkgdmFsdWUsIGZyb20gMC4wMSB0byAyLjIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ2FtbWFcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGdhbW1hOiBbMSwgMSwgMV0sXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAnZ2FtbWEnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5nYW1tYSA9IFsxLCAxLCAxXTtcbiAgICAgIGZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgR2FtbWEgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgZ2FtbWEgPSB0aGlzLmdhbW1hLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBySW52ID0gMSAvIGdhbW1hWzBdLCBnSW52ID0gMSAvIGdhbW1hWzFdLFxuICAgICAgICAgIGJJbnYgPSAxIC8gZ2FtbWFbMl0sIGk7XG5cbiAgICAgIGlmICghdGhpcy5yVmFscykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5yVmFscyA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLmdWYWxzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuYlZhbHMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiAtIHByZS1jb21wdXRlIGEgbG9vay11cCB0YWJsZSBmb3IgZWFjaCBjb2xvciBjaGFubmVsXG4gICAgICAvLyBpbnN0ZWFkIG9mIHBlcmZvcm1pbmcgdGhlc2UgcG93IGNhbGxzIGZvciBlYWNoIHBpeGVsIGluIHRoZSBpbWFnZS5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IDI1NjsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuclZhbHNbaV0gPSBNYXRoLnBvdyhpIC8gMjU1LCBySW52KSAqIDI1NTtcbiAgICAgICAgdGhpcy5nVmFsc1tpXSA9IE1hdGgucG93KGkgLyAyNTUsIGdJbnYpICogMjU1O1xuICAgICAgICB0aGlzLmJWYWxzW2ldID0gTWF0aC5wb3coaSAvIDI1NSwgYkludikgKiAyNTU7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSB0aGlzLnJWYWxzW2RhdGFbaV1dO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHRoaXMuZ1ZhbHNbZGF0YVtpICsgMV1dO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IHRoaXMuYlZhbHNbZGF0YVtpICsgMl1dO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUdhbW1hOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VHYW1tYScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTNmdih1bmlmb3JtTG9jYXRpb25zLnVHYW1tYSwgdGhpcy5nYW1tYSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWFcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBBIGNvbnRhaW5lciBjbGFzcyB0aGF0IGtub3dzIGhvdyB0byBhcHBseSBhIHNlcXVlbmNlIG9mIGZpbHRlcnMgdG8gYW4gaW5wdXQgaW1hZ2UuXG4gICAqL1xuICBmaWx0ZXJzLkNvbXBvc2VkID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkLnByb3RvdHlwZSAqLyB7XG5cbiAgICB0eXBlOiAnQ29tcG9zZWQnLFxuXG4gICAgLyoqXG4gICAgICogQSBub24gc3BhcnNlIGFycmF5IG9mIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKi9cbiAgICBzdWJGaWx0ZXJzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgaW5zdGVhZCBtdXRhdGluZyB0aGUgcHJvdG90eXBlIHdpdGggcHVzaFxuICAgICAgdGhpcy5zdWJGaWx0ZXJzID0gdGhpcy5zdWJGaWx0ZXJzLnNsaWNlKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGlzIGNvbnRhaW5lcidzIGZpbHRlcnMgdG8gdGhlIGlucHV0IGltYWdlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBhcHBsaWVkLlxuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMucGFzc2VzICs9IHRoaXMuc3ViRmlsdGVycy5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5zdWJGaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIGZpbHRlci5hcHBseVRvKG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGlzIGZpbHRlciBpbnRvIEpTT04uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmaWx0ZXIuXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgc3ViRmlsdGVyczogdGhpcy5zdWJGaWx0ZXJzLm1hcChmdW5jdGlvbihmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlci50b09iamVjdCgpOyB9KSxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuc3ViRmlsdGVycy5zb21lKGZ1bmN0aW9uKGZpbHRlcikgeyByZXR1cm4gIWZpbHRlci5pc05ldXRyYWxTdGF0ZSgpOyB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIEpTT04gZGVmaW5pdGlvbiBvZiBhIENvbXBvc2VkRmlsdGVyIGludG8gYSBjb25jcmV0ZSBpbnN0YW5jZS5cbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpbHRlcnMgPSBvYmplY3Quc3ViRmlsdGVycyB8fCBbXSxcbiAgICAgICAgc3ViRmlsdGVycyA9IGZpbHRlcnMubWFwKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnNbZmlsdGVyLnR5cGVdKGZpbHRlcik7XG4gICAgICAgIH0pLFxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db21wb3NlZCh7IHN1YkZpbHRlcnM6IHN1YkZpbHRlcnMgfSk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBIdWVSb3RhdGlvbiBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbih7XG4gICAqICAgcm90YXRpb246IC0wLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5IdWVSb3RhdGlvbiA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQ29sb3JNYXRyaXgsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdIdWVSb3RhdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBIdWVSb3RhdGlvbiB2YWx1ZSwgZnJvbSAtMSB0byAxLlxuICAgICAqIHRoZSB1bml0IGlzIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbXlQYXJhbWV0ZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ3JvdGF0aW9uJyxcblxuICAgIGNhbGN1bGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFkID0gdGhpcy5yb3RhdGlvbiAqIE1hdGguUEksIGNvcyA9IGZhYnJpYy51dGlsLmNvcyhyYWQpLCBzaW4gPSBmYWJyaWMudXRpbC5zaW4ocmFkKSxcbiAgICAgICAgICBhVGhpcmQgPSAxIC8gMywgYVRoaXJkU3F0U2luID0gTWF0aC5zcXJ0KGFUaGlyZCkgKiBzaW4sIE9uZU1pbnVzQ29zID0gMSAtIGNvcztcbiAgICAgIHRoaXMubWF0cml4ID0gW1xuICAgICAgICAxLCAwLCAwLCAwLCAwLFxuICAgICAgICAwLCAxLCAwLCAwLCAwLFxuICAgICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICBdO1xuICAgICAgdGhpcy5tYXRyaXhbMF0gPSBjb3MgKyBPbmVNaW51c0NvcyAvIDM7XG4gICAgICB0aGlzLm1hdHJpeFsxXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMl0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzVdID0gYVRoaXJkICogT25lTWludXNDb3MgKyBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFs2XSA9IGNvcyArIGFUaGlyZCAqIE9uZU1pbnVzQ29zO1xuICAgICAgdGhpcy5tYXRyaXhbN10gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyAtIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzEwXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMTFdID0gYVRoaXJkICogT25lTWludXNDb3MgKyBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsxMl0gPSBjb3MgKyBhVGhpcmQgKiBPbmVNaW51c0NvcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSHVlUm90YXRpb24gaXNOZXV0cmFsU3RhdGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBVc2VkIG9ubHkgaW4gaW1hZ2UgYXBwbHlGaWx0ZXJzIHRvIGRpc2NhcmQgZmlsdGVycyB0aGF0IHdpbGwgbm90IGhhdmUgYW4gZWZmZWN0XG4gICAgICogb24gdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlTWF0cml4KCk7XG4gICAgICByZXR1cm4gZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZS5pc05ldXRyYWxTdGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGlzIGZpbHRlciB0byB0aGUgaW5wdXQgaW1hZ2UgZGF0YSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZS5hcHBseVRvLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9ufSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvblxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgaWYgKGZhYnJpYy5UZXh0KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5UZXh0IGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhZGRpdGlvbmFsUHJvcHMgPVxuICAgICgnZm9udEZhbWlseSBmb250V2VpZ2h0IGZvbnRTaXplIHRleHQgdW5kZXJsaW5lIG92ZXJsaW5lIGxpbmV0aHJvdWdoJyArXG4gICAgJyB0ZXh0QWxpZ24gZm9udFN0eWxlIGxpbmVIZWlnaHQgdGV4dEJhY2tncm91bmRDb2xvciBjaGFyU3BhY2luZyBzdHlsZXMnICtcbiAgICAnIGRpcmVjdGlvbiBwYXRoIHBhdGhTdGFydE9mZnNldCBwYXRoU2lkZSBwYXRoQWxpZ24nKS5zcGxpdCgnICcpO1xuXG4gIC8qKlxuICAgKiBUZXh0IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuVGV4dFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI3RleHR9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UZXh0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVGV4dCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgd2hpY2ggd2hlbiBzZXQgY2F1c2Ugb2JqZWN0IHRvIGNoYW5nZSBkaW1lbnNpb25zXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaW1lbnNpb25BZmZlY3RpbmdQcm9wczogW1xuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ2xpbmVIZWlnaHQnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgJ3N0eWxlcycsXG4gICAgICAncGF0aCcsXG4gICAgICAncGF0aFN0YXJ0T2Zmc2V0JyxcbiAgICAgICdwYXRoU2lkZScsXG4gICAgICAncGF0aEFsaWduJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZU5ld2xpbmU6IC9cXHI/XFxuLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgZm9yIHdoaXRlc3BhY2VzIHRoYXQgaXMgbm90IGEgbmV3IGxpbmUuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2VzQW5kVGFiczogL1sgXFx0XFxyXS9nLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBmb3Igd2hpdGVzcGFjZSB0aGF0IGlzIG5vdCBhIG5ldyBsaW5lLlxuICAgICAqIE1vc3RseSB1c2VkIHdoZW4gdGV4dCBpcyAnanVzdGlmeScgYWxpZ25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlQW5kVGFiOiAvWyBcXHRcXHJdLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgY29uc2VjdXRpdmUgZ3JvdXBzIG9mIG5vbiBzcGFjZXMuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlV29yZHM6IC9cXFMrL2csXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICd0ZXh0JyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFNpemU6ICAgICAgICAgICAgIDQwLFxuXG4gICAgLyoqXG4gICAgICogRm9udCB3ZWlnaHQgKGUuZy4gYm9sZCwgbm9ybWFsLCA0MDAsIDYwMCwgODAwKVxuICAgICAqIEB0eXBlIHsoTnVtYmVyfFN0cmluZyl9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250V2VpZ2h0OiAgICAgICAgICAgJ25vcm1hbCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IGZhbWlseVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udEZhbWlseTogICAgICAgICAgICdUaW1lcyBOZXcgUm9tYW4nLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBkZWNvcmF0aW9uIHVuZGVybGluZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1bmRlcmxpbmU6ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBkZWNvcmF0aW9uIG92ZXJsaW5lLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsaW5lOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgZGVjb3JhdGlvbiBsaW5ldGhyb3VnaC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsaW5ldGhyb3VnaDogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGFsaWdubWVudC4gUG9zc2libGUgdmFsdWVzOiBcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiLCBcImp1c3RpZnlcIixcbiAgICAgKiBcImp1c3RpZnktbGVmdFwiLCBcImp1c3RpZnktY2VudGVyXCIgb3IgXCJqdXN0aWZ5LXJpZ2h0XCIuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0ZXh0QWxpZ246ICAgICAgICAgICAgJ2xlZnQnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzdHlsZSAuIFBvc3NpYmxlIHZhbHVlczogXCJcIiwgXCJub3JtYWxcIiwgXCJpdGFsaWNcIiBvciBcIm9ibGlxdWVcIi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRTdHlsZTogICAgICAgICAgICAnbm9ybWFsJyxcblxuICAgIC8qKlxuICAgICAqIExpbmUgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsaW5lSGVpZ2h0OiAgICAgICAgICAgMS4xNixcblxuICAgIC8qKlxuICAgICAqIFN1cGVyc2NyaXB0IHNjaGVtYSBvYmplY3QgKG1pbmltdW0gb3ZlcmxhcClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3VwZXJzY3JpcHQ6IHtcbiAgICAgIHNpemU6ICAgICAgMC42MCwgLy8gZm9udFNpemUgZmFjdG9yXG4gICAgICBiYXNlbGluZTogLTAuMzUgIC8vIGJhc2VsaW5lLXNoaWZ0IGZhY3RvciAodXB3YXJkcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaXB0IHNjaGVtYSBvYmplY3QgKG1pbmltdW0gb3ZlcmxhcClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Vic2NyaXB0OiB7XG4gICAgICBzaXplOiAgICAgIDAuNjAsIC8vIGZvbnRTaXplIGZhY3RvclxuICAgICAgYmFzZWxpbmU6ICAwLjExICAvLyBiYXNlbGluZS1zaGlmdCBmYWN0b3IgKGRvd253YXJkcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiB0ZXh0IGxpbmVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiAgJycsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZlxuICAgICAqIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdChhZGRpdGlvbmFsUHJvcHMpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgY2FjaGUgbmVlZHMgcmVmcmVzaFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KGFkZGl0aW9uYWxQcm9wcyksXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlZmluZWQsIGFuIG9iamVjdCBpcyByZW5kZXJlZCB2aWEgc3Ryb2tlIGFuZCB0aGlzIHByb3BlcnR5IHNwZWNpZmllcyBpdHMgY29sb3IuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgbmFtZWQgXCJzdHJva2VTdHlsZVwiIHVudGlsIHYxLjEuNlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlOiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyBuYW1lZCBcInRleHRTaGFkb3dcIiAoU3RyaW5nKSB1bnRpbCB2MS4yLjExXG4gICAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2hhZG93OiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmYWJyaWMuUGF0aCB0aGF0IHRoZSB0ZXh0IHNob3VsZCBmb2xsb3cuXG4gICAgICogc2luY2UgNC42LjAgdGhlIHBhdGggd2lsbCBiZSBkcmF3biBhdXRvbWF0aWNhbGx5LlxuICAgICAqIGlmIHlvdSB3YW50IHRvIG1ha2UgdGhlIHBhdGggdmlzaWJsZSwgZ2l2ZSBpdCBhIHN0cm9rZSBhbmQgc3Ryb2tlV2lkdGggb3IgZmlsbCB2YWx1ZVxuICAgICAqIGlmIHlvdSB3YW50IGl0IHRvIGJlIGhpZGRlbiwgYXNzaWduIHZpc2libGUgPSBmYWxzZSB0byB0aGUgcGF0aC5cbiAgICAgKiBUaGlzIGZlYXR1cmUgaXMgaW4gQkVUQSwgYW5kIFNWRyBpbXBvcnQvZXhwb3J0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkLlxuICAgICAqIEB0eXBlIGZhYnJpYy5QYXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgdGV4dFBhdGggPSBuZXcgZmFicmljLlRleHQoJ1RleHQgb24gYSBwYXRoJywge1xuICAgICAqICAgICB0b3A6IDE1MCxcbiAgICAgKiAgICAgbGVmdDogMTUwLFxuICAgICAqICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAqICAgICBjaGFyU3BhY2luZzogLTUwLFxuICAgICAqICAgICBwYXRoOiBuZXcgZmFicmljLlBhdGgoJ00gMCAwIEMgNTAgLTEwMCAxNTAgLTEwMCAyMDAgMCcsIHtcbiAgICAgKiAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAqICAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgKiAgICAgfSksXG4gICAgICogICAgIHBhdGhTaWRlOiAnbGVmdCcsXG4gICAgICogICAgIHBhdGhTdGFydE9mZnNldDogMFxuICAgICAqIH0pO1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aDogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT2Zmc2V0IGFtb3VudCBmb3IgdGV4dCBwYXRoIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICogT25seSB1c2VkIHdoZW4gdGV4dCBoYXMgYSBwYXRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoU3RhcnRPZmZzZXQ6ICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIHNpZGUgb2YgdGhlIHBhdGggdGhlIHRleHQgc2hvdWxkIGJlIGRyYXduIG9uLlxuICAgICAqIE9ubHkgdXNlZCB3aGVuIHRleHQgaGFzIGEgcGF0aFxuICAgICAqIEB0eXBlIHtTdHJpbmd9ICdsZWZ0fHJpZ2h0J1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aFNpZGU6ICAgICAgICAgICAgICAgJ2xlZnQnLFxuXG4gICAgLyoqXG4gICAgICogSG93IHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcGF0aC4gVGhpcyBwcm9wZXJ0eSBkZXRlcm1pbmVzXG4gICAgICogdGhlIHBlcnBlbmRpY3VsYXIgcG9zaXRpb24gb2YgZWFjaCBjaGFyYWN0ZXIgcmVsYXRpdmUgdG8gdGhlIHBhdGguXG4gICAgICogKG9uZSBvZiBcImJhc2VsaW5lXCIsIFwiY2VudGVyXCIsIFwiYXNjZW5kZXJcIiwgXCJkZXNjZW5kZXJcIilcbiAgICAgKiBUaGlzIGZlYXR1cmUgaXMgaW4gQkVUQSwgYW5kIGl0cyBiZWhhdmlvciBtYXkgY2hhbmdlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoQWxpZ246ICAgICAgICAgICAgICAgJ2Jhc2VsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZvbnRTaXplRnJhY3Rpb246IDAuMjIyLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvZmZzZXRzOiB7XG4gICAgICB1bmRlcmxpbmU6IDAuMTAsXG4gICAgICBsaW5ldGhyb3VnaDogLTAuMzE1LFxuICAgICAgb3ZlcmxpbmU6IC0wLjg4XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgTGluZSBwcm9wb3J0aW9uIHRvIGZvbnQgU2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX2ZvbnRTaXplTXVsdDogICAgICAgICAgICAgMS4xMyxcblxuICAgIC8qKlxuICAgICAqIGFkZGl0aW9uYWwgc3BhY2UgYmV0d2VlbiBjaGFyYWN0ZXJzXG4gICAgICogZXhwcmVzc2VkIGluIHRob3VzYW5kcyBvZiBlbSB1bml0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjaGFyU3BhY2luZzogICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBjb250YWluaW5nIGNoYXJhY3RlciBzdHlsZXMgLSB0b3AtbGV2ZWwgcHJvcGVydGllcyAtPiBsaW5lIG51bWJlcnMsXG4gICAgICogMm5kLWxldmVsIHByb3BlcnRpZXMgLSBjaGFyYWN0ZXIgbnVtYmVyc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGEgY29udGV4dCB0byBtZWFzdXJlIHRleHQgY2hhciBvciBjb3VwbGUgb2YgY2hhcnNcbiAgICAgKiB0aGUgY2FjaGVDb250ZXh0IG9mIHRoZSBjYW52YXMgd2lsbCBiZSB1c2VkIG9yIGEgZnJlc2hseSBjcmVhdGVkIG9uZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBvbiBjYW52YXNcbiAgICAgKiBvbmNlIGNyZWF0ZWQgaXQgd2lsbCBiZSByZWZlcmVuY2VkIG9uIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCB0byBhdm9pZCBjcmVhdGluZyBhIGNhbnZhcyBmb3IgZXZlcnlcbiAgICAgKiB0ZXh0IG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfbWVhc3VyaW5nQ29udGV4dDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEJhc2VsaW5lIHNoaWZ0LCBzdHlsZXMgb25seSwga2VlcCBhdCAwIGZvciB0aGUgbWFpbiB0ZXh0IG9iamVjdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkZWx0YVk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBXQVJOSU5HOiBFWFBFUklNRU5UQUwuIE5PVCBTVVBQT1JURUQgWUVUXG4gICAgICogZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRleHQuXG4gICAgICogVGhpcyBoYXMgdG8gYmUgc2V0IG1hbnVhbGx5IHRvZ2V0aGVyIHdpdGggdGV4dEFsaWduIGFuZCBvcmlnaW5YIGZvciBwcm9wZXJcbiAgICAgKiBleHBlcmllbmNlLlxuICAgICAqIHNvbWUgaW50ZXJlc3RpbmcgbGluayBmb3IgdGhlIGZ1dHVyZVxuICAgICAqIGh0dHBzOi8vd3d3LnczLm9yZy9JbnRlcm5hdGlvbmFsL3F1ZXN0aW9ucy9xYS1iaWRpLXVuaWNvZGUtY29udHJvbHNcbiAgICAgKiBAc2luY2UgNC41LjBcbiAgICAgKiBAdHlwZSB7U3RyaW5nfSAnbHRyfHJ0bCdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGRpcmVjdGlvbjogJ2x0cicsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lIGEgc3R5bGUgdW5pdCAob2YgJ3N0eWxlcycpLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIF9zdHlsZVByb3BlcnRpZXM6IFtcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAgICdmaWxsJyxcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAnZm9udFdlaWdodCcsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICd1bmRlcmxpbmUnLFxuICAgICAgJ292ZXJsaW5lJyxcbiAgICAgICdsaW5ldGhyb3VnaCcsXG4gICAgICAnZGVsdGFZJyxcbiAgICAgICd0ZXh0QmFja2dyb3VuZENvbG9yJyxcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogY29udGFpbnMgY2hhcmFjdGVycyBib3VuZGluZyBib3hlc1xuICAgICAqL1xuICAgIF9fY2hhckJvdW5kczogW10sXG5cbiAgICAvKipcbiAgICAgKiB1c2UgdGhpcyBzaXplIHdoZW4gbWVhc3VyaW5nIHRleHQuIFRvIGF2b2lkIElFMTEgcm91bmRpbmcgZXJyb3JzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ0FDSEVfRk9OVF9TSVpFOiA0MDAsXG5cbiAgICAvKipcbiAgICAgKiBjb250YWlucyB0aGUgbWluIHRleHQgd2lkdGggdG8gYXZvaWQgZ2V0dGluZyAwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIE1JTl9URVhUX1dJRFRIOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc3R5bGVzID0gb3B0aW9ucyA/IChvcHRpb25zLnN0eWxlcyB8fCB7IH0pIDogeyB9O1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgIHRoaXMuX19za2lwRGltZW5zaW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgIHRoaXMuc2V0UGF0aEluZm8oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19za2lwRGltZW5zaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5zZXR1cFN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0ZXh0IGhhcyBhIHBhdGgsIGl0IHdpbGwgYWRkIHRoZSBleHRyYSBpbmZvcm1hdGlvbiBuZWVkZWRcbiAgICAgKiBmb3IgcGF0aCBhbmQgdGV4dCBjYWxjdWxhdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldFBhdGhJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcGF0aC5zZWdtZW50c0luZm8gPSBmYWJyaWMudXRpbC5nZXRQYXRoU2VnbWVudHNJbmZvKHBhdGgucGF0aCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvbnRleHQgZm9yIG1lYXN1cmVtZW50IG9mIHRleHQgc3RyaW5nLlxuICAgICAqIGlmIGNyZWF0ZWQgaXQgZ2V0cyBzdG9yZWQgZm9yIHJldXNlXG4gICAgICogdGhpcyBpcyBmb3IgaW50ZXJuYWwgdXNlLCBwbGVhc2UgZG8gbm90IHVzZSBpdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBnZXRNZWFzdXJpbmdDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGlmIHdlIGRpZCBub3QgcmV0dXJuIHdlIGhhdmUgdG8gbWVhc3VyZSBzb21ldGhpbmcuXG4gICAgICBpZiAoIWZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCkge1xuICAgICAgICBmYWJyaWMuX21lYXN1cmluZ0NvbnRleHQgPSB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jb250ZXh0Q2FjaGUgfHxcbiAgICAgICAgICBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWJyaWMuX21lYXN1cmluZ0NvbnRleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGl2aWRlcyB0ZXh0IGludG8gbGluZXMgb2YgdGV4dCBhbmQgbGluZXMgb2YgZ3JhcGhlbWVzLlxuICAgICAqL1xuICAgIF9zcGxpdFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5ld0xpbmVzID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKHRoaXMudGV4dCk7XG4gICAgICB0aGlzLnRleHRMaW5lcyA9IG5ld0xpbmVzLmxpbmVzO1xuICAgICAgdGhpcy5fdGV4dExpbmVzID0gbmV3TGluZXMuZ3JhcGhlbWVMaW5lcztcbiAgICAgIHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lcyA9IG5ld0xpbmVzLl91bndyYXBwZWRMaW5lcztcbiAgICAgIHRoaXMuX3RleHQgPSBuZXdMaW5lcy5ncmFwaGVtZVRleHQ7XG4gICAgICByZXR1cm4gbmV3TGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgb3IgdXBkYXRlIHRleHQgZGltZW5zaW9ucy5cbiAgICAgKiBVcGRhdGVzIHRoaXMud2lkdGggYW5kIHRoaXMuaGVpZ2h0IHdpdGggdGhlIHByb3BlciB2YWx1ZXMuXG4gICAgICogRG9lcyBub3QgcmV0dXJuIGRpbWVuc2lvbnMuXG4gICAgICovXG4gICAgaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX19za2lwRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NwbGl0VGV4dCgpO1xuICAgICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5wYXRoLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMucGF0aC5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY2FsY1RleHRXaWR0aCgpIHx8IHRoaXMuY3Vyc29yV2lkdGggfHwgdGhpcy5NSU5fVEVYVF9XSURUSDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbGNUZXh0SGVpZ2h0KCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAvLyBvbmNlIHRleHQgaXMgbWVhc3VyZWQgd2UgbmVlZCB0byBtYWtlIHNwYWNlIGZhdHRlciB0byBtYWtlIGp1c3RpZmllZCB0ZXh0LlxuICAgICAgICB0aGlzLmVubGFyZ2VTcGFjZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmxhcmdlIHNwYWNlIGJveGVzIGFuZCBzaGlmdCB0aGUgb3RoZXJzXG4gICAgICovXG4gICAgZW5sYXJnZVNwYWNlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGlmZlNwYWNlLCBjdXJyZW50TGluZVdpZHRoLCBudW1iZXJPZlNwYWNlcywgYWNjdW11bGF0ZWRTcGFjZSwgbGluZSwgY2hhckJvdW5kLCBzcGFjZXM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRBbGlnbiAhPT0gJ2p1c3RpZnknICYmIChpID09PSBsZW4gLSAxIHx8IHRoaXMuaXNFbmRPZldyYXBwaW5nKGkpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtdWxhdGVkU3BhY2UgPSAwO1xuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoaSk7XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoIDwgdGhpcy53aWR0aCAmJiAoc3BhY2VzID0gdGhpcy50ZXh0TGluZXNbaV0ubWF0Y2godGhpcy5fcmVTcGFjZXNBbmRUYWJzKSkpIHtcbiAgICAgICAgICBudW1iZXJPZlNwYWNlcyA9IHNwYWNlcy5sZW5ndGg7XG4gICAgICAgICAgZGlmZlNwYWNlID0gKHRoaXMud2lkdGggLSBjdXJyZW50TGluZVdpZHRoKSAvIG51bWJlck9mU3BhY2VzO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPD0gamxlbjsgaisrKSB7XG4gICAgICAgICAgICBjaGFyQm91bmQgPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtqXSkpIHtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLndpZHRoICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmtlcm5lZFdpZHRoICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmxlZnQgKz0gYWNjdW11bGF0ZWRTcGFjZTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZWRTcGFjZSArPSBkaWZmU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmxlZnQgKz0gYWNjdW11bGF0ZWRTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIHRoZSB0ZXh0IGxpbmUgaXMgZW5kZWQgd2l0aCBhbiBoYXJkIGJyZWFrXG4gICAgICogdGV4dCBhbmQgaXRleHQgZG8gbm90IGhhdmUgd3JhcHBpbmcsIHJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbmRPZldyYXBwaW5nOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiBsaW5lSW5kZXggPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYSBsaW5lIGhhcyBhIGxpbmVicmVhayBhbmQgc28gd2UgbmVlZCB0byBhY2NvdW50IGZvciBpdCB3aGVuIG1vdmluZ1xuICAgICAqIGFuZCBjb3VudGluZyBzdHlsZS5cbiAgICAgKiBJdCByZXR1cm4gYWx3YXlzIGZvciB0ZXh0IGFuZCBJdGV4dC5cbiAgICAgKiBAcmV0dXJuIE51bWJlclxuICAgICAqL1xuICAgIG1pc3NpbmdOZXdsaW5lT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRleHQgb2JqZWN0XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5UZXh0ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRleHRcIjogXCInICsgdGhpcy50ZXh0ICsgJ1wiLCBcImZvbnRGYW1pbHlcIjogXCInICsgdGhpcy5mb250RmFtaWx5ICsgJ1wiIH0+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaW1lbnNpb24gYW5kIHRoZSB6b29tIGxldmVsIG5lZWRlZCB0byBjcmVhdGUgYSBjYWNoZSBjYW52YXNcbiAgICAgKiBiaWcgZW5vdWdoIHRvIGhvc3QgdGhlIG9iamVjdCB0byBiZSBjYWNoZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltLnggd2lkdGggb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW0ueSBoZWlnaHQgb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2dldENhY2hlQ2FudmFzRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltcyA9IHRoaXMuY2FsbFN1cGVyKCdfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zJyk7XG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmZvbnRTaXplO1xuICAgICAgZGltcy53aWR0aCArPSBmb250U2l6ZSAqIGRpbXMuem9vbVg7XG4gICAgICBkaW1zLmhlaWdodCArPSBmb250U2l6ZSAqIGRpbXMuem9vbVk7XG4gICAgICByZXR1cm4gZGltcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgIHBhdGggJiYgIXBhdGguaXNOb3RWaXNpYmxlKCkgJiYgcGF0aC5fcmVuZGVyKGN0eCk7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGVzKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICd1bmRlcmxpbmUnKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ292ZXJsaW5lJyk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICdsaW5ldGhyb3VnaCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0U3Ryb2tlKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRGaWxsKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dEZpbGwoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dFN0cm9rZShjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZvbnQgcGFyYW1ldGVyIG9mIHRoZSBjb250ZXh0IHdpdGggdGhlIG9iamVjdCBwcm9wZXJ0aWVzIG9yIHdpdGggY2hhclN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjaGFyU3R5bGVdIG9iamVjdCB3aXRoIGZvbnQgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRGYW1pbHldIEZvbnQgRmFtaWx5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjaGFyU3R5bGUuZm9udFNpemVdIEZvbnQgc2l6ZSBpbiBwaXhlbHMuICggd2l0aG91dCBweCBzdWZmaXggKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRXZWlnaHRdIEZvbnQgd2VpZ2h0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udFN0eWxlXSBGb250IHN0eWxlIChpdGFsaWN8bm9ybWFsKVxuICAgICAqL1xuICAgIF9zZXRUZXh0U3R5bGVzOiBmdW5jdGlvbihjdHgsIGNoYXJTdHlsZSwgZm9yTWVhc3VyaW5nKSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWNhbCc7XG4gICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wYXRoQWxpZ24pIHtcbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXNjZW5kZXInOlxuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGVzY2VuZGVyJzpcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHguZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihjaGFyU3R5bGUsIGZvck1lYXN1cmluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSB0ZXh0IFdpZHRoIG1lYXN1cmluZyBlYWNoIGxpbmUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBNYXhpbXVtIHdpZHRoIG9mIGZhYnJpYy5UZXh0IG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoMCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgIG1heFdpZHRoID0gY3VycmVudExpbmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1heFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWUgKFwiZmlsbFRleHRcIiBvciBcInN0cm9rZVRleHRcIilcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgVGV4dCB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IHBvc2l0aW9uIG9mIHRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmUgaW4gYSB0ZXh0XG4gICAgICovXG4gICAgX3JlbmRlclRleHRMaW5lOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckNoYXJzKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHRleHQgYmFja2dyb3VuZCBmb3IgbGluZXMsIHRha2luZyBjYXJlIG9mIHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgIXRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGVpZ2h0T2ZMaW5lLFxuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0LCBvcmlnaW5hbEZpbGwgPSBjdHguZmlsbFN0eWxlLFxuICAgICAgICAgIGxpbmUsIGxhc3RDb2xvcixcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICAgIGxpbmVUb3BPZmZzZXQgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgICBib3hTdGFydCA9IDAsIGJveFdpZHRoID0gMCwgY2hhckJveCwgY3VycmVudENvbG9yLCBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIGRyYXdTdGFydDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgIXRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InLCBpKSkge1xuICAgICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgYm94U3RhcnQgPSAwO1xuICAgICAgICBsYXN0Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgY3VycmVudENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjaGFyQm94LnJlbmRlckxlZnQsIGNoYXJCb3gucmVuZGVyVG9wKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoY2hhckJveC5hbmdsZSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudENvbG9yO1xuICAgICAgICAgICAgY3VycmVudENvbG9yICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgLWNoYXJCb3gud2lkdGggLyAyLFxuICAgICAgICAgICAgICAtaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSxcbiAgICAgICAgICAgICAgY2hhckJveC53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoY3VycmVudENvbG9yICE9PSBsYXN0Q29sb3IpIHtcbiAgICAgICAgICAgIGRyYXdTdGFydCA9IGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0O1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgICBkcmF3U3RhcnQgPSB0aGlzLndpZHRoIC0gZHJhd1N0YXJ0IC0gYm94V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFzdENvbG9yO1xuICAgICAgICAgICAgbGFzdENvbG9yICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgZHJhd1N0YXJ0LFxuICAgICAgICAgICAgICBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgICBsYXN0Q29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xvciAmJiAhcGF0aCkge1xuICAgICAgICAgIGRyYXdTdGFydCA9IGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0O1xuICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAgIGRyYXdTdGFydCA9IHRoaXMud2lkdGggLSBkcmF3U3RhcnQgLSBib3hXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBkcmF3U3RhcnQsXG4gICAgICAgICAgICBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9yaWdpbmFsRmlsbDtcbiAgICAgIC8vIGlmIHRoZXJlIGlzIHRleHQgYmFja2dyb3VuZCBjb2xvciBub1xuICAgICAgLy8gb3RoZXIgc2hhZG93cyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjbCBzdHlsZSBkZWNsYXJhdGlvbiBmb3IgY2FjaGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250RmFtaWx5IGZvbnRGYW1pbHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250U3R5bGUgZm9udFN0eWxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlY2wuZm9udFdlaWdodCBmb250V2VpZ2h0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSByZWZlcmVuY2UgdG8gY2FjaGVcbiAgICAgKi9cbiAgICBnZXRGb250Q2FjaGU6IGZ1bmN0aW9uKGRlY2wpIHtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZGVjbC5mb250RmFtaWx5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIWZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0pIHtcbiAgICAgICAgZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWNoZSA9IGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0sXG4gICAgICAgICAgY2FjaGVQcm9wID0gZGVjbC5mb250U3R5bGUudG9Mb3dlckNhc2UoKSArICdfJyArIChkZWNsLmZvbnRXZWlnaHQgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghY2FjaGVbY2FjaGVQcm9wXSkge1xuICAgICAgICBjYWNoZVtjYWNoZVByb3BdID0geyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlW2NhY2hlUHJvcF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgYW5kIHJldHVybiB0aGUgd2lkdGggb2YgYSBzaW5nbGUgY2hhcmFjdGVyLlxuICAgICAqIHBvc3NpYmx5IG92ZXJyaWRkZW4gdG8gYWNjb21tb2RhdGUgZGlmZmVyZW50IG1lYXN1cmUgbG9naWMgb3JcbiAgICAgKiB0byBob29rIHNvbWUgZXh0ZXJuYWwgbGliIGZvciBjaGFyYWN0ZXIgbWVhc3VyZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBfY2hhciwgY2hhciB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFyU3R5bGUgc3R5bGUgb2YgY2hhciB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJldmlvdXNDaGFyXSBwcmV2aW91cyBjaGFyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcmV2Q2hhclN0eWxlXSBzdHlsZSBvZiBwcmV2aW91cyBjaGFyXG4gICAgICovXG4gICAgX21lYXN1cmVDaGFyOiBmdW5jdGlvbihfY2hhciwgY2hhclN0eWxlLCBwcmV2aW91c0NoYXIsIHByZXZDaGFyU3R5bGUpIHtcbiAgICAgIC8vIGZpcnN0IGkgdHJ5IHRvIHJldHVybiBmcm9tIGNhY2hlXG4gICAgICB2YXIgZm9udENhY2hlID0gdGhpcy5nZXRGb250Q2FjaGUoY2hhclN0eWxlKSwgZm9udERlY2xhcmF0aW9uID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGNoYXJTdHlsZSksXG4gICAgICAgICAgcHJldmlvdXNGb250RGVjbGFyYXRpb24gPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24ocHJldkNoYXJTdHlsZSksIGNvdXBsZSA9IHByZXZpb3VzQ2hhciArIF9jaGFyLFxuICAgICAgICAgIHN0eWxlc0FyZUVxdWFsID0gZm9udERlY2xhcmF0aW9uID09PSBwcmV2aW91c0ZvbnREZWNsYXJhdGlvbiwgd2lkdGgsIGNvdXBsZVdpZHRoLCBwcmV2aW91c1dpZHRoLFxuICAgICAgICAgIGZvbnRNdWx0aXBsaWVyID0gY2hhclN0eWxlLmZvbnRTaXplIC8gdGhpcy5DQUNIRV9GT05UX1NJWkUsIGtlcm5lZFdpZHRoO1xuXG4gICAgICBpZiAocHJldmlvdXNDaGFyICYmIGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJldmlvdXNXaWR0aCA9IGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRDYWNoZVtfY2hhcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXJuZWRXaWR0aCA9IHdpZHRoID0gZm9udENhY2hlW19jaGFyXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZXNBcmVFcXVhbCAmJiBmb250Q2FjaGVbY291cGxlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvdXBsZVdpZHRoID0gZm9udENhY2hlW2NvdXBsZV07XG4gICAgICAgIGtlcm5lZFdpZHRoID0gY291cGxlV2lkdGggLSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgcHJldmlvdXNXaWR0aCA9PT0gdW5kZWZpbmVkIHx8IGNvdXBsZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0TWVhc3VyaW5nQ29udGV4dCgpO1xuICAgICAgICAvLyBzZW5kIGEgVFJVRSB0byBzcGVjaWZ5IG1lYXN1cmluZyBmb250IHNpemUgQ0FDSEVfRk9OVF9TSVpFXG4gICAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4LCBjaGFyU3R5bGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2VybmVkV2lkdGggPSB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChfY2hhcikud2lkdGg7XG4gICAgICAgIGZvbnRDYWNoZVtfY2hhcl0gPSB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2aW91c1dpZHRoID09PSB1bmRlZmluZWQgJiYgc3R5bGVzQXJlRXF1YWwgJiYgcHJldmlvdXNDaGFyKSB7XG4gICAgICAgIHByZXZpb3VzV2lkdGggPSBjdHgubWVhc3VyZVRleHQocHJldmlvdXNDaGFyKS53aWR0aDtcbiAgICAgICAgZm9udENhY2hlW3ByZXZpb3VzQ2hhcl0gPSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlc0FyZUVxdWFsICYmIGNvdXBsZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gd2UgY2FuIG1lYXN1cmUgdGhlIGtlcm5pbmcgY291cGxlIGFuZCBzdWJ0cmFjdCB0aGUgd2lkdGggb2YgdGhlIHByZXZpb3VzIGNoYXJhY3RlclxuICAgICAgICBjb3VwbGVXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChjb3VwbGUpLndpZHRoO1xuICAgICAgICBmb250Q2FjaGVbY291cGxlXSA9IGNvdXBsZVdpZHRoO1xuICAgICAgICBrZXJuZWRXaWR0aCA9IGNvdXBsZVdpZHRoIC0gcHJldmlvdXNXaWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCAqIGZvbnRNdWx0aXBsaWVyLCBrZXJuZWRXaWR0aDoga2VybmVkV2lkdGggKiBmb250TXVsdGlwbGllciB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBoZWlnaHQgb2YgY2hhcmFjdGVyIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmUgdGhlIGxpbmUgaW5kZXggbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IF9jaGFyIHRoZSBjaGFyYWN0ZXIgaW5kZXggbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBmb250U2l6ZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgICovXG4gICAgZ2V0SGVpZ2h0T2ZDaGFyOiBmdW5jdGlvbihsaW5lLCBfY2hhcikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZSwgX2NoYXIsICdmb250U2l6ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGEgdGV4dCBsaW5lIG1lYXN1cmluZyBhbGwgY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIHdpZHRoXG4gICAgICovXG4gICAgbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVJbmZvID0gdGhpcy5fbWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGxpbmVJbmZvLndpZHRoIC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVJbmZvLndpZHRoIDwgMCkge1xuICAgICAgICBsaW5lSW5mby53aWR0aCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZUluZm87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgZXZlcnkgZ3JhcGhlbWUgb2YgYSBsaW5lLCBwb3B1bGF0aW5nIF9fY2hhckJvdW5kc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aCB0b3RhbCB3aWR0aCBvZiBjaGFyYWN0ZXJzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qud2lkdGhPZlNwYWNlcyBsZW5ndGggb2YgY2hhcnMgdGhhdCBtYXRjaCB0aGlzLl9yZVNwYWNlc0FuZFRhYnNcbiAgICAgKi9cbiAgICBfbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIHdpZHRoID0gMCwgaSwgZ3JhcGhlbWUsIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSwgcHJldkdyYXBoZW1lLFxuICAgICAgICAgIGdyYXBoZW1lSW5mbywgbnVtT2ZTcGFjZXMgPSAwLCBsaW5lQm91bmRzID0gbmV3IEFycmF5KGxpbmUubGVuZ3RoKSxcbiAgICAgICAgICBwb3NpdGlvbkluUGF0aCA9IDAsIHN0YXJ0aW5nUG9pbnQsIHRvdGFsUGF0aExlbmd0aCwgcGF0aCA9IHRoaXMucGF0aCxcbiAgICAgICAgICByZXZlcnNlID0gdGhpcy5wYXRoU2lkZSA9PT0gJ3JpZ2h0JztcblxuICAgICAgdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XSA9IGxpbmVCb3VuZHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBncmFwaGVtZSA9IGxpbmVbaV07XG4gICAgICAgIGdyYXBoZW1lSW5mbyA9IHRoaXMuX2dldEdyYXBoZW1lQm94KGdyYXBoZW1lLCBsaW5lSW5kZXgsIGksIHByZXZHcmFwaGVtZSk7XG4gICAgICAgIGxpbmVCb3VuZHNbaV0gPSBncmFwaGVtZUluZm87XG4gICAgICAgIHdpZHRoICs9IGdyYXBoZW1lSW5mby5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gZ3JhcGhlbWU7XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGxhdGVzdCBib3VuZCBib3ggcmVwcmVzZW50IHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgbGluZVxuICAgICAgLy8gdG8gc2ltcGxpZnkgY3Vyc29yIGhhbmRsaW5nIGluIGludGVyYWN0aXZlIG1vZGUuXG4gICAgICBsaW5lQm91bmRzW2ldID0ge1xuICAgICAgICBsZWZ0OiBncmFwaGVtZUluZm8gPyBncmFwaGVtZUluZm8ubGVmdCArIGdyYXBoZW1lSW5mby53aWR0aCA6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBrZXJuZWRXaWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmZvbnRTaXplXG4gICAgICB9O1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdG90YWxQYXRoTGVuZ3RoID0gcGF0aC5zZWdtZW50c0luZm9bcGF0aC5zZWdtZW50c0luZm8ubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgICAgICBzdGFydGluZ1BvaW50ID0gZmFicmljLnV0aWwuZ2V0UG9pbnRPblBhdGgocGF0aC5wYXRoLCAwLCBwYXRoLnNlZ21lbnRzSW5mbyk7XG4gICAgICAgIHN0YXJ0aW5nUG9pbnQueCArPSBwYXRoLnBhdGhPZmZzZXQueDtcbiAgICAgICAgc3RhcnRpbmdQb2ludC55ICs9IHBhdGgucGF0aE9mZnNldC55O1xuICAgICAgICBzd2l0Y2ggKHRoaXMudGV4dEFsaWduKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBwb3NpdGlvbkluUGF0aCA9IHJldmVyc2UgPyAodG90YWxQYXRoTGVuZ3RoIC0gd2lkdGgpIDogMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBwb3NpdGlvbkluUGF0aCA9ICh0b3RhbFBhdGhMZW5ndGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgcG9zaXRpb25JblBhdGggPSByZXZlcnNlID8gMCA6ICh0b3RhbFBhdGhMZW5ndGggLSB3aWR0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvL3RvZG8gLSBhZGQgc3VwcG9ydCBmb3IganVzdGlmeVxuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uSW5QYXRoICs9IHRoaXMucGF0aFN0YXJ0T2Zmc2V0ICogKHJldmVyc2UgPyAtMSA6IDEpO1xuICAgICAgICBmb3IgKGkgPSByZXZlcnNlID8gbGluZS5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICByZXZlcnNlID8gaSA+PSAwIDogaSA8IGxpbmUubGVuZ3RoO1xuICAgICAgICAgIHJldmVyc2UgPyBpLS0gOiBpKyspIHtcbiAgICAgICAgICBncmFwaGVtZUluZm8gPSBsaW5lQm91bmRzW2ldO1xuICAgICAgICAgIGlmIChwb3NpdGlvbkluUGF0aCA+IHRvdGFsUGF0aExlbmd0aCkge1xuICAgICAgICAgICAgcG9zaXRpb25JblBhdGggJT0gdG90YWxQYXRoTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChwb3NpdGlvbkluUGF0aCA8IDApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uSW5QYXRoICs9IHRvdGFsUGF0aExlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaXQgd291bGQgcHJvYmFibHkgbXVjaCBmYXN0ZXIgdG8gc2VuZCBhbGwgdGhlIGdyYXBoZW1lIHBvc2l0aW9uIGZvciBhIGxpbmVcbiAgICAgICAgICAvLyBhbmQgY2FsY3VsYXRlIHBhdGggcG9zaXRpb24vYW5nbGUgYXQgb25jZS5cbiAgICAgICAgICB0aGlzLl9zZXRHcmFwaGVtZU9uUGF0aChwb3NpdGlvbkluUGF0aCwgZ3JhcGhlbWVJbmZvLCBzdGFydGluZ1BvaW50KTtcbiAgICAgICAgICBwb3NpdGlvbkluUGF0aCArPSBncmFwaGVtZUluZm8ua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgbnVtT2ZTcGFjZXM6IG51bU9mU3BhY2VzIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgYW5nbGUgIGFuZCB0aGUgbGVmdCx0b3AgcG9zaXRpb24gb2YgdGhlIGNoYXIgdGhhdCBmb2xsb3cgYSBwYXRoLlxuICAgICAqIEl0IGFwcGVuZHMgaXQgdG8gZ3JhcGhlbWVJbmZvIHRvIGJlIHJldXNlZCBsYXRlciBhdCByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbkluUGF0aCB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGVtZUluZm8gY3VycmVudCBncmFwaGVtZSBib3ggaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhcnRpbmdQb2ludCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBfc2V0R3JhcGhlbWVPblBhdGg6IGZ1bmN0aW9uKHBvc2l0aW9uSW5QYXRoLCBncmFwaGVtZUluZm8sIHN0YXJ0aW5nUG9pbnQpIHtcbiAgICAgIHZhciBjZW50ZXJQb3NpdGlvbiA9IHBvc2l0aW9uSW5QYXRoICsgZ3JhcGhlbWVJbmZvLmtlcm5lZFdpZHRoIC8gMixcbiAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoO1xuXG4gICAgICAvLyB3ZSBhcmUgYXQgY3VycmVudFBvc2l0aW9uT25QYXRoLiB3ZSB3YW50IHRvIGtub3cgd2hhdCBwb2ludCBvbiB0aGUgcGF0aCBpcy5cbiAgICAgIHZhciBpbmZvID0gZmFicmljLnV0aWwuZ2V0UG9pbnRPblBhdGgocGF0aC5wYXRoLCBjZW50ZXJQb3NpdGlvbiwgcGF0aC5zZWdtZW50c0luZm8pO1xuICAgICAgZ3JhcGhlbWVJbmZvLnJlbmRlckxlZnQgPSBpbmZvLnggLSBzdGFydGluZ1BvaW50Lng7XG4gICAgICBncmFwaGVtZUluZm8ucmVuZGVyVG9wID0gaW5mby55IC0gc3RhcnRpbmdQb2ludC55O1xuICAgICAgZ3JhcGhlbWVJbmZvLmFuZ2xlID0gaW5mby5hbmdsZSArICh0aGlzLnBhdGhTaWRlID09PSAgJ3JpZ2h0JyA/IE1hdGguUEkgOiAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZSBhbmQgcmV0dXJuIHRoZSBpbmZvIG9mIGEgc2luZ2xlIGdyYXBoZW1lLlxuICAgICAqIG5lZWRzIHRoZSB0aGUgaW5mbyBvZiBwcmV2aW91cyBncmFwaGVtZXMgYWxyZWFkeSBmaWxsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncmFwaGVtZSB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggaW5kZXggb2YgdGhlIGxpbmUgd2hlcmUgdGhlIGNoYXIgaXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHBvc2l0aW9uIGluIHRoZSBsaW5lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmV2R3JhcGhlbWVdIGNoYXJhY3RlciBwcmVjZWRpbmcgdGhlIG9uZSB0byBiZSBtZWFzdXJlZFxuICAgICAqL1xuICAgIF9nZXRHcmFwaGVtZUJveDogZnVuY3Rpb24oZ3JhcGhlbWUsIGxpbmVJbmRleCwgY2hhckluZGV4LCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgcHJldlN0eWxlID0gcHJldkdyYXBoZW1lID8gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXggLSAxKSA6IHsgfSxcbiAgICAgICAgICBpbmZvID0gdGhpcy5fbWVhc3VyZUNoYXIoZ3JhcGhlbWUsIHN0eWxlLCBwcmV2R3JhcGhlbWUsIHByZXZTdHlsZSksXG4gICAgICAgICAga2VybmVkV2lkdGggPSBpbmZvLmtlcm5lZFdpZHRoLFxuICAgICAgICAgIHdpZHRoID0gaW5mby53aWR0aCwgY2hhclNwYWNpbmc7XG5cbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICAgIHdpZHRoICs9IGNoYXJTcGFjaW5nO1xuICAgICAgICBrZXJuZWRXaWR0aCArPSBjaGFyU3BhY2luZztcbiAgICAgIH1cblxuICAgICAgdmFyIGJveCA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmZvbnRTaXplLFxuICAgICAgICBrZXJuZWRXaWR0aDoga2VybmVkV2lkdGgsXG4gICAgICAgIGRlbHRhWTogc3R5bGUuZGVsdGFZLFxuICAgICAgfTtcbiAgICAgIGlmIChjaGFySW5kZXggPiAwICYmICFza2lwTGVmdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2NoYXJJbmRleCAtIDFdO1xuICAgICAgICBib3gubGVmdCA9IHByZXZpb3VzQm94LmxlZnQgKyBwcmV2aW91c0JveC53aWR0aCArIGluZm8ua2VybmVkV2lkdGggLSBpbmZvLndpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGhlaWdodCBvZiBsaW5lIGF0ICdsaW5lSW5kZXgnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCBvZiBsaW5lIHRvIGNhbGN1bGF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHRPZkxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbGluZUhlaWdodHNbbGluZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICAvLyBjaGFyIDAgaXMgbWVhc3VyZWQgYmVmb3JlIHRoZSBsaW5lIGN5Y2xlIGJlY2F1c2UgaXQgbm5lZHMgdG8gY2hhclxuICAgICAgICAgIC8vIGVtcHR5bGluZXNcbiAgICAgICAgICBtYXhIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mQ2hhcihsaW5lSW5kZXgsIDApO1xuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGxpbmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5nZXRIZWlnaHRPZkNoYXIobGluZUluZGV4LCBpKSwgbWF4SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdID0gbWF4SGVpZ2h0ICogdGhpcy5saW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVNdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGV4dCBib3ggaGVpZ2h0XG4gICAgICovXG4gICAgY2FsY1RleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVIZWlnaHQsIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaGVpZ2h0ICs9IChpID09PSBsZW4gLSAxID8gbGluZUhlaWdodCAvIHRoaXMubGluZUhlaWdodCA6IGxpbmVIZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExlZnQgb2Zmc2V0XG4gICAgICovXG4gICAgX2dldExlZnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSAnbHRyJyA/IC10aGlzLndpZHRoIC8gMiA6IHRoaXMud2lkdGggLyAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVG9wIG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRUb3BPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC10aGlzLmhlaWdodCAvIDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWUgKFwiZmlsbFRleHRcIiBvciBcInN0cm9rZVRleHRcIilcbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dENvbW1vbjogZnVuY3Rpb24oY3R4LCBtZXRob2QpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgbGluZUhlaWdodHMgPSAwLCBsZWZ0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLCB0b3AgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpLFxuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZShcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgY3R4LFxuICAgICAgICAgIHRoaXMuX3RleHRMaW5lc1tpXSxcbiAgICAgICAgICBsZWZ0ICsgbGVmdE9mZnNldCxcbiAgICAgICAgICB0b3AgKyBsaW5lSGVpZ2h0cyArIG1heEhlaWdodCxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIGxpbmVIZWlnaHRzICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0RmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuZmlsbCAmJiAhdGhpcy5zdHlsZUhhcygnZmlsbCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyVGV4dENvbW1vbihjdHgsICdmaWxsVGV4dCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSAmJiB0aGlzLmlzRW1wdHlTdHlsZXMoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNoYWRvdyAmJiAhdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0Q29tbW9uKGN0eCwgJ3N0cm9rZVRleHQnKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBmaWxsVGV4dCBvciBzdHJva2VUZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lIENvbnRlbnQgb2YgdGhlIGxpbmUsIHNwbGl0dGVkIGluIGFuIGFycmF5IGJ5IGdyYXBoZW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyczogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XG4gICAgICAvLyBzZXQgcHJvcGVyIGxpbmUgb2Zmc2V0XG4gICAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGxpbmVJbmRleCksXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBhY3R1YWxTdHlsZSxcbiAgICAgICAgICBuZXh0U3R5bGUsXG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnLFxuICAgICAgICAgIGNoYXJCb3gsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIHRpbWVUb1JlbmRlcixcbiAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIHNob3J0Q3V0ID0gIWlzSnVzdGlmeSAmJiB0aGlzLmNoYXJTcGFjaW5nID09PSAwICYmIHRoaXMuaXNFbXB0eVN0eWxlcyhsaW5lSW5kZXgpICYmICFwYXRoLFxuICAgICAgICAgIGlzTHRyID0gdGhpcy5kaXJlY3Rpb24gPT09ICdsdHInLCBzaWduID0gdGhpcy5kaXJlY3Rpb24gPT09ICdsdHInID8gMSA6IC0xLFxuICAgICAgICAgIGRyYXdpbmdMZWZ0LCBjdXJyZW50RGlyZWN0aW9uID0gY3R4LmNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2RpcicpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGlmIChjdXJyZW50RGlyZWN0aW9uICE9PSB0aGlzLmRpcmVjdGlvbikge1xuICAgICAgICBjdHguY2FudmFzLnNldEF0dHJpYnV0ZSgnZGlyJywgaXNMdHIgPyAnbHRyJyA6ICdydGwnKTtcbiAgICAgICAgY3R4LmRpcmVjdGlvbiA9IGlzTHRyID8gJ2x0cicgOiAncnRsJztcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IGlzTHRyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH1cbiAgICAgIHRvcCAtPSBsaW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVGcmFjdGlvbiAvIHRoaXMubGluZUhlaWdodDtcbiAgICAgIGlmIChzaG9ydEN1dCkge1xuICAgICAgICAvLyByZW5kZXIgYWxsIHRoZSBsaW5lIGluIG9uZSBwYXNzIHdpdGhvdXQgY2hlY2tpbmdcbiAgICAgICAgLy8gZHJhd2luZ0xlZnQgPSBpc0x0ciA/IGxlZnQgOiBsZWZ0IC0gdGhpcy5nZXRMaW5lV2lkdGgobGluZUluZGV4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcihtZXRob2QsIGN0eCwgbGluZUluZGV4LCAwLCBsaW5lLmpvaW4oJycpLCBsZWZ0LCB0b3AsIGxpbmVIZWlnaHQpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZS5sZW5ndGggLSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRpbWVUb1JlbmRlciA9IGkgPT09IGxlbiB8fCB0aGlzLmNoYXJTcGFjaW5nIHx8IHBhdGg7XG4gICAgICAgIGNoYXJzVG9SZW5kZXIgKz0gbGluZVtpXTtcbiAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1baV07XG4gICAgICAgIGlmIChib3hXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIGxlZnQgKz0gc2lnbiAqIChjaGFyQm94Lmtlcm5lZFdpZHRoIC0gY2hhckJveC53aWR0aCk7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0p1c3RpZnkgJiYgIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtpXSkpIHtcbiAgICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBjaGFyU3BhY2luZywgd2UgcmVuZGVyIGNoYXIgYnkgY2hhclxuICAgICAgICAgIGFjdHVhbFN0eWxlID0gYWN0dWFsU3R5bGUgfHwgdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpKTtcbiAgICAgICAgICBuZXh0U3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkgKyAxKTtcbiAgICAgICAgICB0aW1lVG9SZW5kZXIgPSB0aGlzLl9oYXNTdHlsZUNoYW5nZWQoYWN0dWFsU3R5bGUsIG5leHRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjaGFyQm94LnJlbmRlckxlZnQsIGNoYXJCb3gucmVuZGVyVG9wKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoY2hhckJveC5hbmdsZSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGksIGNoYXJzVG9SZW5kZXIsIC1ib3hXaWR0aCAvIDIsIDAsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkcmF3aW5nTGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGksIGNoYXJzVG9SZW5kZXIsIGRyYXdpbmdMZWZ0LCB0b3AsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJyc7XG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBuZXh0U3R5bGU7XG4gICAgICAgICAgbGVmdCArPSBzaWduICogYm94V2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyeSB0byBwYXRjaCB0aGUgbWlzc2luZyBncmFkaWVudFRyYW5zZm9ybSBvbiBjYW52YXMgZ3JhZGllbnRzLlxuICAgICAqIHRyYW5zZm9ybWluZyBhIGNvbnRleHQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCwgaXMgZ29pbmcgdG8gdHJhbnNmb3JtIHRoZSBzdHJva2UgdG9vLlxuICAgICAqIHdlIHdhbnQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCBidXQgbm90IHRoZSBzdHJva2Ugb3BlcmF0aW9uLCBzbyB3ZSBjcmVhdGVcbiAgICAgKiBhIHRyYW5zZm9ybWVkIGdyYWRpZW50IG9uIGEgcGF0dGVybiBhbmQgdGhlbiB3ZSB1c2UgdGhlIHBhdHRlcm4gaW5zdGVhZCBvZiB0aGUgZ3JhZGllbnQuXG4gICAgICogdGhpcyBtZXRob2QgaGFzIGRyYXdiYWNrczogaXMgc2xvdywgaXMgaW4gbG93IHJlc29sdXRpb24sIG5lZWRzIGEgcGF0Y2ggZm9yIHdoZW4gdGhlIHNpemVcbiAgICAgKiBpcyBsaW1pdGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuR3JhZGllbnR9IGZpbGxlciBhIGZhYnJpYyBncmFkaWVudCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0NhbnZhc1BhdHRlcm59IGEgcGF0dGVybiB0byB1c2UgYXMgZmlsbC9zdHJva2Ugc3R5bGVcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm1UZXh0OiBmdW5jdGlvbihmaWxsZXIpIHtcbiAgICAgIHZhciBwQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLCBwQ3R4LFxuICAgICAgICAgIC8vIFRPRE86IHZlcmlmeSBjb21wYXRpYmlsaXR5IHdpdGggc3Ryb2tlVW5pZm9ybVxuICAgICAgICAgIHdpZHRoID0gdGhpcy53aWR0aCArIHRoaXMuc3Ryb2tlV2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgIHBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcEN0eCA9IHBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHBDdHguYmVnaW5QYXRoKCk7IHBDdHgubW92ZVRvKDAsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgMCk7IHBDdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcEN0eC5saW5lVG8oMCwgaGVpZ2h0KTsgcEN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHBDdHgudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICBwQ3R4LmZpbGxTdHlsZSA9IGZpbGxlci50b0xpdmUocEN0eCk7XG4gICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShwQ3R4LCBmaWxsZXIpO1xuICAgICAgcEN0eC5maWxsKCk7XG4gICAgICByZXR1cm4gcEN0eC5jcmVhdGVQYXR0ZXJuKHBDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlRmlsbGVyOiBmdW5jdGlvbihjdHgsIHByb3BlcnR5LCBmaWxsZXIpIHtcbiAgICAgIHZhciBvZmZzZXRYLCBvZmZzZXRZO1xuICAgICAgaWYgKGZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgaWYgKGZpbGxlci5ncmFkaWVudFVuaXRzID09PSAncGVyY2VudGFnZScgfHwgZmlsbGVyLmdyYWRpZW50VHJhbnNmb3JtIHx8IGZpbGxlci5wYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgICAgICAgLy8gbmVlZCB0byB0cmFuc2Zvcm0gZ3JhZGllbnQgaW4gYSBwYXR0ZXJuLlxuICAgICAgICAgIC8vIHRoaXMgaXMgYSBzbG93IHByb2Nlc3MuIElmIHlvdSBhcmUgaGl0dGluZyB0aGlzIGNvZGVwYXRoLCBhbmQgdGhlIG9iamVjdFxuICAgICAgICAgIC8vIGlzIG5vdCB1c2luZyBjYWNoaW5nLCB5b3Ugc2hvdWxkIGNvbnNpZGVyIHN3aXRjaGluZyBpdCBvbi5cbiAgICAgICAgICAvLyB3ZSBuZWVkIGEgY2FudmFzIGFzIGJpZyBhcyB0aGUgY3VycmVudCBvYmplY3QgY2FjaGluZyBjYW52YXMuXG4gICAgICAgICAgb2Zmc2V0WCA9IC10aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICBvZmZzZXRZID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgIGN0eFtwcm9wZXJ0eV0gPSB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybVRleHQoZmlsbGVyKTtcbiAgICAgICAgICByZXR1cm4geyBvZmZzZXRYOiBvZmZzZXRYLCBvZmZzZXRZOiBvZmZzZXRZIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gaXMgYSBzaW1wbGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuICAgICAgICAgIGN0eFtwcm9wZXJ0eV0gPSBmaWxsZXIudG9MaXZlKGN0eCwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgZmlsbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGlzIGEgY29sb3JcbiAgICAgICAgY3R4W3Byb3BlcnR5XSA9IGZpbGxlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG9mZnNldFg6IDAsIG9mZnNldFk6IDAgfTtcbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gZGVjbC5zdHJva2VXaWR0aDtcbiAgICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5zdHJva2VEYXNoT2Zmc2V0O1xuICAgICAgY3R4LmxpbmVKb2luID0gdGhpcy5zdHJva2VMaW5lSm9pbjtcbiAgICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0O1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRmlsbGVyKGN0eCwgJ3N0cm9rZVN0eWxlJywgZGVjbC5zdHJva2UpO1xuICAgIH0sXG5cbiAgICBfc2V0RmlsbFN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVGaWxsZXIoY3R4LCAnZmlsbFN0eWxlJywgZGVjbC5maWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0IEhlaWdodCBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBjaGFySW5kZXgsIF9jaGFyLCBsZWZ0LCB0b3ApIHtcbiAgICAgIHZhciBkZWNsID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgZnVsbERlY2wgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgc2hvdWxkRmlsbCA9IG1ldGhvZCA9PT0gJ2ZpbGxUZXh0JyAmJiBmdWxsRGVjbC5maWxsLFxuICAgICAgICAgIHNob3VsZFN0cm9rZSA9IG1ldGhvZCA9PT0gJ3N0cm9rZVRleHQnICYmIGZ1bGxEZWNsLnN0cm9rZSAmJiBmdWxsRGVjbC5zdHJva2VXaWR0aCxcbiAgICAgICAgICBmaWxsT2Zmc2V0cywgc3Ryb2tlT2Zmc2V0cztcblxuICAgICAgaWYgKCFzaG91bGRTdHJva2UgJiYgIXNob3VsZEZpbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgc2hvdWxkRmlsbCAmJiAoZmlsbE9mZnNldHMgPSB0aGlzLl9zZXRGaWxsU3R5bGVzKGN0eCwgZnVsbERlY2wpKTtcbiAgICAgIHNob3VsZFN0cm9rZSAmJiAoc3Ryb2tlT2Zmc2V0cyA9IHRoaXMuX3NldFN0cm9rZVN0eWxlcyhjdHgsIGZ1bGxEZWNsKSk7XG5cbiAgICAgIGN0eC5mb250ID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGZ1bGxEZWNsKTtcblxuXG4gICAgICBpZiAoZGVjbCAmJiBkZWNsLnRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVjbCAmJiBkZWNsLmRlbHRhWSkge1xuICAgICAgICB0b3AgKz0gZGVjbC5kZWx0YVk7XG4gICAgICB9XG4gICAgICBzaG91bGRGaWxsICYmIGN0eC5maWxsVGV4dChfY2hhciwgbGVmdCAtIGZpbGxPZmZzZXRzLm9mZnNldFgsIHRvcCAtIGZpbGxPZmZzZXRzLm9mZnNldFkpO1xuICAgICAgc2hvdWxkU3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KF9jaGFyLCBsZWZ0IC0gc3Ryb2tlT2Zmc2V0cy5vZmZzZXRYLCB0b3AgLSBzdHJva2VPZmZzZXRzLm9mZnNldFkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybnMgdGhlIGNoYXJhY3RlciBpbnRvIGEgJ3N1cGVyaW9yIGZpZ3VyZScgKGkuZS4gJ3N1cGVyc2NyaXB0JylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHJldHVybnMge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFN1cGVyc2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0U2NyaXB0KHN0YXJ0LCBlbmQsIHRoaXMuc3VwZXJzY3JpcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUdXJucyB0aGUgY2hhcmFjdGVyIGludG8gYW4gJ2luZmVyaW9yIGZpZ3VyZScgKGkuZS4gJ3N1YnNjcmlwdCcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTdWJzY3JpcHQ6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRTY3JpcHQoc3RhcnQsIGVuZCwgdGhpcy5zdWJzY3JpcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzICdzY2hlbWEnIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjaGVtYVxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfc2V0U2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kLCBzY2hlbWEpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc3RhcnQsIHRydWUpLFxuICAgICAgICAgIGZvbnRTaXplID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4LCAnZm9udFNpemUnKSxcbiAgICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwgJ2RlbHRhWScpLFxuICAgICAgICAgIHN0eWxlID0geyBmb250U2l6ZTogZm9udFNpemUgKiBzY2hlbWEuc2l6ZSwgZGVsdGFZOiBkeSArIGZvbnRTaXplICogc2NoZW1hLmJhc2VsaW5lIH07XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0eWxlcyhzdHlsZSwgc3RhcnQsIGVuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJldlN0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNTdHlsZVxuICAgICAqL1xuICAgIF9oYXNTdHlsZUNoYW5nZWQ6IGZ1bmN0aW9uKHByZXZTdHlsZSwgdGhpc1N0eWxlKSB7XG4gICAgICByZXR1cm4gcHJldlN0eWxlLmZpbGwgIT09IHRoaXNTdHlsZS5maWxsIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5zdHJva2UgIT09IHRoaXNTdHlsZS5zdHJva2UgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLnN0cm9rZVdpZHRoICE9PSB0aGlzU3R5bGUuc3Ryb2tlV2lkdGggfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRTaXplICE9PSB0aGlzU3R5bGUuZm9udFNpemUgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRGYW1pbHkgIT09IHRoaXNTdHlsZS5mb250RmFtaWx5IHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250V2VpZ2h0ICE9PSB0aGlzU3R5bGUuZm9udFdlaWdodCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFN0eWxlICE9PSB0aGlzU3R5bGUuZm9udFN0eWxlIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5kZWx0YVkgIT09IHRoaXNTdHlsZS5kZWx0YVk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzU3R5bGVcbiAgICAgKi9cbiAgICBfaGFzU3R5bGVDaGFuZ2VkRm9yU3ZnOiBmdW5jdGlvbihwcmV2U3R5bGUsIHRoaXNTdHlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1N0eWxlQ2hhbmdlZChwcmV2U3R5bGUsIHRoaXNTdHlsZSkgfHxcbiAgICAgICAgcHJldlN0eWxlLm92ZXJsaW5lICE9PSB0aGlzU3R5bGUub3ZlcmxpbmUgfHxcbiAgICAgICAgcHJldlN0eWxlLnVuZGVybGluZSAhPT0gdGhpc1N0eWxlLnVuZGVybGluZSB8fFxuICAgICAgICBwcmV2U3R5bGUubGluZXRocm91Z2ggIT09IHRoaXNTdHlsZS5saW5ldGhyb3VnaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGluZGV4IHRleHQgbGluZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSBsZWZ0IG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRMaW5lTGVmdE9mZnNldDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgobGluZUluZGV4KSxcbiAgICAgICAgICBsaW5lRGlmZiA9IHRoaXMud2lkdGggLSBsaW5lV2lkdGgsIHRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduLCBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbixcbiAgICAgICAgICBpc0VuZE9mV3JhcHBpbmcsIGxlZnRPZmZzZXQgPSAwLCBpc0VuZE9mV3JhcHBpbmcgPSB0aGlzLmlzRW5kT2ZXcmFwcGluZyhsaW5lSW5kZXgpO1xuICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnknXG4gICAgICAgIHx8ICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LWNlbnRlcicgJiYgIWlzRW5kT2ZXcmFwcGluZylcbiAgICAgICAgfHwgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnktcmlnaHQnICYmICFpc0VuZE9mV3JhcHBpbmcpXG4gICAgICAgIHx8ICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LWxlZnQnICYmICFpc0VuZE9mV3JhcHBpbmcpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICBsZWZ0T2Zmc2V0ID0gbGluZURpZmYgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBsZWZ0T2Zmc2V0ID0gbGluZURpZmY7XG4gICAgICB9XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeS1jZW50ZXInKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgPSBsaW5lRGlmZiAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeS1yaWdodCcpIHtcbiAgICAgICAgbGVmdE9mZnNldCA9IGxpbmVEaWZmO1xuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgbGVmdE9mZnNldCAtPSBsaW5lRGlmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0T2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19saW5lV2lkdGhzID0gW107XG4gICAgICB0aGlzLl9fbGluZUhlaWdodHMgPSBbXTtcbiAgICAgIHRoaXMuX19jaGFyQm91bmRzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gdGhpcy5fZm9yY2VDbGVhckNhY2hlO1xuICAgICAgc2hvdWxkQ2xlYXIgfHwgKHNob3VsZENsZWFyID0gdGhpcy5oYXNTdGF0ZUNoYW5nZWQoJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycpKTtcbiAgICAgIGlmIChzaG91bGRDbGVhcikge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkQ2xlYXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1lYXN1cmUgYSBzaW5nbGUgbGluZSBnaXZlbiBpdHMgaW5kZXguIFVzZWQgdG8gY2FsY3VsYXRlIHRoZSBpbml0aWFsXG4gICAgICogdGV4dCBib3VuZGluZyBib3guIFRoZSB2YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgYW5kIHN0b3JlZCBpbiBfX2xpbmVXaWR0aHMgY2FjaGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIHdpZHRoXG4gICAgICovXG4gICAgZ2V0TGluZVdpZHRoOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9fbGluZVdpZHRoc1tsaW5lSW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lSW5mbyA9IHRoaXMubWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgIHZhciB3aWR0aCA9IGxpbmVJbmZvLndpZHRoO1xuICAgICAgdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSA9IHdpZHRoO1xuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICBfZ2V0V2lkdGhPZkNoYXJTcGFjaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRTaXplICogdGhpcy5jaGFyU3BhY2luZyAvIDEwMDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBhdCBnaXZlbiBjaGFyYWN0ZXIgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRoZSBsaW5lIG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggdGhlIGNoYXJhY3RlciBudW1iZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgdGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgb2YgJ3Byb3BlcnR5J1xuICAgICAqL1xuICAgIGdldFZhbHVlT2ZQcm9wZXJ0eUF0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBjaGFyU3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICAgIGlmIChjaGFyU3R5bGUgJiYgdHlwZW9mIGNoYXJTdHlsZVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBjaGFyU3R5bGVbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKGN0eCwgdHlwZSkge1xuICAgICAgaWYgKCF0aGlzW3R5cGVdICYmICF0aGlzLnN0eWxlSGFzKHR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRPZkxpbmUsIHNpemUsIF9zaXplLFxuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0LCBkeSwgX2R5LFxuICAgICAgICAgIGxpbmUsIGxhc3REZWNvcmF0aW9uLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksIHRvcCxcbiAgICAgICAgICBib3hTdGFydCwgYm94V2lkdGgsIGNoYXJCb3gsIGN1cnJlbnREZWNvcmF0aW9uLFxuICAgICAgICAgIG1heEhlaWdodCwgY3VycmVudEZpbGwsIGxhc3RGaWxsLCBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCksXG4gICAgICAgICAgb2Zmc2V0WSA9IHRoaXMub2Zmc2V0c1t0eXBlXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaWYgKCF0aGlzW3R5cGVdICYmICF0aGlzLnN0eWxlSGFzKHR5cGUsIGkpKSB7XG4gICAgICAgICAgdG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGJveFN0YXJ0ID0gMDtcbiAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICBsYXN0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgdHlwZSk7XG4gICAgICAgIGxhc3RGaWxsID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAnZmlsbCcpO1xuICAgICAgICB0b3AgPSB0b3BPZmZzZXQgKyBtYXhIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pO1xuICAgICAgICBzaXplID0gdGhpcy5nZXRIZWlnaHRPZkNoYXIoaSwgMCk7XG4gICAgICAgIGR5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAnZGVsdGFZJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgY3VycmVudERlY29yYXRpb24gPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosIHR5cGUpO1xuICAgICAgICAgIGN1cnJlbnRGaWxsID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAnZmlsbCcpO1xuICAgICAgICAgIF9zaXplID0gdGhpcy5nZXRIZWlnaHRPZkNoYXIoaSwgaik7XG4gICAgICAgICAgX2R5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAnZGVsdGFZJyk7XG4gICAgICAgICAgaWYgKHBhdGggJiYgY3VycmVudERlY29yYXRpb24gJiYgY3VycmVudEZpbGwpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFzdEZpbGw7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNoYXJCb3gucmVuZGVyTGVmdCwgY2hhckJveC5yZW5kZXJUb3ApO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShjaGFyQm94LmFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgLWNoYXJCb3gua2VybmVkV2lkdGggLyAyLFxuICAgICAgICAgICAgICBvZmZzZXRZICogX3NpemUgKyBfZHksXG4gICAgICAgICAgICAgIGNoYXJCb3gua2VybmVkV2lkdGgsXG4gICAgICAgICAgICAgIHRoaXMuZm9udFNpemUgLyAxNVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgKGN1cnJlbnREZWNvcmF0aW9uICE9PSBsYXN0RGVjb3JhdGlvbiB8fCBjdXJyZW50RmlsbCAhPT0gbGFzdEZpbGwgfHwgX3NpemUgIT09IHNpemUgfHwgX2R5ICE9PSBkeSlcbiAgICAgICAgICAgICYmIGJveFdpZHRoID4gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGRyYXdTdGFydCA9IGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0O1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgICBkcmF3U3RhcnQgPSB0aGlzLndpZHRoIC0gZHJhd1N0YXJ0IC0gYm94V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdERlY29yYXRpb24gJiYgbGFzdEZpbGwpIHtcbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhc3RGaWxsO1xuICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgICAgZHJhd1N0YXJ0LFxuICAgICAgICAgICAgICAgIHRvcCArIG9mZnNldFkgKiBzaXplICsgZHksXG4gICAgICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5mb250U2l6ZSAvIDE1XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICAgIGJveFdpZHRoID0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICAgIGxhc3REZWNvcmF0aW9uID0gY3VycmVudERlY29yYXRpb247XG4gICAgICAgICAgICBsYXN0RmlsbCA9IGN1cnJlbnRGaWxsO1xuICAgICAgICAgICAgc2l6ZSA9IF9zaXplO1xuICAgICAgICAgICAgZHkgPSBfZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYXdTdGFydCA9IGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgZHJhd1N0YXJ0ID0gdGhpcy53aWR0aCAtIGRyYXdTdGFydCAtIGJveFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50RmlsbDtcbiAgICAgICAgY3VycmVudERlY29yYXRpb24gJiYgY3VycmVudEZpbGwgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIGRyYXdTdGFydCxcbiAgICAgICAgICB0b3AgKyBvZmZzZXRZICogc2l6ZSArIGR5LFxuICAgICAgICAgIGJveFdpZHRoIC0gY2hhclNwYWNpbmcsXG4gICAgICAgICAgdGhpcy5mb250U2l6ZSAvIDE1XG4gICAgICAgICk7XG4gICAgICAgIHRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGVyZSBpcyB0ZXh0IGJhY2tncm91bmQgY29sb3Igbm9cbiAgICAgIC8vIG90aGVyIHNoYWRvd3Mgc2hvdWxkIGJlIGNhc3RlZFxuICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBmb250IGRlY2xhcmF0aW9uIHN0cmluZyBmb3IgY2FudmFzIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT2JqZWN0XSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBmb250IGRlY2xhcmF0aW9uIGZvcm1hdHRlZCBmb3IgY2FudmFzIGNvbnRleHQuXG4gICAgICovXG4gICAgX2dldEZvbnREZWNsYXJhdGlvbjogZnVuY3Rpb24oc3R5bGVPYmplY3QsIGZvck1lYXN1cmluZykge1xuICAgICAgdmFyIHN0eWxlID0gc3R5bGVPYmplY3QgfHwgdGhpcywgZmFtaWx5ID0gdGhpcy5mb250RmFtaWx5LFxuICAgICAgICAgIGZvbnRJc0dlbmVyaWMgPSBmYWJyaWMuVGV4dC5nZW5lcmljRm9udHMuaW5kZXhPZihmYW1pbHkudG9Mb3dlckNhc2UoKSkgPiAtMTtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZmFtaWx5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIGZhbWlseS5pbmRleE9mKCdcXCcnKSA+IC0xIHx8IGZhbWlseS5pbmRleE9mKCcsJykgPiAtMSB8fFxuICAgICAgZmFtaWx5LmluZGV4T2YoJ1wiJykgPiAtMSB8fCBmb250SXNHZW5lcmljXG4gICAgICAgID8gc3R5bGUuZm9udEZhbWlseSA6ICdcIicgKyBzdHlsZS5mb250RmFtaWx5ICsgJ1wiJztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC8vIG5vZGUtY2FudmFzIG5lZWRzIFwid2VpZ2h0IHN0eWxlXCIsIHdoaWxlIGJyb3dzZXJzIG5lZWQgXCJzdHlsZSB3ZWlnaHRcIlxuICAgICAgICAvLyB2ZXJpZnkgaWYgdGhpcyBjYW4gYmUgZml4ZWQgaW4gSlNET01cbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyBzdHlsZS5mb250V2VpZ2h0IDogc3R5bGUuZm9udFN0eWxlKSxcbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyBzdHlsZS5mb250U3R5bGUgOiBzdHlsZS5mb250V2VpZ2h0KSxcbiAgICAgICAgZm9yTWVhc3VyaW5nID8gdGhpcy5DQUNIRV9GT05UX1NJWkUgKyAncHgnIDogc3R5bGUuZm9udFNpemUgKyAncHgnLFxuICAgICAgICBmb250RmFtaWx5XG4gICAgICBdLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IGluc3RhbmNlIG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuc2tpcE9mZnNjcmVlbiAmJiAhdGhpcy5ncm91cCAmJiAhdGhpcy5pc09uU2NyZWVuKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCBhcyBhbiBhcnJheSBvZiBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgICogQHJldHVybnMge0FycmF5fSBMaW5lcyBpbiB0aGUgdGV4dFxuICAgICAqL1xuICAgIF9zcGxpdFRleHRJbnRvTGluZXM6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQodGhpcy5fcmVOZXdsaW5lKSxcbiAgICAgICAgICBuZXdMaW5lcyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpLFxuICAgICAgICAgIG5ld0xpbmUgPSBbJ1xcbiddLFxuICAgICAgICAgIG5ld1RleHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3TGluZXNbaV0gPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChsaW5lc1tpXSk7XG4gICAgICAgIG5ld1RleHQgPSBuZXdUZXh0LmNvbmNhdChuZXdMaW5lc1tpXSwgbmV3TGluZSk7XG4gICAgICB9XG4gICAgICBuZXdUZXh0LnBvcCgpO1xuICAgICAgcmV0dXJuIHsgX3Vud3JhcHBlZExpbmVzOiBuZXdMaW5lcywgbGluZXM6IGxpbmVzLCBncmFwaGVtZVRleHQ6IG5ld1RleHQsIGdyYXBoZW1lTGluZXM6IG5ld0xpbmVzIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBhbGxQcm9wZXJ0aWVzID0gYWRkaXRpb25hbFByb3BzLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIHZhciBvYmogPSB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBhbGxQcm9wZXJ0aWVzKTtcbiAgICAgIC8vIHN0eWxlcyB3aWxsIGJlIG92ZXJyaWRkZW4gd2l0aCBhIHByb3Blcmx5IGNsb25lZCBzdHJ1Y3R1cmVcbiAgICAgIG9iai5zdHlsZXMgPSBjbG9uZSh0aGlzLnN0eWxlcywgdHJ1ZSk7XG4gICAgICBpZiAob2JqLnBhdGgpIHtcbiAgICAgICAgb2JqLnBhdGggPSB0aGlzLnBhdGgudG9PYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcHJvcGVydHkgdG8gYSBnaXZlbiB2YWx1ZS4gV2hlbiBjaGFuZ2luZyBwb3NpdGlvbi9kaW1lbnNpb24gLXJlbGF0ZWQgcHJvcGVydGllcyAobGVmdCwgdG9wLCBzY2FsZSwgYW5nbGUsIGV0Yy4pIGBzZXRgIGRvZXMgbm90IHVwZGF0ZSBwb3NpdGlvbiBvZiBvYmplY3QncyBib3JkZXJzL2NvbnRyb2xzLiBJZiB5b3UgbmVlZCB0byB1cGRhdGUgdGhvc2UsIGNhbGwgYHNldENvb3JkcygpYC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGtleSBQcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCAoaWYgb2JqZWN0LCBpdGVyYXRlIG92ZXIgdGhlIG9iamVjdCBwcm9wZXJ0aWVzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSAoaWYgZnVuY3Rpb24sIHRoZSB2YWx1ZSBpcyBwYXNzZWQgaW50byBpdCBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGFzIGEgbmV3IG9uZSlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgdmFyIG5lZWRzRGltcyA9IGZhbHNlO1xuICAgICAgdmFyIGlzQWRkaW5nUGF0aCA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIF9rZXkgaW4ga2V5KSB7XG4gICAgICAgICAgaWYgKF9rZXkgPT09ICdwYXRoJykge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXRoSW5mbygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZWVkc0RpbXMgPSBuZWVkc0RpbXMgfHwgdGhpcy5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuaW5kZXhPZihfa2V5KSAhPT0gLTE7XG4gICAgICAgICAgaXNBZGRpbmdQYXRoID0gaXNBZGRpbmdQYXRoIHx8IF9rZXkgPT09ICdwYXRoJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5lZWRzRGltcyA9IHRoaXMuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgICAgIGlzQWRkaW5nUGF0aCA9IGtleSA9PT0gJ3BhdGgnO1xuICAgICAgfVxuICAgICAgaWYgKGlzQWRkaW5nUGF0aCkge1xuICAgICAgICB0aGlzLnNldFBhdGhJbmZvKCk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNEaW1zKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuVGV4dC5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy90ZXh0Lmh0bWwjVGV4dEVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5UZXh0LkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoXG4gICAgJ3ggeSBkeCBkeSBmb250LWZhbWlseSBmb250LXN0eWxlIGZvbnQtd2VpZ2h0IGZvbnQtc2l6ZSBsZXR0ZXItc3BhY2luZyB0ZXh0LWRlY29yYXRpb24gdGV4dC1hbmNob3InLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IFNWRyBmb250IHNpemVcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICovXG4gIGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRSA9IDE2O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnQgKDxiPm5vdCB5ZXQgaW1wbGVtZW50ZWQ8L2I+KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlRleHQuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuVGV4dC5BVFRSSUJVVEVfTkFNRVMpLFxuICAgICAgICBwYXJzZWRBbmNob3IgPSBwYXJzZWRBdHRyaWJ1dGVzLnRleHRBbmNob3IgfHwgJ2xlZnQnO1xuICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKChvcHRpb25zID8gY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKTtcblxuICAgIG9wdGlvbnMudG9wID0gb3B0aW9ucy50b3AgfHwgMDtcbiAgICBvcHRpb25zLmxlZnQgPSBvcHRpb25zLmxlZnQgfHwgMDtcbiAgICBpZiAocGFyc2VkQXR0cmlidXRlcy50ZXh0RGVjb3JhdGlvbikge1xuICAgICAgdmFyIHRleHREZWNvcmF0aW9uID0gcGFyc2VkQXR0cmlidXRlcy50ZXh0RGVjb3JhdGlvbjtcbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCd1bmRlcmxpbmUnKSAhPT0gLTEpIHtcbiAgICAgICAgb3B0aW9ucy51bmRlcmxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uLmluZGV4T2YoJ292ZXJsaW5lJykgIT09IC0xKSB7XG4gICAgICAgIG9wdGlvbnMub3ZlcmxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uLmluZGV4T2YoJ2xpbmUtdGhyb3VnaCcpICE9PSAtMSkge1xuICAgICAgICBvcHRpb25zLmxpbmV0aHJvdWdoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBvcHRpb25zLnRleHREZWNvcmF0aW9uO1xuICAgIH1cbiAgICBpZiAoJ2R4JyBpbiBwYXJzZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLmxlZnQgKz0gcGFyc2VkQXR0cmlidXRlcy5keDtcbiAgICB9XG4gICAgaWYgKCdkeScgaW4gcGFyc2VkQXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy50b3AgKz0gcGFyc2VkQXR0cmlidXRlcy5keTtcbiAgICB9XG4gICAgaWYgKCEoJ2ZvbnRTaXplJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5mb250U2l6ZSA9IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dENvbnRlbnQgPSAnJztcblxuICAgIC8vIFRoZSBYTUwgaXMgbm90IHByb3Blcmx5IHBhcnNlZCBpbiBJRTkgc28gYSB3b3JrYXJvdW5kIHRvIGdldFxuICAgIC8vIHRleHRDb250ZW50IGlzIHRocm91Z2ggZmlyc3RDaGlsZC5kYXRhLiBBbm90aGVyIHdvcmthcm91bmQgd291bGQgYmVcbiAgICAvLyB0byBjb252ZXJ0IFhNTCBsb2FkZWQgZnJvbSBhIGZpbGUgdG8gYmUgY29udmVydGVkIHVzaW5nIERPTVBhcnNlciAoc2FtZSB3YXkgbG9hZFNWR0Zyb21TdHJpbmcoKSBkb2VzKVxuICAgIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZWxlbWVudCkpIHtcbiAgICAgIGlmICgnZmlyc3RDaGlsZCcgaW4gZWxlbWVudCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCdkYXRhJyBpbiBlbGVtZW50LmZpcnN0Q2hpbGQgJiYgZWxlbWVudC5maXJzdENoaWxkLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IGVsZW1lbnQuZmlyc3RDaGlsZC5kYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGV4dENvbnRlbnQgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICAgIH1cblxuICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyR8XFxuKy9nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIHZhciBvcmlnaW5hbFN0cm9rZVdpZHRoID0gb3B0aW9ucy5zdHJva2VXaWR0aDtcbiAgICBvcHRpb25zLnN0cm9rZVdpZHRoID0gMDtcblxuICAgIHZhciB0ZXh0ID0gbmV3IGZhYnJpYy5UZXh0KHRleHRDb250ZW50LCBvcHRpb25zKSxcbiAgICAgICAgdGV4dEhlaWdodFNjYWxlRmFjdG9yID0gdGV4dC5nZXRTY2FsZWRIZWlnaHQoKSAvIHRleHQuaGVpZ2h0LFxuICAgICAgICBsaW5lSGVpZ2h0RGlmZiA9ICh0ZXh0LmhlaWdodCArIHRleHQuc3Ryb2tlV2lkdGgpICogdGV4dC5saW5lSGVpZ2h0IC0gdGV4dC5oZWlnaHQsXG4gICAgICAgIHNjYWxlZERpZmYgPSBsaW5lSGVpZ2h0RGlmZiAqIHRleHRIZWlnaHRTY2FsZUZhY3RvcixcbiAgICAgICAgdGV4dEhlaWdodCA9IHRleHQuZ2V0U2NhbGVkSGVpZ2h0KCkgKyBzY2FsZWREaWZmLFxuICAgICAgICBvZmZYID0gMDtcbiAgICAvKlxuICAgICAgQWRqdXN0IHBvc2l0aW9uaW5nOlxuICAgICAgICB4L3kgYXR0cmlidXRlcyBpbiBTVkcgY29ycmVzcG9uZCB0byB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRleHQgYm91bmRpbmcgYm94XG4gICAgICAgIGZhYnJpYyBvdXRwdXQgYnkgZGVmYXVsdCBhdCB0b3AsIGxlZnQuXG4gICAgKi9cbiAgICBpZiAocGFyc2VkQW5jaG9yID09PSAnY2VudGVyJykge1xuICAgICAgb2ZmWCA9IHRleHQuZ2V0U2NhbGVkV2lkdGgoKSAvIDI7XG4gICAgfVxuICAgIGlmIChwYXJzZWRBbmNob3IgPT09ICdyaWdodCcpIHtcbiAgICAgIG9mZlggPSB0ZXh0LmdldFNjYWxlZFdpZHRoKCk7XG4gICAgfVxuICAgIHRleHQuc2V0KHtcbiAgICAgIGxlZnQ6IHRleHQubGVmdCAtIG9mZlgsXG4gICAgICB0b3A6IHRleHQudG9wIC0gKHRleHRIZWlnaHQgLSB0ZXh0LmZvbnRTaXplICogKDAuMDcgKyB0ZXh0Ll9mb250U2l6ZUZyYWN0aW9uKSkgLyB0ZXh0LmxpbmVIZWlnaHQsXG4gICAgICBzdHJva2VXaWR0aDogdHlwZW9mIG9yaWdpbmFsU3Ryb2tlV2lkdGggIT09ICd1bmRlZmluZWQnID8gb3JpZ2luYWxTdHJva2VXaWR0aCA6IDEsXG4gICAgfSk7XG4gICAgY2FsbGJhY2sodGV4dCk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlRleHQgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBwbGFpbiBqcyBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuVGV4dCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuVGV4dC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBvYmplY3RDb3B5ID0gY2xvbmUob2JqZWN0KSwgcGF0aCA9IG9iamVjdC5wYXRoO1xuICAgIGRlbGV0ZSBvYmplY3RDb3B5LnBhdGg7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RleHQnLCBvYmplY3RDb3B5LCBmdW5jdGlvbih0ZXh0SW5zdGFuY2UpIHtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BhdGgnLCBwYXRoLCBmdW5jdGlvbihwYXRoSW5zdGFuY2UpIHtcbiAgICAgICAgICB0ZXh0SW5zdGFuY2Uuc2V0KCdwYXRoJywgcGF0aEluc3RhbmNlKTtcbiAgICAgICAgICBjYWxsYmFjayh0ZXh0SW5zdGFuY2UpO1xuICAgICAgICB9LCAncGF0aCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKHRleHRJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSwgJ3RleHQnKTtcbiAgfTtcblxuICBmYWJyaWMuVGV4dC5nZW5lcmljRm9udHMgPSBbJ3NhbnMtc2VyaWYnLCAnc2VyaWYnLCAnY3Vyc2l2ZScsICdmYW50YXN5JywgJ21vbm9zcGFjZSddO1xuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyAmJiBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMoZmFicmljLlRleHQpO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5UZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuVGV4dC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIG5vIHN0eWxpbmcgb3Igbm8gc3R5bGluZyBpbiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4ICwgbGluZUluZGV4IGlzIG9uIHdyYXBwZWQgbGluZXMuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5U3R5bGVzOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxpbmVJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdHlwZW9mIGxpbmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnN0eWxlcyA6IHsgbGluZTogdGhpcy5zdHlsZXNbbGluZUluZGV4XSB9O1xuICAgICAgZm9yICh2YXIgcDEgaW4gb2JqKSB7XG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICBmb3IgKHZhciBwMyBpbiBvYmpbcDFdW3AyXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIGEgc3R5bGUgcHJvcGVydHkgb3IgaGFzIGl0IGluYSBzcGVjaWZpZWQgbGluZVxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkZXRlY3QgaWYgYSB0ZXh0IHdpbGwgdXNlIGEgcGFydGljdWxhciBwcm9wZXJ0eSBvciBub3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IHRvIGNoZWNrIGZvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggdG8gY2hlY2sgdGhlIHN0eWxlIG9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdHlsZUhhczogZnVuY3Rpb24ocHJvcGVydHksIGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcyB8fCAhcHJvcGVydHkgfHwgcHJvcGVydHkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGluZUluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiAhdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdHlwZW9mIGxpbmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnN0eWxlcyA6IHsgMDogdGhpcy5zdHlsZXNbbGluZUluZGV4XSB9O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9ialtwMV1bcDJdW3Byb3BlcnR5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjaGFyYWN0ZXJzIGluIGEgdGV4dCBoYXZlIGEgdmFsdWUgZm9yIGEgcHJvcGVydHlcbiAgICAgKiB3aG9zZSB2YWx1ZSBtYXRjaGVzIHRoZSB0ZXh0Ym94J3MgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkuICBJZiBzbyxcbiAgICAgKiB0aGUgY2hhcmFjdGVyLWxldmVsIHByb3BlcnR5IGlzIGRlbGV0ZWQuICBJZiB0aGUgY2hhcmFjdGVyXG4gICAgICogaGFzIG5vIG90aGVyIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYWxzbyBkZWxldGVkLiAgRmluYWxseSxcbiAgICAgKiBpZiB0aGUgbGluZSBjb250YWluaW5nIHRoYXQgY2hhcmFjdGVyIGhhcyBubyBvdGhlciBjaGFyYWN0ZXJzXG4gICAgICogdGhlbiBpdCBhbHNvIGlzIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNvbXBhcmUgYmV0d2VlbiBjaGFyYWN0ZXJzIGFuZCB0ZXh0LlxuICAgICAqL1xuICAgIGNsZWFuU3R5bGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHRoaXMuc3R5bGVzLCBzdHlsZXNDb3VudCA9IDAsIGxldHRlckNvdW50LCBzdHlsZVByb3BlcnR5VmFsdWUsXG4gICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSB0cnVlLCBncmFwaGVtZUNvdW50ID0gMCwgc3R5bGVPYmplY3Q7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBsZXR0ZXJDb3VudCA9IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgdmFyIHN0eWxlT2JqZWN0ID0gb2JqW3AxXVtwMl0sXG4gICAgICAgICAgICAgIHN0eWxlUHJvcGVydHlIYXNCZWVuU2V0ID0gc3R5bGVPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpO1xuXG4gICAgICAgICAgc3R5bGVzQ291bnQrKztcblxuICAgICAgICAgIGlmIChzdHlsZVByb3BlcnR5SGFzQmVlblNldCkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgc3R5bGVQcm9wZXJ0eVZhbHVlID0gc3R5bGVPYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGVPYmplY3RbcHJvcGVydHldICE9PSBzdHlsZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0eWxlT2JqZWN0W3Byb3BlcnR5XSA9PT0gdGhpc1twcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdHlsZU9iamVjdCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBsZXR0ZXJDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbcDFdW3AyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGV0dGVyQ291bnQgPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqW3AxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgZXZlcnkgZ3JhcGhlbWUgaGFzIHRoZSBzYW1lIHN0eWxlIHNldCB0aGVuXG4gICAgICAvLyBkZWxldGUgdGhvc2Ugc3R5bGVzIGFuZCBzZXQgaXQgb24gdGhlIHBhcmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JhcGhlbWVDb3VudCArPSB0aGlzLl90ZXh0TGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoICYmIHN0eWxlc0NvdW50ID09PSBncmFwaGVtZUNvdW50KSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gc3R5bGVQcm9wZXJ0eVZhbHVlO1xuICAgICAgICB0aGlzLnJlbW92ZVN0eWxlKHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3R5bGUgcHJvcGVydHkgb3IgcHJvcGVydGllcyBmcm9tIGFsbCBpbmRpdmlkdWFsIGNoYXJhY3RlciBzdHlsZXNcbiAgICAgKiBpbiBhIHRleHQgb2JqZWN0LiAgRGVsZXRlcyB0aGUgY2hhcmFjdGVyIHN0eWxlIG9iamVjdCBpZiBpdCBjb250YWlucyBubyBvdGhlciBzdHlsZVxuICAgICAqIHByb3BzLiAgRGVsZXRlcyBhIGxpbmUgc3R5bGUgb2JqZWN0IGlmIGl0IGNvbnRhaW5zIG5vIG90aGVyIGNoYXJhY3RlciBzdHlsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcHMgVGhlIHByb3BlcnR5IHRvIHJlbW92ZSBmcm9tIGNoYXJhY3RlciBzdHlsZXMuXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHRoaXMuc3R5bGVzLCBsaW5lLCBsaW5lTnVtLCBjaGFyTnVtO1xuICAgICAgZm9yIChsaW5lTnVtIGluIG9iaikge1xuICAgICAgICBsaW5lID0gb2JqW2xpbmVOdW1dO1xuICAgICAgICBmb3IgKGNoYXJOdW0gaW4gbGluZSkge1xuICAgICAgICAgIGRlbGV0ZSBsaW5lW2NoYXJOdW1dW3Byb3BlcnR5XTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobGluZVtjaGFyTnVtXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgbGluZVtjaGFyTnVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpbmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbbGluZU51bV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXh0ZW5kU3R5bGVzOiBmdW5jdGlvbihpbmRleCwgc3R5bGVzKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGluZGV4KTtcblxuICAgICAgaWYgKCF0aGlzLl9nZXRMaW5lU3R5bGUobG9jLmxpbmVJbmRleCkpIHtcbiAgICAgICAgdGhpcy5fc2V0TGluZVN0eWxlKGxvYy5saW5lSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCkpIHtcbiAgICAgICAgdGhpcy5fc2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQodGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KSwgc3R5bGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAyZCByZXByZXNlbnRhdGlvbiAobGluZUluZGV4IGFuZCBjaGFySW5kZXgpIG9mIGN1cnNvciAob3Igc2VsZWN0aW9uIHN0YXJ0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VsZWN0aW9uU3RhcnRdIE9wdGlvbmFsIGluZGV4LiBXaGVuIG5vdCBnaXZlbiwgY3VycmVudCBzZWxlY3Rpb25TdGFydCBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBXcmFwcGluZ10gY29uc2lkZXIgdGhlIGxvY2F0aW9uIGZvciB1bndyYXBwZWQgbGluZXMuIHVzZWZ1bCB0byBtYW5hZ2Ugc3R5bGVzLlxuICAgICAqL1xuICAgIGdldDJEQ3Vyc29yTG9jYXRpb246IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0LCBza2lwV3JhcHBpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0aW9uU3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lcyA9IHNraXBXcmFwcGluZyA/IHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lcyA6IHRoaXMuX3RleHRMaW5lcyxcbiAgICAgICAgICBsZW4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA8PSBsaW5lc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZUluZGV4OiBpLFxuICAgICAgICAgICAgY2hhckluZGV4OiBzZWxlY3Rpb25TdGFydFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgLT0gbGluZXNbaV0ubGVuZ3RoICsgdGhpcy5taXNzaW5nTmV3bGluZU9mZnNldChpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVJbmRleDogaSAtIDEsXG4gICAgICAgIGNoYXJJbmRleDogbGluZXNbaSAtIDFdLmxlbmd0aCA8IHNlbGVjdGlvblN0YXJ0ID8gbGluZXNbaSAtIDFdLmxlbmd0aCA6IHNlbGVjdGlvblN0YXJ0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHN0eWxlIG9mIGEgY3VycmVudCBzZWxlY3Rpb24vY3Vyc29yIChhdCB0aGUgc3RhcnQgcG9zaXRpb24pXG4gICAgICogaWYgc3RhcnRJbmRleCBvciBlbmRJbmRleCBhcmUgbm90IHByb3ZpZGVkLCBzZWxlY3Rpb25TdGFydCBvciBzZWxlY3Rpb25FbmQgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRJbmRleF0gU3RhcnQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kSW5kZXhdIEVuZCBpbmRleCB0byBnZXQgc3R5bGVzIGF0LCBpZiBub3Qgc3BlY2lmaWVkIHNlbGVjdGlvbkVuZCBvciBzdGFydEluZGV4ICsgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXBsZXRlXSBnZXQgZnVsbCBzdHlsZSBvciBub3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gc3R5bGVzIGFuIGFycmF5IHdpdGggb25lLCB6ZXJvIG9yIG1vcmUgU3R5bGUgb2JqZWN0c1xuICAgICAqL1xuICAgIGdldFNlbGVjdGlvblN0eWxlczogZnVuY3Rpb24oc3RhcnRJbmRleCwgZW5kSW5kZXgsIGNvbXBsZXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0SW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmRJbmRleCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IHN0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgc3R5bGVzLnB1c2godGhpcy5nZXRTdHlsZUF0UG9zaXRpb24oaSwgY29tcGxldGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbi9jdXJzb3IgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gIHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wbGV0ZV0gZnVsbCBzdHlsZSBpZiB0cnVlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBTdHlsZSBvYmplY3QgYXQgYSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFN0eWxlQXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24sIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHBvc2l0aW9uKSxcbiAgICAgICAgICBzdHlsZSA9IGNvbXBsZXRlID8gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCkgOlxuICAgICAgICAgICAgdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KTtcbiAgICAgIHJldHVybiBzdHlsZSB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uLCBpZiBubyBzZWxlY3Rpb24gZXhpc3QsIGRvIG5vdCBzZXQgYW55dGhpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZXNdIFN0eWxlcyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXhdIFN0YXJ0IGluZGV4IHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEluZGV4XSBFbmQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdCwgaWYgbm90IHNwZWNpZmllZCBzZWxlY3Rpb25FbmQgb3Igc3RhcnRJbmRleCArIDFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3R5bGVzOiBmdW5jdGlvbihzdHlsZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0SW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmRJbmRleCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IHN0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgdGhpcy5fZXh0ZW5kU3R5bGVzKGksIHN0eWxlcyk7XG4gICAgICB9XG4gICAgICAvKiBub3QgaW5jbHVkZWQgaW4gX2V4dGVuZFN0eWxlcyB0byBhdm9pZCBjbGVhcmluZyBjYWNoZSBtb3JlIHRoYW4gb25jZSAqL1xuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHJlZmVyZW5jZSwgbm90IGEgY2xvbmUsIG9mIHRoZSBzdHlsZSBvYmplY3QgZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHN0eWxlIG9iamVjdFxuICAgICAqL1xuICAgIF9nZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIGxpbmVTdHlsZSA9IHRoaXMuc3R5bGVzICYmIHRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgICBpZiAoIWxpbmVTdHlsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lU3R5bGVbY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgbmV3IG9iamVjdCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgc3R5bGUgcHJvcGVydHkgZm9yIGEgY2hhcmFjdGVyXG4gICAgICogdGhlIG9iamVjdCByZXR1cm5lZCBpcyBuZXdseSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBvZiB0aGUgbGluZSB3aGVyZSB0aGUgY2hhcmFjdGVyIGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBwb3NpdGlvbiBvZiB0aGUgY2hhcmFjdGVyIG9uIHRoZSBsaW5lXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB8fCB7IH0sXG4gICAgICAgICAgc3R5bGVPYmplY3QgPSB7IH0sIHByb3A7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N0eWxlUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9wID0gdGhpcy5fc3R5bGVQcm9wZXJ0aWVzW2ldO1xuICAgICAgICBzdHlsZU9iamVjdFtwcm9wXSA9IHR5cGVvZiBzdHlsZVtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzW3Byb3BdIDogc3R5bGVbcHJvcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlKSB7XG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gaWYgdGhlIGxpbmUgZXhpc3RzIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxpbmUgc3R5bGUgdG8gYW4gZW1wdHkgb2JqZWN0IHNvIHRoYXQgaXMgaW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZUxpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gcGFyc2VEZWNvcmF0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QudGV4dERlY29yYXRpb24pIHtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCd1bmRlcmxpbmUnKSA+IC0xICYmIChvYmplY3QudW5kZXJsaW5lID0gdHJ1ZSk7XG4gICAgICBvYmplY3QudGV4dERlY29yYXRpb24uaW5kZXhPZignbGluZS10aHJvdWdoJykgPiAtMSAmJiAob2JqZWN0LmxpbmV0aHJvdWdoID0gdHJ1ZSk7XG4gICAgICBvYmplY3QudGV4dERlY29yYXRpb24uaW5kZXhPZignb3ZlcmxpbmUnKSA+IC0xICYmIChvYmplY3Qub3ZlcmxpbmUgPSB0cnVlKTtcbiAgICAgIGRlbGV0ZSBvYmplY3QudGV4dERlY29yYXRpb247XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElUZXh0IGNsYXNzIChpbnRyb2R1Y2VkIGluIDxiPnYxLjQ8L2I+KSBFdmVudHMgYXJlIGFsc28gZmlyZWQgd2l0aCBcInRleHQ6XCJcbiAgICogcHJlZml4IHdoZW4gb2JzZXJ2aW5nIGNhbnZhcy5cbiAgICogQGNsYXNzIGZhYnJpYy5JVGV4dFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuVGV4dFxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICpcbiAgICogQGZpcmVzIGNoYW5nZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjaGFuZ2VkXG4gICAqIEBmaXJlcyBlZGl0aW5nOmVudGVyZWRcbiAgICogQGZpcmVzIGVkaXRpbmc6ZXhpdGVkXG4gICAqXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSVRleHQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICpcbiAgICogPHA+U3VwcG9ydGVkIGtleSBjb21iaW5hdGlvbnM6PC9wPlxuICAgKiA8cHJlPlxuICAgKiAgIE1vdmUgY3Vyc29yOiAgICAgICAgICAgICAgICAgICAgbGVmdCwgcmlnaHQsIHVwLCBkb3duXG4gICAqICAgU2VsZWN0IGNoYXJhY3RlcjogICAgICAgICAgICAgICBzaGlmdCArIGxlZnQsIHNoaWZ0ICsgcmlnaHRcbiAgICogICBTZWxlY3QgdGV4dCB2ZXJ0aWNhbGx5OiAgICAgICAgIHNoaWZ0ICsgdXAsIHNoaWZ0ICsgZG93blxuICAgKiAgIE1vdmUgY3Vyc29yIGJ5IHdvcmQ6ICAgICAgICAgICAgYWx0ICsgbGVmdCwgYWx0ICsgcmlnaHRcbiAgICogICBTZWxlY3Qgd29yZHM6ICAgICAgICAgICAgICAgICAgIHNoaWZ0ICsgYWx0ICsgbGVmdCwgc2hpZnQgKyBhbHQgKyByaWdodFxuICAgKiAgIE1vdmUgY3Vyc29yIHRvIGxpbmUgc3RhcnQvZW5kOiAgY21kICsgbGVmdCwgY21kICsgcmlnaHQgb3IgaG9tZSwgZW5kXG4gICAqICAgU2VsZWN0IHRpbGwgc3RhcnQvZW5kIG9mIGxpbmU6ICBjbWQgKyBzaGlmdCArIGxlZnQsIGNtZCArIHNoaWZ0ICsgcmlnaHQgb3Igc2hpZnQgKyBob21lLCBzaGlmdCArIGVuZFxuICAgKiAgIEp1bXAgdG8gc3RhcnQvZW5kIG9mIHRleHQ6ICAgICAgY21kICsgdXAsIGNtZCArIGRvd25cbiAgICogICBTZWxlY3QgdGlsbCBzdGFydC9lbmQgb2YgdGV4dDogIGNtZCArIHNoaWZ0ICsgdXAsIGNtZCArIHNoaWZ0ICsgZG93biBvciBzaGlmdCArIHBnVXAsIHNoaWZ0ICsgcGdEb3duXG4gICAqICAgRGVsZXRlIGNoYXJhY3RlcjogICAgICAgICAgICAgICBiYWNrc3BhY2VcbiAgICogICBEZWxldGUgd29yZDogICAgICAgICAgICAgICAgICAgIGFsdCArIGJhY2tzcGFjZVxuICAgKiAgIERlbGV0ZSBsaW5lOiAgICAgICAgICAgICAgICAgICAgY21kICsgYmFja3NwYWNlXG4gICAqICAgRm9yd2FyZCBkZWxldGU6ICAgICAgICAgICAgICAgICBkZWxldGVcbiAgICogICBDb3B5IHRleHQ6ICAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgY1xuICAgKiAgIFBhc3RlIHRleHQ6ICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyB2XG4gICAqICAgQ3V0IHRleHQ6ICAgICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIHhcbiAgICogICBTZWxlY3QgZW50aXJlIHRleHQ6ICAgICAgICAgICAgIGN0cmwvY21kICsgYVxuICAgKiAgIFF1aXQgZWRpdGluZyAgICAgICAgICAgICAgICAgICAgdGFiIG9yIGVzY1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogPHA+U3VwcG9ydGVkIG1vdXNlL3RvdWNoIGNvbWJpbmF0aW9uPC9wPlxuICAgKiA8cHJlPlxuICAgKiAgIFBvc2l0aW9uIGN1cnNvcjogICAgICAgICAgICAgICAgY2xpY2svdG91Y2hcbiAgICogICBDcmVhdGUgc2VsZWN0aW9uOiAgICAgICAgICAgICAgIGNsaWNrL3RvdWNoICYgZHJhZ1xuICAgKiAgIENyZWF0ZSBzZWxlY3Rpb246ICAgICAgICAgICAgICAgY2xpY2sgJiBzaGlmdCArIGNsaWNrXG4gICAqICAgU2VsZWN0IHdvcmQ6ICAgICAgICAgICAgICAgICAgICBkb3VibGUgY2xpY2tcbiAgICogICBTZWxlY3QgbGluZTogICAgICAgICAgICAgICAgICAgIHRyaXBsZSBjbGlja1xuICAgKiA8L3ByZT5cbiAgICovXG4gIGZhYnJpYy5JVGV4dCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5UZXh0LCBmYWJyaWMuT2JzZXJ2YWJsZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnaS10ZXh0JyxcblxuICAgIC8qKlxuICAgICAqIEluZGV4IHdoZXJlIHRleHQgc2VsZWN0aW9uIHN0YXJ0cyAob3Igd2hlcmUgY3Vyc29yIGlzIHdoZW4gdGhlcmUgaXMgbm8gc2VsZWN0aW9uKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uU3RhcnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCB3aGVyZSB0ZXh0IHNlbGVjdGlvbiBlbmRzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25FbmQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0ZXh0IHNlbGVjdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQ29sb3I6ICdyZ2JhKDE3LDExOSwyNTUsMC4zKScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0ZXh0IGlzIGluIGVkaXRpbmcgbW9kZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGlzRWRpdGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhIHRleHQgY2FuIGJlIGVkaXRlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVkaXRhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQm9yZGVyIGNvbG9yIG9mIHRleHQgb2JqZWN0IHdoaWxlIGl0J3MgaW4gZWRpdGluZyBtb2RlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlZGl0aW5nQm9yZGVyQ29sb3I6ICdyZ2JhKDEwMiwxNTMsMjU1LDAuMjUpJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGN1cnNvciAoaW4gcHgpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JXaWR0aDogMixcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRleHQgY3Vyc29yIGNvbG9yIGluIGVkaXRpbmcgbW9kZS5cbiAgICAgKiBpZiBub3Qgc2V0IChkZWZhdWx0KSB3aWxsIHRha2UgY29sb3IgZnJvbSB0aGUgdGV4dC5cbiAgICAgKiBpZiBzZXQgdG8gYSBjb2xvciB2YWx1ZSB0aGF0IGZhYnJpYyBjYW4gdW5kZXJzdGFuZCwgaXQgd2lsbFxuICAgICAqIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgY29sb3Igb2YgdGhlIHRleHQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBEZWxheSBiZXR3ZWVuIGN1cnNvciBibGluayAoaW4gbXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JEZWxheTogMTAwMCxcblxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIGN1cnNvciBmYWRlaW4gKGluIG1zKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yRHVyYXRpb246IDYwMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGludGVybmFsIHRleHQgY2hhciB3aWR0aHMgY2FuIGJlIGNhY2hlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBET00gY29udGFpbmVyIHRvIGFwcGVuZCB0aGUgaGlkZGVuVGV4dGFyZWEuXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYXR0YWNoaW5nIHRvIHRoZSBkb2N1bWVudC5ib2R5LlxuICAgICAqIFVzZWZ1bCB0byByZWR1Y2UgbGFnZ2lzaCByZWRyYXcgb2YgdGhlIGZ1bGwgZG9jdW1lbnQuYm9keSB0cmVlIGFuZFxuICAgICAqIGFsc28gd2l0aCBtb2RhbHMgZXZlbnQgY2FwdHVyaW5nIHRoYXQgd29uJ3QgbGV0IHRoZSB0ZXh0YXJlYSB0YWtlIGZvY3VzLlxuICAgICAqIEB0eXBlIEhUTUxFbGVtZW50XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoaWRkZW5UZXh0YXJlYUNvbnRhaW5lcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2U6IC9cXHN8XFxuLyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2N1cnJlbnRDdXJzb3JPcGFjaXR5OiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VsZWN0aW9uRGlyZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWJvcnRDdXJzb3JBbmltYXRpb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3dpZHRoT2ZTcGFjZTogW10sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwcyBkZXRlcm1pbmluZyB3aGVuIHRoZSB0ZXh0IGlzIGluIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZSBjdXJzb3JcbiAgICAgKiByZW5kZXJpbmcgaXMgYWx0ZXJlZC5cbiAgICAgKi9cbiAgICBpbkNvbXBvc2l0aW9uTW9kZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgdGV4dCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmluaXRCZWhhdmlvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGlvbiBzdGFydCAobGVmdCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBzdGFydCB0b1xuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gICAgICB0aGlzLl91cGRhdGVBbmRGaXJlKCdzZWxlY3Rpb25TdGFydCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3Rpb24gZW5kIChyaWdodCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBlbmQgdG9cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25FbmQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLnRleHQubGVuZ3RoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEZpcmUoJ3NlbGVjdGlvbkVuZCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgJ3NlbGVjdGlvblN0YXJ0JyBvciAnc2VsZWN0aW9uRW5kJ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBuZXcgcG9zaXRpb24gb2YgcHJvcGVydHlcbiAgICAgKi9cbiAgICBfdXBkYXRlQW5kRmlyZTogZnVuY3Rpb24ocHJvcGVydHksIGluZGV4KSB7XG4gICAgICBpZiAodGhpc1twcm9wZXJ0eV0gIT09IGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5kZXg7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB0aGUgZXZlbiBvZiBzZWxlY3Rpb24gY2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNoYW5nZWQnKTtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6c2VsZWN0aW9uOmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0ZXh0IGRpbWVuc2lvbnMuIFJlbmRlciBhbGwgdGV4dCBvbiBnaXZlbiBjb250ZXh0XG4gICAgICogb3Igb24gYSBvZmZzY3JlZW4gY2FudmFzIHRvIGdldCB0aGUgdGV4dCB3aWR0aCB3aXRoIG1lYXN1cmVUZXh0LlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdERpbWVuc2lvbnMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICAgIC8vIGNsZWFyIHRoZSBjdXJzb3JPZmZzZXRDYWNoZSwgc28gd2UgZW5zdXJlIHRvIGNhbGN1bGF0ZSBvbmNlIHBlciByZW5kZXJDdXJzb3JcbiAgICAgIC8vIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGJ1dCBub3QgYXQgZXZlcnkgY3Vyc29yIGFuaW1hdGlvbi5cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXInLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGFuZCBjbGVhbiB0aGUgY29udGV4dFRvcFxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dFRvcDogZnVuY3Rpb24oc2tpcFJlc3RvcmUpIHtcbiAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuY2FudmFzIHx8ICF0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCB2ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKGN0eCk7XG4gICAgICB0aGlzLl9jbGVhclRleHRBcmVhKGN0eCk7XG4gICAgICBza2lwUmVzdG9yZSB8fCBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3Igb3Igc2VsZWN0aW9uIChkZXBlbmRpbmcgb24gd2hhdCBleGlzdHMpXG4gICAgICogaXQgZG9lcyBvbiB0aGUgY29udGV4dFRvcC4gSWYgY29udGV4dFRvcCBpcyBub3QgYXZhaWxhYmxlLCBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIHJlbmRlckN1cnNvck9yU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuY2FudmFzIHx8ICF0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBib3VuZGFyaWVzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcygpLFxuICAgICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCh0cnVlKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvcihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICBfY2xlYXJUZXh0QXJlYTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyB3ZSBhZGQgNCBwaXhlbCwgdG8gYmUgc3VyZSB0byBkbyBub3QgbGVhdmUgYW55IHBpeGVsIG91dFxuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCArIDQsIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgNDtcbiAgICAgIGN0eC5jbGVhclJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnNvciBib3VuZGFyaWVzIChsZWZ0LCB0b3AsIGxlZnRPZmZzZXQsIHRvcE9mZnNldClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzIEFycmF5IG9mIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZU9mQm91bmRhcmllc1xuICAgICAqL1xuICAgIF9nZXRDdXJzb3JCb3VuZGFyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuXG4gICAgICAvLyBsZWZ0L3RvcCBhcmUgbGVmdC90b3Agb2YgZW50aXJlIHRleHQgYm94XG4gICAgICAvLyBsZWZ0T2Zmc2V0L3RvcE9mZnNldCBhcmUgb2Zmc2V0IGZyb20gdGhhdCBsZWZ0L3RvcCBwb2ludCBvZiBhIHRleHQgYm94XG5cbiAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzKHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0T2Zmc2V0OiBvZmZzZXRzLmxlZnQsXG4gICAgICAgIHRvcE9mZnNldDogb2Zmc2V0cy50b3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgaWYgKHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgJiYgJ3RvcCcgaW4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgICBsaW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4LFxuICAgICAgICAgIHRvcE9mZnNldCA9IDAsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IDAsXG4gICAgICAgICAgYm91bmRhcmllcyxcbiAgICAgICAgICBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihwb3NpdGlvbik7XG4gICAgICBjaGFySW5kZXggPSBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXg7XG4gICAgICBsaW5lSW5kZXggPSBjdXJzb3JQb3NpdGlvbi5saW5lSW5kZXg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVJbmRleDsgaSsrKSB7XG4gICAgICAgIHRvcE9mZnNldCArPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgIH1cbiAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KTtcbiAgICAgIHZhciBib3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICAgIGJvdW5kICYmIChsZWZ0T2Zmc2V0ID0gYm91bmQubGVmdCk7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCAmJiBjaGFySW5kZXggPT09IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLmxlbmd0aCkge1xuICAgICAgICBsZWZ0T2Zmc2V0IC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgYm91bmRhcmllcyA9IHtcbiAgICAgICAgdG9wOiB0b3BPZmZzZXQsXG4gICAgICAgIGxlZnQ6IGxpbmVMZWZ0T2Zmc2V0ICsgKGxlZnRPZmZzZXQgPiAwID8gbGVmdE9mZnNldCA6IDApLFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgYm91bmRhcmllcy5sZWZ0ICo9IC0xO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IGJvdW5kYXJpZXM7XG4gICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm91bmRhcmllc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdHJhbnNmb3JtZWQgY29udGV4dCB0byBkcmF3IG9uXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yOiBmdW5jdGlvbihib3VuZGFyaWVzLCBjdHgpIHtcbiAgICAgIHZhciBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbigpLFxuICAgICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXggPiAwID8gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4IC0gMSA6IDAsXG4gICAgICAgICAgY2hhckhlaWdodCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmb250U2l6ZScpLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSB0aGlzLnNjYWxlWCAqIHRoaXMuY2FudmFzLmdldFpvb20oKSxcbiAgICAgICAgICBjdXJzb3JXaWR0aCA9IHRoaXMuY3Vyc29yV2lkdGggLyBtdWx0aXBsaWVyLFxuICAgICAgICAgIHRvcE9mZnNldCA9IGJvdW5kYXJpZXMudG9wT2Zmc2V0LFxuICAgICAgICAgIGR5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgJ2RlbHRhWScpO1xuICAgICAgdG9wT2Zmc2V0ICs9ICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgIC0gY2hhckhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jdXJzb3JDb2xvciB8fCB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZmlsbCcpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fX2lzTW91c2Vkb3duID8gMSA6IHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5O1xuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBib3VuZGFyaWVzLmxlZnRPZmZzZXQgLSBjdXJzb3JXaWR0aCAvIDIsXG4gICAgICAgIHRvcE9mZnNldCArIGJvdW5kYXJpZXMudG9wICsgZHksXG4gICAgICAgIGN1cnNvcldpZHRoLFxuICAgICAgICBjaGFySGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZGFyaWVzIE9iamVjdCB3aXRoIGxlZnQvdG9wL2xlZnRPZmZzZXQvdG9wT2Zmc2V0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0cmFuc2Zvcm1lZCBjb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKi9cbiAgICByZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKGJvdW5kYXJpZXMsIGN0eCkge1xuXG4gICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgc2VsZWN0aW9uRW5kID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kIDogdGhpcy5zZWxlY3Rpb25FbmQsXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgZW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvbkVuZCksXG4gICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGVuZExpbmUgPSBlbmQubGluZUluZGV4LFxuICAgICAgICAgIHN0YXJ0Q2hhciA9IHN0YXJ0LmNoYXJJbmRleCA8IDAgPyAwIDogc3RhcnQuY2hhckluZGV4LFxuICAgICAgICAgIGVuZENoYXIgPSBlbmQuY2hhckluZGV4IDwgMCA/IDAgOiBlbmQuY2hhckluZGV4O1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICB2YXIgbGluZU9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpIHx8IDAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSksXG4gICAgICAgICAgICByZWFsTGluZUhlaWdodCA9IDAsIGJveFN0YXJ0ID0gMCwgYm94RW5kID0gMDtcblxuICAgICAgICBpZiAoaSA9PT0gc3RhcnRMaW5lKSB7XG4gICAgICAgICAgYm94U3RhcnQgPSB0aGlzLl9fY2hhckJvdW5kc1tzdGFydExpbmVdW3N0YXJ0Q2hhcl0ubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBzdGFydExpbmUgJiYgaSA8IGVuZExpbmUpIHtcbiAgICAgICAgICBib3hFbmQgPSBpc0p1c3RpZnkgJiYgIXRoaXMuaXNFbmRPZldyYXBwaW5nKGkpID8gdGhpcy53aWR0aCA6IHRoaXMuZ2V0TGluZVdpZHRoKGkpIHx8IDU7IC8vIFdURiBpcyB0aGlzIDU/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PT0gZW5kTGluZSkge1xuICAgICAgICAgIGlmIChlbmRDaGFyID09PSAwKSB7XG4gICAgICAgICAgICBib3hFbmQgPSB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyXS5sZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGFyU3BhY2luZyA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICAgICAgYm94RW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbZW5kTGluZV1bZW5kQ2hhciAtIDFdLmxlZnRcbiAgICAgICAgICAgICAgKyB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyIC0gMV0ud2lkdGggLSBjaGFyU3BhY2luZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVhbExpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5saW5lSGVpZ2h0IDwgMSB8fCAoaSA9PT0gZW5kTGluZSAmJiB0aGlzLmxpbmVIZWlnaHQgPiAxKSkge1xuICAgICAgICAgIGxpbmVIZWlnaHQgLz0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmF3U3RhcnQgPSBib3VuZGFyaWVzLmxlZnQgKyBsaW5lT2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICBkcmF3V2lkdGggPSBib3hFbmQgLSBib3hTdGFydCxcbiAgICAgICAgICAgIGRyYXdIZWlnaHQgPSBsaW5lSGVpZ2h0LCBleHRyYVRvcCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29tcG9zaXRpb25Db2xvciB8fCAnYmxhY2snO1xuICAgICAgICAgIGRyYXdIZWlnaHQgPSAxO1xuICAgICAgICAgIGV4dHJhVG9wID0gbGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgZHJhd1N0YXJ0ID0gdGhpcy53aWR0aCAtIGRyYXdTdGFydCAtIGRyYXdXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgZHJhd1N0YXJ0LFxuICAgICAgICAgIGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBleHRyYVRvcCxcbiAgICAgICAgICBkcmF3V2lkdGgsXG4gICAgICAgICAgZHJhd0hlaWdodCk7XG4gICAgICAgIGJvdW5kYXJpZXMudG9wT2Zmc2V0ICs9IHJlYWxMaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIGZ1bmN0aW9uIHRvIGtub3cgdGhlIGhlaWdodCBvZiB0aGUgY3Vyc29yLlxuICAgICAqIHRoZSBjdXJyZW50Q2hhciBpcyB0aGUgb25lIHRoYXQgcHJlY2VkZXMgdGhlIGN1cnNvclxuICAgICAqIFJldHVybnMgZm9udFNpemUgb2YgY2hhciBhdCB0aGUgY3VycmVudCBjdXJzb3JcbiAgICAgKiBVbnVzZWQgZnJvbSB0aGUgbGlicmFyeSwgaXMgZm9yIHRoZSBlbmQgdXNlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQ2hhcmFjdGVyIGZvbnQgc2l6ZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyRm9udFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNwID0gdGhpcy5fZ2V0Q3VycmVudENoYXJJbmRleCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoY3AubCwgY3AuYywgJ2ZvbnRTaXplJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdG8ga25vdyB0aGUgY29sb3Igb2YgdGhlIGN1cnNvci5cbiAgICAgKiB0aGUgY3VycmVudENoYXIgaXMgdGhlIG9uZSB0aGF0IHByZWNlZGVzIHRoZSBjdXJzb3JcbiAgICAgKiBSZXR1cm5zIGNvbG9yIChmaWxsKSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIGlmIHRoZSB0ZXh0IG9iamVjdCBoYXMgYSBwYXR0ZXJuIG9yIGdyYWRpZW50IGZvciBmaWxsZXIsIGl0IHdpbGwgcmV0dXJuIHRoYXQuXG4gICAgICogVW51c2VkIGJ5IHRoZSBsaWJyYXJ5LCBpcyBmb3IgdGhlIGVuZCB1c2VyXG4gICAgICogQHJldHVybiB7U3RyaW5nIHwgZmFicmljLkdyYWRpZW50IHwgZmFicmljLlBhdHRlcm59IENoYXJhY3RlciBjb2xvciAoZmlsbClcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2hhckNvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjcCA9IHRoaXMuX2dldEN1cnJlbnRDaGFySW5kZXgoKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGNwLmwsIGNwLmMsICdmaWxsJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnNvciBwb3NpdGlvbiBmb3IgdGhlIGdldEN1cnJlbnQuLiBmdW5jdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDdXJyZW50Q2hhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbih0aGlzLnNlbGVjdGlvblN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXggPiAwID8gY3Vyc29yUG9zaXRpb24uY2hhckluZGV4IC0gMSA6IDA7XG4gICAgICByZXR1cm4geyBsOiBjdXJzb3JQb3NpdGlvbi5saW5lSW5kZXgsIGM6IGNoYXJJbmRleCB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLklUZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JVGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgYXJndW1lbnRcbiAgICovXG4gIGZhYnJpYy5JVGV4dC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHBhcnNlRGVjb3JhdGlvbihvYmplY3QpO1xuICAgIGlmIChvYmplY3Quc3R5bGVzKSB7XG4gICAgICBmb3IgKHZhciBpIGluIG9iamVjdC5zdHlsZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBvYmplY3Quc3R5bGVzW2ldKSB7XG4gICAgICAgICAgcGFyc2VEZWNvcmF0aW9uKG9iamVjdC5zdHlsZXNbaV1bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0lUZXh0Jywgb2JqZWN0LCBjYWxsYmFjaywgJ3RleHQnKTtcbiAgfTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbGwgdGhlIGludGVyYWN0aXZlIGJlaGF2aW9yIG9mIElUZXh0XG4gICAgICovXG4gICAgaW5pdEJlaGF2aW9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5pdEFkZGVkSGFuZGxlcigpO1xuICAgICAgdGhpcy5pbml0UmVtb3ZlZEhhbmRsZXIoKTtcbiAgICAgIHRoaXMuaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzKCk7XG4gICAgICB0aGlzLmluaXREb3VibGVDbGlja1NpbXVsYXRpb24oKTtcbiAgICAgIHRoaXMubW91c2VNb3ZlSGFuZGxlciA9IHRoaXMubW91c2VNb3ZlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgIH0sXG5cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuZXhpdEVkaXRpbmcoKTtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgXCJhZGRlZFwiIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBpbml0QWRkZWRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLm9uKCdhZGRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gX3RoaXMuY2FudmFzO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgaWYgKCFjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNhbnZhcy5faGFzSVRleHRIYW5kbGVycyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5faW5pdENhbnZhc0hhbmRsZXJzKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMgPSBjYW52YXMuX2lUZXh0SW5zdGFuY2VzIHx8IFtdO1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMucHVzaChfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpbml0UmVtb3ZlZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMub24oJ3JlbW92ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IF90aGlzLmNhbnZhcztcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMgPSBjYW52YXMuX2lUZXh0SW5zdGFuY2VzIHx8IFtdO1xuICAgICAgICAgIGZhYnJpYy51dGlsLnJlbW92ZUZyb21BcnJheShjYW52YXMuX2lUZXh0SW5zdGFuY2VzLCBfdGhpcyk7XG4gICAgICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9yZW1vdmVDYW52YXNIYW5kbGVycyhjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIGNhbnZhcyBldmVudCB0byBtYW5hZ2UgZXhpdGluZyBvbiBvdGhlciBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0Q2FudmFzSGFuZGxlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgb2JqLl9faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNhbnZhcy5vbignbW91c2U6dXAnLCBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgY2FudmFzIGV2ZW50IHRvIG1hbmFnZSBleGl0aW5nIG9uIG90aGVyIGluc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUNhbnZhc0hhbmRsZXJzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIGNhbnZhcy5vZmYoJ21vdXNlOnVwJywgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGljazogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja1N0YXRlID0gdGhpcy5fYW5pbWF0ZUN1cnNvcih0aGlzLCAxLCB0aGlzLmN1cnNvckR1cmF0aW9uLCAnX29uVGlja0NvbXBsZXRlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVDdXJzb3I6IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0T3BhY2l0eSwgZHVyYXRpb24sIGNvbXBsZXRlTWV0aG9kKSB7XG5cbiAgICAgIHZhciB0aWNrU3RhdGU7XG5cbiAgICAgIHRpY2tTdGF0ZSA9IHtcbiAgICAgICAgaXNBYm9ydGVkOiBmYWxzZSxcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaXNBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIG9iai5hbmltYXRlKCdfY3VycmVudEN1cnNvck9wYWNpdHknLCB0YXJnZXRPcGFjaXR5LCB7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCF0aWNrU3RhdGUuaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICBvYmpbY29tcGxldGVNZXRob2RdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gYW5pbWF0ZSBhIHNlbGVjdGlvbiwgb25seSBjdXJzb3JcbiAgICAgICAgICBpZiAob2JqLmNhbnZhcyAmJiBvYmouc2VsZWN0aW9uU3RhcnQgPT09IG9iai5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgIG9iai5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aWNrU3RhdGUuaXNBYm9ydGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aWNrU3RhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uVGlja0NvbXBsZXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2N1cnNvclRpbWVvdXQxKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0MSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jdXJzb3JUaW1lb3V0MSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgPSBfdGhpcy5fYW5pbWF0ZUN1cnNvcihfdGhpcywgMCwgdGhpcy5jdXJzb3JEdXJhdGlvbiAvIDIsICdfdGljaycpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgZGVsYXllZCBjdXJzb3JcbiAgICAgKi9cbiAgICBpbml0RGVsYXllZEN1cnNvcjogZnVuY3Rpb24ocmVzdGFydCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBkZWxheSA9IHJlc3RhcnQgPyAwIDogdGhpcy5jdXJzb3JEZWxheTtcblxuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuICAgICAgdGhpcy5fY3Vyc29yVGltZW91dDIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fdGljaygpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgY3Vyc29yIGFuaW1hdGlvbiBhbmQgY2xlYXJzIGFsbCB0aW1lb3V0c1xuICAgICAqL1xuICAgIGFib3J0Q3Vyc29yQW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzaG91bGRDbGVhciA9IHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgfHwgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLFxuICAgICAgICAgIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tTdGF0ZSAmJiB0aGlzLl9jdXJyZW50VGlja1N0YXRlLmFib3J0KCk7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgJiYgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLmFib3J0KCk7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0MSk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDIpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDA7XG4gICAgICAvLyB0byBjbGVhciBqdXN0IGl0ZXh0IGFyZWEgd2UgbmVlZCB0byB0cmFuc2Zvcm0gdGhlIGNvbnRleHRcbiAgICAgIC8vIGl0IG1heSBub3QgYmUgd29ydGggaXRcbiAgICAgIGlmIChzaG91bGRDbGVhciAmJiBjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLmNsZWFyQ29udGV4dChjYW52YXMuY29udGV4dFRvcCB8fCBjYW52YXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBlbnRpcmUgdGV4dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuX3RleHQubGVuZ3RoO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzZWxlY3RlZCB0ZXh0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGV4dC5zbGljZSh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCkuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgc3RhcnQgb2YgY3VycmVudCB3b3JkIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kV29yZEJvdW5kYXJ5TGVmdDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb20gLSAxO1xuXG4gICAgICAvLyByZW1vdmUgc3BhY2UgYmVmb3JlIGN1cnNvciBmaXJzdFxuICAgICAgaWYgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoL1xcUy8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSAtIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBlbmQgb2YgY3VycmVudCB3b3JkIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kV29yZEJvdW5kYXJ5UmlnaHQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tO1xuXG4gICAgICAvLyByZW1vdmUgc3BhY2UgYWZ0ZXIgY3Vyc29yIGZpcnN0XG4gICAgICBpZiAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgvXFxTLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA8IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tICsgb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIHN0YXJ0IG9mIGN1cnJlbnQgbGluZSBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZExpbmVCb3VuZGFyeUxlZnQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tIC0gMTtcblxuICAgICAgd2hpbGUgKCEvXFxuLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tIC0gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIGVuZCBvZiBjdXJyZW50IGxpbmUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRMaW5lQm91bmRhcnlSaWdodDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb207XG5cbiAgICAgIHdoaWxlICghL1xcbi8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPCB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgaW5kZXggY29ycmVzcG9uZGluZyB0byBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgd29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gMSBvciAtMVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgYSB3b3JkXG4gICAgICovXG4gICAgc2VhcmNoV29yZEJvdW5kYXJ5OiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuX3RleHQsXG4gICAgICAgICAgaW5kZXggICAgID0gdGhpcy5fcmVTcGFjZS50ZXN0KHRleHRbc2VsZWN0aW9uU3RhcnRdKSA/IHNlbGVjdGlvblN0YXJ0IC0gMSA6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIF9jaGFyICAgICA9IHRleHRbaW5kZXhdLFxuICAgICAgICAgIC8vIHdyb25nXG4gICAgICAgICAgcmVOb25Xb3JkID0gZmFicmljLnJlTm9uV29yZDtcblxuICAgICAgd2hpbGUgKCFyZU5vbldvcmQudGVzdChfY2hhcikgJiYgaW5kZXggPiAwICYmIGluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyZWN0aW9uO1xuICAgICAgICBfY2hhciA9IHRleHRbaW5kZXhdO1xuICAgICAgfVxuICAgICAgaWYgKHJlTm9uV29yZC50ZXN0KF9jaGFyKSkge1xuICAgICAgICBpbmRleCArPSBkaXJlY3Rpb24gPT09IDEgPyAwIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIHdvcmQgYmFzZWQgb24gdGhlIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGlvblN0YXJ0IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAgICovXG4gICAgc2VsZWN0V29yZDogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VhcmNoV29yZEJvdW5kYXJ5KHNlbGVjdGlvblN0YXJ0LCAtMSksIC8qIHNlYXJjaCBiYWNrd2FyZHMgKi9cbiAgICAgICAgICBuZXdTZWxlY3Rpb25FbmQgPSB0aGlzLnNlYXJjaFdvcmRCb3VuZGFyeShzZWxlY3Rpb25TdGFydCwgMSk7IC8qIHNlYXJjaCBmb3J3YXJkICovXG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uRW5kO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSBsaW5lIGJhc2VkIG9uIHRoZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZWxlY3RMaW5lOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCkge1xuICAgICAgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydCB8fCB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5maW5kTGluZUJvdW5kYXJ5TGVmdChzZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgbmV3U2VsZWN0aW9uRW5kID0gdGhpcy5maW5kTGluZUJvdW5kYXJ5UmlnaHQoc2VsZWN0aW9uU3RhcnQpO1xuXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbkVuZDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVudGVycyBlZGl0aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGVudGVyRWRpdGluZzogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuaXNFZGl0aW5nIHx8ICF0aGlzLmVkaXRhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmNhbGNPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5leGl0RWRpdGluZ09uT3RoZXJzKHRoaXMuY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0VkaXRpbmcgPSB0cnVlO1xuXG4gICAgICB0aGlzLmluaXRIaWRkZW5UZXh0YXJlYShlKTtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKTtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUgPSB0aGlzLnRleHQ7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgdGhpcy5fc2F2ZUVkaXRpbmdQcm9wcygpO1xuICAgICAgdGhpcy5fc2V0RWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl90ZXh0QmVmb3JlRWRpdCA9IHRoaXMudGV4dDtcblxuICAgICAgdGhpcy5fdGljaygpO1xuICAgICAgdGhpcy5maXJlKCdlZGl0aW5nOmVudGVyZWQnKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDplZGl0aW5nOmVudGVyZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIHRoaXMuaW5pdE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBleGl0RWRpdGluZ09uT3RoZXJzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICBvYmouc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAob2JqLmlzRWRpdGluZykge1xuICAgICAgICAgICAgb2JqLmV4aXRFZGl0aW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgXCJtb3VzZW1vdmVcIiBldmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgaW5pdE1vdXNlTW92ZUhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jYW52YXMub24oJ21vdXNlOm1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1vdXNlTW92ZUhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5fX2lzTW91c2Vkb3duIHx8ICF0aGlzLmlzRWRpdGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpLFxuICAgICAgICAgIGN1cnJlbnRTdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgY3VycmVudEVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgICAgaWYgKFxuICAgICAgICAobmV3U2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duIHx8IGN1cnJlbnRTdGFydCA9PT0gY3VycmVudEVuZClcbiAgICAgICAgJiZcbiAgICAgICAgKGN1cnJlbnRTdGFydCA9PT0gbmV3U2VsZWN0aW9uU3RhcnQgfHwgY3VycmVudEVuZCA9PT0gbmV3U2VsZWN0aW9uU3RhcnQpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1NlbGVjdGlvblN0YXJ0ID4gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24pIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSBjdXJyZW50U3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25FbmQgIT09IGN1cnJlbnRFbmQpIHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0Q3Vyc29ySWZOZWVkZWQoKTtcbiAgICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ob3ZlckN1cnNvciA9ICd0ZXh0JztcblxuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IgPSB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yID0gJ3RleHQnO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy5lZGl0aW5nQm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5zZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLmxvY2tNb3ZlbWVudFkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGZyb20gdGV4dGFyZWEgdG8gZ3JhcGhlbWUgaW5kZXhlc1xuICAgICAqL1xuICAgIGZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uOiBmdW5jdGlvbihzdGFydCwgZW5kLCB0ZXh0KSB7XG4gICAgICB2YXIgc21hbGxlclRleHRTdGFydCA9IHRleHQuc2xpY2UoMCwgc3RhcnQpLFxuICAgICAgICAgIGdyYXBoZW1lU3RhcnQgPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChzbWFsbGVyVGV4dFN0YXJ0KS5sZW5ndGg7XG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0IH07XG4gICAgICB9XG4gICAgICB2YXIgc21hbGxlclRleHRFbmQgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIGdyYXBoZW1lRW5kID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoc21hbGxlclRleHRFbmQpLmxlbmd0aDtcbiAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgKyBncmFwaGVtZUVuZCB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGZyb20gZmFicmljIHRvIHRleHRhcmVhIHZhbHVlc1xuICAgICAqL1xuICAgIGZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uOiBmdW5jdGlvbihzdGFydCwgZW5kLCBfdGV4dCkge1xuICAgICAgdmFyIHNtYWxsZXJUZXh0U3RhcnQgPSBfdGV4dC5zbGljZSgwLCBzdGFydCksXG4gICAgICAgICAgZ3JhcGhlbWVTdGFydCA9IHNtYWxsZXJUZXh0U3RhcnQuam9pbignJykubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCB9O1xuICAgICAgfVxuICAgICAgdmFyIHNtYWxsZXJUZXh0RW5kID0gX3RleHQuc2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICAgICAgZ3JhcGhlbWVFbmQgPSBzbWFsbGVyVGV4dEVuZC5qb2luKCcnKS5sZW5ndGg7XG4gICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0ICsgZ3JhcGhlbWVFbmQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlVGV4dGFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IHsgfTtcbiAgICAgIGlmICghdGhpcy5oaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZnJvbUdyYXBoZW1lVG9TdHJpbmdTZWxlY3Rpb24odGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIHRoaXMuX3RleHQpO1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25FbmQ7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVRleHRhcmVhUG9zaXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVGcm9tVGV4dEFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmhpZGRlblRleHRhcmVhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5mcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbihcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCwgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQsIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvbkVuZDtcbiAgICAgIGlmICghdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlVGV4dGFyZWFQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS5sZWZ0ID0gc3R5bGUubGVmdDtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS50b3AgPSBzdHlsZS50b3A7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBjb250YWlucyBzdHlsZSBmb3IgaGlkZGVuVGV4dGFyZWFcbiAgICAgKi9cbiAgICBfY2FsY1RleHRhcmVhUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4geyB4OiAxLCB5OiAxIH07XG4gICAgICB9XG4gICAgICB2YXIgZGVzaXJlZFBvc2l0aW9uID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuY29tcG9zaXRpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgYm91bmRhcmllcyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXMoZGVzaXJlZFBvc2l0aW9uKSxcbiAgICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihkZXNpcmVkUG9zaXRpb24pLFxuICAgICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgICAgY2hhckhlaWdodCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmb250U2l6ZScpICogdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSBib3VuZGFyaWVzLmxlZnRPZmZzZXQsXG4gICAgICAgICAgbSA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIHAgPSB7XG4gICAgICAgICAgICB4OiBib3VuZGFyaWVzLmxlZnQgKyBsZWZ0T2Zmc2V0LFxuICAgICAgICAgICAgeTogYm91bmRhcmllcy50b3AgKyBib3VuZGFyaWVzLnRvcE9mZnNldCArIGNoYXJIZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJldGluYVNjYWxpbmcgPSB0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCksXG4gICAgICAgICAgdXBwZXJDYW52YXMgPSB0aGlzLmNhbnZhcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIHVwcGVyQ2FudmFzV2lkdGggPSB1cHBlckNhbnZhcy53aWR0aCAvIHJldGluYVNjYWxpbmcsXG4gICAgICAgICAgdXBwZXJDYW52YXNIZWlnaHQgPSB1cHBlckNhbnZhcy5oZWlnaHQgLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIG1heFdpZHRoID0gdXBwZXJDYW52YXNXaWR0aCAtIGNoYXJIZWlnaHQsXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gdXBwZXJDYW52YXNIZWlnaHQgLSBjaGFySGVpZ2h0LFxuICAgICAgICAgIHNjYWxlWCA9IHVwcGVyQ2FudmFzLmNsaWVudFdpZHRoIC8gdXBwZXJDYW52YXNXaWR0aCxcbiAgICAgICAgICBzY2FsZVkgPSB1cHBlckNhbnZhcy5jbGllbnRIZWlnaHQgLyB1cHBlckNhbnZhc0hlaWdodDtcblxuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIG0pO1xuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHAueCAqPSBzY2FsZVg7XG4gICAgICBwLnkgKj0gc2NhbGVZO1xuICAgICAgaWYgKHAueCA8IDApIHtcbiAgICAgICAgcC54ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnggPiBtYXhXaWR0aCkge1xuICAgICAgICBwLnggPSBtYXhXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnkgPCAwKSB7XG4gICAgICAgIHAueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocC55ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIHAueSA9IG1heEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGNhbnZhcyBvZmZzZXQgb24gZG9jdW1lbnRcbiAgICAgIHAueCArPSB0aGlzLmNhbnZhcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwLnkgKz0gdGhpcy5jYW52YXMuX29mZnNldC50b3A7XG5cbiAgICAgIHJldHVybiB7IGxlZnQ6IHAueCArICdweCcsIHRvcDogcC55ICsgJ3B4JywgZm9udFNpemU6IGNoYXJIZWlnaHQgKyAncHgnLCBjaGFySGVpZ2h0OiBjaGFySGVpZ2h0IH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NhdmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2F2ZWRQcm9wcyA9IHtcbiAgICAgICAgaGFzQ29udHJvbHM6IHRoaXMuaGFzQ29udHJvbHMsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmJvcmRlckNvbG9yLFxuICAgICAgICBsb2NrTW92ZW1lbnRYOiB0aGlzLmxvY2tNb3ZlbWVudFgsXG4gICAgICAgIGxvY2tNb3ZlbWVudFk6IHRoaXMubG9ja01vdmVtZW50WSxcbiAgICAgICAgaG92ZXJDdXJzb3I6IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgIHNlbGVjdGFibGU6IHRoaXMuc2VsZWN0YWJsZSxcbiAgICAgICAgZGVmYXVsdEN1cnNvcjogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvcixcbiAgICAgICAgbW92ZUN1cnNvcjogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMubW92ZUN1cnNvclxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzdG9yZUVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX3NhdmVkUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhvdmVyQ3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5ob3ZlckN1cnNvcjtcbiAgICAgIHRoaXMuaGFzQ29udHJvbHMgPSB0aGlzLl9zYXZlZFByb3BzLmhhc0NvbnRyb2xzO1xuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuX3NhdmVkUHJvcHMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLnNlbGVjdGFibGUgPSB0aGlzLl9zYXZlZFByb3BzLnNlbGVjdGFibGU7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFg7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFkgPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFk7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5kZWZhdWx0Q3Vyc29yO1xuICAgICAgICB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5tb3ZlQ3Vyc29yO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGl0cyBmcm9tIGVkaXRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZXhpdEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzVGV4dENoYW5nZWQgPSAodGhpcy5fdGV4dEJlZm9yZUVkaXQgIT09IHRoaXMudGV4dCk7XG4gICAgICB2YXIgaGlkZGVuVGV4dGFyZWEgPSB0aGlzLmhpZGRlblRleHRhcmVhO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcblxuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuXG4gICAgICBpZiAoaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgaGlkZGVuVGV4dGFyZWEuYmx1ciAmJiBoaWRkZW5UZXh0YXJlYS5ibHVyKCk7XG4gICAgICAgIGhpZGRlblRleHRhcmVhLnBhcmVudE5vZGUgJiYgaGlkZGVuVGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWRkZW5UZXh0YXJlYSk7XG4gICAgICB9XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhID0gbnVsbDtcbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX3Jlc3RvcmVFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMDtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdlZGl0aW5nOmV4aXRlZCcpO1xuICAgICAgaXNUZXh0Q2hhbmdlZCAmJiB0aGlzLmZpcmUoJ21vZGlmaWVkJyk7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMub2ZmKCdtb3VzZTptb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDplZGl0aW5nOmV4aXRlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgICBpc1RleHRDaGFuZ2VkICYmIHRoaXMuY2FudmFzLmZpcmUoJ29iamVjdDptb2RpZmllZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHRMaW5lc1twcm9wXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYW5kIHJlZmxvdyBhIHN0eWxlIGJsb2NrIGZyb20gc3RhcnQgdG8gZW5kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBsaW5lYXIgc3RhcnQgcG9zaXRpb24gZm9yIHJlbW92YWwgKGluY2x1ZGVkIGluIHJlbW92YWwpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBsaW5lYXIgZW5kIHBvc2l0aW9uIGZvciByZW1vdmFsICggZXhjbHVkZWQgZnJvbSByZW1vdmFsIClcbiAgICAgKi9cbiAgICByZW1vdmVTdHlsZUZyb21UbzogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGN1cnNvclN0YXJ0ID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBjdXJzb3JFbmQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oZW5kLCB0cnVlKSxcbiAgICAgICAgICBsaW5lU3RhcnQgPSBjdXJzb3JTdGFydC5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhclN0YXJ0ID0gY3Vyc29yU3RhcnQuY2hhckluZGV4LFxuICAgICAgICAgIGxpbmVFbmQgPSBjdXJzb3JFbmQubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJFbmQgPSBjdXJzb3JFbmQuY2hhckluZGV4LFxuICAgICAgICAgIGksIHN0eWxlT2JqO1xuICAgICAgaWYgKGxpbmVTdGFydCAhPT0gbGluZUVuZCkge1xuICAgICAgICAvLyBzdGVwMSByZW1vdmUgdGhlIHRyYWlsaW5nIG9mIGxpbmVTdGFydFxuICAgICAgICBpZiAodGhpcy5zdHlsZXNbbGluZVN0YXJ0XSkge1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJTdGFydDsgaSA8IHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lc1tsaW5lU3RhcnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZVN0YXJ0XVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RlcDIgbW92ZSB0aGUgdHJhaWxpbmcgb2YgbGluZUVuZCB0byBsaW5lU3RhcnQgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lRW5kXSkge1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJFbmQ7IGkgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZUVuZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0eWxlT2JqID0gdGhpcy5zdHlsZXNbbGluZUVuZF1baV07XG4gICAgICAgICAgICBpZiAoc3R5bGVPYmopIHtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbGluZVN0YXJ0XSB8fCAodGhpcy5zdHlsZXNbbGluZVN0YXJ0XSA9IHsgfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVTdGFydF1bY2hhclN0YXJ0ICsgaSAtIGNoYXJFbmRdID0gc3R5bGVPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAzIGRldGVjdHMgbGluZXMgd2lsbCBiZSBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgIGZvciAoaSA9IGxpbmVTdGFydCArIDE7IGkgPD0gbGluZUVuZDsgaSsrKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXA0IHNoaWZ0IHJlbWFpbmluZyBsaW5lcy5cbiAgICAgICAgdGhpcy5zaGlmdExpbmVTdHlsZXMobGluZUVuZCwgbGluZVN0YXJ0IC0gbGluZUVuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFuZCBzaGlmdCBsZWZ0IG9uIHRoZSBzYW1lIGxpbmVcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICBzdHlsZU9iaiA9IHRoaXMuc3R5bGVzW2xpbmVTdGFydF07XG4gICAgICAgICAgdmFyIGRpZmYgPSBjaGFyRW5kIC0gY2hhclN0YXJ0LCBudW1lcmljQ2hhciwgX2NoYXI7XG4gICAgICAgICAgZm9yIChpID0gY2hhclN0YXJ0OyBpIDwgY2hhckVuZDsgaSsrKSB7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVPYmpbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoX2NoYXIgaW4gdGhpcy5zdHlsZXNbbGluZVN0YXJ0XSkge1xuICAgICAgICAgICAgbnVtZXJpY0NoYXIgPSBwYXJzZUludChfY2hhciwgMTApO1xuICAgICAgICAgICAgaWYgKG51bWVyaWNDaGFyID49IGNoYXJFbmQpIHtcbiAgICAgICAgICAgICAgc3R5bGVPYmpbbnVtZXJpY0NoYXIgLSBkaWZmXSA9IHN0eWxlT2JqW19jaGFyXTtcbiAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqW19jaGFyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIGxpbmUgc3R5bGVzIHVwIG9yIGRvd25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgQ2FuIGFueSBudW1iZXI/XG4gICAgICovXG4gICAgc2hpZnRMaW5lU3R5bGVzOiBmdW5jdGlvbihsaW5lSW5kZXgsIG9mZnNldCkge1xuICAgICAgLy8gc2hpZnQgYWxsIGxpbmUgc3R5bGVzIGJ5IG9mZnNldCB1cHdhcmQgb3IgZG93bndhcmRcbiAgICAgIC8vIGRvIG5vdCBjbG9uZSBkZWVwLiB3ZSBuZWVkIG5ldyBhcnJheSwgbm90IG5ldyBzdHlsZSBvYmplY3RzXG4gICAgICB2YXIgY2xvbmVkU3R5bGVzID0gY2xvbmUodGhpcy5zdHlsZXMpO1xuICAgICAgZm9yICh2YXIgbGluZSBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICB2YXIgbnVtZXJpY0xpbmUgPSBwYXJzZUludChsaW5lLCAxMCk7XG4gICAgICAgIGlmIChudW1lcmljTGluZSA+IGxpbmVJbmRleCkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lICsgb2Zmc2V0XSA9IGNsb25lZFN0eWxlc1tudW1lcmljTGluZV07XG4gICAgICAgICAgaWYgKCFjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmUgLSBvZmZzZXRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXN0YXJ0Q3Vyc29ySWZOZWVkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jdXJyZW50VGlja1N0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUuaXNBYm9ydGVkXG4gICAgICAgIHx8ICF0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgfHwgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLmlzQWJvcnRlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluc2VydGlvbiBvZiBtb3JlIGNvbnNlY3V0aXZlIHN0eWxlIGxpbmVzIGZvciB3aGVuIG9uZSBvciBtb3JlXG4gICAgICogbmV3bGluZXMgZ2V0cyBhZGRlZCB0byB0aGUgdGV4dC4gU2luY2UgY3VycmVudCBzdHlsZSBuZWVkcyB0byBiZSBzaGlmdGVkXG4gICAgICogZmlyc3Qgd2Ugc2hpZnQgdGhlIGN1cnJlbnQgc3R5bGUgb2YgdGhlIG51bWJlciBsaW5lcyBuZWVkZWQsIHRoZW4gd2UgYWRkXG4gICAgICogbmV3IGxpbmVzIGZyb20gdGhlIGxhc3QgdG8gdGhlIGZpcnN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXR5IG51bWJlciBvZiBsaW5lcyB0byBhZGRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb3BpZWRTdHlsZSBBcnJheSBvZiBvYmplY3RzIHN0eWxlc1xuICAgICAqL1xuICAgIGluc2VydE5ld2xpbmVTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHF0eSwgY29waWVkU3R5bGUpIHtcbiAgICAgIHZhciBjdXJyZW50Q2hhclN0eWxlLFxuICAgICAgICAgIG5ld0xpbmVTdHlsZXMgPSB7fSxcbiAgICAgICAgICBzb21ldGhpbmdBZGRlZCA9IGZhbHNlLFxuICAgICAgICAgIGlzRW5kT2ZMaW5lID0gdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzW2xpbmVJbmRleF0ubGVuZ3RoID09PSBjaGFySW5kZXg7XG5cbiAgICAgIHF0eSB8fCAocXR5ID0gMSk7XG4gICAgICB0aGlzLnNoaWZ0TGluZVN0eWxlcyhsaW5lSW5kZXgsIHF0eSk7XG4gICAgICBpZiAodGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICBjdXJyZW50Q2hhclN0eWxlID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggPT09IDAgPyBjaGFySW5kZXggOiBjaGFySW5kZXggLSAxXTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIGNsb25lIHN0eWxlcyBvZiBhbGwgY2hhcnNcbiAgICAgIC8vIGFmdGVyIGN1cnNvciBvbnRvIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgIGZvciAodmFyIGluZGV4IGluIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgdmFyIG51bUluZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgaWYgKG51bUluZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIHNvbWV0aGluZ0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZXdMaW5lU3R5bGVzW251bUluZGV4IC0gY2hhckluZGV4XSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1baW5kZXhdO1xuICAgICAgICAgIC8vIHJlbW92ZSBsaW5lcyBmcm9tIHRoZSBwcmV2aW91cyBsaW5lIHNpbmNlIHRoZXkncmUgb24gYSBuZXcgbGluZSBub3dcbiAgICAgICAgICBpZiAoIShpc0VuZE9mTGluZSAmJiBjaGFySW5kZXggPT09IDApKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVDYXJyaWVkT3ZlciA9IGZhbHNlO1xuICAgICAgaWYgKHNvbWV0aGluZ0FkZGVkICYmICFpc0VuZE9mTGluZSkge1xuICAgICAgICAvLyBpZiBpcyBlbmQgb2YgbGluZSwgdGhlIGV4dHJhIHN0eWxlIHdlIGNvcGllZFxuICAgICAgICAvLyBpcyBwcm9iYWJseSBub3Qgc29tZXRoaW5nIHdlIHdhbnRcbiAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XSA9IG5ld0xpbmVTdHlsZXM7XG4gICAgICAgIHN0eWxlQ2FycmllZE92ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlQ2FycmllZE92ZXIpIHtcbiAgICAgICAgLy8gc2tpcCB0aGUgbGFzdCBsaW5lIG9mIHNpbmNlIHdlIGFscmVhZHkgcHJlcGFyZWQgaXQuXG4gICAgICAgIHF0eS0tO1xuICAgICAgfVxuICAgICAgLy8gZm9yIHRoZSBhbGwgdGhlIGxpbmVzIG9yIGFsbCB0aGUgb3RoZXIgbGluZXNcbiAgICAgIC8vIHdlIGNsb25lIGN1cnJlbnQgY2hhciBzdHlsZSBvbnRvIHRoZSBuZXh0IChvdGhlcndpc2UgZW1wdHkpIGxpbmVcbiAgICAgIHdoaWxlIChxdHkgPiAwKSB7XG4gICAgICAgIGlmIChjb3BpZWRTdHlsZSAmJiBjb3BpZWRTdHlsZVtxdHkgLSAxXSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSB7IDA6IGNsb25lKGNvcGllZFN0eWxlW3F0eSAtIDFdKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDaGFyU3R5bGUpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldID0geyAwOiBjbG9uZShjdXJyZW50Q2hhclN0eWxlKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldO1xuICAgICAgICB9XG4gICAgICAgIHF0eS0tO1xuICAgICAgfVxuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBzdHlsZSBvYmplY3QgZm9yIGEgZ2l2ZW4gbGluZS9jaGFyIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IEluZGV4IG9mIGEgY2hhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFudGl0eSBudW1iZXIgU3R5bGUgb2JqZWN0IHRvIGluc2VydCwgaWYgZ2l2ZW5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb3BpZWRTdHlsZSBhcnJheSBvZiBzdHlsZSBvYmplY3RzXG4gICAgICovXG4gICAgaW5zZXJ0Q2hhclN0eWxlT2JqZWN0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcXVhbnRpdHksIGNvcGllZFN0eWxlKSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudExpbmVTdHlsZXMgICAgICAgPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkID0gY3VycmVudExpbmVTdHlsZXMgPyBjbG9uZShjdXJyZW50TGluZVN0eWxlcykgOiB7fTtcblxuICAgICAgcXVhbnRpdHkgfHwgKHF1YW50aXR5ID0gMSk7XG4gICAgICAvLyBzaGlmdCBhbGwgY2hhciBzdHlsZXMgYnkgcXVhbnRpdHkgZm9yd2FyZFxuICAgICAgLy8gMCwxLDIsMyAtPiAoY2hhckluZGV4PTIpIC0+IDAsMSwzLDQgLT4gKGluc2VydCAyKSAtPiAwLDEsMiwzLDRcbiAgICAgIGZvciAodmFyIGluZGV4IGluIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkKSB7XG4gICAgICAgIHZhciBudW1lcmljSW5kZXggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0luZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzW251bWVyaWNJbmRleCArIHF1YW50aXR5XSA9IGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkW251bWVyaWNJbmRleF07XG4gICAgICAgICAgLy8gb25seSBkZWxldGUgdGhlIHN0eWxlIGlmIHRoZXJlIHdhcyBub3RoaW5nIG1vdmVkIHRoZXJlXG4gICAgICAgICAgaWYgKCFjdXJyZW50TGluZVN0eWxlc0Nsb25lZFtudW1lcmljSW5kZXggLSBxdWFudGl0eV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICAgIGlmIChjb3BpZWRTdHlsZSkge1xuICAgICAgICB3aGlsZSAocXVhbnRpdHktLSkge1xuICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoY29waWVkU3R5bGVbcXVhbnRpdHldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggKyBxdWFudGl0eV0gPSBjbG9uZShjb3BpZWRTdHlsZVtxdWFudGl0eV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudExpbmVTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1N0eWxlID0gY3VycmVudExpbmVTdHlsZXNbY2hhckluZGV4ID8gY2hhckluZGV4IC0gMSA6IDFdO1xuICAgICAgd2hpbGUgKG5ld1N0eWxlICYmIHF1YW50aXR5LS0pIHtcbiAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggKyBxdWFudGl0eV0gPSBjbG9uZShuZXdTdHlsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0KHMpXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5zZXJ0ZWRUZXh0IENoYXJhY3RlcnMgYXQgdGhlIGxvY2F0aW9uIHdoZXJlIHN0eWxlIGlzIGluc2VydGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGN1cnNvciBpbmRleCBmb3IgaW5zZXJ0aW5nIHN0eWxlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvcGllZFN0eWxlXSBhcnJheSBvZiBzdHlsZSBvYmplY3RzIHRvIGluc2VydC5cbiAgICAgKi9cbiAgICBpbnNlcnROZXdTdHlsZUJsb2NrOiBmdW5jdGlvbihpbnNlcnRlZFRleHQsIHN0YXJ0LCBjb3BpZWRTdHlsZSkge1xuICAgICAgdmFyIGN1cnNvckxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgYWRkZWRMaW5lcyA9IFswXSwgbGluZXNMZW5ndGggPSAwO1xuICAgICAgLy8gZ2V0IGFuIGFycmF5IG9mIGhvdyBtYW55IGNoYXIgcGVyIGxpbmVzIGFyZSBiZWluZyBhZGRlZC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zZXJ0ZWRUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnNlcnRlZFRleHRbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgbGluZXNMZW5ndGgrKztcbiAgICAgICAgICBhZGRlZExpbmVzW2xpbmVzTGVuZ3RoXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWRkZWRMaW5lc1tsaW5lc0xlbmd0aF0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZm9yIHRoZSBmaXJzdCBsaW5lIGNvcHkgdGhlIHN0eWxlIGZyb20gdGhlIGN1cnJlbnQgY2hhciBwb3NpdGlvbi5cbiAgICAgIGlmIChhZGRlZExpbmVzWzBdID4gMCkge1xuICAgICAgICB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChjdXJzb3JMb2MubGluZUluZGV4LCBjdXJzb3JMb2MuY2hhckluZGV4LCBhZGRlZExpbmVzWzBdLCBjb3BpZWRTdHlsZSk7XG4gICAgICAgIGNvcGllZFN0eWxlID0gY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGUuc2xpY2UoYWRkZWRMaW5lc1swXSArIDEpO1xuICAgICAgfVxuICAgICAgbGluZXNMZW5ndGggJiYgdGhpcy5pbnNlcnROZXdsaW5lU3R5bGVPYmplY3QoXG4gICAgICAgIGN1cnNvckxvYy5saW5lSW5kZXgsIGN1cnNvckxvYy5jaGFySW5kZXggKyBhZGRlZExpbmVzWzBdLCBsaW5lc0xlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpbmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFkZGVkTGluZXNbaV0gPiAwKSB7XG4gICAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QoY3Vyc29yTG9jLmxpbmVJbmRleCArIGksIDAsIGFkZGVkTGluZXNbaV0sIGNvcGllZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3BpZWRTdHlsZSkge1xuICAgICAgICAgIC8vIHRoaXMgdGVzdCBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBjbG9zZSAjNjg0MVxuICAgICAgICAgIC8vIHdoZW4gYSBwYXN0ZWQgYnVmZmVyIGJlZ2lucyB3aXRoIGEgbmV3bGluZSB0aGVuXG4gICAgICAgICAgLy8gdGhpcy5zdHlsZXNbY3Vyc29yTG9jLmxpbmVJbmRleCArIGldIGFuZCBjb3BpZWRTdHlsZVswXVxuICAgICAgICAgIC8vIG1heSBiZSB1bmRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gICAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2N1cnNvckxvYy5saW5lSW5kZXggKyBpXSAmJiBjb3BpZWRTdHlsZVswXSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXNbY3Vyc29yTG9jLmxpbmVJbmRleCArIGldWzBdID0gY29waWVkU3R5bGVbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvcGllZFN0eWxlID0gY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGUuc2xpY2UoYWRkZWRMaW5lc1tpXSArIDEpO1xuICAgICAgfVxuICAgICAgLy8gd2UgdXNlIGkgb3V0c2lkZSB0aGUgbG9vcCB0byBnZXQgaXQgbGlrZSBsaW5lc0xlbmd0aFxuICAgICAgaWYgKGFkZGVkTGluZXNbaV0gPiAwKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGN1cnNvckxvYy5saW5lSW5kZXggKyBpLCAwLCBhZGRlZExpbmVzW2ldLCBjb3BpZWRTdHlsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBhY2NvcmRpbmcgdG8gdGhlIG5ldyBwb3NpdGlvbiBvZiBjdXJzb3JcbiAgICAgKiBtaW1pYyB0aGUga2V5IC0gbW91c2UgbmF2aWdhdGlvbiB3aGVuIHNoaWZ0IGlzIHByZXNzZWQuXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3RhcnRFbmRXaXRoU2hpZnQ6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG5ld1NlbGVjdGlvbikge1xuICAgICAgaWYgKG5ld1NlbGVjdGlvbiA8PSBzdGFydCkge1xuICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobmV3U2VsZWN0aW9uID4gc3RhcnQgJiYgbmV3U2VsZWN0aW9uIDwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmV3U2VsZWN0aW9uIGlzID4gc2VsZWN0aW9uIHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRTZWxlY3Rpb25JbkJvdW5kYXJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+IGxlbmd0aCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA8IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA8IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLklUZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwiZGJjbGlja1wiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXREb3VibGVDbGlja1NpbXVsYXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gZm9yIGRvdWJsZSBjbGlja1xuICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICAvLyBmb3IgdHJpcGxlIGNsaWNrXG4gICAgdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICB0aGlzLl9fbGFzdFBvaW50ZXIgPSB7IH07XG5cbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBoYW5kbGVyIHRvIHNpbXVsYXRlIHRyaXBsZSBjbGlja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX19uZXdDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbmV3UG9pbnRlciA9IG9wdGlvbnMucG9pbnRlcjtcbiAgICBpZiAodGhpcy5pc1RyaXBsZUNsaWNrKG5ld1BvaW50ZXIpKSB7XG4gICAgICB0aGlzLmZpcmUoJ3RyaXBsZWNsaWNrJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9zdG9wRXZlbnQob3B0aW9ucy5lKTtcbiAgICB9XG4gICAgdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lID0gdGhpcy5fX2xhc3RDbGlja1RpbWU7XG4gICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgPSB0aGlzLl9fbmV3Q2xpY2tUaW1lO1xuICAgIHRoaXMuX19sYXN0UG9pbnRlciA9IG5ld1BvaW50ZXI7XG4gICAgdGhpcy5fX2xhc3RJc0VkaXRpbmcgPSB0aGlzLmlzRWRpdGluZztcbiAgICB0aGlzLl9fbGFzdFNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZDtcbiAgfSxcblxuICBpc1RyaXBsZUNsaWNrOiBmdW5jdGlvbihuZXdQb2ludGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX19uZXdDbGlja1RpbWUgLSB0aGlzLl9fbGFzdENsaWNrVGltZSA8IDUwMCAmJlxuICAgICAgICB0aGlzLl9fbGFzdENsaWNrVGltZSAtIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA8IDUwMCAmJlxuICAgICAgICB0aGlzLl9fbGFzdFBvaW50ZXIueCA9PT0gbmV3UG9pbnRlci54ICYmXG4gICAgICAgIHRoaXMuX19sYXN0UG9pbnRlci55ID09PSBuZXdQb2ludGVyLnk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RvcEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24gJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZXZlbnQgaGFuZGxlcnMgcmVsYXRlZCB0byBjdXJzb3Igb3Igc2VsZWN0aW9uXG4gICAqL1xuICBpbml0Q3Vyc29yU2VsZWN0aW9uSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5pdE1vdXNlZG93bkhhbmRsZXIoKTtcbiAgICB0aGlzLmluaXRNb3VzZXVwSGFuZGxlcigpO1xuICAgIHRoaXMuaW5pdENsaWNrcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGhhbmRsZXIgZm9yIGRvdWJsZSBjbGljaywgc2VsZWN0IGEgd29yZFxuICAgKi9cbiAgZG91YmxlQ2xpY2tIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdFdvcmQodGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGhhbmRsZXIgZm9yIHRyaXBsZSBjbGljaywgc2VsZWN0IGEgbGluZVxuICAgKi9cbiAgdHJpcGxlQ2xpY2tIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdExpbmUodGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBkb3VibGUgYW5kIHRyaXBsZSBjbGljayBldmVudCBoYW5kbGVyc1xuICAgKi9cbiAgaW5pdENsaWNrczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbignbW91c2VkYmxjbGljaycsIHRoaXMuZG91YmxlQ2xpY2tIYW5kbGVyKTtcbiAgICB0aGlzLm9uKCd0cmlwbGVjbGljaycsIHRoaXMudHJpcGxlQ2xpY2tIYW5kbGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBoYW5kbGVyIGZvciB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzIG5lZWRlZCBvbiBfbW91c2VEb3duXG4gICAqIGNhbiBiZSBvdmVycmlkZGVuIHRvIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQuXG4gICAqIFNjb3BlIG9mIHRoaXMgaW1wbGVtZW50YXRpb24gaXM6IGZpbmQgdGhlIGNsaWNrIHBvc2l0aW9uLCBzZXQgc2VsZWN0aW9uU3RhcnRcbiAgICogZmluZCBzZWxlY3Rpb25FbmQsIGluaXRpYWxpemUgdGhlIGRyYXdpbmcgb2YgZWl0aGVyIGN1cnNvciBvciBzZWxlY3Rpb24gYXJlYVxuICAgKiBpbml0aWFsaXppbmcgYSBtb3VzZWREb3duIG9uIGEgdGV4dCBhcmVhIHdpbGwgY2FuY2VsIGZhYnJpY2pzIGtub3dsZWRnZSBvZlxuICAgKiBjdXJyZW50IGNvbXBvc2l0aW9uTW9kZS4gSXQgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG4gICAqL1xuICBfbW91c2VEb3duSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYW52YXMgfHwgIXRoaXMuZWRpdGFibGUgfHwgKG9wdGlvbnMuZS5idXR0b24gJiYgb3B0aW9ucy5lLmJ1dHRvbiAhPT0gMSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9faXNNb3VzZWRvd24gPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0Q3Vyc29yQnlDbGljayhvcHRpb25zLmUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRWRpdGluZykge1xuICAgICAgdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24gPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllcyBuZWVkZWQgb24gbW91c2Vkb3duOmJlZm9yZVxuICAgKiBjYW4gYmUgb3ZlcnJpZGRlbiB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50LlxuICAgKiBTY29wZSBvZiB0aGlzIGltcGxlbWVudGF0aW9uIGlzOiB2ZXJpZnkgdGhlIG9iamVjdCBpcyBhbHJlYWR5IHNlbGVjdGVkIHdoZW4gbW91c2luZyBkb3duXG4gICAqL1xuICBfbW91c2VEb3duSGFuZGxlckJlZm9yZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYW52YXMgfHwgIXRoaXMuZWRpdGFibGUgfHwgKG9wdGlvbnMuZS5idXR0b24gJiYgb3B0aW9ucy5lLmJ1dHRvbiAhPT0gMSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gd2Ugd2FudCB0byBhdm9pZCB0aGF0IGFuIG9iamVjdCB0aGF0IHdhcyBzZWxlY3RlZCBhbmQgdGhlbiBiZWNvbWVzIHVuc2VsZWN0YWJsZSxcbiAgICAvLyBtYXkgdHJpZ2dlciBlZGl0aW5nIG1vZGUgaW4gc29tZSB3YXkuXG4gICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMgPT09IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwibW91c2Vkb3duXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdE1vdXNlZG93bkhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuX21vdXNlRG93bkhhbmRsZXIpO1xuICAgIHRoaXMub24oJ21vdXNlZG93bjpiZWZvcmUnLCB0aGlzLl9tb3VzZURvd25IYW5kbGVyQmVmb3JlKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgXCJtb3VzZXVwXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdE1vdXNldXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwSGFuZGxlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHN0YW5kYXJkIGhhbmRsZXIgZm9yIG1vdXNlIHVwLCBvdmVycmlkYWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbW91c2VVcEhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZWRpdGFibGUgfHwgdGhpcy5ncm91cCB8fFxuICAgICAgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9wdGlvbnMudHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCkgfHxcbiAgICAgIChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZSA9IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAoY3VycmVudEFjdGl2ZSAmJiBjdXJyZW50QWN0aXZlICE9PSB0aGlzKSB7XG4gICAgICAgIC8vIGF2b2lkIHJ1bm5pbmcgdGhpcyBsb2dpYyB3aGVuIHRoZXJlIGlzIGFuIGFjdGl2ZSBvYmplY3RcbiAgICAgICAgLy8gdGhpcyBiZWNhdXNlIGlzIHBvc3NpYmxlIHdpdGggc2hpZnQgY2xpY2sgYW5kIGZhc3QgY2xpY2tzLFxuICAgICAgICAvLyB0byByYXBpZGx5IGRlc2VsZWN0IGFuZCByZXNlbGVjdCB0aGlzIG9iamVjdCBhbmQgdHJpZ2dlciBhbiBlbnRlckVkaXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9fbGFzdFNlbGVjdGVkICYmICF0aGlzLl9fY29ybmVyKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fbGFzdFNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVudGVyRWRpdGluZyhvcHRpb25zLmUpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IodHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hhbmdlcyBjdXJzb3IgbG9jYXRpb24gaW4gYSB0ZXh0IGRlcGVuZGluZyBvbiBwYXNzZWQgcG9pbnRlciAoeC95KSBvYmplY3RcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHNldEN1cnNvckJ5Q2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKGUpLFxuICAgICAgICBzdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsIGVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHN0YXJ0LCBlbmQsIG5ld1NlbGVjdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBpbmRleCBvZiBhIGNoYXJhY3RlciBjb3JyZXNwb25kaW5nIHRvIHdoZXJlIGFuIG9iamVjdCB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAqL1xuICBnZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1vdXNlT2Zmc2V0ID0gdGhpcy5nZXRMb2NhbFBvaW50ZXIoZSksXG4gICAgICAgIHByZXZXaWR0aCA9IDAsXG4gICAgICAgIHdpZHRoID0gMCxcbiAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgY2hhckluZGV4ID0gMCxcbiAgICAgICAgbGluZUluZGV4ID0gMCxcbiAgICAgICAgbGluZUxlZnRPZmZzZXQsXG4gICAgICAgIGxpbmU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGhlaWdodCA8PSBtb3VzZU9mZnNldC55KSB7XG4gICAgICAgIGhlaWdodCArPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsaW5lSW5kZXggPSBpO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBjaGFySW5kZXggKz0gdGhpcy5fdGV4dExpbmVzW2kgLSAxXS5sZW5ndGggKyB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGkgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCk7XG4gICAgd2lkdGggPSBsaW5lTGVmdE9mZnNldCAqIHRoaXMuc2NhbGVYO1xuICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XTtcbiAgICAvLyBoYW5kbGluZyBvZiBSVEw6IGluIG9yZGVyIHRvIGdldCB0aGluZ3Mgd29yayBjb3JyZWN0bHksXG4gICAgLy8gd2UgYXNzdW1lIFJUTCB3cml0aW5nIGlzIG1pcnJvcmVkIGNvbXBhcmVkIHRvIExUUiB3cml0aW5nLlxuICAgIC8vIHNvIGluIHBvc2l0aW9uIGRldGVjdGlvbiB3ZSBtaXJyb3IgdGhlIFggb2Zmc2V0LCBhbmQgd2hlbiBpcyB0aW1lXG4gICAgLy8gb2YgcmVuZGVyaW5nIGl0LCB3ZSBtaXJyb3IgaXQgYWdhaW4uXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgbW91c2VPZmZzZXQueCA9IHRoaXMud2lkdGggKiB0aGlzLnNjYWxlWCAtIG1vdXNlT2Zmc2V0LnggKyB3aWR0aDtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgcHJldldpZHRoID0gd2lkdGg7XG4gICAgICAvLyBpIHJlbW92ZWQgc29tZXRoaW5nIGFib3V0IGZsaXBYIGhlcmUsIGNoZWNrLlxuICAgICAgd2lkdGggKz0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtqXS5rZXJuZWRXaWR0aCAqIHRoaXMuc2NhbGVYO1xuICAgICAgaWYgKHdpZHRoIDw9IG1vdXNlT2Zmc2V0LngpIHtcbiAgICAgICAgY2hhckluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXROZXdTZWxlY3Rpb25TdGFydEZyb21PZmZzZXQobW91c2VPZmZzZXQsIHByZXZXaWR0aCwgd2lkdGgsIGNoYXJJbmRleCwgamxlbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0OiBmdW5jdGlvbihtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgaW5kZXgsIGpsZW4pIHtcbiAgICAvLyB3ZSBuZWVkIE1hdGguYWJzIGJlY2F1c2Ugd2hlbiB3aWR0aCBpcyBhZnRlciB0aGUgbGFzdCBjaGFyLCB0aGUgb2Zmc2V0IGlzIGdpdmVuIGFzIDEsIHdoaWxlIGlzIDBcbiAgICB2YXIgZGlzdGFuY2VCdHdMYXN0Q2hhckFuZEN1cnNvciA9IG1vdXNlT2Zmc2V0LnggLSBwcmV2V2lkdGgsXG4gICAgICAgIGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPSB3aWR0aCAtIG1vdXNlT2Zmc2V0LngsXG4gICAgICAgIG9mZnNldCA9IGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPiBkaXN0YW5jZUJ0d0xhc3RDaGFyQW5kQ3Vyc29yIHx8XG4gICAgICAgICAgZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA8IDAgPyAwIDogMSxcbiAgICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSBpbmRleCArIG9mZnNldDtcbiAgICAvLyBpZiBvYmplY3QgaXMgaG9yaXpvbnRhbGx5IGZsaXBwZWQsIG1pcnJvciBjdXJzb3IgbG9jYXRpb24gZnJvbSB0aGUgZW5kXG4gICAgaWYgKHRoaXMuZmxpcFgpIHtcbiAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gamxlbiAtIG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA+IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuX3RleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdTZWxlY3Rpb25TdGFydDtcbiAgfVxufSk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBoaWRkZW4gdGV4dGFyZWEgKG5lZWRlZCB0byBicmluZyB1cCBrZXlib2FyZCBpbiBpT1MpXG4gICAqL1xuICBpbml0SGlkZGVuVGV4dGFyZWE6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jb3JyZWN0JywgJ29mZicpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY29tcGxldGUnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnZGF0YS1mYWJyaWMtaGlkZGVudGV4dGFyZWEnLCAnJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ3dyYXAnLCAnb2ZmJyk7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICAvLyBsaW5lLWhlaWdodDogMXB4OyB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBzdHlsZSB0byBmaXggdGhpczpcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04NzA5NjZcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyB0b3A6ICcgKyBzdHlsZS50b3AgK1xuICAgICc7IGxlZnQ6ICcgKyBzdHlsZS5sZWZ0ICsgJzsgei1pbmRleDogLTk5OTsgb3BhY2l0eTogMDsgd2lkdGg6IDFweDsgaGVpZ2h0OiAxcHg7IGZvbnQtc2l6ZTogMXB4OycgK1xuICAgICcgcGFkZGluZ++9sHRvcDogJyArIHN0eWxlLmZvbnRTaXplICsgJzsnO1xuXG4gICAgaWYgKHRoaXMuaGlkZGVuVGV4dGFyZWFDb250YWluZXIpIHtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWFDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5oaWRkZW5UZXh0YXJlYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5oaWRkZW5UZXh0YXJlYSk7XG4gICAgfVxuXG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAna2V5dXAnLCB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2lucHV0JywgdGhpcy5vbklucHV0LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb3B5JywgdGhpcy5jb3B5LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjdXQnLCB0aGlzLmNvcHkuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ3Bhc3RlJywgdGhpcy5wYXN0ZS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb25zdGFydCcsIHRoaXMub25Db21wb3NpdGlvblN0YXJ0LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbnVwZGF0ZScsIHRoaXMub25Db21wb3NpdGlvblVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb25lbmQnLCB0aGlzLm9uQ29tcG9zaXRpb25FbmQuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAoIXRoaXMuX2NsaWNrSGFuZGxlckluaXRpYWxpemVkICYmIHRoaXMuY2FudmFzKSB7XG4gICAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmNhbnZhcy51cHBlckNhbnZhc0VsLCAnY2xpY2snLCB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9jbGlja0hhbmRsZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZnVuY3Rpb25hbGl0aWVzIG9uIGtleURvd25cbiAgICogTWFwIGEgc3BlY2lhbCBrZXkgdG8gYSBmdW5jdGlvbiBvZiB0aGUgaW5zdGFuY2UvcHJvdG90eXBlXG4gICAqIElmIHlvdSBuZWVkIGRpZmZlcmVudCBiZWhhdmlvdXIgZm9yIEVTQyBvciBUQUIgb3IgYXJyb3dzLCB5b3UgaGF2ZSB0byBjaGFuZ2VcbiAgICogdGhpcyBtYXAgc2V0dGluZyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRoYXQgeW91IGJ1aWxkIG9uIHRoZSBmYWJyaWMuSXRleHQgb3JcbiAgICogeW91ciBwcm90b3R5cGUuXG4gICAqIHRoZSBtYXAgY2hhbmdlIHdpbGwgYWZmZWN0IGFsbCBJbnN0YW5jZXMgdW5sZXNzIHlvdSBuZWVkIGZvciBvbmx5IHNvbWUgdGV4dCBJbnN0YW5jZXNcbiAgICogaW4gdGhhdCBjYXNlIHlvdSBoYXZlIHRvIGNsb25lIHRoaXMgb2JqZWN0IGFuZCBhc3NpZ24geW91ciBJbnN0YW5jZS5cbiAgICogdGhpcy5rZXlzTWFwID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHRoaXMua2V5c01hcCk7XG4gICAqIFRoZSBmdW5jdGlvbiBtdXN0IGJlIGluIGZhYnJpYy5JdGV4dC5wcm90b3R5cGUubXlGdW5jdGlvbiBBbmQgd2lsbCByZWNlaXZlIGV2ZW50IGFzIGFyZ3NbMF1cbiAgICovXG4gIGtleXNNYXA6IHtcbiAgICA5OiAgJ2V4aXRFZGl0aW5nJyxcbiAgICAyNzogJ2V4aXRFZGl0aW5nJyxcbiAgICAzMzogJ21vdmVDdXJzb3JVcCcsXG4gICAgMzQ6ICdtb3ZlQ3Vyc29yRG93bicsXG4gICAgMzU6ICdtb3ZlQ3Vyc29yUmlnaHQnLFxuICAgIDM2OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDM3OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDM4OiAnbW92ZUN1cnNvclVwJyxcbiAgICAzOTogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgNDA6ICdtb3ZlQ3Vyc29yRG93bicsXG4gIH0sXG5cbiAga2V5c01hcFJ0bDoge1xuICAgIDk6ICAnZXhpdEVkaXRpbmcnLFxuICAgIDI3OiAnZXhpdEVkaXRpbmcnLFxuICAgIDMzOiAnbW92ZUN1cnNvclVwJyxcbiAgICAzNDogJ21vdmVDdXJzb3JEb3duJyxcbiAgICAzNTogJ21vdmVDdXJzb3JMZWZ0JyxcbiAgICAzNjogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgMzc6ICdtb3ZlQ3Vyc29yUmlnaHQnLFxuICAgIDM4OiAnbW92ZUN1cnNvclVwJyxcbiAgICAzOTogJ21vdmVDdXJzb3JMZWZ0JyxcbiAgICA0MDogJ21vdmVDdXJzb3JEb3duJyxcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGZ1bmN0aW9uYWxpdGllcyBvbiBrZXlVcCArIGN0cmwgfHwgY21kXG4gICAqL1xuICBjdHJsS2V5c01hcFVwOiB7XG4gICAgNjc6ICdjb3B5JyxcbiAgICA4ODogJ2N1dCdcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGZ1bmN0aW9uYWxpdGllcyBvbiBrZXlEb3duICsgY3RybCB8fCBjbWRcbiAgICovXG4gIGN0cmxLZXlzTWFwRG93bjoge1xuICAgIDY1OiAnc2VsZWN0QWxsJ1xuICB9LFxuXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE5vIG5lZWQgdG8gdHJpZ2dlciBjbGljayBldmVudCBoZXJlLCBmb2N1cyBpcyBlbm91Z2ggdG8gaGF2ZSB0aGUga2V5Ym9hcmQgYXBwZWFyIG9uIEFuZHJvaWRcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhICYmIHRoaXMuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBrZXlkb3duIGV2ZW50XG4gICAqIG9ubHkgdXNlZCBmb3IgYXJyb3dzIGFuZCBjb21iaW5hdGlvbiBvZiBtb2RpZmllciBrZXlzLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25LZXlEb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIga2V5TWFwID0gdGhpcy5kaXJlY3Rpb24gPT09ICdydGwnID8gdGhpcy5rZXlzTWFwUnRsIDogdGhpcy5rZXlzTWFwO1xuICAgIGlmIChlLmtleUNvZGUgaW4ga2V5TWFwKSB7XG4gICAgICB0aGlzW2tleU1hcFtlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGUua2V5Q29kZSBpbiB0aGlzLmN0cmxLZXlzTWFwRG93bikgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICB0aGlzW3RoaXMuY3RybEtleXNNYXBEb3duW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGUua2V5Q29kZSA+PSAzMyAmJiBlLmtleUNvZGUgPD0gNDApIHtcbiAgICAgIC8vIGlmIGkgcHJlc3MgYW4gYXJyb3cga2V5IGp1c3QgdXBkYXRlIHNlbGVjdGlvblxuICAgICAgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleXVwIGV2ZW50XG4gICAqIFdlIGhhbmRsZSBLZXlVcCBiZWNhdXNlIGllMTEgYW5kIGVkZ2UgaGF2ZSBkaWZmaWN1bHRpZXMgY29weS9wYXN0aW5nXG4gICAqIGlmIGEgY29weS9jdXQgZXZlbnQgZmlyZWQsIGtleXVwIGlzIGRpc21pc3NlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25LZXlVcDogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgdGhpcy5fY29weURvbmUgfHwgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgdGhpcy5fY29weURvbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChlLmtleUNvZGUgaW4gdGhpcy5jdHJsS2V5c01hcFVwKSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkpIHtcbiAgICAgIHRoaXNbdGhpcy5jdHJsS2V5c01hcFVwW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG9uSW5wdXQgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uSW5wdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZnJvbVBhc3RlID0gdGhpcy5mcm9tUGFzdGU7XG4gICAgdGhpcy5mcm9tUGFzdGUgPSBmYWxzZTtcbiAgICBlICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBkZWNpc2lvbnMgYWJvdXQgc3R5bGUgY2hhbmdlcy5cbiAgICB2YXIgbmV4dFRleHQgPSB0aGlzLl9zcGxpdFRleHRJbnRvTGluZXModGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSkuZ3JhcGhlbWVUZXh0LFxuICAgICAgICBjaGFyQ291bnQgPSB0aGlzLl90ZXh0Lmxlbmd0aCxcbiAgICAgICAgbmV4dENoYXJDb3VudCA9IG5leHRUZXh0Lmxlbmd0aCxcbiAgICAgICAgcmVtb3ZlZFRleHQsIGluc2VydGVkVGV4dCxcbiAgICAgICAgY2hhckRpZmYgPSBuZXh0Q2hhckNvdW50IC0gY2hhckNvdW50LFxuICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kLFxuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kLFxuICAgICAgICBjb3BpZWRTdHlsZSwgcmVtb3ZlRnJvbSwgcmVtb3ZlVG87XG4gICAgaWYgKHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUgPT09ICcnKSB7XG4gICAgICB0aGlzLnN0eWxlcyA9IHsgfTtcbiAgICAgIHRoaXMudXBkYXRlRnJvbVRleHRBcmVhKCk7XG4gICAgICB0aGlzLmZpcmUoJ2NoYW5nZWQnKTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0YXJlYVNlbGVjdGlvbiA9IHRoaXMuZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24oXG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQsXG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlXG4gICAgKTtcbiAgICB2YXIgYmFja0RlbGV0ZSA9IHNlbGVjdGlvblN0YXJ0ID4gdGV4dGFyZWFTZWxlY3Rpb24uc2VsZWN0aW9uU3RhcnQ7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICBjaGFyRGlmZiArPSBzZWxlY3Rpb25FbmQgLSBzZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV4dENoYXJDb3VudCA8IGNoYXJDb3VudCkge1xuICAgICAgaWYgKGJhY2tEZWxldGUpIHtcbiAgICAgICAgcmVtb3ZlZFRleHQgPSB0aGlzLl90ZXh0LnNsaWNlKHNlbGVjdGlvbkVuZCArIGNoYXJEaWZmLCBzZWxlY3Rpb25FbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uU3RhcnQgLSBjaGFyRGlmZik7XG4gICAgICB9XG4gICAgfVxuICAgIGluc2VydGVkVGV4dCA9IG5leHRUZXh0LnNsaWNlKHRleHRhcmVhU2VsZWN0aW9uLnNlbGVjdGlvbkVuZCAtIGNoYXJEaWZmLCB0ZXh0YXJlYVNlbGVjdGlvbi5zZWxlY3Rpb25FbmQpO1xuICAgIGlmIChyZW1vdmVkVGV4dCAmJiByZW1vdmVkVGV4dC5sZW5ndGgpIHtcbiAgICAgIGlmIChpbnNlcnRlZFRleHQubGVuZ3RoKSB7XG4gICAgICAgIC8vIGxldCdzIGNvcHkgc29tZSBzdHlsZSBiZWZvcmUgZGVsZXRpbmcuXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gY29weSB0aGUgc3R5bGUgYmVmb3JlIHRoZSBjdXJzb3IgT1IgdGhlIHN0eWxlIGF0IHRoZSBjdXJzb3IgaWYgc2VsZWN0aW9uXG4gICAgICAgIC8vIGlzIGJpZ2dlciB0aGFuIDAuXG4gICAgICAgIGNvcGllZFN0eWxlID0gdGhpcy5nZXRTZWxlY3Rpb25TdHlsZXMoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvblN0YXJ0ICsgMSwgZmFsc2UpO1xuICAgICAgICAvLyBub3cgZHVwbGljYXRlIHRoZSBzdHlsZSBvbmUgZm9yIGVhY2ggaW5zZXJ0ZWQgdGV4dC5cbiAgICAgICAgY29waWVkU3R5bGUgPSBpbnNlcnRlZFRleHQubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHRoaXMgcmV0dXJuIGFuIGFycmF5IG9mIHJlZmVyZW5jZXMsIGJ1dCB0aGF0IGlzIGZpbmUgc2luY2Ugd2UgYXJlXG4gICAgICAgICAgLy8gY29weWluZyB0aGUgc3R5bGUgbGF0ZXIuXG4gICAgICAgICAgcmV0dXJuIGNvcGllZFN0eWxlWzBdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVtb3ZlRnJvbSA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICByZW1vdmVUbyA9IHNlbGVjdGlvbkVuZDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJhY2tEZWxldGUpIHtcbiAgICAgICAgLy8gZGV0ZWN0IGRpZmZlcmVuY2VzIGJldHdlZW4gZm9yd2FyZERlbGV0ZSBhbmQgYmFja0RlbGV0ZVxuICAgICAgICByZW1vdmVGcm9tID0gc2VsZWN0aW9uRW5kIC0gcmVtb3ZlZFRleHQubGVuZ3RoO1xuICAgICAgICByZW1vdmVUbyA9IHNlbGVjdGlvbkVuZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVGcm9tID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICByZW1vdmVUbyA9IHNlbGVjdGlvbkVuZCArIHJlbW92ZWRUZXh0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8ocmVtb3ZlRnJvbSwgcmVtb3ZlVG8pO1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgaWYgKGZyb21QYXN0ZSAmJiBpbnNlcnRlZFRleHQuam9pbignJykgPT09IGZhYnJpYy5jb3BpZWRUZXh0ICYmICFmYWJyaWMuZGlzYWJsZVN0eWxlQ29weVBhc3RlKSB7XG4gICAgICAgIGNvcGllZFN0eWxlID0gZmFicmljLmNvcGllZFRleHRTdHlsZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zZXJ0TmV3U3R5bGVCbG9jayhpbnNlcnRlZFRleHQsIHNlbGVjdGlvblN0YXJ0LCBjb3BpZWRTdHlsZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRnJvbVRleHRBcmVhKCk7XG4gICAgdGhpcy5maXJlKCdjaGFuZ2VkJyk7XG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDb21wb3NpdGlvbiBzdGFydFxuICAgKi9cbiAgb25Db21wb3NpdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ29tcG9zaXRpb24gZW5kXG4gICAqL1xuICBvbkNvbXBvc2l0aW9uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gIH0sXG5cbiAgLy8gLyoqXG4gIC8vICAqIENvbXBvc2l0aW9uIHVwZGF0ZVxuICAvLyAgKi9cbiAgb25Db21wb3NpdGlvblVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuY29tcG9zaXRpb25TdGFydCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0O1xuICAgIHRoaXMuY29tcG9zaXRpb25FbmQgPSBlLnRhcmdldC5zZWxlY3Rpb25FbmQ7XG4gICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcGllcyBzZWxlY3RlZCB0ZXh0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIC8vZG8gbm90IGN1dC1jb3B5IGlmIG5vIHNlbGVjdGlvblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy5jb3BpZWRUZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKTtcbiAgICBpZiAoIWZhYnJpYy5kaXNhYmxlU3R5bGVDb3B5UGFzdGUpIHtcbiAgICAgIGZhYnJpYy5jb3BpZWRUZXh0U3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlcyh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLmNvcGllZFRleHRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2NvcHlEb25lID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUGFzdGVzIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHBhc3RlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZyb21QYXN0ZSA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH0gQ2xpcGJvYXJkIGRhdGEgb2JqZWN0XG4gICAqL1xuICBfZ2V0Q2xpcGJvYXJkRGF0YTogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoZSAmJiBlLmNsaXBib2FyZERhdGEpIHx8IGZhYnJpYy53aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIHdpZHRoIGluIHBpeGVscyBiZWZvcmUgdGhlIGN1cnNvciBvbiB0aGUgc2FtZSBsaW5lXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoQmVmb3JlQ3Vyc29yIHdpZHRoIGJlZm9yZSBjdXJzb3JcbiAgICovXG4gIF9nZXRXaWR0aEJlZm9yZUN1cnNvcjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpLCBib3VuZDtcblxuICAgIGlmIChjaGFySW5kZXggPiAwKSB7XG4gICAgICBib3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV07XG4gICAgICB3aWR0aEJlZm9yZUN1cnNvciArPSBib3VuZC5sZWZ0ICsgYm91bmQud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aEJlZm9yZUN1cnNvcjtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBzdGFydCBvZmZzZXQgb2YgYSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldERvd25DdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICAvLyBpZiBvbiBsYXN0IGxpbmUsIGRvd24gY3Vyc29yIGdvZXMgdG8gZW5kIG9mIGxpbmVcbiAgICBpZiAobGluZUluZGV4ID09PSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoIC0gMSB8fCBlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzNCkge1xuICAgICAgLy8gbW92ZSB0byB0aGUgZW5kIG9mIGEgdGV4dFxuICAgICAgcmV0dXJuIHRoaXMuX3RleHQubGVuZ3RoIC0gc2VsZWN0aW9uUHJvcDtcbiAgICB9XG4gICAgdmFyIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRXaWR0aEJlZm9yZUN1cnNvcihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgIGluZGV4T25PdGhlckxpbmUgPSB0aGlzLl9nZXRJbmRleE9uTGluZShsaW5lSW5kZXggKyAxLCB3aWR0aEJlZm9yZUN1cnNvciksXG4gICAgICAgIHRleHRBZnRlckN1cnNvciA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLnNsaWNlKGNoYXJJbmRleCk7XG4gICAgcmV0dXJuIHRleHRBZnRlckN1cnNvci5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lICsgMSArIHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQobGluZUluZGV4KTtcbiAgfSxcblxuICAvKipcbiAgICogcHJpdmF0ZVxuICAgKiBIZWxwcyBmaW5kaW5nIGlmIHRoZSBvZmZzZXQgc2hvdWxkIGJlIGNvdW50ZWQgZnJvbSBTdGFydCBvciBFbmRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIF9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCAmJiBpc1JpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VXBDdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICBpZiAobGluZUluZGV4ID09PSAwIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDMzKSB7XG4gICAgICAvLyBpZiBvbiBmaXJzdCBsaW5lLCB1cCBjdXJzb3IgZ29lcyB0byBzdGFydCBvZiBsaW5lXG4gICAgICByZXR1cm4gLXNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4IC0gMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QmVmb3JlQ3Vyc29yID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0uc2xpY2UoMCwgY2hhckluZGV4KSxcbiAgICAgICAgbWlzc2luZ05ld2xpbmVPZmZzZXQgPSB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGxpbmVJbmRleCAtIDEpO1xuICAgIC8vIHJldHVybiBhIG5lZ2F0aXZlIG9mZnNldFxuICAgIHJldHVybiAtdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleCAtIDFdLmxlbmd0aFxuICAgICArIGluZGV4T25PdGhlckxpbmUgLSB0ZXh0QmVmb3JlQ3Vyc29yLmxlbmd0aCArICgxIC0gbWlzc2luZ05ld2xpbmVPZmZzZXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmb3IgYSBnaXZlbiB3aWR0aCBpdCBmb3VuZHMgdGhlIG1hdGNoaW5nIGNoYXJhY3Rlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRJbmRleE9uTGluZTogZnVuY3Rpb24obGluZUluZGV4LCB3aWR0aCkge1xuXG4gICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpLFxuICAgICAgICB3aWR0aE9mQ2hhcnNPbkxpbmUgPSBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgaW5kZXhPbkxpbmUgPSAwLCBjaGFyV2lkdGgsIGZvdW5kTWF0Y2g7XG5cbiAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICBjaGFyV2lkdGggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2pdLndpZHRoO1xuICAgICAgd2lkdGhPZkNoYXJzT25MaW5lICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmICh3aWR0aE9mQ2hhcnNPbkxpbmUgPiB3aWR0aCkge1xuICAgICAgICBmb3VuZE1hdGNoID0gdHJ1ZTtcbiAgICAgICAgdmFyIGxlZnRFZGdlID0gd2lkdGhPZkNoYXJzT25MaW5lIC0gY2hhcldpZHRoLFxuICAgICAgICAgICAgcmlnaHRFZGdlID0gd2lkdGhPZkNoYXJzT25MaW5lLFxuICAgICAgICAgICAgb2Zmc2V0RnJvbUxlZnRFZGdlID0gTWF0aC5hYnMobGVmdEVkZ2UgLSB3aWR0aCksXG4gICAgICAgICAgICBvZmZzZXRGcm9tUmlnaHRFZGdlID0gTWF0aC5hYnMocmlnaHRFZGdlIC0gd2lkdGgpO1xuXG4gICAgICAgIGluZGV4T25MaW5lID0gb2Zmc2V0RnJvbVJpZ2h0RWRnZSA8IG9mZnNldEZyb21MZWZ0RWRnZSA/IGogOiAoaiAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWFjaGVkIGVuZFxuICAgIGlmICghZm91bmRNYXRjaCkge1xuICAgICAgaW5kZXhPbkxpbmUgPSBsaW5lLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4T25MaW5lO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBkb3duXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yRG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID49IHRoaXMuX3RleHQubGVuZ3RoICYmIHRoaXMuc2VsZWN0aW9uRW5kID49IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JVcE9yRG93bignRG93bicsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXBcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JVcDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRoaXMuc2VsZWN0aW9uRW5kID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JVcE9yRG93bignVXAnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwIG9yIGRvd24sIGZpcmVzIHRoZSBldmVudHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAnVXAnIG9yICdEb3duJ1xuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX21vdmVDdXJzb3JVcE9yRG93bjogZnVuY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgLy8gZ2V0VXBDdXJzb3JPZmZzZXRcbiAgICAvLyBnZXREb3duQ3Vyc29yT2Zmc2V0XG4gICAgdmFyIGFjdGlvbiA9ICdnZXQnICsgZGlyZWN0aW9uICsgJ0N1cnNvck9mZnNldCcsXG4gICAgICAgIG9mZnNldCA9IHRoaXNbYWN0aW9uXShlLCB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcpO1xuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLm1vdmVDdXJzb3JXaXRoU2hpZnQob2Zmc2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLm1vdmVDdXJzb3JXaXRob3V0U2hpZnQob2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25JbkJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcbiAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHdpdGggc2hpZnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgbW92ZUN1cnNvcldpdGhTaGlmdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnXG4gICAgICA/IHRoaXMuc2VsZWN0aW9uU3RhcnQgKyBvZmZzZXRcbiAgICAgIDogdGhpcy5zZWxlY3Rpb25FbmQgKyBvZmZzZXQ7XG4gICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdCh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgbmV3U2VsZWN0aW9uKTtcbiAgICByZXR1cm4gb2Zmc2V0ICE9PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXAgd2l0aG91dCBzaGlmdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBtb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCArPSBvZmZzZXQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICE9PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQoJ0xlZnQnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBhIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgX21vdmU6IGZ1bmN0aW9uKGUsIHByb3AsIGRpcmVjdGlvbikge1xuICAgIHZhciBuZXdWYWx1ZTtcbiAgICBpZiAoZS5hbHRLZXkpIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpc1snZmluZFdvcmRCb3VuZGFyeScgKyBkaXJlY3Rpb25dKHRoaXNbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzNSB8fCAgZS5rZXlDb2RlID09PSAzNiApIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpc1snZmluZExpbmVCb3VuZGFyeScgKyBkaXJlY3Rpb25dKHRoaXNbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcF0gKz0gZGlyZWN0aW9uID09PSAnTGVmdCcgPyAtMSA6IDE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXNbcHJvcF0gIT09IG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzW3Byb3BdID0gbmV3VmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZUxlZnQ6IGZ1bmN0aW9uKGUsIHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZShlLCBwcm9wLCAnTGVmdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVSaWdodDogZnVuY3Rpb24oZSwgcHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlKGUsIHByb3AsICdSaWdodCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdCB3aXRob3V0IGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0V2l0aG91dFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNoYW5nZSA9IHRydWU7XG4gICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuXG4gICAgLy8gb25seSBtb3ZlIGN1cnNvciB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdGlvbixcbiAgICAvLyBvdGhlcndpc2Ugd2UgZGlzY2FyZCBpdCwgYW5kIGxlYXZlIGN1cnNvciBvbiBzYW1lIHBsYWNlXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uRW5kID09PSB0aGlzLnNlbGVjdGlvblN0YXJ0ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDApIHtcbiAgICAgIGNoYW5nZSA9IHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuXG4gICAgfVxuICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdCB3aGlsZSBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdFdpdGhTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uRW5kJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDApe1xuICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQoJ1JpZ2h0JywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodCBvciBMZWZ0LCBmaXJlcyBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uICdMZWZ0JywgJ1JpZ2h0J1xuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX21vdmVDdXJzb3JMZWZ0T3JSaWdodDogZnVuY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgdmFyIGFjdGlvbk5hbWUgPSAnbW92ZUN1cnNvcicgKyBkaXJlY3Rpb24gKyAnV2l0aCc7XG4gICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuXG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIGFjdGlvbk5hbWUgKz0gJ1NoaWZ0JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhY3Rpb25OYW1lICs9ICdvdXRTaGlmdCc7XG4gICAgfVxuICAgIGlmICh0aGlzW2FjdGlvbk5hbWVdKGUpKSB7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodCB3aGlsZSBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHRXaXRoU2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCcgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uRW5kICE9PSB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvbkVuZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IHdpdGhvdXQga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodFdpdGhvdXRTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICBjaGFuZ2VkID0gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY2hhcmFjdGVycyBmcm9tIHN0YXJ0L2VuZFxuICAgKiBzdGFydC9lbmQgYXIgcGVyIGdyYXBoZW1lIHBvc2l0aW9uIGluIF90ZXh0IGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBkZWZhdWx0IHRvIHN0YXJ0ICsgMVxuICAgKi9cbiAgcmVtb3ZlQ2hhcnM6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IHN0YXJ0ICsgMTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVTdHlsZUZyb21UbyhzdGFydCwgZW5kKTtcbiAgICB0aGlzLl90ZXh0LnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgIHRoaXMudGV4dCA9IHRoaXMuX3RleHQuam9pbignJyk7XG4gICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlRXh0cmFuZW91c1N0eWxlcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBpbnNlcnQgY2hhcmFjdGVycyBhdCBzdGFydCBwb3NpdGlvbiwgYmVmb3JlIHN0YXJ0IHBvc2l0aW9uLlxuICAgKiBzdGFydCAgZXF1YWwgMSBpdCBtZWFucyB0aGUgdGV4dCBnZXQgaW5zZXJ0ZWQgYmV0d2VlbiBhY3R1YWwgZ3JhcGhlbWUgMCBhbmQgMVxuICAgKiBpZiBzdHlsZSBhcnJheSBpcyBwcm92aWRlZCwgaXQgbXVzdCBiZSBhcyB0aGUgc2FtZSBsZW5ndGggb2YgdGV4dCBpbiBncmFwaGVtZXNcbiAgICogaWYgZW5kIGlzIHByb3ZpZGVkIGFuZCBpcyBiaWdnZXIgdGhhbiBzdGFydCwgb2xkIHRleHQgaXMgcmVwbGFjZWQuXG4gICAqIHN0YXJ0L2VuZCBhciBwZXIgZ3JhcGhlbWUgcG9zaXRpb24gaW4gX3RleHQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRleHQgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlIGFycmF5IG9mIHN0eWxlIG9iamVjdHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgZGVmYXVsdCB0byBzdGFydCArIDFcbiAgICovXG4gIGluc2VydENoYXJzOiBmdW5jdGlvbih0ZXh0LCBzdHlsZSwgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgdGhpcy5yZW1vdmVTdHlsZUZyb21UbyhzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgdmFyIGdyYXBoZW1lcyA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KHRleHQpO1xuICAgIHRoaXMuaW5zZXJ0TmV3U3R5bGVCbG9jayhncmFwaGVtZXMsIHN0YXJ0LCBzdHlsZSk7XG4gICAgdGhpcy5fdGV4dCA9IFtdLmNvbmNhdCh0aGlzLl90ZXh0LnNsaWNlKDAsIHN0YXJ0KSwgZ3JhcGhlbWVzLCB0aGlzLl90ZXh0LnNsaWNlKGVuZCkpO1xuICAgIHRoaXMudGV4dCA9IHRoaXMuX3RleHQuam9pbignJyk7XG4gICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlRXh0cmFuZW91c1N0eWxlcygpO1xuICB9LFxuXG59KTtcblxuXG4vKiBfVE9fU1ZHX1NUQVJUXyAqL1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBtdWx0aXBsZVNwYWNlc1JlZ2V4ID0gLyAgKy9nO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5UZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9mZnNldHMgPSB0aGlzLl9nZXRTVkdMZWZ0VG9wT2Zmc2V0cygpLFxuICAgICAgICAgIHRleHRBbmRCZyA9IHRoaXMuX2dldFNWR1RleHRBbmRCZyhvZmZzZXRzLnRleHRUb3AsIG9mZnNldHMudGV4dExlZnQpO1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBTVkdUZXh0QW5kQmcodGV4dEFuZEJnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKFxuICAgICAgICB0aGlzLl90b1NWRygpLFxuICAgICAgICB7IHJldml2ZXI6IHJldml2ZXIsIG5vU3R5bGU6IHRydWUsIHdpdGhTaGFkb3c6IHRydWUgfVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U1ZHTGVmdFRvcE9mZnNldHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dExlZnQ6IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgdGV4dFRvcDogLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgbGluZVRvcDogdGhpcy5nZXRIZWlnaHRPZkxpbmUoMClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3dyYXBTVkdUZXh0QW5kQmc6IGZ1bmN0aW9uKHRleHRBbmRCZykge1xuICAgICAgdmFyIG5vU2hhZG93ID0gdHJ1ZSxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0U3ZnVGV4dERlY29yYXRpb24odGhpcyk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0ZXh0QW5kQmcudGV4dEJnUmVjdHMuam9pbignJyksXG4gICAgICAgICdcXHRcXHQ8dGV4dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiICcsXG4gICAgICAgICh0aGlzLmZvbnRGYW1pbHkgPyAnZm9udC1mYW1pbHk9XCInICsgdGhpcy5mb250RmFtaWx5LnJlcGxhY2UoL1wiL2csICdcXCcnKSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U2l6ZSA/ICdmb250LXNpemU9XCInICsgdGhpcy5mb250U2l6ZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U3R5bGUgPyAnZm9udC1zdHlsZT1cIicgKyB0aGlzLmZvbnRTdHlsZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250V2VpZ2h0ID8gJ2ZvbnQtd2VpZ2h0PVwiJyArIHRoaXMuZm9udFdlaWdodCArICdcIiAnIDogJycpLFxuICAgICAgICAodGV4dERlY29yYXRpb24gPyAndGV4dC1kZWNvcmF0aW9uPVwiJyArIHRleHREZWNvcmF0aW9uICsgJ1wiICcgOiAnJyksXG4gICAgICAgICdzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKG5vU2hhZG93KSwgJ1wiJywgdGhpcy5hZGRQYWludE9yZGVyKCksICcgPicsXG4gICAgICAgIHRleHRBbmRCZy50ZXh0U3BhbnMuam9pbignJyksXG4gICAgICAgICc8L3RleHQ+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGV4dFRvcE9mZnNldCBUZXh0IHRvcCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGV4dExlZnRPZmZzZXQgVGV4dCBsZWZ0IG9mZnNldFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBfZ2V0U1ZHVGV4dEFuZEJnOiBmdW5jdGlvbih0ZXh0VG9wT2Zmc2V0LCB0ZXh0TGVmdE9mZnNldCkge1xuICAgICAgdmFyIHRleHRTcGFucyA9IFtdLFxuICAgICAgICAgIHRleHRCZ1JlY3RzID0gW10sXG4gICAgICAgICAgaGVpZ2h0ID0gdGV4dFRvcE9mZnNldCwgbGluZU9mZnNldDtcbiAgICAgIC8vIGJvdW5kaW5nLWJveCBiYWNrZ3JvdW5kXG4gICAgICB0aGlzLl9zZXRTVkdCZyh0ZXh0QmdSZWN0cyk7XG5cbiAgICAgIC8vIHRleHQgYW5kIHRleHQtYmFja2dyb3VuZFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lT2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGlmICh0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy5zdHlsZUhhcygndGV4dEJhY2tncm91bmRDb2xvcicsIGkpKSB7XG4gICAgICAgICAgdGhpcy5fc2V0U1ZHVGV4dExpbmVCZyh0ZXh0QmdSZWN0cywgaSwgdGV4dExlZnRPZmZzZXQgKyBsaW5lT2Zmc2V0LCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFNWR1RleHRMaW5lVGV4dCh0ZXh0U3BhbnMsIGksIHRleHRMZWZ0T2Zmc2V0ICsgbGluZU9mZnNldCwgaGVpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0U3BhbnM6IHRleHRTcGFucyxcbiAgICAgICAgdGV4dEJnUmVjdHM6IHRleHRCZ1JlY3RzXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVUZXh0Q2hhclNwYW46IGZ1bmN0aW9uKF9jaGFyLCBzdHlsZURlY2wsIGxlZnQsIHRvcCkge1xuICAgICAgdmFyIHNob3VsZFVzZVdoaXRlc3BhY2UgPSBfY2hhciAhPT0gX2NoYXIudHJpbSgpIHx8IF9jaGFyLm1hdGNoKG11bHRpcGxlU3BhY2VzUmVnZXgpLFxuICAgICAgICAgIHN0eWxlUHJvcHMgPSB0aGlzLmdldFN2Z1NwYW5TdHlsZXMoc3R5bGVEZWNsLCBzaG91bGRVc2VXaGl0ZXNwYWNlKSxcbiAgICAgICAgICBmaWxsU3R5bGVzID0gc3R5bGVQcm9wcyA/ICdzdHlsZT1cIicgKyBzdHlsZVByb3BzICsgJ1wiJyA6ICcnLFxuICAgICAgICAgIGR5ID0gc3R5bGVEZWNsLmRlbHRhWSwgZHlTcGFuID0gJycsXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgIGlmIChkeSkge1xuICAgICAgICBkeVNwYW4gPSAnIGR5PVwiJyArIHRvRml4ZWQoZHksIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiICc7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPHRzcGFuIHg9XCInLCB0b0ZpeGVkKGxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgeT1cIicsXG4gICAgICAgIHRvRml4ZWQodG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJ1wiICcsIGR5U3BhbixcbiAgICAgICAgZmlsbFN0eWxlcywgJz4nLFxuICAgICAgICBmYWJyaWMudXRpbC5zdHJpbmcuZXNjYXBlWG1sKF9jaGFyKSxcbiAgICAgICAgJzwvdHNwYW4+J1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgX3NldFNWR1RleHRMaW5lVGV4dDogZnVuY3Rpb24odGV4dFNwYW5zLCBsaW5lSW5kZXgsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSB7XG4gICAgICAvLyBzZXQgcHJvcGVyIGxpbmUgb2Zmc2V0XG4gICAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGxpbmVJbmRleCksXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBhY3R1YWxTdHlsZSxcbiAgICAgICAgICBuZXh0U3R5bGUsXG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnLFxuICAgICAgICAgIGNoYXJCb3gsIHN0eWxlLFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sXG4gICAgICAgICAgdGltZVRvUmVuZGVyO1xuXG4gICAgICB0ZXh0VG9wT2Zmc2V0ICs9IGxpbmVIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmUubGVuZ3RoIC0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICB0aW1lVG9SZW5kZXIgPSBpID09PSBsZW4gfHwgdGhpcy5jaGFyU3BhY2luZztcbiAgICAgICAgY2hhcnNUb1JlbmRlciArPSBsaW5lW2ldO1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtpXTtcbiAgICAgICAgaWYgKGJveFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgdGV4dExlZnRPZmZzZXQgKz0gY2hhckJveC5rZXJuZWRXaWR0aCAtIGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0p1c3RpZnkgJiYgIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtpXSkpIHtcbiAgICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBjaGFyU3BhY2luZywgd2UgcmVuZGVyIGNoYXIgYnkgY2hhclxuICAgICAgICAgIGFjdHVhbFN0eWxlID0gYWN0dWFsU3R5bGUgfHwgdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpKTtcbiAgICAgICAgICBuZXh0U3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkgKyAxKTtcbiAgICAgICAgICB0aW1lVG9SZW5kZXIgPSB0aGlzLl9oYXNTdHlsZUNoYW5nZWRGb3JTdmcoYWN0dWFsU3R5bGUsIG5leHRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpIHx8IHsgfTtcbiAgICAgICAgICB0ZXh0U3BhbnMucHVzaCh0aGlzLl9jcmVhdGVUZXh0Q2hhclNwYW4oY2hhcnNUb1JlbmRlciwgc3R5bGUsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSk7XG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnO1xuICAgICAgICAgIGFjdHVhbFN0eWxlID0gbmV4dFN0eWxlO1xuICAgICAgICAgIHRleHRMZWZ0T2Zmc2V0ICs9IGJveFdpZHRoO1xuICAgICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcHVzaFRleHRCZ1JlY3Q6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzLCBjb2xvciwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgIHRleHRCZ1JlY3RzLnB1c2goXG4gICAgICAgICdcXHRcXHQ8cmVjdCAnLFxuICAgICAgICB0aGlzLl9nZXRGaWxsQXR0cmlidXRlcyhjb2xvciksXG4gICAgICAgICcgeD1cIicsXG4gICAgICAgIHRvRml4ZWQobGVmdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiB5PVwiJyxcbiAgICAgICAgdG9GaXhlZCh0b3AsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgd2lkdGg9XCInLFxuICAgICAgICB0b0ZpeGVkKHdpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgIHRvRml4ZWQoaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiPjwvcmVjdD5cXG4nKTtcbiAgICB9LFxuXG4gICAgX3NldFNWR1RleHRMaW5lQmc6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzLCBpLCBsZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXSxcbiAgICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSAvIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICBib3hXaWR0aCA9IDAsXG4gICAgICAgICAgYm94U3RhcnQgPSAwLFxuICAgICAgICAgIGNoYXJCb3gsIGN1cnJlbnRDb2xvcixcbiAgICAgICAgICBsYXN0Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgY3VycmVudENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgICBpZiAoY3VycmVudENvbG9yICE9PSBsYXN0Q29sb3IpIHtcbiAgICAgICAgICBsYXN0Q29sb3IgJiYgdGhpcy5fcHVzaFRleHRCZ1JlY3QodGV4dEJnUmVjdHMsIGxhc3RDb2xvciwgbGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgdGV4dFRvcE9mZnNldCwgYm94V2lkdGgsIGhlaWdodE9mTGluZSk7XG4gICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgYm94V2lkdGggPSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgIGxhc3RDb2xvciA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyZW50Q29sb3IgJiYgdGhpcy5fcHVzaFRleHRCZ1JlY3QodGV4dEJnUmVjdHMsIGN1cnJlbnRDb2xvciwgbGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICB0ZXh0VG9wT2Zmc2V0LCBib3hXaWR0aCwgaGVpZ2h0T2ZMaW5lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRvYmUgSWxsdXN0cmF0b3IgKGF0IGxlYXN0IENTNSkgaXMgdW5hYmxlIHRvIHJlbmRlciByZ2JhKCktYmFzZWQgZmlsbCB2YWx1ZXNcbiAgICAgKiB3ZSB3b3JrIGFyb3VuZCBpdCBieSBcIm1vdmluZ1wiIGFscGhhIGNoYW5uZWwgaW50byBvcGFjaXR5IGF0dHJpYnV0ZSBhbmQgc2V0dGluZyBmaWxsJ3MgYWxwaGEgdG8gMVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIF9nZXRGaWxsQXR0cmlidXRlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgPyBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSA6ICcnO1xuICAgICAgaWYgKCFmaWxsQ29sb3IgfHwgIWZpbGxDb2xvci5nZXRTb3VyY2UoKSB8fCBmaWxsQ29sb3IuZ2V0QWxwaGEoKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ2ZpbGw9XCInICsgdmFsdWUgKyAnXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdvcGFjaXR5PVwiJyArIGZpbGxDb2xvci5nZXRBbHBoYSgpICsgJ1wiIGZpbGw9XCInICsgZmlsbENvbG9yLnNldEFscGhhKDEpLnRvUmdiKCkgKyAnXCInO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMaW5lVG9wT2Zmc2V0OiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lVG9wT2Zmc2V0ID0gMCwgbGFzdEhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVJbmRleDsgaisrKSB7XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaik7XG4gICAgICB9XG4gICAgICBsYXN0SGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lVG9wOiBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICBvZmZzZXQ6ICh0aGlzLl9mb250U2l6ZU11bHQgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAqIGxhc3RIZWlnaHQgLyAodGhpcy5saW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVNdWx0KVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwU2hhZG93IGEgYm9vbGVhbiB0byBza2lwIHNoYWRvdyBmaWx0ZXIgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oc2tpcFNoYWRvdykge1xuICAgICAgdmFyIHN2Z1N0eWxlID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuZ2V0U3ZnU3R5bGVzLmNhbGwodGhpcywgc2tpcFNoYWRvdyk7XG4gICAgICByZXR1cm4gc3ZnU3R5bGUgKyAnIHdoaXRlLXNwYWNlOiBwcmU7JztcbiAgICB9LFxuICB9KTtcbn0pKCk7XG4vKiBfVE9fU1ZHX0VORF8gKi9cblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0ge30pO1xuXG4gIC8qKlxuICAgKiBUZXh0Ym94IGNsYXNzLCBiYXNlZCBvbiBJVGV4dCwgYWxsb3dzIHRoZSB1c2VyIHRvIHJlc2l6ZSB0aGUgdGV4dCByZWN0YW5nbGVcbiAgICogYW5kIHdyYXBzIGxpbmVzIGF1dG9tYXRpY2FsbHkuIFRleHRib3hlcyBoYXZlIHRoZWlyIFkgc2NhbGluZyBsb2NrZWQsIHRoZVxuICAgKiB1c2VyIGNhbiBvbmx5IGNoYW5nZSB3aWR0aC4gSGVpZ2h0IGlzIGFkanVzdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhlXG4gICAqIHdyYXBwaW5nIG9mIGxpbmVzLlxuICAgKiBAY2xhc3MgZmFicmljLlRleHRib3hcbiAgICogQGV4dGVuZHMgZmFicmljLklUZXh0XG4gICAqIEBtaXhlcyBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dGJveH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuVGV4dGJveCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRleHRib3ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuSVRleHQsIGZhYnJpYy5PYnNlcnZhYmxlLCB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3RleHRib3gnLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSB3aWR0aCBvZiB0ZXh0Ym94LCBpbiBwaXhlbHMuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5XaWR0aDogMjAsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGNhbGN1bGF0ZWQgd2lkdGggb2YgYSB0ZXh0Ym94LCBpbiBwaXhlbHMuXG4gICAgICogZml4ZWQgdG8gMiBzbyB0aGF0IGFuIGVtcHR5IHRleHRib3ggY2Fubm90IGdvIHRvIDBcbiAgICAgKiBhbmQgaXMgc3RpbGwgc2VsZWN0YWJsZSB3aXRob3V0IHRleHQuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkeW5hbWljTWluV2lkdGg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgYXJyYXkgb2YgdGV4dCB3cmFwcGluZy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIF9fY2FjaGVkTGluZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzdGFuZGFyZCBPYmplY3QgY2xhc3MgdmFsdWVzXG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgc3RhbmRhcmQgT2JqZWN0IGNsYXNzIHZhbHVlc1xuICAgICAqIFRleHRib3ggbmVlZHMgdGhpcyBvbiBmYWxzZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIHdoaWNoIHdoZW4gc2V0IGNhdXNlIG9iamVjdCB0byBjaGFuZ2UgZGltZW5zaW9uc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzOiBmYWJyaWMuVGV4dC5wcm90b3R5cGUuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLmNvbmNhdCgnd2lkdGgnKSxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBzcGxpdCBzdHJpbmdzIGluIGJyZWFrYWJsZSBsaW5lc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3dvcmRKb2luZXJzOiAvWyBcXHRcXHJdLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGJvb2xlYW4gcHJvcGVydHkgaW4gb3JkZXIgdG8gc3BsaXQgc3RyaW5ncyB0aGF0IGhhdmUgbm8gd2hpdGUgc3BhY2UgY29uY2VwdC5cbiAgICAgKiB0aGlzIGlzIGEgY2hlYXAgd2F5IHRvIGhlbHAgd2l0aCBjaGluZXNlL2phcGFuZXNlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAyLjYuMFxuICAgICAqL1xuICAgIHNwbGl0QnlHcmFwaGVtZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBVbmxpa2Ugc3VwZXJjbGFzcydzIHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbiwgVGV4dGJveCBkb2VzIG5vdCB1cGRhdGVcbiAgICAgKiBpdHMgd2lkdGguXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fX3NraXBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTtcbiAgICAgIC8vIGNsZWFyIGR5bmFtaWNNaW5XaWR0aCBhcyBpdCB3aWxsIGJlIGRpZmZlcmVudCBhZnRlciB3ZSByZS13cmFwIGxpbmVcbiAgICAgIHRoaXMuZHluYW1pY01pbldpZHRoID0gMDtcbiAgICAgIC8vIHdyYXAgbGluZXNcbiAgICAgIHRoaXMuX3N0eWxlTWFwID0gdGhpcy5fZ2VuZXJhdGVTdHlsZU1hcCh0aGlzLl9zcGxpdFRleHQoKSk7XG4gICAgICAvLyBpZiBhZnRlciB3cmFwcGluZywgdGhlIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiBkeW5hbWljTWluV2lkdGgsIGNoYW5nZSB0aGUgd2lkdGggYW5kIHJlLXdyYXBcbiAgICAgIGlmICh0aGlzLmR5bmFtaWNNaW5XaWR0aCA+IHRoaXMud2lkdGgpIHtcbiAgICAgICAgdGhpcy5fc2V0KCd3aWR0aCcsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xKSB7XG4gICAgICAgIC8vIG9uY2UgdGV4dCBpcyBtZWFzdXJlZCB3ZSBuZWVkIHRvIG1ha2Ugc3BhY2UgZmF0dGVyIHRvIG1ha2UganVzdGlmaWVkIHRleHQuXG4gICAgICAgIHRoaXMuZW5sYXJnZVNwYWNlcygpO1xuICAgICAgfVxuICAgICAgLy8gY2xlYXIgY2FjaGUgYW5kIHJlLWNhbGN1bGF0ZSBoZWlnaHRcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYWxjVGV4dEhlaWdodCgpO1xuICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIG9iamVjdCB0aGF0IHRyYW5zbGF0ZXMgdGhlIHN0eWxlIG9iamVjdCBzbyB0aGF0IGl0IGlzXG4gICAgICogYnJva2VuIHVwIGJ5IHZpc3VhbCBsaW5lcyAobmV3IGxpbmVzIGFuZCBhdXRvbWF0aWMgd3JhcHBpbmcpLlxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IHN0eWxlcyBvYmplY3QgaXMgYnJva2VuIHVwIGJ5IGFjdHVhbCBsaW5lcyAobmV3IGxpbmVzIG9ubHkpLFxuICAgICAqIHdoaWNoIGlzIG9ubHkgc3VmZmljaWVudCBmb3IgVGV4dCAvIElUZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVTdHlsZU1hcDogZnVuY3Rpb24odGV4dEluZm8pIHtcbiAgICAgIHZhciByZWFsTGluZUNvdW50ICAgICA9IDAsXG4gICAgICAgICAgcmVhbExpbmVDaGFyQ291bnQgPSAwLFxuICAgICAgICAgIGNoYXJDb3VudCAgICAgICAgID0gMCxcbiAgICAgICAgICBtYXAgICAgICAgICAgICAgICA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRJbmZvLmdyYXBoZW1lTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRleHRJbmZvLmdyYXBoZW1lVGV4dFtjaGFyQ291bnRdID09PSAnXFxuJyAmJiBpID4gMCkge1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ID0gMDtcbiAgICAgICAgICBjaGFyQ291bnQrKztcbiAgICAgICAgICByZWFsTGluZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3BsaXRCeUdyYXBoZW1lICYmIHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdCh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSkgJiYgaSA+IDApIHtcbiAgICAgICAgICAvLyB0aGlzIGNhc2UgZGVhbHMgd2l0aCBzcGFjZSdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBlbmQgb2YgbGluZXMgd2hlbiB3cmFwcGluZ1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbaV0gPSB7IGxpbmU6IHJlYWxMaW5lQ291bnQsIG9mZnNldDogcmVhbExpbmVDaGFyQ291bnQgfTtcblxuICAgICAgICBjaGFyQ291bnQgKz0gdGV4dEluZm8uZ3JhcGhlbWVMaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ICs9IHRleHRJbmZvLmdyYXBoZW1lTGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBvbiBhIHNwZWNpZmllZCBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3R5bGVIYXM6IGZ1bmN0aW9uKHByb3BlcnR5LCBsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWJyaWMuVGV4dC5wcm90b3R5cGUuc3R5bGVIYXMuY2FsbCh0aGlzLCBwcm9wZXJ0eSwgbGluZUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgbm8gc3R5bGluZyBvciBubyBzdHlsaW5nIGluIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggLCBsaW5lSW5kZXggaXMgb24gd3JhcHBlZCBsaW5lcy5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHlTdHlsZXM6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSAwLCBuZXh0TGluZUluZGV4ID0gbGluZUluZGV4ICsgMSwgbmV4dE9mZnNldCwgb2JqLCBzaG91bGRMaW1pdCA9IGZhbHNlLFxuICAgICAgICAgIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0sIG1hcE5leHRMaW5lID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4ICsgMV07XG4gICAgICBpZiAobWFwKSB7XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBvZmZzZXQgPSBtYXAub2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG1hcE5leHRMaW5lKSB7XG4gICAgICAgIG5leHRMaW5lSW5kZXggPSBtYXBOZXh0TGluZS5saW5lO1xuICAgICAgICBzaG91bGRMaW1pdCA9IG5leHRMaW5lSW5kZXggPT09IGxpbmVJbmRleDtcbiAgICAgICAgbmV4dE9mZnNldCA9IG1hcE5leHRMaW5lLm9mZnNldDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgaWYgKHAyID49IG9mZnNldCAmJiAoIXNob3VsZExpbWl0IHx8IHAyIDwgbmV4dE9mZnNldCkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfZ2V0U3R5bGVEZWNsYXJhdGlvbicsIGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuXG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwcm9iYWJseSBicm9rZW4gbmVlZCBhIGZpeFxuICAgICAqIFJldHVybnMgdGhlIHJlYWwgc3R5bGUgbGluZSB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHdyYXBwZWQgbGluZUluZGV4IGxpbmVcbiAgICAgKiBVc2VkIGp1c3QgdG8gdmVyaWZ5IGlmIHRoZSBsaW5lIGRvZXMgZXhpc3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaWYgdGhlIGxpbmUgZXhpc3RzIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHJldHVybiAhIXRoaXMuc3R5bGVzW21hcC5saW5lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsaW5lIHN0eWxlIHRvIGFuIGVtcHR5IG9iamVjdCBzbyB0aGF0IGlzIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHRoaXMuc3R5bGVzW21hcC5saW5lXSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0ZXh0IHVzaW5nIHRoZSAnd2lkdGgnIHByb3BlcnR5IG9mIFRleHRib3guIEZpcnN0IHRoaXMgZnVuY3Rpb25cbiAgICAgKiBzcGxpdHMgdGV4dCBvbiBuZXdsaW5lcywgc28gd2UgcHJlc2VydmUgbmV3bGluZXMgZW50ZXJlZCBieSB0aGUgdXNlci5cbiAgICAgKiBUaGVuIGl0IHdyYXBzIGVhY2ggbGluZSB1c2luZyB0aGUgd2lkdGggb2YgdGhlIFRleHRib3ggYnkgY2FsbGluZ1xuICAgICAqIF93cmFwTGluZSgpLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVzIFRoZSBzdHJpbmcgYXJyYXkgb2YgdGV4dCB0aGF0IGlzIHNwbGl0IGludG8gbGluZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzaXJlZFdpZHRoIHdpZHRoIHlvdSB3YW50IHRvIHdyYXAgdG9cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzXG4gICAgICovXG4gICAgX3dyYXBUZXh0OiBmdW5jdGlvbihsaW5lcywgZGVzaXJlZFdpZHRoKSB7XG4gICAgICB2YXIgd3JhcHBlZCA9IFtdLCBpO1xuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gdHJ1ZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5jb25jYXQodGhpcy5fd3JhcExpbmUobGluZXNbaV0sIGksIGRlc2lyZWRXaWR0aCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG1lYXN1cmUgYSBzdHJpbmcgb2YgdGV4dCwgZ2l2ZW4gaXRzIGxpbmVJbmRleCBhbmQgY2hhckluZGV4IG9mZnNldFxuICAgICAqIGl0IGdldHMgY2FsbGVkIHdoZW4gY2hhckJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSB5ZXQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyT2Zmc2V0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tZWFzdXJlV29yZDogZnVuY3Rpb24od29yZCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0ID0gdHJ1ZTtcbiAgICAgIGNoYXJPZmZzZXQgPSBjaGFyT2Zmc2V0IHx8IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd29yZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYm94ID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3god29yZFtpXSwgbGluZUluZGV4LCBpICsgY2hhck9mZnNldCwgcHJldkdyYXBoZW1lLCBza2lwTGVmdCk7XG4gICAgICAgIHdpZHRoICs9IGJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gd29yZFtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBsaW5lIG9mIHRleHQgdXNpbmcgdGhlIHdpZHRoIG9mIHRoZSBUZXh0Ym94IGFuZCBhIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBUaGUgZ3JhcGhlbWUgYXJyYXkgdGhhdCByZXByZXNlbnQgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc2lyZWRXaWR0aCB3aWR0aCB5b3Ugd2FudCB0byB3cmFwIHRoZSBsaW5lIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlc2VydmVkU3BhY2Ugc3BhY2UgdG8gcmVtb3ZlIGZyb20gd3JhcHBpbmcgZm9yIGN1c3RvbSBmdW5jdGlvbmFsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmUocykgaW50byB3aGljaCB0aGUgZ2l2ZW4gdGV4dCBpcyB3cmFwcGVkXG4gICAgICogdG8uXG4gICAgICovXG4gICAgX3dyYXBMaW5lOiBmdW5jdGlvbihfbGluZSwgbGluZUluZGV4LCBkZXNpcmVkV2lkdGgsIHJlc2VydmVkU3BhY2UpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSAwLFxuICAgICAgICAgIHNwbGl0QnlHcmFwaGVtZSA9IHRoaXMuc3BsaXRCeUdyYXBoZW1lLFxuICAgICAgICAgIGdyYXBoZW1lTGluZXMgPSBbXSxcbiAgICAgICAgICBsaW5lID0gW10sXG4gICAgICAgICAgLy8gc3BhY2VzIGluIGRpZmZlcmVudCBsYW5ndWFnZXM/XG4gICAgICAgICAgd29yZHMgPSBzcGxpdEJ5R3JhcGhlbWUgPyBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChfbGluZSkgOiBfbGluZS5zcGxpdCh0aGlzLl93b3JkSm9pbmVycyksXG4gICAgICAgICAgd29yZCA9ICcnLFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgaW5maXggPSBzcGxpdEJ5R3JhcGhlbWUgPyAnJyA6ICcgJyxcbiAgICAgICAgICB3b3JkV2lkdGggPSAwLFxuICAgICAgICAgIGluZml4V2lkdGggPSAwLFxuICAgICAgICAgIGxhcmdlc3RXb3JkV2lkdGggPSAwLFxuICAgICAgICAgIGxpbmVKdXN0U3RhcnRlZCA9IHRydWUsXG4gICAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCksXG4gICAgICAgICAgcmVzZXJ2ZWRTcGFjZSA9IHJlc2VydmVkU3BhY2UgfHwgMDtcbiAgICAgIC8vIGZpeCBhIGRpZmZlcmVuY2UgYmV0d2VlbiBzcGxpdCBhbmQgZ3JhcGhlbWVTcGxpdFxuICAgICAgaWYgKHdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB3b3Jkcy5wdXNoKFtdKTtcbiAgICAgIH1cbiAgICAgIGRlc2lyZWRXaWR0aCAtPSByZXNlcnZlZFNwYWNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBpZiB1c2luZyBzcGxpdEJ5R3JhcGhlbWUgd29yZHMgYXJlIGFscmVhZHkgaW4gZ3JhcGhlbWVzLlxuICAgICAgICB3b3JkID0gc3BsaXRCeUdyYXBoZW1lID8gd29yZHNbaV0gOiBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdCh3b3Jkc1tpXSk7XG4gICAgICAgIHdvcmRXaWR0aCA9IHRoaXMuX21lYXN1cmVXb3JkKHdvcmQsIGxpbmVJbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHdvcmQubGVuZ3RoO1xuXG4gICAgICAgIGxpbmVXaWR0aCArPSBpbmZpeFdpZHRoICsgd29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICBpZiAobGluZVdpZHRoID4gZGVzaXJlZFdpZHRoICYmICFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBncmFwaGVtZUxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgIGxpbmVXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgICBsaW5lSnVzdFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxpbmVXaWR0aCArPSBhZGRpdGlvbmFsU3BhY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxpbmVKdXN0U3RhcnRlZCAmJiAhc3BsaXRCeUdyYXBoZW1lKSB7XG4gICAgICAgICAgbGluZS5wdXNoKGluZml4KTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gbGluZS5jb25jYXQod29yZCk7XG5cbiAgICAgICAgaW5maXhXaWR0aCA9IHNwbGl0QnlHcmFwaGVtZSA/IDAgOiB0aGlzLl9tZWFzdXJlV29yZChbaW5maXhdLCBsaW5lSW5kZXgsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBsaW5lSnVzdFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBsYXJnZXN0IHdvcmRcbiAgICAgICAgaWYgKHdvcmRXaWR0aCA+IGxhcmdlc3RXb3JkV2lkdGgpIHtcbiAgICAgICAgICBsYXJnZXN0V29yZFdpZHRoID0gd29yZFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGkgJiYgZ3JhcGhlbWVMaW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgICBpZiAobGFyZ2VzdFdvcmRXaWR0aCArIHJlc2VydmVkU3BhY2UgPiB0aGlzLmR5bmFtaWNNaW5XaWR0aCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IGxhcmdlc3RXb3JkV2lkdGggLSBhZGRpdGlvbmFsU3BhY2UgKyByZXNlcnZlZFNwYWNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYXBoZW1lTGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiB0aGUgdGV4dCBsaW5lIGlzIGVuZGVkIHdpdGggYW4gaGFyZCBicmVha1xuICAgICAqIHRleHQgYW5kIGl0ZXh0IGRvIG5vdCBoYXZlIHdyYXBwaW5nLCByZXR1cm4gZmFsc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRleHQgdG8gc3BsaXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW5kT2ZXcmFwcGluZzogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdKSB7XG4gICAgICAgIC8vIGlzIGxhc3QgbGluZSwgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdLmxpbmUgIT09IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0ubGluZSkge1xuICAgICAgICAvLyB0aGlzIGlzIGxhc3QgbGluZSBiZWZvcmUgYSBsaW5lIGJyZWFrLCByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBhIGxpbmUgaGFzIGEgbGluZWJyZWFrIGFuZCBzbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGl0IHdoZW4gbW92aW5nXG4gICAgICogYW5kIGNvdW50aW5nIHN0eWxlLlxuICAgICAqIEByZXR1cm4gTnVtYmVyXG4gICAgICovXG4gICAgbWlzc2luZ05ld2xpbmVPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuc3BsaXRCeUdyYXBoZW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRW5kT2ZXcmFwcGluZyhsaW5lSW5kZXgpID8gMSA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBHZXRzIGxpbmVzIG9mIHRleHQgdG8gcmVuZGVyIGluIHRoZSBUZXh0Ym94LiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXNcbiAgICAqIHRleHQgd3JhcHBpbmcgb24gdGhlIGZseSBldmVyeSB0aW1lIGl0IGlzIGNhbGxlZC5cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRleHQgdG8gc3BsaXRcbiAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgbGluZXMgaW4gdGhlIFRleHRib3guXG4gICAgKiBAb3ZlcnJpZGVcbiAgICAqL1xuICAgIF9zcGxpdFRleHRJbnRvTGluZXM6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBuZXdUZXh0ID0gZmFicmljLlRleHQucHJvdG90eXBlLl9zcGxpdFRleHRJbnRvTGluZXMuY2FsbCh0aGlzLCB0ZXh0KSxcbiAgICAgICAgICBncmFwaGVtZUxpbmVzID0gdGhpcy5fd3JhcFRleHQobmV3VGV4dC5saW5lcywgdGhpcy53aWR0aCksXG4gICAgICAgICAgbGluZXMgPSBuZXcgQXJyYXkoZ3JhcGhlbWVMaW5lcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gZ3JhcGhlbWVMaW5lc1tpXS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIG5ld1RleHQubGluZXMgPSBsaW5lcztcbiAgICAgIG5ld1RleHQuZ3JhcGhlbWVMaW5lcyA9IGdyYXBoZW1lTGluZXM7XG4gICAgICByZXR1cm4gbmV3VGV4dDtcbiAgICB9LFxuXG4gICAgZ2V0TWluV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWluV2lkdGgsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVzVG9LZWVwID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuX3N0eWxlTWFwKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBsaW5lc1RvS2VlcFt0aGlzLl9zdHlsZU1hcFtwcm9wXS5saW5lXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgaWYgKCFsaW5lc1RvS2VlcFtwcm9wXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsnbWluV2lkdGgnLCAnc3BsaXRCeUdyYXBoZW1lJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0Ym94XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRleHRib3ggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlRleHRib3guZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dGJveCcsIG9iamVjdCwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBjb250cm9sc1V0aWxzID0gZmFicmljLmNvbnRyb2xzVXRpbHMsXG4gICAgICBzY2FsZVNrZXdTdHlsZUhhbmRsZXIgPSBjb250cm9sc1V0aWxzLnNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlcixcbiAgICAgIHNjYWxlU3R5bGVIYW5kbGVyID0gY29udHJvbHNVdGlscy5zY2FsZUN1cnNvclN0eWxlSGFuZGxlcixcbiAgICAgIHNjYWxpbmdFcXVhbGx5ID0gY29udHJvbHNVdGlscy5zY2FsaW5nRXF1YWxseSxcbiAgICAgIHNjYWxpbmdZT3JTa2V3aW5nWCA9IGNvbnRyb2xzVXRpbHMuc2NhbGluZ1lPclNrZXdpbmdYLFxuICAgICAgc2NhbGluZ1hPclNrZXdpbmdZID0gY29udHJvbHNVdGlscy5zY2FsaW5nWE9yU2tld2luZ1ksXG4gICAgICBzY2FsZU9yU2tld0FjdGlvbk5hbWUgPSBjb250cm9sc1V0aWxzLnNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgICAgIG9iamVjdENvbnRyb2xzID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuY29udHJvbHM7XG5cbiAgb2JqZWN0Q29udHJvbHMubWwgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IC0wLjUsXG4gICAgeTogMCxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nWE9yU2tld2luZ1ksXG4gICAgZ2V0QWN0aW9uTmFtZTogc2NhbGVPclNrZXdBY3Rpb25OYW1lLFxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5tciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMC41LFxuICAgIHk6IDAsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ1hPclNrZXdpbmdZLFxuICAgIGdldEFjdGlvbk5hbWU6IHNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMubWIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IDAsXG4gICAgeTogMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdZT3JTa2V3aW5nWCxcbiAgICBnZXRBY3Rpb25OYW1lOiBzY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLm10ID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLFxuICAgIHk6IC0wLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ1lPclNrZXdpbmdYLFxuICAgIGdldEFjdGlvbk5hbWU6IHNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMudGwgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IC0wLjUsXG4gICAgeTogLTAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLnRyID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLjUsXG4gICAgeTogLTAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLmJsID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAtMC41LFxuICAgIHk6IDAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLmJyID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLjUsXG4gICAgeTogMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ0VxdWFsbHlcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMubXRyID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLFxuICAgIHk6IC0wLjUsXG4gICAgYWN0aW9uSGFuZGxlcjogY29udHJvbHNVdGlscy5yb3RhdGlvbldpdGhTbmFwcGluZyxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IGNvbnRyb2xzVXRpbHMucm90YXRpb25TdHlsZUhhbmRsZXIsXG4gICAgb2Zmc2V0WTogLTQwLFxuICAgIHdpdGhDb25uZWN0aW9uOiB0cnVlLFxuICAgIGFjdGlvbk5hbWU6ICdyb3RhdGUnLFxuICB9KTtcblxuICBpZiAoZmFicmljLlRleHRib3gpIHtcbiAgICAvLyB0aGlzIGlzIGJyZWFraW5nIHRoZSBwcm90b3R5cGUgaW5oZXJpdGFuY2UsIG5vIHRpbWUgLyBpZGVhcyB0byBmaXggaXQuXG4gICAgLy8gaXMgaW1wb3J0YW50IHRvIGRvY3VtZW50IHRoYXQgaWYgeW91IHdhbnQgdG8gaGF2ZSBhbGwgb2JqZWN0cyB0byBoYXZlIGFcbiAgICAvLyBzcGVjaWZpYyBjdXN0b20gY29udHJvbCwgeW91IGhhdmUgdG8gYWRkIGl0IHRvIE9iamVjdCBwcm90b3R5cGUgYW5kIHRvIFRleHRib3hcbiAgICAvLyBwcm90b3R5cGUuIFRoZSBjb250cm9scyBhcmUgc2hhcmVkIGFzIHJlZmVyZW5jZXMuIFNvIGNoYW5nZXMgdG8gY29udHJvbCBgdHJgXG4gICAgLy8gY2FuIHN0aWxsIGFwcGx5IHRvIGFsbCBvYmplY3RzIGlmIG5lZWRlZC5cbiAgICB2YXIgdGV4dEJveENvbnRyb2xzID0gZmFicmljLlRleHRib3gucHJvdG90eXBlLmNvbnRyb2xzID0geyB9O1xuXG4gICAgdGV4dEJveENvbnRyb2xzLm10ciA9IG9iamVjdENvbnRyb2xzLm10cjtcbiAgICB0ZXh0Qm94Q29udHJvbHMudHIgPSBvYmplY3RDb250cm9scy50cjtcbiAgICB0ZXh0Qm94Q29udHJvbHMuYnIgPSBvYmplY3RDb250cm9scy5icjtcbiAgICB0ZXh0Qm94Q29udHJvbHMudGwgPSBvYmplY3RDb250cm9scy50bDtcbiAgICB0ZXh0Qm94Q29udHJvbHMuYmwgPSBvYmplY3RDb250cm9scy5ibDtcbiAgICB0ZXh0Qm94Q29udHJvbHMubXQgPSBvYmplY3RDb250cm9scy5tdDtcbiAgICB0ZXh0Qm94Q29udHJvbHMubWIgPSBvYmplY3RDb250cm9scy5tYjtcblxuICAgIHRleHRCb3hDb250cm9scy5tciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgICB4OiAwLjUsXG4gICAgICB5OiAwLFxuICAgICAgYWN0aW9uSGFuZGxlcjogY29udHJvbHNVdGlscy5jaGFuZ2VXaWR0aCxcbiAgICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgICAgYWN0aW9uTmFtZTogJ3Jlc2l6aW5nJyxcbiAgICB9KTtcblxuICAgIHRleHRCb3hDb250cm9scy5tbCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgICB4OiAtMC41LFxuICAgICAgeTogMCxcbiAgICAgIGFjdGlvbkhhbmRsZXI6IGNvbnRyb2xzVXRpbHMuY2hhbmdlV2lkdGgsXG4gICAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICAgIGFjdGlvbk5hbWU6ICdyZXNpemluZycsXG4gICAgfSk7XG4gIH1cbn0pKCk7XG5cbiJdLCJuYW1lcyI6WyJmYWJyaWMiLCJ2ZXJzaW9uIiwiZXhwb3J0cyIsImRlZmluZSIsImFtZCIsImRvY3VtZW50IiwiSFRNTERvY3VtZW50IiwiRG9jdW1lbnQiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZUhUTUxEb2N1bWVudCIsIndpbmRvdyIsImpzZG9tIiwicmVxdWlyZSIsInZpcnR1YWxXaW5kb3ciLCJKU0RPTSIsImRlY29kZVVSSUNvbXBvbmVudCIsImZlYXR1cmVzIiwiRmV0Y2hFeHRlcm5hbFJlc291cmNlcyIsInJlc291cmNlcyIsImpzZG9tSW1wbEZvcldyYXBwZXIiLCJpbXBsRm9yV3JhcHBlciIsIm5vZGVDYW52YXMiLCJDYW52YXMiLCJET01QYXJzZXIiLCJpc1RvdWNoU3VwcG9ydGVkIiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJpc0xpa2VseU5vZGUiLCJCdWZmZXIiLCJTSEFSRURfQVRUUklCVVRFUyIsIkRQSSIsInJlTnVtIiwiY29tbWFXc3AiLCJyZVBhdGhDb21tYW5kIiwicmVOb25Xb3JkIiwiZm9udFBhdGhzIiwiaU1hdHJpeCIsInN2Z05TIiwicGVyZkxpbWl0U2l6ZVRvdGFsIiwibWF4Q2FjaGVTaWRlTGltaXQiLCJtaW5DYWNoZVNpZGVMaW1pdCIsImNoYXJXaWR0aHNDYWNoZSIsInRleHR1cmVTaXplIiwiZGlzYWJsZVN0eWxlQ29weVBhc3RlIiwiZW5hYmxlR0xGaWx0ZXJpbmciLCJkZXZpY2VQaXhlbFJhdGlvIiwid2Via2l0RGV2aWNlUGl4ZWxSYXRpbyIsIm1vekRldmljZVBpeGVsUmF0aW8iLCJicm93c2VyU2hhZG93Qmx1ckNvbnN0YW50IiwiYXJjVG9TZWdtZW50c0NhY2hlIiwiYm91bmRzT2ZDdXJ2ZUNhY2hlIiwiY2FjaGVzQm91bmRzT2ZDdXJ2ZSIsImZvcmNlR0xQdXRJbWFnZURhdGEiLCJpbml0RmlsdGVyQmFja2VuZCIsImlzV2ViZ2xTdXBwb3J0ZWQiLCJjb25zb2xlIiwibG9nIiwibWF4VGV4dHVyZVNpemUiLCJXZWJnbEZpbHRlckJhY2tlbmQiLCJ0aWxlU2l6ZSIsIkNhbnZhczJkRmlsdGVyQmFja2VuZCIsIl9yZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnROYW1lIiwiaGFuZGxlciIsIl9fZXZlbnRMaXN0ZW5lcnMiLCJldmVudExpc3RlbmVyIiwiaW5kZXhPZiIsInV0aWwiLCJhcnJheSIsImZpbGwiLCJvbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInByb3AiLCJwdXNoIiwiX29uY2UiLCJfaGFuZGxlciIsImFwcGx5Iiwib2ZmIiwiYmluZCIsIm9uY2UiLCJjYWxsIiwiZmlyZSIsIm9wdGlvbnMiLCJsaXN0ZW5lcnNGb3JFdmVudCIsImkiLCJsZW4iLCJmaWx0ZXIiLCJ2YWx1ZSIsIk9ic2VydmFibGUiLCJDb2xsZWN0aW9uIiwiX29iamVjdHMiLCJhZGQiLCJfb25PYmplY3RBZGRlZCIsInJlbmRlck9uQWRkUmVtb3ZlIiwicmVxdWVzdFJlbmRlckFsbCIsImluc2VydEF0Iiwib2JqZWN0IiwiaW5kZXgiLCJub25TcGxpY2luZyIsIm9iamVjdHMiLCJzcGxpY2UiLCJyZW1vdmUiLCJzb21ldGhpbmdSZW1vdmVkIiwiX29uT2JqZWN0UmVtb3ZlZCIsImZvckVhY2hPYmplY3QiLCJjYWxsYmFjayIsImNvbnRleHQiLCJnZXRPYmplY3RzIiwidHlwZSIsImNvbmNhdCIsIm8iLCJpdGVtIiwiaXNFbXB0eSIsInNpemUiLCJjb250YWlucyIsImRlZXAiLCJzb21lIiwib2JqIiwiY29tcGxleGl0eSIsInJlZHVjZSIsIm1lbW8iLCJjdXJyZW50IiwiQ29tbW9uTWV0aG9kcyIsIl9zZXRPcHRpb25zIiwic2V0IiwiX2luaXRHcmFkaWVudCIsImZpbGxlciIsInByb3BlcnR5IiwiY29sb3JTdG9wcyIsIkdyYWRpZW50IiwiX2luaXRQYXR0ZXJuIiwic291cmNlIiwiUGF0dGVybiIsIl9zZXRPYmplY3QiLCJfc2V0Iiwia2V5IiwidG9nZ2xlIiwiZ2V0IiwiZ2xvYmFsIiwic3FydCIsIk1hdGgiLCJhdGFuMiIsInBvdyIsIlBpQnkxODAiLCJQSSIsIlBpQnkyIiwiY29zIiwiYW5nbGUiLCJhbmdsZVNsaWNlIiwic2luIiwic2lnbiIsInJlbW92ZUZyb21BcnJheSIsImlkeCIsImdldFJhbmRvbUludCIsIm1pbiIsIm1heCIsImZsb29yIiwicmFuZG9tIiwiZGVncmVlc1RvUmFkaWFucyIsImRlZ3JlZXMiLCJyYWRpYW5zVG9EZWdyZWVzIiwicmFkaWFucyIsInJvdGF0ZVBvaW50IiwicG9pbnQiLCJvcmlnaW4iLCJuZXdQb2ludCIsIlBvaW50IiwieCIsInkiLCJ2Iiwicm90YXRlVmVjdG9yIiwiYWRkRXF1YWxzIiwidmVjdG9yIiwicngiLCJyeSIsImNyZWF0ZVZlY3RvciIsImZyb20iLCJ0byIsImNhbGNBbmdsZUJldHdlZW5WZWN0b3JzIiwiYSIsImIiLCJhY29zIiwiaHlwb3QiLCJnZXRIYXRWZWN0b3IiLCJtdWx0aXBseSIsImdldEJpc2VjdG9yIiwiQSIsIkIiLCJDIiwiQUIiLCJBQyIsImFscGhhIiwicm8iLCJwaGkiLCJwcm9qZWN0U3Ryb2tlT25Qb2ludHMiLCJwb2ludHMiLCJvcGVuUGF0aCIsImNvb3JkcyIsInMiLCJzdHJva2VXaWR0aCIsInN0cm9rZVVuaWZvcm1TY2FsYXIiLCJzdHJva2VVbmlmb3JtIiwic2NhbGVYIiwic2NhbGVZIiwiZ2V0U3Ryb2tlSGF0VmVjdG9yIiwic2NhbGFyIiwiZm9yRWFjaCIsInAiLCJiaXNlY3RvciIsImJpc2VjdG9yVmVjdG9yIiwibWl0ZXJWZWN0b3IiLCJzdHJva2VMaW5lSm9pbiIsInN0cm9rZU1pdGVyTGltaXQiLCJzdWJ0cmFjdCIsIlNRUlQyIiwidHJhbnNmb3JtUG9pbnQiLCJ0IiwiaWdub3JlT2Zmc2V0IiwibWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyIsInRyYW5zZm9ybSIsInhQb2ludHMiLCJtaW5YIiwibWF4WCIsIndpZHRoIiwieVBvaW50cyIsIm1pblkiLCJtYXhZIiwiaGVpZ2h0IiwibGVmdCIsInRvcCIsImludmVydFRyYW5zZm9ybSIsInIiLCJ0b0ZpeGVkIiwibnVtYmVyIiwiZnJhY3Rpb25EaWdpdHMiLCJwYXJzZUZsb2F0IiwiTnVtYmVyIiwicGFyc2VVbml0IiwiZm9udFNpemUiLCJ1bml0IiwiZXhlYyIsIlRleHQiLCJERUZBVUxUX1NWR19GT05UX1NJWkUiLCJmYWxzZUZ1bmN0aW9uIiwiZ2V0S2xhc3MiLCJuYW1lc3BhY2UiLCJzdHJpbmciLCJjYW1lbGl6ZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJyZXNvbHZlTmFtZXNwYWNlIiwiZ2V0U3ZnQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJwYXJ0cyIsInNwbGl0IiwibG9hZEltYWdlIiwidXJsIiwiY3Jvc3NPcmlnaW4iLCJpbWciLCJjcmVhdGVJbWFnZSIsIm9uTG9hZENhbGxiYWNrIiwib25sb2FkIiwib25lcnJvciIsInNyYyIsInVuZGVmaW5lZCIsInN1YnN0cmluZyIsImxvYWRJbWFnZUluRG9tIiwiZGl2IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwicG9zaXRpb24iLCJhcHBlbmRDaGlsZCIsInF1ZXJ5U2VsZWN0b3IiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJlbmxpdmVuT2JqZWN0cyIsInJldml2ZXIiLCJlbmxpdmVuZWRPYmplY3RzIiwibnVtTG9hZGVkT2JqZWN0cyIsIm51bVRvdGFsT2JqZWN0cyIsIm9uTG9hZGVkIiwia2xhc3MiLCJmcm9tT2JqZWN0IiwiZXJyb3IiLCJlbmxpdmVuT2JqZWN0RW5saXZhYmxlcyIsImVubGl2ZW5Qcm9wcyIsIk9iamVjdCIsIkVOTElWRU5fUFJPUFMiLCJtYXAiLCJlbmxpdmVkUHJvcHMiLCJlbmxpdmVuUGF0dGVybnMiLCJwYXR0ZXJucyIsIm51bUxvYWRlZFBhdHRlcm5zIiwibnVtUGF0dGVybnMiLCJlbmxpdmVuZWRQYXR0ZXJucyIsInBhdHRlcm4iLCJncm91cFNWR0VsZW1lbnRzIiwiZWxlbWVudHMiLCJwYXRoIiwiY2VudGVyUG9pbnQiLCJHcm91cCIsInNvdXJjZVBhdGgiLCJwb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzIiwiZGVzdGluYXRpb24iLCJwcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjcmVhdGVDYW52YXNFbGVtZW50IiwiY29weUNhbnZhc0VsZW1lbnQiLCJjYW52YXMiLCJuZXdDYW52YXMiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwidG9EYXRhVVJMIiwiY2FudmFzRWwiLCJmb3JtYXQiLCJxdWFsaXR5IiwibXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyIsImlzMngyIiwicXJEZWNvbXBvc2UiLCJkZW5vbSIsInNrZXdYIiwic2tld1kiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsImNhbGNSb3RhdGVNYXRyaXgiLCJ0aGV0YSIsImNhbGNEaW1lbnNpb25zTWF0cml4Iiwic2NhbGVNYXRyaXgiLCJmbGlwWCIsImZsaXBZIiwidGFuIiwiY29tcG9zZU1hdHJpeCIsIm1hdHJpeCIsInJlc2V0T2JqZWN0VHJhbnNmb3JtIiwidGFyZ2V0Iiwicm90YXRlIiwic2F2ZU9iamVjdFRyYW5zZm9ybSIsImlzVHJhbnNwYXJlbnQiLCJjdHgiLCJ0b2xlcmFuY2UiLCJfaXNUcmFuc3BhcmVudCIsInRlbXAiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJsIiwiZGF0YSIsInBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZSIsImF0dHJpYnV0ZSIsIm1lZXRPclNsaWNlIiwiYWxpZ25YIiwiYWxpZ25ZIiwiYXNwZWN0UmF0aW9BdHRycyIsImFsaWduIiwicG9wIiwiY2xlYXJGYWJyaWNGb250Q2FjaGUiLCJmb250RmFtaWx5IiwidG9Mb3dlckNhc2UiLCJsaW1pdERpbXNCeUFyZWEiLCJhciIsIm1heGltdW1BcmVhIiwicm91Z2hXaWR0aCIsInBlcmZMaW1pdFNpemVZIiwiY2FwVmFsdWUiLCJmaW5kU2NhbGVUb0ZpdCIsImZpbmRTY2FsZVRvQ292ZXIiLCJtYXRyaXhUb1NWRyIsIk5VTV9GUkFDVElPTl9ESUdJVFMiLCJqb2luIiwicmVtb3ZlVHJhbnNmb3JtRnJvbU9iamVjdCIsImludmVydGVkIiwiZmluYWxUcmFuc2Zvcm0iLCJjYWxjT3duTWF0cml4IiwiYXBwbHlUcmFuc2Zvcm1Ub09iamVjdCIsImFkZFRyYW5zZm9ybVRvT2JqZWN0IiwiY2VudGVyIiwic2V0UG9zaXRpb25CeU9yaWdpbiIsInNpemVBZnRlclRyYW5zZm9ybSIsImRpbVgiLCJkaW1ZIiwidHJhbnNmb3JtTWF0cml4IiwiYmJveCIsIm1lcmdlQ2xpcFBhdGhzIiwiYzEiLCJjMiIsImNhbGNUcmFuc2Zvcm1NYXRyaXgiLCJjbGlwUGF0aCIsIl9qb2luIiwiQXJyYXkiLCJjb21tYW5kTGVuZ3RocyIsIm0iLCJoIiwiYyIsInEiLCJyZXBlYXRlZENvbW1hbmRzIiwiTSIsInNlZ21lbnRUb0JlemllciIsInRoMiIsInRoMyIsImNvc1RoIiwic2luVGgiLCJjeDEiLCJjeTEiLCJtVCIsImZyb21YIiwiZnJvbVkiLCJjb3N0aDIiLCJzaW50aDIiLCJjb3N0aDMiLCJzaW50aDMiLCJ0b1giLCJ0b1kiLCJjcDFYIiwiY3AxWSIsImNwMlgiLCJjcDJZIiwiYXJjVG9TZWdtZW50cyIsImxhcmdlIiwic3dlZXAiLCJyb3RhdGVYIiwidGgiLCJhYnMiLCJweCIsInB5IiwicngyIiwicnkyIiwicHkyIiwicHgyIiwicGwiLCJyb290IiwiY3giLCJjeSIsIm1UaGV0YSIsImNhbGNWZWN0b3JBbmdsZSIsImR0aGV0YSIsInNlZ21lbnRzIiwiY2VpbCIsInJlc3VsdCIsIm1EZWx0YSIsInV4IiwidXkiLCJ2eCIsInZ5IiwidGEiLCJ0YiIsImdldEJvdW5kc09mQ3VydmUiLCJ4MCIsInkwIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4MyIsInkzIiwiYXJnc1N0cmluZyIsInR2YWx1ZXMiLCJib3VuZHMiLCJ0MSIsInQyIiwiYjJhYyIsInNxcnRiMmFjIiwiaiIsImpsZW4iLCJtdCIsImZyb21BcmNUb0JlemllcnMiLCJmeCIsImZ5Iiwicm90IiwidHgiLCJ0eSIsInNlZ3NOb3JtIiwibWFrZVBhdGhTaW1wbGVyIiwiY29udmVydGVkIiwiZGVzdGluYXRpb25QYXRoIiwicHJldmlvdXMiLCJjb250cm9sWCIsImNvbnRyb2xZIiwiY2FsY0xpbmVMZW5ndGgiLCJDQjEiLCJDQjIiLCJDQjMiLCJDQjQiLCJnZXRQb2ludE9uQ3ViaWNCZXppZXJJdGVyYXRvciIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsInAzeCIsInAzeSIsInA0eCIsInA0eSIsInBjdCIsImMzIiwiYzQiLCJnZXRUYW5nZW50Q3ViaWNJdGVyYXRvciIsImludlQiLCJ0YW5nZW50WCIsInRhbmdlbnRZIiwiUUIxIiwiUUIyIiwiUUIzIiwiZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllckl0ZXJhdG9yIiwiZ2V0VGFuZ2VudFF1YWRyYXRpY0l0ZXJhdG9yIiwicGF0aEl0ZXJhdG9yIiwiaXRlcmF0b3IiLCJ0ZW1wUCIsInRtcExlbiIsInBlcmMiLCJmaW5kUGVyY2VudGFnZUZvckRpc3RhbmNlIiwic2VnSW5mbyIsImRpc3RhbmNlIiwibmV4dExlbiIsIm5leHRTdGVwIiwiYW5nbGVGaW5kZXIiLCJsYXN0UGVyYyIsImdldFBhdGhTZWdtZW50c0luZm8iLCJ0b3RhbExlbmd0aCIsImluZm8iLCJ0ZW1wSW5mbyIsImNvbW1hbmQiLCJkZXN0WCIsImRlc3RZIiwiZ2V0UG9pbnRPblBhdGgiLCJpbmZvcyIsInNlZ1BlcmNlbnQiLCJzZWdtZW50IiwibGVycCIsInBhcnNlUGF0aCIsInBhdGhTdHJpbmciLCJjdXJyZW50UGF0aCIsInBhcnNlZCIsInJlIiwick51bWJlciIsInJOdW1iZXJDb21tYVdzcCIsInJGbGFnQ29tbWFXc3AiLCJyQXJjU2VxIiwicmVnQXJjQXJndW1lbnRTZXF1ZW5jZSIsIlJlZ0V4cCIsIm1hdGNoIiwiY29vcmRzU3RyIiwiY29vcmRzUGFyc2VkIiwidHJpbSIsImFyZ3MiLCJpc05hTiIsImNvbW1hbmRMZW5ndGgiLCJyZXBlYXRlZENvbW1hbmQiLCJrIiwia2xlbiIsImdldFNtb290aFBhdGhGcm9tUG9pbnRzIiwiY29ycmVjdGlvbiIsInAxIiwicDIiLCJtdWx0U2lnblgiLCJtdWx0U2lnblkiLCJtYW55UG9pbnRzIiwiZXEiLCJtaWRQb2ludCIsIm1pZFBvaW50RnJvbSIsInRyYW5zZm9ybVBhdGgiLCJwYXRoT2Zmc2V0IiwicGF0aFNlZ21lbnQiLCJuZXdTZWdtZW50Iiwiam9pblBhdGgiLCJwYXRoRGF0YSIsImludm9rZSIsIm1ldGhvZCIsImJ5UHJvcGVydHkiLCJmaW5kIiwidmFsdWUxIiwidmFsdWUyIiwiY29uZGl0aW9uIiwiZXh0ZW5kIiwiRWxlbWVudCIsImhhc093blByb3BlcnR5IiwiY2xvbmUiLCJyZXBsYWNlIiwiY2hhcmFjdGVyIiwiY2FwaXRhbGl6ZSIsImZpcnN0TGV0dGVyT25seSIsImVzY2FwZVhtbCIsImdyYXBoZW1lU3BsaXQiLCJ0ZXh0c3RyaW5nIiwiY2hyIiwiZ3JhcGhlbWVzIiwiZ2V0V2hvbGVDaGFyIiwic3RyIiwiY29kZSIsImNoYXJDb2RlQXQiLCJuZXh0IiwicHJldiIsImVtcHR5RnVuY3Rpb24iLCJJU19ET05URU5VTV9CVUdHWSIsImFkZE1ldGhvZHMiLCJwYXJlbnQiLCJzdXBlcmNsYXNzIiwiY29uc3RydWN0b3IiLCJyZXR1cm5WYWx1ZSIsInZhbHVlT2YiLCJTdWJjbGFzcyIsImNhbGxTdXBlciIsIm1ldGhvZE5hbWUiLCJwYXJlbnRNZXRob2QiLCJfdGhpcyIsInN1cGVyQ2xhc3NNZXRob2QiLCJjcmVhdGVDbGFzcyIsInNoaWZ0IiwiaW5pdGlhbGl6ZSIsInN1YmNsYXNzZXMiLCJjb3VsZFVzZUF0dGFjaEV2ZW50IiwiYXR0YWNoRXZlbnQiLCJ0b3VjaEV2ZW50cyIsImFkZExpc3RlbmVyIiwiZWxlbWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJnZXRUb3VjaEluZm8iLCJldmVudCIsInRvdWNoUHJvcCIsImNoYW5nZWRUb3VjaGVzIiwiZ2V0UG9pbnRlciIsInNjcm9sbCIsImdldFNjcm9sbExlZnRUb3AiLCJfZXZ0IiwiY2xpZW50WCIsImNsaWVudFkiLCJpc1RvdWNoRXZlbnQiLCJwb2ludGVyVHlwZSIsInNldFN0eWxlIiwic3R5bGVzIiwiZWxlbWVudFN0eWxlIiwiY3NzVGV4dCIsInNldE9wYWNpdHkiLCJub3JtYWxpemVkUHJvcGVydHkiLCJzdHlsZUZsb2F0IiwicGFyc2VFbCIsInN1cHBvcnRzT3BhY2l0eSIsIm9wYWNpdHkiLCJzdXBwb3J0c0ZpbHRlcnMiLCJyZU9wYWNpdHkiLCJlcyIsImN1cnJlbnRTdHlsZSIsImhhc0xheW91dCIsInpvb20iLCJ0ZXN0IiwiX3NsaWNlIiwiZ2V0QnlJZCIsImlkIiwiZ2V0RWxlbWVudEJ5SWQiLCJzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMiLCJ0b0FycmF5IiwiYXJyYXlMaWtlIiwiY2hpbGROb2RlcyIsImVyciIsImFyciIsIm1ha2VFbGVtZW50IiwidGFnTmFtZSIsImVsIiwiY2xhc3NOYW1lIiwiaHRtbEZvciIsInNldEF0dHJpYnV0ZSIsImFkZENsYXNzIiwid3JhcEVsZW1lbnQiLCJ3cmFwcGVyIiwicmVwbGFjZUNoaWxkIiwiZG9jRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImJvZHkiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiaG9zdCIsIm5vZGVUeXBlIiwiZ2V0RWxlbWVudE9mZnNldCIsImRvY0VsZW0iLCJkb2MiLCJvd25lckRvY3VtZW50IiwiYm94Iiwib2Zmc2V0Iiwic2Nyb2xsTGVmdFRvcCIsIm9mZnNldEF0dHJpYnV0ZXMiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJUb3BXaWR0aCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1RvcCIsImF0dHIiLCJwYXJzZUludCIsImdldEVsZW1lbnRTdHlsZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJzZWxlY3RQcm9wIiwibWFrZUVsZW1lbnRVbnNlbGVjdGFibGUiLCJvbnNlbGVjdHN0YXJ0IiwidW5zZWxlY3RhYmxlIiwibWFrZUVsZW1lbnRTZWxlY3RhYmxlIiwiZ2V0Tm9kZUNhbnZhcyIsImltcGwiLCJfY2FudmFzIiwiX2ltYWdlIiwiY2xlYW5VcEpzZG9tTm9kZSIsIl9jdXJyZW50U3JjIiwiX2F0dHJpYnV0ZXMiLCJfY2xhc3NMaXN0Iiwic2V0SW1hZ2VTbW9vdGhpbmciLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJ3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJtb3pJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJtc0ltYWdlU21vb3RoaW5nRW5hYmxlZCIsIm9JbWFnZVNtb290aGluZ0VuYWJsZWQiLCJhZGRQYXJhbVRvVXJsIiwicGFyYW0iLCJlbXB0eUZuIiwicmVxdWVzdCIsIm9uQ29tcGxldGUiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInBhcmFtZXRlcnMiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJzZW5kIiwid2FybiIsIlJVTk5JTkdfQU5JTUFUSU9OUyIsImNhbmNlbEFsbCIsImFuaW1hdGlvbnMiLCJhbmltYXRpb24iLCJjYW5jZWwiLCJjYW5jZWxCeUNhbnZhcyIsImNhbmNlbGxlZCIsImNhbmNlbEJ5VGFyZ2V0IiwiZmluZEFuaW1hdGlvbnNCeVRhcmdldCIsImZpbmRBbmltYXRpb25JbmRleCIsImNhbmNlbEZ1bmMiLCJmaW5kQW5pbWF0aW9uIiwibm9vcCIsImRlZmF1bHRFYXNpbmciLCJkIiwiYW5pbWF0ZSIsInJlbW92ZUZyb21SZWdpc3RyeSIsInJ1bm5pbmdBbmltYXRpb25zIiwiY3VycmVudFZhbHVlIiwic3RhcnRWYWx1ZSIsImNvbXBsZXRpb25SYXRlIiwiZHVyYXRpb25SYXRlIiwicmVxdWVzdEFuaW1GcmFtZSIsInRpbWVzdGFtcCIsInN0YXJ0IiwiRGF0ZSIsImR1cmF0aW9uIiwiZmluaXNoIiwidGltZSIsIm9uQ2hhbmdlIiwiYWJvcnQiLCJlYXNpbmciLCJpc01hbnkiLCJlbmRWYWx1ZSIsImJ5VmFsdWUiLCJvblN0YXJ0IiwidGljayIsInRpY2t0aW1lIiwiY3VycmVudFRpbWUiLCJ0aW1lUGVyYyIsIl92YWx1ZSIsInZhbHVlUGVyYyIsIl9yZXF1ZXN0QW5pbUZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsIl9jYW5jZWxBbmltRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImNhbmNlbEFuaW1GcmFtZSIsImNhbGN1bGF0ZUNvbG9yIiwiYmVnaW4iLCJlbmQiLCJwb3MiLCJjb2xvciIsImFuaW1hdGVDb2xvciIsImZyb21Db2xvciIsInRvQ29sb3IiLCJzdGFydENvbG9yIiwiQ29sb3IiLCJnZXRTb3VyY2UiLCJlbmRDb2xvciIsIm9yaWdpbmFsT25Db21wbGV0ZSIsIm9yaWdpbmFsT25DaGFuZ2UiLCJwb3NWYWx1ZSIsImNvbG9yRWFzaW5nIiwiaXNBcnJheSIsIm5vcm1hbGl6ZSIsImFzaW4iLCJlbGFzdGljIiwib3B0cyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5TaW5lIiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRTaW5lIiwiZWFzZUluRXhwbyIsImVhc2VPdXRFeHBvIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbkNpcmMiLCJlYXNlT3V0Q2lyYyIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5FbGFzdGljIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJlYXNlSW5PdXRCb3VuY2UiLCJlYXNlIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwic3ZnVmFsaWRUYWdOYW1lcyIsInN2Z1ZpZXdCb3hFbGVtZW50cyIsInN2Z0ludmFsaWRBbmNlc3RvcnMiLCJzdmdWYWxpZFBhcmVudHMiLCJhdHRyaWJ1dGVzTWFwIiwiZGlzcGxheSIsInZpc2liaWxpdHkiLCJjb2xvckF0dHJpYnV0ZXMiLCJzdHJva2UiLCJmU2l6ZSIsImNQYXRoIiwic3ZnVmFsaWRUYWdOYW1lc1JlZ0V4IiwiZ2V0U3ZnUmVnZXgiLCJzdmdWaWV3Qm94RWxlbWVudHNSZWdFeCIsInN2Z0ludmFsaWRBbmNlc3RvcnNSZWdFeCIsInN2Z1ZhbGlkUGFyZW50c1JlZ0V4IiwiY3NzUnVsZXMiLCJncmFkaWVudERlZnMiLCJjbGlwUGF0aHMiLCJub3JtYWxpemVBdHRyIiwibm9ybWFsaXplVmFsdWUiLCJwYXJlbnRBdHRyaWJ1dGVzIiwicGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUiLCJ2aXNpYmxlIiwiZmlsbEluZGV4Iiwic3Ryb2tlSW5kZXgiLCJfc2V0U3Ryb2tlRmlsbE9wYWNpdHkiLCJzZXRBbHBoYSIsImdldEFscGhhIiwidG9SZ2JhIiwiX2dldE11bHRpcGxlTm9kZXMiLCJub2RlTmFtZXMiLCJub2RlTmFtZSIsIm5vZGVBcnJheSIsIm5vZGVMaXN0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJyb3RhdGVNYXRyaXgiLCJtdWx0aXBsaWVyWCIsIm11bHRpcGxpZXJZIiwic2tld01hdHJpeCIsInRyYW5zbGF0ZU1hdHJpeCIsInNjYWxlIiwidHJhbnNsYXRlIiwidHJhbnNmb3JtcyIsInRyYW5zZm9ybUxpc3QiLCJyZVRyYW5zZm9ybUxpc3QiLCJyZVRyYW5zZm9ybSIsImF0dHJpYnV0ZVZhbHVlIiwibWF0cmljZXMiLCJvcGVyYXRpb24iLCJjb21iaW5lZE1hdHJpeCIsInBhcnNlU3R5bGVTdHJpbmciLCJvU3R5bGUiLCJjaHVuayIsInBhaXIiLCJwYXJzZVN0eWxlT2JqZWN0IiwiZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudCIsInN2Z1VpZCIsInJ1bGUiLCJlbGVtZW50TWF0Y2hlc1J1bGUiLCJzZWxlY3RvcnMiLCJmaXJzdE1hdGNoaW5nIiwicGFyZW50TWF0Y2hpbmciLCJzZWxlY3Rvck1hdGNoZXMiLCJkb2VzU29tZVBhcmVudE1hdGNoIiwic2VsZWN0b3IiLCJjbGFzc05hbWVzIiwiZ2V0QXR0cmlidXRlIiwibWF0Y2hlciIsImVsZW1lbnRCeUlkIiwibm9kZSIsIm5vZGVsaXN0IiwicGFyc2VVc2VEaXJlY3RpdmVzIiwieGxpbmtBdHRyaWJ1dGUiLCJ4bGluayIsInN1YnN0ciIsImVsMiIsImNsb25lTm9kZSIsImN1cnJlbnRUcmFucyIsIm9sZExlbmd0aCIsImF0dHJzIiwiYXBwbHlWaWV3Ym94VHJhbnNmb3JtIiwiZWwzIiwiY3JlYXRlRWxlbWVudE5TIiwic2V0QXR0cmlidXRlTlMiLCJub2RlVmFsdWUiLCJmaXJzdENoaWxkIiwicmVtb3ZlQXR0cmlidXRlIiwicmVWaWV3Qm94QXR0clZhbHVlIiwidmlld0JveEF0dHIiLCJ2aWV3Qm94V2lkdGgiLCJ2aWV3Qm94SGVpZ2h0Iiwid2lkdGhBdHRyIiwiaGVpZ2h0QXR0ciIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJtaXNzaW5nVmlld0JveCIsIm1pc3NpbmdEaW1BdHRyIiwidG9CZVBhcnNlZCIsInBhcnNlZERpbSIsIndpZHRoRGlmZiIsImhlaWdodERpZmYiLCJoYXNBbmNlc3RvcldpdGhOb2RlTmFtZSIsInBhcnNlU1ZHRG9jdW1lbnQiLCJwYXJzaW5nT3B0aW9ucyIsIl9fdWlkIiwiZGVzY2VuZGFudHMiLCJzZWxlY3ROb2RlcyIsImdldEdyYWRpZW50RGVmcyIsImdldENTU1J1bGVzIiwicGFyc2VFbGVtZW50cyIsImluc3RhbmNlcyIsInJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayIsImdyYWRpZW50IiwiZ3JhZGllbnRzQXR0cnMiLCJ4bGlua0F0dHIiLCJ4TGluayIsInJlZmVyZW5jZWRHcmFkaWVudCIsImhhc0F0dHJpYnV0ZSIsImNoaWxkcmVuIiwicmVmZXJlbmNlQ2xvbmUiLCJyZUZvbnREZWNsYXJhdGlvbiIsInBhcnNlRm9udERlY2xhcmF0aW9uIiwiZm9udFN0eWxlIiwiZm9udFdlaWdodCIsImxpbmVIZWlnaHQiLCJ0YWdBcnJheSIsImVsTGlzdCIsInBhcnNlQXR0cmlidXRlcyIsInBhcmVudEZvbnRTaXplIiwib3duQXR0cmlidXRlcyIsImNzc0F0dHJzIiwicGFyc2VTdHlsZUF0dHJpYnV0ZSIsIm5vcm1hbGl6ZWRBdHRyIiwibm9ybWFsaXplZFZhbHVlIiwibm9ybWFsaXplZFN0eWxlIiwiZm9udCIsIm1lcmdlZEF0dHJzIiwiRWxlbWVudHNQYXJzZXIiLCJwYXJzZSIsInBhcnNlUG9pbnRzQXR0cmlidXRlIiwicGFyc2VkUG9pbnRzIiwiYWxsUnVsZXMiLCJydWxlcyIsInN0eWxlQ29udGVudHMiLCJ0ZXh0Q29udGVudCIsInJ1bGVPYmoiLCJkZWNsYXJhdGlvbiIsInByb3BlcnR5VmFsdWVQYWlycyIsIl9ydWxlIiwibG9hZFNWR0Zyb21VUkwiLCJ4bWwiLCJyZXNwb25zZVhNTCIsInJlc3VsdHMiLCJfb3B0aW9ucyIsImFsbEVsZW1lbnRzIiwibG9hZFNWR0Zyb21TdHJpbmciLCJwYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJyZWdleFVybCIsInByb3RvIiwibnVtRWxlbWVudHMiLCJjcmVhdGVPYmplY3RzIiwiY3JlYXRlT2JqZWN0IiwiZmluZFRhZyIsImZyb21FbGVtZW50IiwiY3JlYXRlQ2FsbGJhY2siLCJjaGVja0lmRG9uZSIsInJlc29sdmVHcmFkaWVudCIsIkltYWdlIiwiX29yaWdpbmFsRWxlbWVudCIsIl9yZW1vdmVUcmFuc2Zvcm1NYXRyaXgiLCJyZXNvbHZlQ2xpcFBhdGgiLCJleHRyYWN0UHJvcGVydHlEZWZpbml0aW9uIiwic3RvcmFnZSIsInJlZ2V4IiwibGFzdEluZGV4IiwiZ3JhZGllbnREZWYiLCJvcGFjaXR5QXR0ciIsImNyZWF0ZUNsaXBQYXRoQ2FsbGJhY2siLCJjb250YWluZXIiLCJfbmV3T2JqIiwiZmlsbFJ1bGUiLCJjbGlwUnVsZSIsInVzaW5nRWxlbWVudCIsIm9ialRyYW5zZm9ybUludiIsImdUcmFuc2Zvcm0iLCJjbGlwUGF0aFRhZyIsImNsaXBQYXRoT3duZXIiLCJ0aGF0Iiwic2NhbGFyQWRkIiwic2NhbGFyQWRkRXF1YWxzIiwic3VidHJhY3RFcXVhbHMiLCJzY2FsYXJTdWJ0cmFjdCIsInNjYWxhclN1YnRyYWN0RXF1YWxzIiwibXVsdGlwbHlFcXVhbHMiLCJkaXZpZGUiLCJkaXZpZGVFcXVhbHMiLCJsdCIsImx0ZSIsImd0IiwiZ3RlIiwiZGlzdGFuY2VGcm9tIiwiZHgiLCJkeSIsInNldFhZIiwic2V0WCIsInNldFkiLCJzZXRGcm9tUG9pbnQiLCJzd2FwIiwiSW50ZXJzZWN0aW9uIiwic3RhdHVzIiwiYXBwZW5kUG9pbnQiLCJhcHBlbmRQb2ludHMiLCJpbnRlcnNlY3RMaW5lTGluZSIsImExIiwiYTIiLCJiMSIsImIyIiwidWFUIiwidWJUIiwidUIiLCJ1YSIsInViIiwiaW50ZXJzZWN0TGluZVBvbHlnb24iLCJpbnRlciIsImludGVyc2VjdFBvbHlnb25Qb2x5Z29uIiwicG9pbnRzMSIsInBvaW50czIiLCJpbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlIiwicjEiLCJyMiIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImludGVyMSIsImludGVyMiIsImludGVyMyIsImludGVyNCIsInNldFNvdXJjZSIsIl90cnlQYXJzaW5nQ29sb3IiLCJjb2xvck5hbWVNYXAiLCJzb3VyY2VGcm9tSGV4Iiwic291cmNlRnJvbVJnYiIsInNvdXJjZUZyb21Ic2wiLCJfcmdiVG9Ic2wiLCJnIiwicm91bmQiLCJfc291cmNlIiwidG9SZ2IiLCJ0b0hzbCIsImhzbCIsInRvSHNsYSIsInRvSGV4IiwidG9IZXhhIiwidG9HcmF5c2NhbGUiLCJhdmVyYWdlIiwiY3VycmVudEFscGhhIiwidG9CbGFja1doaXRlIiwidGhyZXNob2xkIiwib3ZlcmxheVdpdGgiLCJvdGhlckNvbG9yIiwib3RoZXJBbHBoYSIsIm90aGVyU291cmNlIiwicmVSR0JhIiwicmVIU0xhIiwicmVIZXgiLCJhbGljZWJsdWUiLCJhbnRpcXVld2hpdGUiLCJhcXVhIiwiYXF1YW1hcmluZSIsImF6dXJlIiwiYmVpZ2UiLCJiaXNxdWUiLCJibGFjayIsImJsYW5jaGVkYWxtb25kIiwiYmx1ZSIsImJsdWV2aW9sZXQiLCJicm93biIsImJ1cmx5d29vZCIsImNhZGV0Ymx1ZSIsImNoYXJ0cmV1c2UiLCJjaG9jb2xhdGUiLCJjb3JhbCIsImNvcm5mbG93ZXJibHVlIiwiY29ybnNpbGsiLCJjcmltc29uIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJkYXJrZ3JleSIsImRhcmtncmVlbiIsImRhcmtraGFraSIsImRhcmttYWdlbnRhIiwiZGFya29saXZlZ3JlZW4iLCJkYXJrb3JhbmdlIiwiZGFya29yY2hpZCIsImRhcmtyZWQiLCJkYXJrc2FsbW9uIiwiZGFya3NlYWdyZWVuIiwiZGFya3NsYXRlYmx1ZSIsImRhcmtzbGF0ZWdyYXkiLCJkYXJrc2xhdGVncmV5IiwiZGFya3R1cnF1b2lzZSIsImRhcmt2aW9sZXQiLCJkZWVwcGluayIsImRlZXBza3libHVlIiwiZGltZ3JheSIsImRpbWdyZXkiLCJkb2RnZXJibHVlIiwiZmlyZWJyaWNrIiwiZmxvcmFsd2hpdGUiLCJmb3Jlc3RncmVlbiIsImZ1Y2hzaWEiLCJnYWluc2Jvcm8iLCJnaG9zdHdoaXRlIiwiZ29sZCIsImdvbGRlbnJvZCIsImdyYXkiLCJncmV5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZXkiLCJsaWdodGdyZWVuIiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlYmVjY2FwdXJwbGUiLCJyZWQiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsImh1ZTJyZ2IiLCJmcm9tUmdiIiwiZnJvbVNvdXJjZSIsImZyb21SZ2JhIiwiZnJvbUhzbCIsImZyb21Ic2xhIiwiZnJvbUhleCIsImlzU2hvcnROb3RhdGlvbiIsImlzUkdCYSIsIm9Db2xvciIsInNjYWxlTWFwIiwic2tld01hcCIsImNvbnRyb2xzIiwiTEVGVCIsIlRPUCIsIlJJR0hUIiwiQk9UVE9NIiwiQ0VOVEVSIiwib3Bwb3NpdGUiLCJib3R0b20iLCJyaWdodCIsImZpbmRDb3JuZXJRdWFkcmFudCIsImZhYnJpY09iamVjdCIsImNvbnRyb2wiLCJjb3JuZXJBbmdsZSIsImZpcmVFdmVudCIsImNhbnZhc09wdGlvbnMiLCJzY2FsZUlzUHJvcG9ydGlvbmFsIiwiZXZlbnREYXRhIiwidW5pU2NhbGVLZXkiLCJ1bmlmb3JtSXNUb2dnbGVkIiwidW5pZm9ybVNjYWxpbmciLCJpc1RyYW5zZm9ybUNlbnRlcmVkIiwib3JpZ2luWCIsIm9yaWdpblkiLCJzY2FsaW5nSXNGb3JiaWRkZW4iLCJieSIsInNjYWxlUHJvcG9ydGlvbmFsbHkiLCJsb2NrWCIsImxvY2tTY2FsaW5nWCIsImxvY2tZIiwibG9ja1NjYWxpbmdZIiwic2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIiLCJub3RBbGxvd2VkIiwibiIsInNrZXdDdXJzb3JTdHlsZUhhbmRsZXIiLCJsb2NrU2tld2luZ1kiLCJsb2NrU2tld2luZ1giLCJzY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIiLCJhbHRBY3Rpb25LZXkiLCJzY2FsZU9yU2tld0FjdGlvbk5hbWUiLCJpc0FsdGVybmF0aXZlIiwicm90YXRpb25TdHlsZUhhbmRsZXIiLCJsb2NrUm90YXRpb24iLCJjdXJzb3JTdHlsZSIsImNvbW1vbkV2ZW50SW5mbyIsImUiLCJwb2ludGVyIiwid3JhcFdpdGhGaXhlZEFuY2hvciIsImFjdGlvbkhhbmRsZXIiLCJnZXRDZW50ZXJQb2ludCIsImNvbnN0cmFpbnQiLCJ0cmFuc2xhdGVUb09yaWdpblBvaW50IiwiYWN0aW9uUGVyZm9ybWVkIiwid3JhcFdpdGhGaXJlRXZlbnQiLCJnZXRMb2NhbFBvaW50IiwiY29ybmVyIiwiZ2V0Wm9vbSIsInBhZGRpbmciLCJsb2NhbFBvaW50IiwidG9Mb2NhbFBvaW50Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJ0YXJnZXRIYXNPbmVGbGlwIiwiY29tcGVuc2F0ZVNjYWxlRm9yU2tldyIsIm9wcG9zaXRlU2tldyIsInNjYWxlVG9Db21wZW5zYXRlIiwiYXhpcyIsInJlZmVyZW5jZSIsIm5ld0RpbSIsIl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMiLCJuZXdWYWx1ZSIsInNrZXdPYmplY3RYIiwiZGltTm9Ta2V3IiwidG90YWxTa2V3U2l6ZSIsImN1cnJlbnRTa2V3IiwibmV3U2tldyIsImhhc1NrZXdlZCIsImRpbUJlZm9yZVNrZXdpbmciLCJza2V3T2JqZWN0WSIsInNrZXdIYW5kbGVyWCIsImxvY2FsUG9pbnRGcm9tQ2VudGVyIiwiZmluYWxIYW5kbGVyIiwic2tld0hhbmRsZXJZIiwicm90YXRpb25XaXRoU25hcHBpbmciLCJwaXZvdFBvaW50IiwibGFzdEFuZ2xlIiwiZXkiLCJleCIsImN1ckFuZ2xlIiwiaGFzUm90YXRlZCIsInNuYXBBbmdsZSIsInNuYXBUaHJlc2hvbGQiLCJyaWdodEFuZ2xlTG9ja2VkIiwibGVmdEFuZ2xlTG9ja2VkIiwic2NhbGVPYmplY3QiLCJkaW0iLCJmb3JiaWRTY2FsaW5nIiwic2lnblgiLCJzaWduWSIsImdlc3R1cmVTY2FsZSIsImxvY2tTY2FsaW5nRmxpcCIsIm9yaWdpbmFsIiwib3JpZ2luYWxEaXN0YW5jZSIsIm9sZFNjYWxlWCIsIm9sZFNjYWxlWSIsInNjYWxlT2JqZWN0RnJvbUNvcm5lciIsInNjYWxlT2JqZWN0WCIsInNjYWxlT2JqZWN0WSIsInNjYWxpbmdZT3JTa2V3aW5nWCIsInNjYWxpbmdZIiwic2NhbGluZ1hPclNrZXdpbmdZIiwic2NhbGluZ1giLCJjaGFuZ2VXaWR0aCIsInN0cm9rZVBhZGRpbmciLCJtdWx0aXBsaWVyIiwib2xkV2lkdGgiLCJuZXdXaWR0aCIsImRyYWdIYW5kbGVyIiwibmV3TGVmdCIsIm5ld1RvcCIsIm1vdmVYIiwibW92ZVkiLCJzY2FsaW5nRXF1YWxseSIsImNvbnRyb2xzVXRpbHMiLCJyZW5kZXJDaXJjbGVDb250cm9sIiwic3R5bGVPdmVycmlkZSIsInhTaXplIiwic2l6ZVgiLCJjb3JuZXJTaXplIiwieVNpemUiLCJzaXplWSIsInRyYW5zcGFyZW50Q29ybmVycyIsImNvcm5lclN0cm9rZUNvbG9yIiwibXlMZWZ0IiwibXlUb3AiLCJzYXZlIiwiZmlsbFN0eWxlIiwiY29ybmVyQ29sb3IiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsImFyYyIsInJlc3RvcmUiLCJyZW5kZXJTcXVhcmVDb250cm9sIiwieFNpemVCeTIiLCJ5U2l6ZUJ5MiIsInN0cm9rZVJlY3QiLCJDb250cm9sIiwiYWN0aW9uTmFtZSIsInRvdWNoU2l6ZVgiLCJ0b3VjaFNpemVZIiwid2l0aENvbm5lY3Rpb24iLCJtb3VzZURvd25IYW5kbGVyIiwibW91c2VVcEhhbmRsZXIiLCJnZXRBY3Rpb25IYW5kbGVyIiwiZ2V0TW91c2VEb3duSGFuZGxlciIsImdldE1vdXNlVXBIYW5kbGVyIiwiY3Vyc29yU3R5bGVIYW5kbGVyIiwiZ2V0QWN0aW9uTmFtZSIsImdldFZpc2liaWxpdHkiLCJjb250cm9sS2V5Iiwib2JqZWN0VmlzaWJpbGl0eSIsIl9jb250cm9sc1Zpc2liaWxpdHkiLCJzZXRWaXNpYmlsaXR5IiwicG9zaXRpb25IYW5kbGVyIiwiZmluYWxNYXRyaXgiLCJjYWxjQ29ybmVyQ29vcmRzIiwib2JqZWN0QW5nbGUiLCJvYmplY3RDb3JuZXJTaXplIiwiY2VudGVyWCIsImNlbnRlclkiLCJpc1RvdWNoIiwiY29zSGFsZk9mZnNldCIsInNpbkhhbGZPZmZzZXQiLCJjb3NIYWxmT2Zmc2V0Q29tcCIsInNpbkhhbGZPZmZzZXRDb21wIiwiY29udHJvbFRyaWFuZ2xlQW5nbGUiLCJjb3JuZXJIeXBvdGVudXNlIiwibmV3VGhldGEiLCJuZXdUaGV0YUNvbXAiLCJ0bCIsInRyIiwiYmwiLCJiciIsInJlbmRlciIsImNvcm5lclN0eWxlIiwiZ2V0Q29sb3JTdG9wIiwiY29sb3JBbHBoYSIsImtleVZhbHVlUGFpcnMiLCJnZXRMaW5lYXJDb29yZHMiLCJnZXRSYWRpYWxDb29yZHMiLCJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50VW5pdHMiLCJrZXlzIiwib3B0aW9uIiwiYWRkQ29sb3JTdG9wIiwidG9PYmplY3QiLCJwcm9wZXJ0aWVzVG9JbmNsdWRlIiwidG9TVkciLCJtYXJrdXAiLCJjb21tb25BdHRyaWJ1dGVzIiwibmVlZHNTd2FwIiwid2l0aFZpZXdwb3J0IiwiYWRkaXRpb25hbFRyYW5zZm9ybSIsInNvcnQiLCJyZXZlcnNlIiwibWluUmFkaXVzIiwibWF4UmFkaXVzIiwicGVyY2VudGFnZVNoaWZ0IiwiY29sb3JTdG9wIiwidG9MaXZlIiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImluc3RhbmNlIiwic3ZnT3B0aW9ucyIsImNvbG9yU3RvcEVscyIsIl9fY29udmVydFBlcmNlbnRVbml0c1RvVmFsdWVzIiwicHJvcFZhbHVlIiwiZmluYWxWYWx1ZSIsInJlcGVhdCIsInBhdHRlcm5UcmFuc2Zvcm0iLCJzZXRPcHRpb25zIiwiaXNFcnJvciIsInBhdHRlcm5Tb3VyY2UiLCJwYXR0ZXJuV2lkdGgiLCJwYXR0ZXJuSGVpZ2h0IiwicGF0dGVybk9mZnNldFgiLCJwYXR0ZXJuT2Zmc2V0WSIsInBhdHRlcm5JbWdTcmMiLCJjb21wbGV0ZSIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJjcmVhdGVQYXR0ZXJuIiwiU2hhZG93IiwiYmx1ciIsImFmZmVjdFN0cm9rZSIsImluY2x1ZGVEZWZhdWx0VmFsdWVzIiwibm9uU2NhbGluZyIsIl9wYXJzZVNoYWRvdyIsInNoYWRvdyIsInNoYWRvd1N0ciIsIm9mZnNldHNBbmRCbHVyIiwicmVPZmZzZXRzQW5kQmx1ciIsImZCb3hYIiwiZkJveFkiLCJCTFVSX0JPWCIsIlN0YXRpY0NhbnZhcyIsIkNBTlZBU19JTklUX0VSUk9SIiwiRXJyb3IiLCJyZW5kZXJBbmRSZXNldEJvdW5kIiwicmVuZGVyQW5kUmVzZXQiLCJyZXF1ZXN0UmVuZGVyQWxsQm91bmQiLCJfaW5pdFN0YXRpYyIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRJbWFnZSIsIm92ZXJsYXlDb2xvciIsIm92ZXJsYXlJbWFnZSIsInN0YXRlZnVsIiwiY29udHJvbHNBYm92ZU92ZXJsYXkiLCJhbGxvd1RvdWNoU2Nyb2xsaW5nIiwidmlld3BvcnRUcmFuc2Zvcm0iLCJiYWNrZ3JvdW5kVnB0Iiwib3ZlcmxheVZwdCIsImVuYWJsZVJldGluYVNjYWxpbmciLCJ2cHRDb29yZHMiLCJza2lwT2Zmc2NyZWVuIiwiY2IiLCJfY3JlYXRlTG93ZXJDYW52YXMiLCJfaW5pdE9wdGlvbnMiLCJpbnRlcmFjdGl2ZSIsIl9pbml0UmV0aW5hU2NhbGluZyIsInNldE92ZXJsYXlJbWFnZSIsInNldEJhY2tncm91bmRJbWFnZSIsInNldEJhY2tncm91bmRDb2xvciIsInNldE92ZXJsYXlDb2xvciIsImNhbGNPZmZzZXQiLCJfaXNSZXRpbmFTY2FsaW5nIiwiZ2V0UmV0aW5hU2NhbGluZyIsInNjYWxlUmF0aW8iLCJfX2luaXRSZXRpbmFTY2FsaW5nIiwibG93ZXJDYW52YXNFbCIsImNvbnRleHRDb250YWluZXIiLCJ1cHBlckNhbnZhc0VsIiwiY29udGV4dFRvcCIsIl9vZmZzZXQiLCJpbWFnZSIsIl9fc2V0QmdPdmVybGF5SW1hZ2UiLCJfX3NldEJnT3ZlcmxheUNvbG9yIiwiX2NyZWF0ZUNhbnZhc0VsZW1lbnQiLCJfb3JpZ2luYWxDYW52YXNTdHlsZSIsIl9hcHBseUNhbnZhc1N0eWxlIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJzZXRXaWR0aCIsInNldERpbWVuc2lvbnMiLCJzZXRIZWlnaHQiLCJkaW1lbnNpb25zIiwiY3NzVmFsdWUiLCJjc3NPbmx5IiwiX3NldEJhY2tzdG9yZURpbWVuc2lvbiIsImhhc0xvc3RDb250ZXh0IiwiYmFja3N0b3JlT25seSIsIl9zZXRDc3NEaW1lbnNpb24iLCJfaXNDdXJyZW50bHlEcmF3aW5nIiwiZnJlZURyYXdpbmdCcnVzaCIsIl9zZXRCcnVzaFN0eWxlcyIsImNhY2hlQ2FudmFzRWwiLCJ3cmFwcGVyRWwiLCJzZXRWaWV3cG9ydFRyYW5zZm9ybSIsInZwdCIsImFjdGl2ZU9iamVjdCIsIl9hY3RpdmVPYmplY3QiLCJiYWNrZ3JvdW5kT2JqZWN0Iiwib3ZlcmxheU9iamVjdCIsImdyb3VwIiwic2V0Q29vcmRzIiwiY2FsY1ZpZXdwb3J0Qm91bmRhcmllcyIsInpvb21Ub1BvaW50IiwiYmVmb3JlIiwiYWZ0ZXIiLCJzZXRab29tIiwiYWJzb2x1dGVQYW4iLCJyZWxhdGl2ZVBhbiIsImdldEVsZW1lbnQiLCJzZXR1cFN0YXRlIiwiY2xlYXJDb250ZXh0IiwiY2xlYXJSZWN0IiwiY2xlYXIiLCJfaGFzSVRleHRIYW5kbGVycyIsIl9tb3VzZVVwSVRleHRIYW5kbGVyIiwiX2lUZXh0SW5zdGFuY2VzIiwicmVuZGVyQWxsIiwiY2FudmFzVG9EcmF3T24iLCJyZW5kZXJDYW52YXMiLCJpc1JlbmRlcmluZyIsImlWcHQiLCJjYW5jZWxSZXF1ZXN0ZWRSZW5kZXIiLCJfcmVuZGVyQmFja2dyb3VuZCIsIl9yZW5kZXJPYmplY3RzIiwiZHJhd0NvbnRyb2xzIiwic2hvdWxkQ2FjaGUiLCJfdHJhbnNmb3JtRG9uZSIsInJlbmRlckNhY2hlIiwiZm9yQ2xpcHBpbmciLCJkcmF3Q2xpcFBhdGhPbkNhbnZhcyIsIl9yZW5kZXJPdmVybGF5IiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiem9vbVgiLCJ6b29tWSIsIl9jYWNoZUNhbnZhcyIsImNhY2hlVHJhbnNsYXRpb25YIiwiY2FjaGVUcmFuc2xhdGlvblkiLCJfcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheSIsIm5lZWRzVnB0IiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwiZ2V0Q2VudGVyIiwiY2VudGVyT2JqZWN0SCIsIl9jZW50ZXJPYmplY3QiLCJjZW50ZXJPYmplY3RWIiwiY2VudGVyT2JqZWN0Iiwidmlld3BvcnRDZW50ZXJPYmplY3QiLCJ2cENlbnRlciIsImdldFZwQ2VudGVyIiwidmlld3BvcnRDZW50ZXJPYmplY3RIIiwidmlld3BvcnRDZW50ZXJPYmplY3RWIiwidG9EYXRhbGVzc0pTT04iLCJ0b0RhdGFsZXNzT2JqZWN0IiwiX3RvT2JqZWN0TWV0aG9kIiwiX3RvT2JqZWN0cyIsImV4Y2x1ZGVGcm9tRXhwb3J0IiwiX3RvT2JqZWN0IiwiX19zZXJpYWxpemVCZ092ZXJsYXkiLCJvcmlnaW5hbFZhbHVlIiwiYmdJbWFnZSIsImJnQ29sb3IiLCJiYWNrZ3JvdW5kIiwib3ZlcmxheSIsInN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb24iLCJfc2V0U1ZHUHJlYW1ibGUiLCJfc2V0U1ZHSGVhZGVyIiwiY2xpcFBhdGhJZCIsIl9zZXRTVkdCZ092ZXJsYXlDb2xvciIsIl9zZXRTVkdCZ092ZXJsYXlJbWFnZSIsIl9zZXRTVkdPYmplY3RzIiwic3VwcHJlc3NQcmVhbWJsZSIsImVuY29kaW5nIiwidmlld0JveCIsImNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cCIsImNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwIiwiY3JlYXRlU1ZHQ2xpcFBhdGhNYXJrdXAiLCJ0b0NsaXBQYXRoU1ZHIiwic2hvdWxkVHJhbnNmb3JtIiwiZm9udExpc3QiLCJyb3ciLCJyb3dJbmRleCIsIl9jaGFyIiwiY2hhckluZGV4IiwiX3NldFNWR09iamVjdCIsImZpbmFsV2lkdGgiLCJmaW5hbEhlaWdodCIsInNob3VsZEludmVydCIsInNlbmRUb0JhY2siLCJhY3RpdmVTZWxlY3Rpb24iLCJvYmpzIiwidW5zaGlmdCIsImJyaW5nVG9Gcm9udCIsInNlbmRCYWNrd2FyZHMiLCJpbnRlcnNlY3RpbmciLCJuZXdJZHgiLCJvYmpzTW92ZWQiLCJfZmluZE5ld0xvd2VySW5kZXgiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdHNXaXRoT2JqZWN0IiwiaXNDb250YWluZWRXaXRoaW5PYmplY3QiLCJicmluZ0ZvcndhcmQiLCJfZmluZE5ld1VwcGVySW5kZXgiLCJkaXNwb3NlIiwiY2xhc3NMaXN0IiwiRGF0YVVSTEV4cG9ydGVyIiwiRU1QVFlfSlNPTiIsInN1cHBvcnRzIiwic2V0TGluZURhc2giLCJ0b0pTT04iLCJjcmVhdGVQTkdTdHJlYW0iLCJjcmVhdGVKUEVHU3RyZWFtIiwiQmFzZUJydXNoIiwic3Ryb2tlTGluZUNhcCIsInN0cm9rZURhc2hBcnJheSIsImxpbWl0ZWRUb0NhbnZhc1NpemUiLCJsaW5lQ2FwIiwibWl0ZXJMaW1pdCIsImxpbmVKb2luIiwiX3NhdmVBbmRUcmFuc2Zvcm0iLCJfc2V0U2hhZG93Iiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwic2hhZG93T2Zmc2V0WCIsInNoYWRvd09mZnNldFkiLCJuZWVkc0Z1bGxSZW5kZXIiLCJfcmVzZXRTaGFkb3ciLCJfaXNPdXRTaWRlQ2FudmFzIiwiUGVuY2lsQnJ1c2giLCJkZWNpbWF0ZSIsImRyYXdTdHJhaWdodExpbmUiLCJzdHJhaWdodExpbmVLZXkiLCJfcG9pbnRzIiwiX2hhc1N0cmFpZ2h0TGluZSIsIl9kcmF3U2VnbWVudCIsInF1YWRyYXRpY0N1cnZlVG8iLCJvbk1vdXNlRG93biIsIl9pc01haW5FdmVudCIsIl9wcmVwYXJlRm9yRHJhd2luZyIsIl9jYXB0dXJlRHJhd2luZ1BhdGgiLCJfcmVuZGVyIiwib25Nb3VzZU1vdmUiLCJvbGRFbmQiLCJvbk1vdXNlVXAiLCJfZmluYWxpemVBbmRBZGRQYXRoIiwiX3Jlc2V0IiwiX2FkZFBvaW50IiwicG9pbnRlclBvaW50IiwiY29udmVydFBvaW50c1RvU1ZHUGF0aCIsIl9pc0VtcHR5U1ZHUGF0aCIsImNyZWF0ZVBhdGgiLCJQYXRoIiwiZGVjaW1hdGVQb2ludHMiLCJhZGp1c3RlZERpc3RhbmNlIiwibGFzdFBvaW50IiwibmV3UG9pbnRzIiwiY0Rpc3RhbmNlIiwiQ2lyY2xlQnJ1c2giLCJkcmF3RG90IiwiYWRkUG9pbnQiLCJkb3QiLCJyYWRpdXMiLCJvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlIiwiY2lyY2xlcyIsImNpcmNsZSIsIkNpcmNsZSIsImNpcmNsZVJhZGl1cyIsImNpcmNsZUNvbG9yIiwiU3ByYXlCcnVzaCIsImRlbnNpdHkiLCJkb3RXaWR0aCIsImRvdFdpZHRoVmFyaWFuY2UiLCJyYW5kb21PcGFjaXR5Iiwib3B0aW1pemVPdmVybGFwcGluZyIsInNwcmF5Q2h1bmtzIiwiYWRkU3ByYXlDaHVuayIsInNwcmF5Q2h1bmtQb2ludHMiLCJyZWN0cyIsImlsZW4iLCJzcHJheUNodW5rIiwicmVjdCIsIlJlY3QiLCJfZ2V0T3B0aW1pemVkUmVjdHMiLCJ1bmlxdWVSZWN0cyIsInVuaXF1ZVJlY3RzQXJyYXkiLCJnbG9iYWxBbHBoYSIsImZpbGxSZWN0IiwiUGF0dGVybkJydXNoIiwiZ2V0UGF0dGVyblNyYyIsImRvdERpc3RhbmNlIiwicGF0dGVybkNhbnZhcyIsInBhdHRlcm5DdHgiLCJnZXRQYXR0ZXJuU3JjRnVuY3Rpb24iLCJTdHJpbmciLCJnZXRQYXR0ZXJuIiwidG9wTGVmdCIsIl9nZXRMZWZ0VG9wQ29vcmRzIiwiX2luaXRJbnRlcmFjdGl2ZSIsIl9jcmVhdGVDYWNoZUNhbnZhcyIsImNlbnRlcmVkU2NhbGluZyIsImNlbnRlcmVkUm90YXRpb24iLCJjZW50ZXJlZEtleSIsInNlbGVjdGlvbiIsInNlbGVjdGlvbktleSIsImFsdFNlbGVjdGlvbktleSIsInNlbGVjdGlvbkNvbG9yIiwic2VsZWN0aW9uRGFzaEFycmF5Iiwic2VsZWN0aW9uQm9yZGVyQ29sb3IiLCJzZWxlY3Rpb25MaW5lV2lkdGgiLCJzZWxlY3Rpb25GdWxseUNvbnRhaW5lZCIsImhvdmVyQ3Vyc29yIiwibW92ZUN1cnNvciIsImRlZmF1bHRDdXJzb3IiLCJmcmVlRHJhd2luZ0N1cnNvciIsIm5vdEFsbG93ZWRDdXJzb3IiLCJjb250YWluZXJDbGFzcyIsInBlclBpeGVsVGFyZ2V0RmluZCIsInRhcmdldEZpbmRUb2xlcmFuY2UiLCJza2lwVGFyZ2V0RmluZCIsImlzRHJhd2luZ01vZGUiLCJwcmVzZXJ2ZU9iamVjdFN0YWNraW5nIiwic3RvcENvbnRleHRNZW51IiwiZmlyZVJpZ2h0Q2xpY2siLCJmaXJlTWlkZGxlQ2xpY2siLCJ0YXJnZXRzIiwiZW5hYmxlUG9pbnRlckV2ZW50cyIsIl9ob3ZlcmVkVGFyZ2V0IiwiX2hvdmVyZWRUYXJnZXRzIiwiX2N1cnJlbnRUcmFuc2Zvcm0iLCJfZ3JvdXBTZWxlY3RvciIsIl9pbml0V3JhcHBlckVsZW1lbnQiLCJfY3JlYXRlVXBwZXJDYW52YXMiLCJfaW5pdEV2ZW50TGlzdGVuZXJzIiwiX2Nob29zZU9iamVjdHNUb1JlbmRlciIsImFjdGl2ZU9iamVjdHMiLCJnZXRBY3RpdmVPYmplY3RzIiwib2Jqc1RvUmVuZGVyIiwiYWN0aXZlR3JvdXBPYmplY3RzIiwiY29udGV4dFRvcERpcnR5IiwicmVuZGVyVG9wTGF5ZXIiLCJfZHJhd1NlbGVjdGlvbiIsInJlbmRlclRvcCIsIl9ub3JtYWxpemVQb2ludGVyIiwiaW52ZXJ0ZWRNIiwidnB0UG9pbnRlciIsInJlc3RvcmVQb2ludGVyVnB0IiwiaXNUYXJnZXRUcmFuc3BhcmVudCIsIm5vcm1hbGl6ZWRQb2ludGVyIiwidGFyZ2V0UmVsYXRpdmVYIiwidGFyZ2V0UmVsYXRpdmVZIiwiX2NhY2hlQ29udGV4dCIsImNvbnRleHRDYWNoZSIsIm9yaWdpbmFsQ29sb3IiLCJzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IiLCJfaXNTZWxlY3Rpb25LZXlQcmVzc2VkIiwic2VsZWN0aW9uS2V5UHJlc3NlZCIsIl9zaG91bGRDbGVhclNlbGVjdGlvbiIsImV2ZW50ZWQiLCJzZWxlY3RhYmxlIiwiX3Nob3VsZENlbnRlclRyYW5zZm9ybSIsImFjdGlvbiIsImFsdEtleSIsImNlbnRlclRyYW5zZm9ybSIsIl9nZXRPcmlnaW5Gcm9tQ29ybmVyIiwiX2dldEFjdGlvbkZyb21Db3JuZXIiLCJhbHJlYWR5U2VsZWN0ZWQiLCJfc2V0dXBDdXJyZW50VHJhbnNmb3JtIiwiX19jb3JuZXIiLCJsYXN0WCIsImxhc3RZIiwic2hpZnRLZXkiLCJfYmVmb3JlVHJhbnNmb3JtIiwic2V0Q3Vyc29yIiwiY3Vyc29yIiwidmlld3BvcnRTdGFydCIsInZpZXdwb3J0RXh0ZW50IiwiZXh0ZW50Iiwic3Ryb2tlT2Zmc2V0IiwiX3NldExpbmVEYXNoIiwiZmluZFRhcmdldCIsInNraXBHcm91cCIsImlnbm9yZVpvb20iLCJhT2JqZWN0cyIsImFjdGl2ZVRhcmdldCIsImFjdGl2ZVRhcmdldFN1YnMiLCJzaG91bGRMb29rRm9yQWN0aXZlIiwiX2ZpbmRUYXJnZXRDb3JuZXIiLCJfc2VhcmNoUG9zc2libGVUYXJnZXRzIiwiX2NoZWNrVGFyZ2V0IiwiZ2xvYmFsUG9pbnRlciIsImNvbnRhaW5zUG9pbnQiLCJpc0VkaXRpbmciLCJzdWJUYXJnZXQiLCJvYmpUb0NoZWNrIiwicG9pbnRlclRvVXNlIiwic3ViVGFyZ2V0Q2hlY2siLCJfYWJzb2x1dGVQb2ludGVyIiwiX3BvaW50ZXIiLCJib3VuZHNXaWR0aCIsImJvdW5kc0hlaWdodCIsImNzc1NjYWxlIiwicmV0aW5hU2NhbGluZyIsImxvd2VyQ2FudmFzQ2xhc3MiLCJfY29weUNhbnZhc1N0eWxlIiwiZnJvbUVsIiwidG9FbCIsImdldFNlbGVjdGlvbkNvbnRleHQiLCJnZXRTZWxlY3Rpb25FbGVtZW50IiwiZ2V0QWN0aXZlT2JqZWN0IiwiYWN0aXZlIiwiX2Rpc2NhcmRBY3RpdmVPYmplY3QiLCJfZmlyZVNlbGVjdGlvbkV2ZW50cyIsIm9sZE9iamVjdHMiLCJzb21ldGhpbmdDaGFuZ2VkIiwiYWRkZWQiLCJyZW1vdmVkIiwib2xkT2JqZWN0Iiwic2VsZWN0ZWQiLCJkZXNlbGVjdGVkIiwic2V0QWN0aXZlT2JqZWN0IiwiY3VycmVudEFjdGl2ZXMiLCJfc2V0QWN0aXZlT2JqZWN0Iiwib25TZWxlY3QiLCJvbkRlc2VsZWN0IiwiZGlzY2FyZEFjdGl2ZU9iamVjdCIsInJlbW92ZUxpc3RlbmVycyIsIl9yZW5kZXJDb250cm9scyIsIm9yaWdpbmFsUHJvcGVydGllcyIsIl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdCIsIl91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0IiwibGF5b3V0UHJvcHMiLCJvcmlnaW5hbFZhbHVlcyIsImNsZWFyQ29udGV4dFRvcCIsIlJJR0hUX0NMSUNLIiwiTUlERExFX0NMSUNLIiwiTEVGVF9DTElDSyIsImFkZEV2ZW50T3B0aW9ucyIsInBhc3NpdmUiLCJjaGVja0NsaWNrIiwiYnV0dG9uIiwibWFpblRvdWNoSWQiLCJfYmluZEV2ZW50cyIsImFkZE9yUmVtb3ZlIiwiX2dldEV2ZW50UHJlZml4IiwiZnVuY3RvciIsImV2ZW50anNGdW5jdG9yIiwiY2FudmFzRWxlbWVudCIsImV2ZW50VHlwZVByZWZpeCIsIl9vblJlc2l6ZSIsIl9vbk1vdXNlRG93biIsIl9vbk1vdXNlTW92ZSIsIl9vbk1vdXNlT3V0IiwiX29uTW91c2VFbnRlciIsIl9vbk1vdXNlV2hlZWwiLCJfb25Db250ZXh0TWVudSIsIl9vbkRvdWJsZUNsaWNrIiwiX29uRHJhZ092ZXIiLCJfb25EcmFnRW50ZXIiLCJfb25EcmFnTGVhdmUiLCJfb25Ecm9wIiwiX29uVG91Y2hTdGFydCIsImV2ZW50anMiLCJfb25HZXN0dXJlIiwiX29uRHJhZyIsIl9vbk9yaWVudGF0aW9uQ2hhbmdlIiwiX29uU2hha2UiLCJfb25Mb25nUHJlc3MiLCJfb25Nb3VzZVVwIiwiX29uVG91Y2hFbmQiLCJldmVudHNCb3VuZCIsIl9zaW1wbGVFdmVudEhhbmRsZXIiLCJzZWxmIiwiX19vblRyYW5zZm9ybUdlc3R1cmUiLCJfX29uRHJhZyIsIl9fb25Nb3VzZVdoZWVsIiwiX3RhcmdldCIsImhpZGRlblRleHRhcmVhIiwiZm9jdXMiLCJfX29uT3JpZW50YXRpb25DaGFuZ2UiLCJfX29uU2hha2UiLCJfX29uTG9uZ1ByZXNzIiwicHJldmVudERlZmF1bHQiLCJfZmlyZUVudGVyTGVhdmVFdmVudHMiLCJzdG9wUHJvcGFnYXRpb24iLCJfY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEiLCJfaGFuZGxlRXZlbnQiLCJfcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEiLCJnZXRQb2ludGVySWQiLCJldnQiLCJpZGVudGlmaWVyIiwicG9pbnRlcklkIiwiaXNQcmltYXJ5IiwidG91Y2hlcyIsIl9fb25Nb3VzZURvd24iLCJfX29uTW91c2VVcCIsIl93aWxsQWRkTW91c2VEb3duIiwiX19vbk1vdXNlTW92ZSIsIl9zaG91bGRSZW5kZXIiLCJncm91cFNlbGVjdG9yIiwic2hvdWxkUmVuZGVyIiwiaXNDbGljayIsIl9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlIiwiX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybSIsInRhcmdldFdhc0FjdGl2ZSIsIl9tYXliZUdyb3VwT2JqZWN0cyIsImFjdGl2ZU9uIiwiaXNNb3ZpbmciLCJvcmlnaW5hbENvbnRyb2wiLCJvcmlnaW5hbE1vdXNlVXBIYW5kbGVyIiwiX3NldEN1cnNvckZyb21FdmVudCIsImV2ZW50VHlwZSIsInN1YlRhcmdldHMiLCJhYnNvbHV0ZVBvaW50ZXIiLCJjdXJyZW50VGFyZ2V0IiwiY3VycmVudFN1YlRhcmdldHMiLCJfc2NhbGluZyIsImhhc1N0YXRlQ2hhbmdlZCIsIl9maXJlIiwiX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZSIsIl9vbk1vdXNlTW92ZUluRHJhd2luZ01vZGUiLCJfcHJldmlvdXNQb2ludGVyIiwic2hvdWxkR3JvdXAiLCJfc2hvdWxkR3JvdXAiLCJfaGFuZGxlR3JvdXBpbmciLCJzYXZlU3RhdGUiLCJfZmlyZU92ZXJPdXRFdmVudHMiLCJfdHJhbnNmb3JtT2JqZWN0IiwiZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzIiwib2xkVGFyZ2V0IiwiZXZ0T3V0IiwiY2FudmFzRXZ0T3V0IiwiZXZ0SW4iLCJjYW52YXNFdnRJbiIsIl9kcmFnZ2Vkb3ZlclRhcmdldCIsImNvbmZpZyIsImluT3B0Iiwib3V0T3B0Iiwib3V0RmlyZXMiLCJpbkZpcmVzIiwidGFyZ2V0Q2hhbmdlZCIsInByZXZpb3VzVGFyZ2V0IiwibmV4dFRhcmdldCIsInJlc2V0IiwiX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb24iLCJnZXRDb3JuZXJDdXJzb3IiLCJfdXBkYXRlQWN0aXZlU2VsZWN0aW9uIiwiX2NyZWF0ZUFjdGl2ZVNlbGVjdGlvbiIsImN1cnJlbnRBY3RpdmVPYmplY3RzIiwicmVtb3ZlV2l0aFVwZGF0ZSIsImFkZFdpdGhVcGRhdGUiLCJfY3JlYXRlR3JvdXAiLCJpc0FjdGl2ZUxvd2VyIiwiZ3JvdXBPYmplY3RzIiwiZXhpdEVkaXRpbmciLCJBY3RpdmVTZWxlY3Rpb24iLCJfZ3JvdXBTZWxlY3RlZE9iamVjdHMiLCJfY29sbGVjdE9iamVjdHMiLCJhR3JvdXAiLCJjdXJyZW50T2JqZWN0Iiwic2VsZWN0aW9uWDFZMSIsInNlbGVjdGlvblgyWTIiLCJhbGxvd0ludGVyc2VjdCIsImludGVyc2VjdHNXaXRoUmVjdCIsImlzQ29udGFpbmVkV2l0aGluUmVjdCIsInRvQ2FudmFzRWxlbWVudCIsImNyb3BwaW5nIiwic2NhbGVkV2lkdGgiLCJzY2FsZWRIZWlnaHQiLCJvcmlnaW5hbFdpZHRoIiwib3JpZ2luYWxIZWlnaHQiLCJuZXdab29tIiwidnAiLCJvcmlnaW5hbEludGVyYWN0aXZlIiwibmV3VnAiLCJvcmlnaW5hbFJldGluYSIsIm9yaWdpbmFsQ29udGV4dFRvcCIsImxvYWRGcm9tSlNPTiIsImpzb24iLCJzZXJpYWxpemVkIiwiSlNPTiIsIl9lbmxpdmVuT2JqZWN0cyIsIl9zZXRCZ092ZXJsYXkiLCJlbmxpdmVuZWRDYW52YXNDbGlwIiwiX19zZXR1cENhbnZhcyIsImxvYWRlZCIsImNiSWZMb2FkZWQiLCJfX3NldEJnT3ZlcmxheSIsImVubGl2ZWRPYmplY3QiLCJfdG9EYXRhVVJMIiwiX3RvRGF0YVVSTFdpdGhNdWx0aXBsaWVyIiwidG9EYXRhVVJMV2l0aE11bHRpcGxpZXIiLCJzdHJpbmdpZnkiLCJjbG9uZVdpdGhvdXREYXRhIiwiYmFja2dyb3VuZEltYWdlT3BhY2l0eSIsImJhY2tncm91bmRJbWFnZVN0cmV0Y2giLCJvYmplY3RDYWNoaW5nIiwiQUxJQVNJTkdfTElNSVQiLCJ0b3VjaENvcm5lclNpemUiLCJib3JkZXJDb2xvciIsImJvcmRlckRhc2hBcnJheSIsImNvcm5lckRhc2hBcnJheSIsInN0cm9rZURhc2hPZmZzZXQiLCJib3JkZXJPcGFjaXR5V2hlbk1vdmluZyIsImJvcmRlclNjYWxlRmFjdG9yIiwibWluU2NhbGVMaW1pdCIsImhhc0NvbnRyb2xzIiwiaGFzQm9yZGVycyIsImxvY2tNb3ZlbWVudFgiLCJsb2NrTW92ZW1lbnRZIiwic3RhdGVmdWxsQ2FjaGUiLCJub1NjYWxlQ2FjaGUiLCJkaXJ0eSIsInBhaW50Rmlyc3QiLCJzdGF0ZVByb3BlcnRpZXMiLCJjYWNoZVByb3BlcnRpZXMiLCJjb2xvclByb3BlcnRpZXMiLCJhYnNvbHV0ZVBvc2l0aW9uZWQiLCJfY2FjaGVQcm9wZXJ0aWVzIiwiX3VwZGF0ZUNhY2hlQ2FudmFzIiwiX2xpbWl0Q2FjaGVTaXplIiwiZGltcyIsImxpbWl0ZWREaW1zIiwiY2FwcGVkIiwiX2dldENhY2hlQ2FudmFzRGltZW5zaW9ucyIsIm9iamVjdFNjYWxlIiwiZ2V0VG90YWxPYmplY3RTY2FsaW5nIiwibmVlZGVkWCIsIm5lZWRlZFkiLCJ0YXJnZXRDYW52YXMiLCJtaW5DYWNoZVNpemUiLCJkcmF3aW5nV2lkdGgiLCJkcmF3aW5nSGVpZ2h0IiwiZGltZW5zaW9uc0NoYW5nZWQiLCJjYWNoZVdpZHRoIiwiY2FjaGVIZWlnaHQiLCJ6b29tQ2hhbmdlZCIsInNob3VsZFJlZHJhdyIsImFkZGl0aW9uYWxXaWR0aCIsImFkZGl0aW9uYWxIZWlnaHQiLCJzaG91bGRSZXNpemVDYW52YXMiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsInNpemVHcm93aW5nIiwic2l6ZVNocmlua2luZyIsImdldEhlaWdodE9mTGluZSIsInNldFRyYW5zZm9ybSIsIm5lZWRGdWxsVHJhbnNmb3JtIiwiX3JlbW92ZURlZmF1bHRWYWx1ZXMiLCJnZXRPYmplY3RTY2FsaW5nIiwicmV0aW5hIiwiZ2V0T2JqZWN0T3BhY2l0eSIsInNob3VsZENvbnN0cmFpblZhbHVlIiwiaXNDaGFuZ2VkIiwiZ3JvdXBOZWVkc1VwZGF0ZSIsIl9jb25zdHJhaW5TY2FsZSIsImlzT25BQ2FjaGUiLCJzZXRPbkdyb3VwIiwiZ2V0Vmlld3BvcnRUcmFuc2Zvcm0iLCJpc05vdFZpc2libGUiLCJpc09uU2NyZWVuIiwiX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uIiwiZHJhd1NlbGVjdGlvbkJhY2tncm91bmQiLCJfc2V0T3BhY2l0eSIsImRyYXdDYWNoZU9uQ2FudmFzIiwiX3JlbW92ZUNhY2hlQ2FudmFzIiwiZHJhd09iamVjdCIsInByb3BlcnR5U2V0IiwiaXNDYWNoZURpcnR5IiwiaGFzU3Ryb2tlIiwiaGFzRmlsbCIsIm5lZWRzSXRzT3duQ2FjaGUiLCJvd25DYWNoaW5nIiwid2lsbERyYXdTaGFkb3ciLCJkcmF3Q2xpcFBhdGhPbkNhY2hlIiwib3JpZ2luYWxGaWxsIiwib3JpZ2luYWxTdHJva2UiLCJfc2V0Q2xpcHBpbmdQcm9wZXJ0aWVzIiwiX2RyYXdDbGlwUGF0aCIsInNraXBDYW52YXMiLCJfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zIiwiX3JlbW92ZVNoYWRvdyIsIl9zZXRTdHJva2VTdHlsZXMiLCJkZWNsIiwibGluZURhc2hPZmZzZXQiLCJfYXBwbHlQYXR0ZXJuRm9yVHJhbnNmb3JtZWRHcmFkaWVudCIsIl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybSIsIl9zZXRGaWxsU3R5bGVzIiwiZGFzaEFycmF5IiwiZHJhd0JvcmRlcnMiLCJmb3JBY3RpdmVTZWxlY3Rpb24iLCJkcmF3Qm9yZGVyc0luR3JvdXAiLCJzY2FsaW5nIiwibXVsdFgiLCJtdWx0WSIsIl9yZW5kZXJQYWludEluT3JkZXIiLCJfcmVuZGVyU3Ryb2tlIiwiX3JlbmRlckZpbGwiLCJwQ2FudmFzIiwicEN0eCIsIl9maW5kQ2VudGVyRnJvbUVsZW1lbnQiLCJfYXNzaWduVHJhbnNmb3JtTWF0cml4UHJvcHMiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucyIsImNyb3BYIiwiY3JvcFkiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwib2JqZWN0Rm9ybSIsIl9mcm9tT2JqZWN0IiwiY2xvbmVBc0ltYWdlIiwidXRpbHMiLCJvcmlnUGFyYW1zIiwib3JpZ2luYWxHcm91cCIsIm9yaWdpbmFsU2hhZG93Iiwid2l0aG91dFRyYW5zZm9ybSIsIndpdGhvdXRTaGFkb3ciLCJib3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ1JlY3QiLCJzaGFkb3dPZmZzZXQiLCJvcmlnaW5hbENhbnZhcyIsImlzVHlwZSIsInNob3VsZENlbnRlck9yaWdpbiIsIl9zZXRPcmlnaW5Ub0NlbnRlciIsIl9yZXNldE9yaWdpbiIsImNlbnRlckgiLCJ2aWV3cG9ydENlbnRlckgiLCJjZW50ZXJWIiwidmlld3BvcnRDZW50ZXJWIiwidmlld3BvcnRDZW50ZXIiLCJnZXRMb2NhbFBvaW50ZXIiLCJwQ2xpY2tlZCIsIm9iamVjdExlZnRUb3AiLCJjcmVhdGVBY2Nlc3NvcnMiLCJleHRyYVBhcmFtIiwib3JpZ2luWE9mZnNldCIsIm9yaWdpbllPZmZzZXQiLCJ0cmFuc2xhdGVUb0dpdmVuT3JpZ2luIiwiZnJvbU9yaWdpblgiLCJmcm9tT3JpZ2luWSIsInRvT3JpZ2luWCIsInRvT3JpZ2luWSIsInRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQiLCJsZWZ0VG9wIiwiZ2V0UG9pbnRCeU9yaWdpbiIsImFkanVzdFBvc2l0aW9uIiwiaHlwb3RGdWxsIiwiZ2V0U2NhbGVkV2lkdGgiLCJ4RnVsbCIsInlGdWxsIiwib2Zmc2V0RnJvbSIsIm9mZnNldFRvIiwiX29yaWdpbmFsT3JpZ2luWCIsIl9vcmlnaW5hbE9yaWdpblkiLCJvcmlnaW5Qb2ludCIsImFycmF5RnJvbUNvb3JkcyIsIm11bHRpcGx5TWF0cmljZXMiLCJvQ29vcmRzIiwiYUNvb3JkcyIsImxpbmVDb29yZHMiLCJvd25NYXRyaXhDYWNoZSIsIm1hdHJpeENhY2hlIiwiX2dldENvb3JkcyIsImFic29sdXRlIiwiY2FsY3VsYXRlIiwiY2FsY0FDb29yZHMiLCJjYWxjTGluZUNvb3JkcyIsImdldENvb3JkcyIsInBvaW50VEwiLCJwb2ludEJSIiwiaW50ZXJzZWN0aW9uIiwib3RoZXIiLCJvdGhlckNvb3JkcyIsImxpbmVzIiwiX2dldEltYWdlTGluZXMiLCJfZmluZENyb3NzUG9pbnRzIiwiX2NvbnRhaW5zQ2VudGVyT2ZDYW52YXMiLCJpc1BhcnRpYWxseU9uU2NyZWVuIiwiYWxsUG9pbnRzQXJlT3V0c2lkZSIsImV2ZXJ5IiwidG9wbGluZSIsInJpZ2h0bGluZSIsImJvdHRvbWxpbmUiLCJsZWZ0bGluZSIsInhpIiwieGNvdW50IiwiaUxpbmUiLCJsaW5lS2V5IiwiZ2V0U2NhbGVkSGVpZ2h0Iiwic2NhbGVUb1dpZHRoIiwiYm91bmRpbmdSZWN0RmFjdG9yIiwic2NhbGVUb0hlaWdodCIsImNvc1AiLCJzaW5QIiwiY29zUFNpblAiLCJjb3NQTWludXNTaW5QIiwiY2FsY09Db29yZHMiLCJfY2FsY1JvdGF0ZU1hdHJpeCIsIl9jYWxjVHJhbnNsYXRlTWF0cml4Iiwic3RhcnRNYXRyaXgiLCJfY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMiLCJmb3JFYWNoQ29udHJvbCIsInciLCJza2lwQ29ybmVycyIsIl9zZXRDb3JuZXJDb29yZHMiLCJ0cmFuc2Zvcm1NYXRyaXhLZXkiLCJzZXAiLCJwcmVmaXgiLCJjYWNoZSIsInRNYXRyaXgiLCJub1NrZXciLCJfZmluYWxpemVEaW1lbnNpb25zIiwiZ2V0U3ZnQ29sb3JTdHJpbmciLCJnZXRTdmdTdHlsZXMiLCJza2lwU2hhZG93IiwiZ2V0U3ZnRmlsdGVyIiwiZ2V0U3ZnU3BhblN0eWxlcyIsInVzZVdoaXRlU3BhY2UiLCJ0ZXJtIiwidGV4dERlY29yYXRpb24iLCJnZXRTdmdUZXh0RGVjb3JhdGlvbiIsImRlbHRhWSIsImRlY29yYXRpb24iLCJnZXRTdmdDb21tb25zIiwiZ2V0U3ZnVHJhbnNmb3JtIiwiZnVsbCIsInN2Z1RyYW5zZm9ybSIsIl9zZXRTVkdCZyIsInRleHRCZ1JlY3RzIiwiX2dldEZpbGxBdHRyaWJ1dGVzIiwiX2NyZWF0ZUJhc2VTVkdNYXJrdXAiLCJfdG9TVkciLCJfY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwIiwib2JqZWN0TWFya3VwIiwiY29tbW9uUGllY2VzIiwibm9TdHlsZSIsInN0eWxlSW5mbyIsInNoYWRvd0luZm8iLCJ3aXRoU2hhZG93IiwidmVjdG9yRWZmZWN0IiwiYWJzb2x1dGVDbGlwUGF0aCIsImNsaXBQYXRoTWFya3VwIiwiYWRkUGFpbnRPcmRlciIsIm9yaWdpbmFsU2V0Iiwic2F2ZVByb3BzIiwicHJvcHMiLCJ0bXBPYmoiLCJfaXNFcXVhbCIsIm9yaWdWYWx1ZSIsImZpcnN0UGFzcyIsImRhc2hlZFByb3BlcnR5U2V0IiwiZm9yVG91Y2giLCJpc0NvbnRyb2xWaXNpYmxlIiwidG91Y2hDb3JuZXIiLCJmbiIsImNvbnRyb2xPYmplY3QiLCJ3aCIsInNob3VsZFN0cm9rZSIsInNldENvbnRyb2xWaXNpYmxlIiwic2V0Q29udHJvbHNWaXNpYmlsaXR5IiwiRlhfRFVSQVRJT04iLCJmeENlbnRlck9iamVjdEgiLCJjYWxsYmFja3MiLCJlbXB0eSIsImZ4Q2VudGVyT2JqZWN0ViIsImZ4UmVtb3ZlIiwicHJvcHNUb0FuaW1hdGUiLCJza2lwQ2FsbGJhY2tzIiwib3V0IiwiX2FuaW1hdGUiLCJwcm9wUGFpciIsInByb3BJc0NvbG9yIiwidmFsdWVQcm9ncmVzcyIsInRpbWVQcm9ncmVzcyIsImNvb3JkUHJvcHMiLCJMaW5lIiwiX3NldFdpZHRoSGVpZ2h0IiwiX2dldExlZnRUb09yaWdpblgiLCJfZ2V0VG9wVG9PcmlnaW5ZIiwibWFrZUVkZ2VUb09yaWdpbkdldHRlciIsImF4aXMxIiwiYXhpczIiLCJkaW1lbnNpb24iLCJuZWFyZXN0IiwiZmFydGhlc3QiLCJjYWxjTGluZVBvaW50cyIsIm9yaWdTdHJva2VTdHlsZSIsInhNdWx0IiwieU11bHQiLCJBVFRSSUJVVEVfTkFNRVMiLCJwYXJzZWRBdHRyaWJ1dGVzIiwiX2NhbGxiYWNrIiwicHJvcGVydHlOYW1lcyIsIm9yaWdpblZhbHVlcyIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsInNldFJhZGl1cyIsInN2Z1N0cmluZyIsInN0YXJ0WCIsInN0YXJ0WSIsImVuZFgiLCJlbmRZIiwibGFyZ2VGbGFnIiwiZ2V0UmFkaXVzWCIsImdldFJhZGl1c1kiLCJpc1ZhbGlkUmFkaXVzIiwiVHJpYW5nbGUiLCJ3aWR0aEJ5MiIsImhlaWdodEJ5MiIsInBpQnkyIiwiRWxsaXBzZSIsImdldFJ4IiwiZ2V0UnkiLCJfaW5pdFJ4UnkiLCJpc1JvdW5kZWQiLCJiZXppZXJDdXJ2ZVRvIiwiUG9seWxpbmUiLCJleGFjdEJvdW5kaW5nQm94IiwiX3NldFBvc2l0aW9uRGltZW5zaW9ucyIsIl9wcm9qZWN0U3Ryb2tlT25Qb2ludHMiLCJjYWxjRGltIiwiX2NhbGNEaW1lbnNpb25zIiwiY29ycmVjdExlZnRUb3AiLCJjb3JyZWN0U2l6ZSIsImZyb21TVkciLCJkaWZmWCIsImRpZmZZIiwiY29tbW9uUmVuZGVyIiwiZnJvbUVsZW1lbnRHZW5lcmF0b3IiLCJfY2xhc3MiLCJQb2x5Z29uIiwiX3RvU3RyaW5nIiwiX3NldFBhdGgiLCJmcm9tQXJyYXkiLCJfcmVuZGVyUGF0aENvbW1hbmRzIiwic3VicGF0aFN0YXJ0WCIsInN1YnBhdGhTdGFydFkiLCJfZ2V0T2Zmc2V0VHJhbnNmb3JtIiwiZGlnaXRzIiwiYVgiLCJhWSIsImRlbHRhWCIsInBhdGhVcmwiLCJ1c2VTZXRPbkdyb3VwIiwiaXNBbHJlYWR5R3JvdXBlZCIsIl9jYWxjQm91bmRzIiwiX3VwZGF0ZU9iamVjdHNDb29yZHMiLCJfdXBkYXRlT2JqZWN0c0FDb29yZHMiLCJza2lwQ29udHJvbHMiLCJfdXBkYXRlT2JqZWN0Q29vcmRzIiwib2JqZWN0TGVmdCIsIm9iamVjdFRvcCIsIm5lc3RlZCIsIl9yZXN0b3JlT2JqZWN0c1N0YXRlIiwiX2luY2x1ZGVEZWZhdWx0VmFsdWVzIiwib2Jqc1RvT2JqZWN0Iiwib3JpZ2luYWxEZWZhdWx0cyIsIl9vYmoiLCJvd25DYWNoZSIsImdyb3VwTWF0cml4IiwiZGVzdHJveSIsInRvQWN0aXZlU2VsZWN0aW9uIiwidW5ncm91cE9uQ2FudmFzIiwic2V0T2JqZWN0c0Nvb3JkcyIsIm9ubHlXaWR0aEhlaWdodCIsImlMZW4iLCJqTGVuIiwiX2dldEJvdW5kcyIsIm1pblhZIiwibWF4WFkiLCJ0b0dyb3VwIiwibmV3R3JvdXAiLCJjaGlsZHJlbk92ZXJyaWRlIiwic3JjRnJvbUF0dHJpYnV0ZSIsIl9sYXN0U2NhbGVYIiwiX2xhc3RTY2FsZVkiLCJfZmlsdGVyU2NhbGluZ1giLCJfZmlsdGVyU2NhbGluZ1kiLCJtaW5pbXVtU2NhbGVUcmlnZ2VyIiwiY2FjaGVLZXkiLCJpbWFnZVNtb290aGluZyIsImZpbHRlcnMiLCJfaW5pdEVsZW1lbnQiLCJfZWxlbWVudCIsInNldEVsZW1lbnQiLCJyZW1vdmVUZXh0dXJlIiwiX2luaXRDb25maWciLCJhcHBseUZpbHRlcnMiLCJyZXNpemVGaWx0ZXIiLCJhcHBseVJlc2l6ZUZpbHRlcnMiLCJiYWNrZW5kIiwiZmlsdGVyQmFja2VuZCIsImV2aWN0Q2FjaGVzRm9yS2V5IiwiZ2V0Q3Jvc3NPcmlnaW4iLCJnZXRPcmlnaW5hbFNpemUiLCJfc3Ryb2tlIiwiZmlsdGVyT2JqIiwiZ2V0U3JjIiwiaGFzQ3JvcCIsImltYWdlTWFya3VwIiwic3Ryb2tlU3ZnIiwiaW1hZ2VSZW5kZXJpbmciLCJnZXRTdmdTcmMiLCJvcmlnRmlsbCIsImZpbHRlcmVkIiwic2V0U3JjIiwibWluaW11bVNjYWxlIiwiZWxlbWVudFRvRmlsdGVyIiwiX2ZpbHRlcmVkRWwiLCJzb3VyY2VXaWR0aCIsInNvdXJjZUhlaWdodCIsImlzTmV1dHJhbFN0YXRlIiwiaW1nRWxlbWVudCIsIl9uZWVkc1Jlc2l6ZSIsImVsZW1lbnRUb0RyYXciLCJlbFdpZHRoIiwiZWxIZWlnaHQiLCJzWCIsInNZIiwic1ciLCJzSCIsIm1heERlc3RXIiwibWF4RGVzdEgiLCJfcmVzZXRXaWR0aEhlaWdodCIsIkNTU19DQU5WQVMiLCJfaW5pdEZpbHRlcnMiLCJwQVIiLCJyV2lkdGgiLCJySGVpZ2h0IiwicFdpZHRoIiwicEhlaWdodCIsIl9vYmplY3QiLCJyZXNpemVGaWx0ZXJzIiwiZnJvbVVSTCIsImltZ09wdGlvbnMiLCJfZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW4iLCJzdHJhaWdodGVuIiwiZnhTdHJhaWdodGVuIiwic3RyYWlnaHRlbk9iamVjdCIsImZ4U3RyYWlnaHRlbk9iamVjdCIsInRlc3RQcmVjaXNpb24iLCJnbCIsInByZWNpc2lvbiIsImZyYWdtZW50U291cmNlIiwiZnJhZ21lbnRTaGFkZXIiLCJjcmVhdGVTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJzaGFkZXJTb3VyY2UiLCJjb21waWxlU2hhZGVyIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJpc1N1cHBvcnRlZCIsImdldFBhcmFtZXRlciIsIk1BWF9URVhUVVJFX1NJWkUiLCJwcmVjaXNpb25zIiwid2ViR2xQcmVjaXNpb24iLCJzZXR1cEdMQ29udGV4dCIsImNhcHR1cmVHUFVJbmZvIiwiY3JlYXRlV2ViR0xDYW52YXMiLCJhUG9zaXRpb24iLCJGbG9hdDMyQXJyYXkiLCJjaG9vc2VGYXN0ZXN0Q29weUdMVG8yRE1ldGhvZCIsImNhbk1lYXN1cmVQZXJmIiwicGVyZm9ybWFuY2UiLCJjYW5Vc2VJbWFnZURhdGEiLCJJbWFnZURhdGEiLCJjYW5Vc2VBcnJheUJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiY2FuVXNlVWludDhDbGFtcGVkIiwiVWludDhDbGFtcGVkQXJyYXkiLCJpbWFnZUJ1ZmZlciIsImNvcHlHTFRvMkQiLCJjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhIiwidGVzdENvbnRleHQiLCJkZXN0aW5hdGlvbldpZHRoIiwiZGVzdGluYXRpb25IZWlnaHQiLCJzdGFydFRpbWUiLCJkcmF3SW1hZ2VUaW1lIiwicHV0SW1hZ2VEYXRhVGltZSIsIm5vdyIsImNvcHlHTFRvMkREcmF3SW1hZ2UiLCJnbE9wdGlvbnMiLCJwcmVtdWx0aXBsaWVkQWxwaGEiLCJkZXB0aCIsInN0ZW5jaWwiLCJhbnRpYWxpYXMiLCJjbGVhckNvbG9yIiwiY2FjaGVkVGV4dHVyZSIsImdldENhY2hlZFRleHR1cmUiLCJwaXBlbGluZVN0YXRlIiwic291cmNlVGV4dHVyZSIsImNyZWF0ZVRleHR1cmUiLCJ0YXJnZXRUZXh0dXJlIiwib3JpZ2luYWxUZXh0dXJlIiwicGFzc2VzIiwid2ViZ2wiLCJwcm9ncmFtQ2FjaGUiLCJwYXNzIiwidGVtcEZibyIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJhcHBseVRvIiwicmVzaXplQ2FudmFzSWZOZWVkZWQiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJkZWxldGVUZXh0dXJlIiwiZGVsZXRlRnJhbWVidWZmZXIiLCJjbGVhcldlYkdMQ2FjaGVzIiwidGV4dHVyZUNhY2hlIiwidGV4dHVyZUltYWdlU291cmNlIiwidGV4dHVyZSIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01BR19GSUxURVIiLCJORUFSRVNUIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiVEVYVFVSRV9XUkFQX1MiLCJDTEFNUF9UT19FREdFIiwiVEVYVFVSRV9XUkFQX1QiLCJ0ZXhJbWFnZTJEIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJ1bmlxdWVJZCIsImdwdUluZm8iLCJyZW5kZXJlciIsInZlbmRvciIsImV4dCIsImdldEV4dGVuc2lvbiIsIlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMIiwiVU5NQVNLRURfVkVORE9SX1dFQkdMIiwiZFdpZHRoIiwiZEhlaWdodCIsImdsQ2FudmFzIiwic291cmNlWSIsIm51bUJ5dGVzIiwidTgiLCJVaW50OEFycmF5IiwidThDbGFtcGVkIiwicmVhZFBpeGVscyIsImltZ0RhdGEiLCJwdXRJbWFnZURhdGEiLCJzb3VyY2VFbGVtZW50Iiwib3JpZ2luYWxJbWFnZURhdGEiLCJvcmlnaW5hbEVsIiwiQmFzZUZpbHRlciIsInZlcnRleFNvdXJjZSIsImNyZWF0ZVByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiZ2V0U2hhZGVySW5mb0xvZyIsInByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImdldFByb2dyYW1JbmZvTG9nIiwiYXR0cmlidXRlTG9jYXRpb25zIiwiZ2V0QXR0cmlidXRlTG9jYXRpb25zIiwidW5pZm9ybUxvY2F0aW9ucyIsImdldFVuaWZvcm1Mb2NhdGlvbnMiLCJ1U3RlcFciLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ1U3RlcEgiLCJnZXRBdHRyaWJMb2NhdGlvbiIsInNlbmRBdHRyaWJ1dGVEYXRhIiwiYVBvc2l0aW9uRGF0YSIsImF0dHJpYnV0ZUxvY2F0aW9uIiwiYnVmZmVyIiwiY3JlYXRlQnVmZmVyIiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwiYnVmZmVyRGF0YSIsIlNUQVRJQ19EUkFXIiwiX3NldHVwRnJhbWVCdWZmZXIiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIkNPTE9SX0FUVEFDSE1FTlQwIiwiX3N3YXBUZXh0dXJlcyIsIm1haW4iLCJtYWluUGFyYW1ldGVyIiwiYXBwbHlUb1dlYkdMIiwiYXBwbHlUbzJkIiwicmV0cmlldmVTaGFkZXIiLCJzaGFkZXIiLCJ1c2VQcm9ncmFtIiwidW5pZm9ybTFmIiwic2VuZFVuaWZvcm1EYXRhIiwidmlld3BvcnQiLCJkcmF3QXJyYXlzIiwiVFJJQU5HTEVfU1RSSVAiLCJiaW5kQWRkaXRpb25hbFRleHR1cmUiLCJ0ZXh0dXJlVW5pdCIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsInVuYmluZEFkZGl0aW9uYWxUZXh0dXJlIiwiZ2V0TWFpblBhcmFtZXRlciIsInNldE1haW5QYXJhbWV0ZXIiLCJjcmVhdGVIZWxwTGF5ZXIiLCJoZWxwTGF5ZXIiLCJtYWluUCIsIkNvbG9yTWF0cml4IiwiY29sb3JzT25seSIsInVDb2xvck1hdHJpeCIsInVDb25zdGFudHMiLCJjb25zdGFudHMiLCJ1bmlmb3JtTWF0cml4NGZ2IiwidW5pZm9ybTRmdiIsIkJyaWdodG5lc3MiLCJicmlnaHRuZXNzIiwidUJyaWdodG5lc3MiLCJDb252b2x1dGUiLCJvcGFxdWUiLCJDb252b2x1dGVfM18xIiwiQ29udm9sdXRlXzNfMCIsIkNvbnZvbHV0ZV81XzEiLCJDb252b2x1dGVfNV8wIiwiQ29udm9sdXRlXzdfMSIsIkNvbnZvbHV0ZV83XzAiLCJDb252b2x1dGVfOV8xIiwiQ29udm9sdXRlXzlfMCIsIndlaWdodHMiLCJzaWRlIiwiaGFsZlNpZGUiLCJzdyIsInNoIiwib3V0cHV0IiwiY3JlYXRlSW1hZ2VEYXRhIiwiZHN0IiwiYWxwaGFGYWMiLCJkc3RPZmYiLCJzY3giLCJzY3kiLCJzcmNPZmYiLCJ3dCIsInVNYXRyaXgiLCJ1T3BhcXVlIiwidUhhbGZTaXplIiwidVNpemUiLCJ1bmlmb3JtMWZ2IiwiR3JheXNjYWxlIiwibGlnaHRuZXNzIiwibHVtaW5vc2l0eSIsIm1vZGUiLCJ1TW9kZSIsInVuaWZvcm0xaSIsIkludmVydCIsImludmVydCIsInVJbnZlcnQiLCJOb2lzZSIsIm5vaXNlIiwicmFuZCIsInVOb2lzZSIsInVTZWVkIiwiUGl4ZWxhdGUiLCJibG9ja3NpemUiLCJfaSIsIl9qIiwiX2lMZW4iLCJfakxlbiIsInVCbG9ja3NpemUiLCJSZW1vdmVDb2xvciIsInVzZUFscGhhIiwibG93QyIsImhpZ2hDIiwidUxvdyIsInVIaWdoIiwiQnJvd25pZSIsIlZpbnRhZ2UiLCJLb2RhY2hyb21lIiwiVGVjaG5pY29sb3IiLCJQb2xhcm9pZCIsIlNlcGlhIiwiQmxhY2tXaGl0ZSIsIkJsZW5kQ29sb3IiLCJzY3JlZW4iLCJkaWZmIiwibGlnaHRlbiIsImRhcmtlbiIsImV4Y2x1c2lvbiIsInRpbnQiLCJidWlsZFNvdXJjZSIsInRnIiwiYWxwaGExIiwidUNvbG9yIiwiQmxlbmRJbWFnZSIsIm1hc2siLCJURVhUVVJFMSIsImNhbGN1bGF0ZU1hdHJpeCIsImNhbnZhczEiLCJibGVuZERhdGEiLCJibGVuZEltYWdlIiwidVRyYW5zZm9ybU1hdHJpeCIsInVJbWFnZSIsInVuaWZvcm1NYXRyaXgzZnYiLCJSZXNpemUiLCJyZXNpemVUeXBlIiwibGFuY3pvc0xvYmVzIiwidURlbHRhIiwidVRhcHMiLCJ1bmlmb3JtMmZ2IiwiaG9yaXpvbnRhbCIsInRhcHMiLCJmaWx0ZXJXaW5kb3ciLCJnZXRGaWx0ZXJXaW5kb3ciLCJnZW5lcmF0ZVNoYWRlciIsInRlbXBTY2FsZSIsImdldFRhcHMiLCJsb2JlRnVuY3Rpb24iLCJsYW5jem9zQ3JlYXRlIiwib2Zmc2V0cyIsImZyYWdtZW50U291cmNlVE9QIiwiZFciLCJkSCIsImxvYmVzIiwieHgiLCJyY3BTY2FsZVgiLCJyY3BTY2FsZVkiLCJvVyIsIm9IIiwibmV3RGF0YSIsInNsaWNlQnlUd28iLCJoZXJtaXRlRmFzdFJlc2l6ZSIsImJpbGluZWFyRmlsdGVyaW5nIiwibGFuY3pvc1Jlc2l6ZSIsIm11bHQiLCJkb25lVyIsImRvbmVIIiwic3RlcFciLCJzdGVwSCIsInRtcENhbnZhcyIsImRYIiwiZFkiLCJwcm9jZXNzIiwidSIsIndlaWdodCIsImZYIiwiZlkiLCJyYXRpb1giLCJpY2VudGVyIiwicmF0aW9ZIiwicmFuZ2UyWCIsImNhY2hlTGFuYyIsInJhbmdlMlkiLCJsYW5jem9zIiwicmNwUmF0aW9YIiwicmNwUmF0aW9ZIiwic3JjRGF0YSIsImRlc3REYXRhIiwiZGVzdEltZyIsInhEaWZmIiwieURpZmYiLCJjaG5sIiwib3JpZ1BpeCIsInc0IiwicGl4ZWxzIiwiZGVzdEltYWdlIiwiZGVzdFBpeGVscyIsInJhdGlvVyIsInJhdGlvSCIsInJhdGlvV0hhbGYiLCJyYXRpb0hIYWxmIiwiaW1nMiIsImRhdGEyIiwid2VpZ2h0c0FscGhhIiwiZ3hSIiwiZ3hHIiwiZ3hCIiwiZ3hBIiwieXkiLCJ3MCIsIkNvbnRyYXN0IiwiY29udHJhc3QiLCJjb250cmFzdEYiLCJ1Q29udHJhc3QiLCJTYXR1cmF0aW9uIiwic2F0dXJhdGlvbiIsImFkanVzdCIsInVTYXR1cmF0aW9uIiwiVmlicmFuY2UiLCJ2aWJyYW5jZSIsImF2ZyIsImFtdCIsInVWaWJyYW5jZSIsIkJsdXIiLCJhc3BlY3RSYXRpbyIsInNpbXBsZUJsdXIiLCJjYW52YXMyIiwiYmx1ckxheWVyMSIsImJsdXJMYXllcjIiLCJjdHgxIiwiY3R4MiIsIm5TYW1wbGVzIiwicGVyY2VudCIsIm5ld0ltYWdlRGF0YSIsImRlbHRhIiwiY2hvb3NlUmlnaHREZWx0YSIsImJsdXJTY2FsZSIsIkdhbW1hIiwiZ2FtbWEiLCJySW52IiwiZ0ludiIsImJJbnYiLCJyVmFscyIsImdWYWxzIiwiYlZhbHMiLCJ1R2FtbWEiLCJ1bmlmb3JtM2Z2IiwiQ29tcG9zZWQiLCJzdWJGaWx0ZXJzIiwiSHVlUm90YXRpb24iLCJyb3RhdGlvbiIsInJhZCIsImFUaGlyZCIsImFUaGlyZFNxdFNpbiIsIk9uZU1pbnVzQ29zIiwiYWRkaXRpb25hbFByb3BzIiwiX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzIiwiX3JlTmV3bGluZSIsIl9yZVNwYWNlc0FuZFRhYnMiLCJfcmVTcGFjZUFuZFRhYiIsIl9yZVdvcmRzIiwidW5kZXJsaW5lIiwib3ZlcmxpbmUiLCJsaW5ldGhyb3VnaCIsInRleHRBbGlnbiIsInN1cGVyc2NyaXB0IiwiYmFzZWxpbmUiLCJzdWJzY3JpcHQiLCJ0ZXh0QmFja2dyb3VuZENvbG9yIiwicGF0aFN0YXJ0T2Zmc2V0IiwicGF0aFNpZGUiLCJwYXRoQWxpZ24iLCJfZm9udFNpemVGcmFjdGlvbiIsIl9mb250U2l6ZU11bHQiLCJjaGFyU3BhY2luZyIsIl9tZWFzdXJpbmdDb250ZXh0IiwiZGlyZWN0aW9uIiwiX3N0eWxlUHJvcGVydGllcyIsIl9fY2hhckJvdW5kcyIsIkNBQ0hFX0ZPTlRfU0laRSIsIk1JTl9URVhUX1dJRFRIIiwidGV4dCIsIl9fc2tpcERpbWVuc2lvbiIsInNldFBhdGhJbmZvIiwiaW5pdERpbWVuc2lvbnMiLCJzZWdtZW50c0luZm8iLCJnZXRNZWFzdXJpbmdDb250ZXh0IiwiX3NwbGl0VGV4dCIsIm5ld0xpbmVzIiwiX3NwbGl0VGV4dEludG9MaW5lcyIsInRleHRMaW5lcyIsIl90ZXh0TGluZXMiLCJncmFwaGVtZUxpbmVzIiwiX3Vud3JhcHBlZFRleHRMaW5lcyIsIl91bndyYXBwZWRMaW5lcyIsIl90ZXh0IiwiZ3JhcGhlbWVUZXh0IiwiX2NsZWFyQ2FjaGUiLCJjYWxjVGV4dFdpZHRoIiwiY3Vyc29yV2lkdGgiLCJjYWxjVGV4dEhlaWdodCIsImVubGFyZ2VTcGFjZXMiLCJkaWZmU3BhY2UiLCJjdXJyZW50TGluZVdpZHRoIiwibnVtYmVyT2ZTcGFjZXMiLCJhY2N1bXVsYXRlZFNwYWNlIiwibGluZSIsImNoYXJCb3VuZCIsInNwYWNlcyIsImlzRW5kT2ZXcmFwcGluZyIsImdldExpbmVXaWR0aCIsImtlcm5lZFdpZHRoIiwibGluZUluZGV4IiwibWlzc2luZ05ld2xpbmVPZmZzZXQiLCJfc2V0VGV4dFN0eWxlcyIsIl9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kIiwiX3JlbmRlclRleHREZWNvcmF0aW9uIiwiX3JlbmRlclRleHQiLCJfcmVuZGVyVGV4dFN0cm9rZSIsIl9yZW5kZXJUZXh0RmlsbCIsImNoYXJTdHlsZSIsImZvck1lYXN1cmluZyIsInRleHRCYXNlbGluZSIsIl9nZXRGb250RGVjbGFyYXRpb24iLCJtYXhXaWR0aCIsIl9yZW5kZXJUZXh0TGluZSIsIl9yZW5kZXJDaGFycyIsInN0eWxlSGFzIiwiaGVpZ2h0T2ZMaW5lIiwibGluZUxlZnRPZmZzZXQiLCJsYXN0Q29sb3IiLCJsZWZ0T2Zmc2V0IiwiX2dldExlZnRPZmZzZXQiLCJsaW5lVG9wT2Zmc2V0IiwiX2dldFRvcE9mZnNldCIsImJveFN0YXJ0IiwiYm94V2lkdGgiLCJjaGFyQm94IiwiY3VycmVudENvbG9yIiwiZHJhd1N0YXJ0IiwiX2dldExpbmVMZWZ0T2Zmc2V0IiwiZ2V0VmFsdWVPZlByb3BlcnR5QXQiLCJyZW5kZXJMZWZ0IiwiZ2V0Rm9udENhY2hlIiwiY2FjaGVQcm9wIiwiX21lYXN1cmVDaGFyIiwicHJldmlvdXNDaGFyIiwicHJldkNoYXJTdHlsZSIsImZvbnRDYWNoZSIsImZvbnREZWNsYXJhdGlvbiIsInByZXZpb3VzRm9udERlY2xhcmF0aW9uIiwiY291cGxlIiwic3R5bGVzQXJlRXF1YWwiLCJjb3VwbGVXaWR0aCIsInByZXZpb3VzV2lkdGgiLCJmb250TXVsdGlwbGllciIsIm1lYXN1cmVUZXh0IiwiZ2V0SGVpZ2h0T2ZDaGFyIiwibWVhc3VyZUxpbmUiLCJsaW5lSW5mbyIsIl9tZWFzdXJlTGluZSIsIl9nZXRXaWR0aE9mQ2hhclNwYWNpbmciLCJncmFwaGVtZSIsInByZXZHcmFwaGVtZSIsImdyYXBoZW1lSW5mbyIsIm51bU9mU3BhY2VzIiwibGluZUJvdW5kcyIsInBvc2l0aW9uSW5QYXRoIiwic3RhcnRpbmdQb2ludCIsInRvdGFsUGF0aExlbmd0aCIsIl9nZXRHcmFwaGVtZUJveCIsIl9zZXRHcmFwaGVtZU9uUGF0aCIsImNlbnRlclBvc2l0aW9uIiwic2tpcExlZnQiLCJnZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24iLCJwcmV2U3R5bGUiLCJwcmV2aW91c0JveCIsIl9fbGluZUhlaWdodHMiLCJtYXhIZWlnaHQiLCJfcmVuZGVyVGV4dENvbW1vbiIsImxpbmVIZWlnaHRzIiwiaXNFbXB0eVN0eWxlcyIsImlzSnVzdGlmeSIsImFjdHVhbFN0eWxlIiwibmV4dFN0eWxlIiwiY2hhcnNUb1JlbmRlciIsInRpbWVUb1JlbmRlciIsInNob3J0Q3V0IiwiaXNMdHIiLCJkcmF3aW5nTGVmdCIsImN1cnJlbnREaXJlY3Rpb24iLCJfcmVuZGVyQ2hhciIsIl9oYXNTdHlsZUNoYW5nZWQiLCJfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm1UZXh0IiwiaGFuZGxlRmlsbGVyIiwiX2dldFN0eWxlRGVjbGFyYXRpb24iLCJmdWxsRGVjbCIsInNob3VsZEZpbGwiLCJmaWxsT2Zmc2V0cyIsInN0cm9rZU9mZnNldHMiLCJmaWxsVGV4dCIsInN0cm9rZVRleHQiLCJzZXRTdXBlcnNjcmlwdCIsIl9zZXRTY3JpcHQiLCJzZXRTdWJzY3JpcHQiLCJzY2hlbWEiLCJsb2MiLCJnZXQyREN1cnNvckxvY2F0aW9uIiwic2V0U2VsZWN0aW9uU3R5bGVzIiwidGhpc1N0eWxlIiwiX2hhc1N0eWxlQ2hhbmdlZEZvclN2ZyIsImxpbmVEaWZmIiwiX19saW5lV2lkdGhzIiwiX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUiLCJzaG91bGRDbGVhciIsIl9mb3JjZUNsZWFyQ2FjaGUiLCJfc2l6ZSIsIl9keSIsImxhc3REZWNvcmF0aW9uIiwidG9wT2Zmc2V0IiwiY3VycmVudERlY29yYXRpb24iLCJjdXJyZW50RmlsbCIsImxhc3RGaWxsIiwic3R5bGVPYmplY3QiLCJmYW1pbHkiLCJmb250SXNHZW5lcmljIiwiZ2VuZXJpY0ZvbnRzIiwibmV3TGluZSIsIm5ld1RleHQiLCJhbGxQcm9wZXJ0aWVzIiwibmVlZHNEaW1zIiwiaXNBZGRpbmdQYXRoIiwiX2tleSIsInBhcnNlZEFuY2hvciIsInRleHRBbmNob3IiLCJvcmlnaW5hbFN0cm9rZVdpZHRoIiwidGV4dEhlaWdodFNjYWxlRmFjdG9yIiwibGluZUhlaWdodERpZmYiLCJzY2FsZWREaWZmIiwidGV4dEhlaWdodCIsIm9mZlgiLCJvYmplY3RDb3B5IiwidGV4dEluc3RhbmNlIiwicGF0aEluc3RhbmNlIiwicDMiLCJjbGVhblN0eWxlIiwic3R5bGVzQ291bnQiLCJsZXR0ZXJDb3VudCIsInN0eWxlUHJvcGVydHlWYWx1ZSIsImFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoIiwiZ3JhcGhlbWVDb3VudCIsInN0eWxlUHJvcGVydHlIYXNCZWVuU2V0IiwicmVtb3ZlU3R5bGUiLCJsaW5lTnVtIiwiY2hhck51bSIsIl9leHRlbmRTdHlsZXMiLCJfZ2V0TGluZVN0eWxlIiwiX3NldExpbmVTdHlsZSIsIl9zZXRTdHlsZURlY2xhcmF0aW9uIiwic2VsZWN0aW9uU3RhcnQiLCJza2lwV3JhcHBpbmciLCJnZXRTZWxlY3Rpb25TdHlsZXMiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJzZWxlY3Rpb25FbmQiLCJnZXRTdHlsZUF0UG9zaXRpb24iLCJsaW5lU3R5bGUiLCJfZGVsZXRlU3R5bGVEZWNsYXJhdGlvbiIsIl9kZWxldGVMaW5lU3R5bGUiLCJwYXJzZURlY29yYXRpb24iLCJJVGV4dCIsImVkaXRhYmxlIiwiZWRpdGluZ0JvcmRlckNvbG9yIiwiY3Vyc29yQ29sb3IiLCJjdXJzb3JEZWxheSIsImN1cnNvckR1cmF0aW9uIiwiY2FjaGluZyIsImhpZGRlblRleHRhcmVhQ29udGFpbmVyIiwiX3JlU3BhY2UiLCJfY3VycmVudEN1cnNvck9wYWNpdHkiLCJfc2VsZWN0aW9uRGlyZWN0aW9uIiwiX2Fib3J0Q3Vyc29yQW5pbWF0aW9uIiwiX193aWR0aE9mU3BhY2UiLCJpbkNvbXBvc2l0aW9uTW9kZSIsImluaXRCZWhhdmlvciIsInNldFNlbGVjdGlvblN0YXJ0IiwiX3VwZGF0ZUFuZEZpcmUiLCJzZXRTZWxlY3Rpb25FbmQiLCJfZmlyZVNlbGVjdGlvbkNoYW5nZWQiLCJfdXBkYXRlVGV4dGFyZWEiLCJpbml0RGVsYXllZEN1cnNvciIsImN1cnNvck9mZnNldENhY2hlIiwicmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24iLCJza2lwUmVzdG9yZSIsIl9jbGVhclRleHRBcmVhIiwiYm91bmRhcmllcyIsIl9nZXRDdXJzb3JCb3VuZGFyaWVzIiwicmVuZGVyQ3Vyc29yIiwicmVuZGVyU2VsZWN0aW9uIiwiX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzIiwiY3Vyc29yUG9zaXRpb24iLCJib3VuZCIsImN1cnNvckxvY2F0aW9uIiwiY2hhckhlaWdodCIsIl9faXNNb3VzZWRvd24iLCJzdGFydExpbmUiLCJlbmRMaW5lIiwic3RhcnRDaGFyIiwiZW5kQ2hhciIsImxpbmVPZmZzZXQiLCJyZWFsTGluZUhlaWdodCIsImJveEVuZCIsImRyYXdXaWR0aCIsImRyYXdIZWlnaHQiLCJleHRyYVRvcCIsImNvbXBvc2l0aW9uQ29sb3IiLCJnZXRDdXJyZW50Q2hhckZvbnRTaXplIiwiY3AiLCJfZ2V0Q3VycmVudENoYXJJbmRleCIsImdldEN1cnJlbnRDaGFyQ29sb3IiLCJpbml0QWRkZWRIYW5kbGVyIiwiaW5pdFJlbW92ZWRIYW5kbGVyIiwiaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzIiwiaW5pdERvdWJsZUNsaWNrU2ltdWxhdGlvbiIsIm1vdXNlTW92ZUhhbmRsZXIiLCJfaW5pdENhbnZhc0hhbmRsZXJzIiwiX3JlbW92ZUNhbnZhc0hhbmRsZXJzIiwiX3RpY2siLCJfY3VycmVudFRpY2tTdGF0ZSIsIl9hbmltYXRlQ3Vyc29yIiwidGFyZ2V0T3BhY2l0eSIsImNvbXBsZXRlTWV0aG9kIiwidGlja1N0YXRlIiwiaXNBYm9ydGVkIiwiX29uVGlja0NvbXBsZXRlIiwiX2N1cnNvclRpbWVvdXQxIiwiX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSIsInJlc3RhcnQiLCJkZWxheSIsImFib3J0Q3Vyc29yQW5pbWF0aW9uIiwiX2N1cnNvclRpbWVvdXQyIiwic2VsZWN0QWxsIiwiZ2V0U2VsZWN0ZWRUZXh0IiwiZmluZFdvcmRCb3VuZGFyeUxlZnQiLCJzdGFydEZyb20iLCJmaW5kV29yZEJvdW5kYXJ5UmlnaHQiLCJmaW5kTGluZUJvdW5kYXJ5TGVmdCIsImZpbmRMaW5lQm91bmRhcnlSaWdodCIsInNlYXJjaFdvcmRCb3VuZGFyeSIsInNlbGVjdFdvcmQiLCJuZXdTZWxlY3Rpb25TdGFydCIsIm5ld1NlbGVjdGlvbkVuZCIsInNlbGVjdExpbmUiLCJlbnRlckVkaXRpbmciLCJleGl0RWRpdGluZ09uT3RoZXJzIiwiaW5pdEhpZGRlblRleHRhcmVhIiwiX3NhdmVFZGl0aW5nUHJvcHMiLCJfc2V0RWRpdGluZ1Byb3BzIiwiX3RleHRCZWZvcmVFZGl0IiwiaW5pdE1vdXNlTW92ZUhhbmRsZXIiLCJnZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyIiwiY3VycmVudFN0YXJ0IiwiY3VycmVudEVuZCIsIl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93biIsInJlc3RhcnRDdXJzb3JJZk5lZWRlZCIsImZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uIiwic21hbGxlclRleHRTdGFydCIsImdyYXBoZW1lU3RhcnQiLCJzbWFsbGVyVGV4dEVuZCIsImdyYXBoZW1lRW5kIiwiZnJvbUdyYXBoZW1lVG9TdHJpbmdTZWxlY3Rpb24iLCJuZXdTZWxlY3Rpb24iLCJ1cGRhdGVUZXh0YXJlYVBvc2l0aW9uIiwidXBkYXRlRnJvbVRleHRBcmVhIiwiX2NhbGNUZXh0YXJlYVBvc2l0aW9uIiwiZGVzaXJlZFBvc2l0aW9uIiwiY29tcG9zaXRpb25TdGFydCIsInVwcGVyQ2FudmFzIiwidXBwZXJDYW52YXNXaWR0aCIsInVwcGVyQ2FudmFzSGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJfc2F2ZWRQcm9wcyIsIl9yZXN0b3JlRWRpdGluZ1Byb3BzIiwiaXNUZXh0Q2hhbmdlZCIsIl9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzIiwicmVtb3ZlU3R5bGVGcm9tVG8iLCJjdXJzb3JTdGFydCIsImN1cnNvckVuZCIsImxpbmVTdGFydCIsImNoYXJTdGFydCIsImxpbmVFbmQiLCJjaGFyRW5kIiwic3R5bGVPYmoiLCJzaGlmdExpbmVTdHlsZXMiLCJudW1lcmljQ2hhciIsImNsb25lZFN0eWxlcyIsIm51bWVyaWNMaW5lIiwiaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0IiwicXR5IiwiY29waWVkU3R5bGUiLCJjdXJyZW50Q2hhclN0eWxlIiwibmV3TGluZVN0eWxlcyIsInNvbWV0aGluZ0FkZGVkIiwiaXNFbmRPZkxpbmUiLCJudW1JbmRleCIsInN0eWxlQ2FycmllZE92ZXIiLCJpbnNlcnRDaGFyU3R5bGVPYmplY3QiLCJxdWFudGl0eSIsImN1cnJlbnRMaW5lU3R5bGVzIiwiY3VycmVudExpbmVTdHlsZXNDbG9uZWQiLCJudW1lcmljSW5kZXgiLCJuZXdTdHlsZSIsImluc2VydE5ld1N0eWxlQmxvY2siLCJpbnNlcnRlZFRleHQiLCJjdXJzb3JMb2MiLCJhZGRlZExpbmVzIiwibGluZXNMZW5ndGgiLCJzZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdCIsInNldFNlbGVjdGlvbkluQm91bmRhcmllcyIsIl9fbGFzdENsaWNrVGltZSIsIl9fbGFzdExhc3RDbGlja1RpbWUiLCJfX2xhc3RQb2ludGVyIiwiX19uZXdDbGlja1RpbWUiLCJuZXdQb2ludGVyIiwiaXNUcmlwbGVDbGljayIsIl9zdG9wRXZlbnQiLCJfX2xhc3RJc0VkaXRpbmciLCJfX2xhc3RTZWxlY3RlZCIsImluaXRNb3VzZWRvd25IYW5kbGVyIiwiaW5pdE1vdXNldXBIYW5kbGVyIiwiaW5pdENsaWNrcyIsImRvdWJsZUNsaWNrSGFuZGxlciIsInRyaXBsZUNsaWNrSGFuZGxlciIsIl9tb3VzZURvd25IYW5kbGVyIiwic2V0Q3Vyc29yQnlDbGljayIsIl9tb3VzZURvd25IYW5kbGVyQmVmb3JlIiwiY3VycmVudEFjdGl2ZSIsIm1vdXNlT2Zmc2V0IiwicHJldldpZHRoIiwiX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldCIsImRpc3RhbmNlQnR3TGFzdENoYXJBbmRDdXJzb3IiLCJkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yIiwib25LZXlEb3duIiwib25LZXlVcCIsIm9uSW5wdXQiLCJjb3B5IiwicGFzdGUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uVXBkYXRlIiwib25Db21wb3NpdGlvbkVuZCIsIl9jbGlja0hhbmRsZXJJbml0aWFsaXplZCIsIm9uQ2xpY2siLCJrZXlzTWFwIiwia2V5c01hcFJ0bCIsImN0cmxLZXlzTWFwVXAiLCJjdHJsS2V5c01hcERvd24iLCJrZXlNYXAiLCJrZXlDb2RlIiwiY3RybEtleSIsIm1ldGFLZXkiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJfY29weURvbmUiLCJmcm9tUGFzdGUiLCJuZXh0VGV4dCIsImNoYXJDb3VudCIsIm5leHRDaGFyQ291bnQiLCJyZW1vdmVkVGV4dCIsImNoYXJEaWZmIiwicmVtb3ZlRnJvbSIsInJlbW92ZVRvIiwidGV4dGFyZWFTZWxlY3Rpb24iLCJiYWNrRGVsZXRlIiwiY29waWVkVGV4dCIsImNvcGllZFRleHRTdHlsZSIsImNvbXBvc2l0aW9uRW5kIiwiX2dldENsaXBib2FyZERhdGEiLCJjbGlwYm9hcmREYXRhIiwiX2dldFdpZHRoQmVmb3JlQ3Vyc29yIiwid2lkdGhCZWZvcmVDdXJzb3IiLCJnZXREb3duQ3Vyc29yT2Zmc2V0IiwiaXNSaWdodCIsInNlbGVjdGlvblByb3AiLCJfZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0IiwiaW5kZXhPbk90aGVyTGluZSIsIl9nZXRJbmRleE9uTGluZSIsInRleHRBZnRlckN1cnNvciIsImdldFVwQ3Vyc29yT2Zmc2V0IiwidGV4dEJlZm9yZUN1cnNvciIsIndpZHRoT2ZDaGFyc09uTGluZSIsImluZGV4T25MaW5lIiwiY2hhcldpZHRoIiwiZm91bmRNYXRjaCIsImxlZnRFZGdlIiwicmlnaHRFZGdlIiwib2Zmc2V0RnJvbUxlZnRFZGdlIiwib2Zmc2V0RnJvbVJpZ2h0RWRnZSIsIm1vdmVDdXJzb3JEb3duIiwiX21vdmVDdXJzb3JVcE9yRG93biIsIm1vdmVDdXJzb3JVcCIsIm1vdmVDdXJzb3JXaXRoU2hpZnQiLCJtb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0IiwibW92ZUN1cnNvckxlZnQiLCJfbW92ZUN1cnNvckxlZnRPclJpZ2h0IiwiX21vdmUiLCJfbW92ZUxlZnQiLCJfbW92ZVJpZ2h0IiwibW92ZUN1cnNvckxlZnRXaXRob3V0U2hpZnQiLCJjaGFuZ2UiLCJtb3ZlQ3Vyc29yTGVmdFdpdGhTaGlmdCIsIm1vdmVDdXJzb3JSaWdodCIsIm1vdmVDdXJzb3JSaWdodFdpdGhTaGlmdCIsIm1vdmVDdXJzb3JSaWdodFdpdGhvdXRTaGlmdCIsImNoYW5nZWQiLCJyZW1vdmVDaGFycyIsImluc2VydENoYXJzIiwibXVsdGlwbGVTcGFjZXNSZWdleCIsIl9nZXRTVkdMZWZ0VG9wT2Zmc2V0cyIsInRleHRBbmRCZyIsIl9nZXRTVkdUZXh0QW5kQmciLCJ0ZXh0VG9wIiwidGV4dExlZnQiLCJfd3JhcFNWR1RleHRBbmRCZyIsImxpbmVUb3AiLCJub1NoYWRvdyIsInRleHRTcGFucyIsInRleHRUb3BPZmZzZXQiLCJ0ZXh0TGVmdE9mZnNldCIsIl9zZXRTVkdUZXh0TGluZUJnIiwiX3NldFNWR1RleHRMaW5lVGV4dCIsIl9jcmVhdGVUZXh0Q2hhclNwYW4iLCJzdHlsZURlY2wiLCJzaG91bGRVc2VXaGl0ZXNwYWNlIiwic3R5bGVQcm9wcyIsImZpbGxTdHlsZXMiLCJkeVNwYW4iLCJfcHVzaFRleHRCZ1JlY3QiLCJmaWxsQ29sb3IiLCJfZ2V0U1ZHTGluZVRvcE9mZnNldCIsImxhc3RIZWlnaHQiLCJzdmdTdHlsZSIsIlRleHRib3giLCJtaW5XaWR0aCIsImR5bmFtaWNNaW5XaWR0aCIsIl9fY2FjaGVkTGluZXMiLCJfd29yZEpvaW5lcnMiLCJzcGxpdEJ5R3JhcGhlbWUiLCJfc3R5bGVNYXAiLCJfZ2VuZXJhdGVTdHlsZU1hcCIsInRleHRJbmZvIiwicmVhbExpbmVDb3VudCIsInJlYWxMaW5lQ2hhckNvdW50IiwiaXNXcmFwcGluZyIsIm5leHRMaW5lSW5kZXgiLCJuZXh0T2Zmc2V0Iiwic2hvdWxkTGltaXQiLCJtYXBOZXh0TGluZSIsIl93cmFwVGV4dCIsImRlc2lyZWRXaWR0aCIsIndyYXBwZWQiLCJfd3JhcExpbmUiLCJfbWVhc3VyZVdvcmQiLCJ3b3JkIiwiY2hhck9mZnNldCIsIl9saW5lIiwicmVzZXJ2ZWRTcGFjZSIsIndvcmRzIiwiaW5maXgiLCJ3b3JkV2lkdGgiLCJpbmZpeFdpZHRoIiwibGFyZ2VzdFdvcmRXaWR0aCIsImxpbmVKdXN0U3RhcnRlZCIsImFkZGl0aW9uYWxTcGFjZSIsImdldE1pbldpZHRoIiwibGluZXNUb0tlZXAiLCJzY2FsZVNrZXdTdHlsZUhhbmRsZXIiLCJzY2FsZVN0eWxlSGFuZGxlciIsIm9iamVjdENvbnRyb2xzIiwibWwiLCJtciIsIm1iIiwibXRyIiwidGV4dEJveENvbnRyb2xzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fabric-pure-browser/dist/fabric.js\n");

/***/ })

};
;